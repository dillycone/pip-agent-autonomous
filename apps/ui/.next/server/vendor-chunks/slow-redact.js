"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slow-redact";
exports.ids = ["vendor-chunks/slow-redact"];
exports.modules = {

/***/ "(rsc)/../../node_modules/slow-redact/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/slow-redact/index.js ***!
  \***********************************************/
/***/ ((module) => {

eval("\n\nfunction deepClone (obj) {\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  if (obj instanceof Date) {\n    return new Date(obj.getTime())\n  }\n\n  if (obj instanceof Array) {\n    const cloned = []\n    for (let i = 0; i < obj.length; i++) {\n      cloned[i] = deepClone(obj[i])\n    }\n    return cloned\n  }\n\n  if (typeof obj === 'object') {\n    const cloned = Object.create(Object.getPrototypeOf(obj))\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        cloned[key] = deepClone(obj[key])\n      }\n    }\n    return cloned\n  }\n\n  return obj\n}\n\nfunction parsePath (path) {\n  const parts = []\n  let current = ''\n  let inBrackets = false\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if (!inBrackets && char === '.') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n    } else if (char === '[') {\n      if (current) {\n        parts.push(current)\n        current = ''\n      }\n      inBrackets = true\n    } else if (char === ']' && inBrackets) {\n      // Always push the current value when closing brackets, even if it's an empty string\n      parts.push(current)\n      current = ''\n      inBrackets = false\n      inQuotes = false\n    } else if ((char === '\"' || char === \"'\") && inBrackets) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      } else {\n        current += char\n      }\n    } else {\n      current += char\n    }\n  }\n\n  if (current) {\n    parts.push(current)\n  }\n\n  return parts\n}\n\nfunction setValue (obj, parts, value) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      for (let i = 0; i < current.length; i++) {\n        current[i] = value\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          current[key] = value\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      current[lastKey] = value\n    }\n  }\n  return true\n}\n\nfunction removeKey (obj, parts) {\n  let current = obj\n\n  for (let i = 0; i < parts.length - 1; i++) {\n    const key = parts[i]\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current !== 'object' || current === null || !(key in current)) {\n      return false // Path doesn't exist, don't create it\n    }\n    if (typeof current[key] !== 'object' || current[key] === null) {\n      return false // Path doesn't exist properly\n    }\n    current = current[key]\n  }\n\n  const lastKey = parts[parts.length - 1]\n  if (lastKey === '*') {\n    if (Array.isArray(current)) {\n      // For arrays, we can't really \"remove\" all items as that would change indices\n      // Instead, we set them to undefined which will be omitted by JSON.stringify\n      for (let i = 0; i < current.length; i++) {\n        current[i] = undefined\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      for (const key in current) {\n        if (Object.prototype.hasOwnProperty.call(current, key)) {\n          delete current[key]\n        }\n      }\n    }\n  } else {\n    // Type safety: Check if current is an object before using 'in' operator\n    if (typeof current === 'object' && current !== null && lastKey in current && Object.prototype.hasOwnProperty.call(current, lastKey)) {\n      delete current[lastKey]\n    }\n  }\n  return true\n}\n\n// Sentinel object to distinguish between undefined value and non-existent path\nconst PATH_NOT_FOUND = Symbol('PATH_NOT_FOUND')\n\nfunction getValueIfExists (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return PATH_NOT_FOUND\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return PATH_NOT_FOUND\n    }\n    // Check if the property exists before accessing it\n    if (!(part in current)) {\n      return PATH_NOT_FOUND\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction getValue (obj, parts) {\n  let current = obj\n\n  for (const part of parts) {\n    if (current === null || current === undefined) {\n      return undefined\n    }\n    // Type safety: Check if current is an object before property access\n    if (typeof current !== 'object' || current === null) {\n      return undefined\n    }\n    current = current[part]\n  }\n\n  return current\n}\n\nfunction redactPaths (obj, paths, censor, remove = false) {\n  for (const path of paths) {\n    const parts = parsePath(path)\n\n    if (parts.includes('*')) {\n      redactWildcardPath(obj, parts, censor, path, remove)\n    } else {\n      if (remove) {\n        removeKey(obj, parts)\n      } else {\n        // Get value only if path exists - single traversal\n        const value = getValueIfExists(obj, parts)\n        if (value === PATH_NOT_FOUND) {\n          continue\n        }\n\n        const actualCensor = typeof censor === 'function'\n          ? censor(value, parts)\n          : censor\n        setValue(obj, parts, actualCensor)\n      }\n    }\n  }\n}\n\nfunction redactWildcardPath (obj, parts, censor, originalPath, remove = false) {\n  const wildcardIndex = parts.indexOf('*')\n\n  if (wildcardIndex === parts.length - 1) {\n    const parentParts = parts.slice(0, -1)\n    let current = obj\n\n    for (const part of parentParts) {\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n    }\n\n    if (Array.isArray(current)) {\n      if (remove) {\n        // For arrays, set all items to undefined which will be omitted by JSON.stringify\n        for (let i = 0; i < current.length; i++) {\n          current[i] = undefined\n        }\n      } else {\n        for (let i = 0; i < current.length; i++) {\n          const indexPath = [...parentParts, i.toString()]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[i], indexPath)\n            : censor\n          current[i] = actualCensor\n        }\n      }\n    } else if (typeof current === 'object' && current !== null) {\n      if (remove) {\n        // Collect keys to delete to avoid issues with deleting during iteration\n        const keysToDelete = []\n        for (const key in current) {\n          if (Object.prototype.hasOwnProperty.call(current, key)) {\n            keysToDelete.push(key)\n          }\n        }\n        for (const key of keysToDelete) {\n          delete current[key]\n        }\n      } else {\n        for (const key in current) {\n          const keyPath = [...parentParts, key]\n          const actualCensor = typeof censor === 'function'\n            ? censor(current[key], keyPath)\n            : censor\n          current[key] = actualCensor\n        }\n      }\n    }\n  } else {\n    redactIntermediateWildcard(obj, parts, censor, wildcardIndex, originalPath, remove)\n  }\n}\n\nfunction redactIntermediateWildcard (obj, parts, censor, wildcardIndex, originalPath, remove = false) {\n  const beforeWildcard = parts.slice(0, wildcardIndex)\n  const afterWildcard = parts.slice(wildcardIndex + 1)\n  const pathArray = [] // Cached array to avoid allocations\n\n  function traverse (current, pathLength) {\n    if (pathLength === beforeWildcard.length) {\n      if (Array.isArray(current)) {\n        for (let i = 0; i < current.length; i++) {\n          pathArray[pathLength] = i.toString()\n          traverse(current[i], pathLength + 1)\n        }\n      } else if (typeof current === 'object' && current !== null) {\n        for (const key in current) {\n          pathArray[pathLength] = key\n          traverse(current[key], pathLength + 1)\n        }\n      }\n    } else if (pathLength < beforeWildcard.length) {\n      const nextKey = beforeWildcard[pathLength]\n      // Type safety: Check if current is an object before using 'in' operator\n      if (current && typeof current === 'object' && current !== null && nextKey in current) {\n        pathArray[pathLength] = nextKey\n        traverse(current[nextKey], pathLength + 1)\n      }\n    } else {\n      // Check if afterWildcard contains more wildcards\n      if (afterWildcard.includes('*')) {\n        // Recursively handle remaining wildcards\n        // Wrap censor to prepend current path context\n        const wrappedCensor = typeof censor === 'function'\n          ? (value, path) => {\n              const fullPath = [...pathArray.slice(0, pathLength), ...path]\n              return censor(value, fullPath)\n            }\n          : censor\n        redactWildcardPath(current, afterWildcard, wrappedCensor, originalPath, remove)\n      } else {\n        // No more wildcards, apply the redaction directly\n        if (remove) {\n          removeKey(current, afterWildcard)\n        } else {\n          const actualCensor = typeof censor === 'function'\n            ? censor(getValue(current, afterWildcard), [...pathArray.slice(0, pathLength), ...afterWildcard])\n            : censor\n          setValue(current, afterWildcard, actualCensor)\n        }\n      }\n    }\n  }\n\n  if (beforeWildcard.length === 0) {\n    traverse(obj, 0)\n  } else {\n    let current = obj\n    for (let i = 0; i < beforeWildcard.length; i++) {\n      const part = beforeWildcard[i]\n      if (current === null || current === undefined) return\n      // Type safety: Check if current is an object before property access\n      if (typeof current !== 'object' || current === null) return\n      current = current[part]\n      pathArray[i] = part\n    }\n    if (current !== null && current !== undefined) {\n      traverse(current, beforeWildcard.length)\n    }\n  }\n}\n\nfunction buildPathStructure (pathsToClone) {\n  if (pathsToClone.length === 0) {\n    return null // No paths to redact\n  }\n\n  // Parse all paths and organize by depth\n  const pathStructure = new Map()\n  for (const path of pathsToClone) {\n    const parts = parsePath(path)\n    let current = pathStructure\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]\n      if (!current.has(part)) {\n        current.set(part, new Map())\n      }\n      current = current.get(part)\n    }\n  }\n  return pathStructure\n}\n\nfunction selectiveClone (obj, pathStructure) {\n  if (!pathStructure) {\n    return obj // No paths to redact, return original\n  }\n\n  function cloneSelectively (source, pathMap, depth = 0) {\n    if (!pathMap || pathMap.size === 0) {\n      return source // No more paths to clone, return reference\n    }\n\n    if (source === null || typeof source !== 'object') {\n      return source\n    }\n\n    if (source instanceof Date) {\n      return new Date(source.getTime())\n    }\n\n    if (Array.isArray(source)) {\n      const cloned = []\n      for (let i = 0; i < source.length; i++) {\n        const indexStr = i.toString()\n        if (pathMap.has(indexStr) || pathMap.has('*')) {\n          cloned[i] = cloneSelectively(source[i], pathMap.get(indexStr) || pathMap.get('*'))\n        } else {\n          cloned[i] = source[i] // Share reference for non-redacted items\n        }\n      }\n      return cloned\n    }\n\n    // Handle objects\n    const cloned = Object.create(Object.getPrototypeOf(source))\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        if (pathMap.has(key) || pathMap.has('*')) {\n          cloned[key] = cloneSelectively(source[key], pathMap.get(key) || pathMap.get('*'))\n        } else {\n          cloned[key] = source[key] // Share reference for non-redacted properties\n        }\n      }\n    }\n    return cloned\n  }\n\n  return cloneSelectively(obj, pathStructure)\n}\n\nfunction validatePath (path) {\n  if (typeof path !== 'string') {\n    throw new Error('Paths must be (non-empty) strings')\n  }\n\n  if (path === '') {\n    throw new Error('Invalid redaction path ()')\n  }\n\n  // Check for double dots\n  if (path.includes('..')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for comma-separated paths (invalid syntax)\n  if (path.includes(',')) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n\n  // Check for unmatched brackets\n  let bracketCount = 0\n  let inQuotes = false\n  let quoteChar = ''\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path[i]\n\n    if ((char === '\"' || char === \"'\") && bracketCount > 0) {\n      if (!inQuotes) {\n        inQuotes = true\n        quoteChar = char\n      } else if (char === quoteChar) {\n        inQuotes = false\n        quoteChar = ''\n      }\n    } else if (char === '[' && !inQuotes) {\n      bracketCount++\n    } else if (char === ']' && !inQuotes) {\n      bracketCount--\n      if (bracketCount < 0) {\n        throw new Error(`Invalid redaction path (${path})`)\n      }\n    }\n  }\n\n  if (bracketCount !== 0) {\n    throw new Error(`Invalid redaction path (${path})`)\n  }\n}\n\nfunction validatePaths (paths) {\n  if (!Array.isArray(paths)) {\n    throw new TypeError('paths must be an array')\n  }\n\n  for (const path of paths) {\n    validatePath(path)\n  }\n}\n\nfunction slowRedact (options = {}) {\n  const {\n    paths = [],\n    censor = '[REDACTED]',\n    serialize = JSON.stringify,\n    strict = true,\n    remove = false\n  } = options\n\n  // Validate paths upfront to match fast-redact behavior\n  validatePaths(paths)\n\n  // Build path structure once during setup, not on every call\n  const pathStructure = buildPathStructure(paths)\n\n  return function redact (obj) {\n    if (strict && (obj === null || typeof obj !== 'object')) {\n      if (obj === null || obj === undefined) {\n        return serialize ? serialize(obj) : obj\n      }\n      if (typeof obj !== 'object') {\n        return serialize ? serialize(obj) : obj\n      }\n    }\n\n    // Only clone paths that need redaction\n    const cloned = selectiveClone(obj, pathStructure)\n    const original = obj // Keep reference to original for restore\n\n    let actualCensor = censor\n    if (typeof censor === 'function') {\n      actualCensor = censor\n    }\n\n    redactPaths(cloned, paths, actualCensor, remove)\n\n    if (serialize === false) {\n      cloned.restore = function () {\n        return deepClone(original) // Full clone only when restore is called\n      }\n      return cloned\n    }\n\n    if (typeof serialize === 'function') {\n      return serialize(cloned)\n    }\n\n    return JSON.stringify(cloned)\n  }\n}\n\nmodule.exports = slowRedact\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3Nsb3ctcmVkYWN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9zbG93LXJlZGFjdC9pbmRleC5qcz83OWNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5mdW5jdGlvbiBkZWVwQ2xvbmUgKG9iaikge1xuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9ialxuICB9XG5cbiAgaWYgKG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUob2JqLmdldFRpbWUoKSlcbiAgfVxuXG4gIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGNvbnN0IGNsb25lZCA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNsb25lZFtpXSA9IGRlZXBDbG9uZShvYmpbaV0pXG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZShvYmpba2V5XSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSBbXVxuICBsZXQgY3VycmVudCA9ICcnXG4gIGxldCBpbkJyYWNrZXRzID0gZmFsc2VcbiAgbGV0IGluUXVvdGVzID0gZmFsc2VcbiAgbGV0IHF1b3RlQ2hhciA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IHBhdGhbaV1cblxuICAgIGlmICghaW5CcmFja2V0cyAmJiBjaGFyID09PSAnLicpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3VycmVudClcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnWycpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHBhcnRzLnB1c2goY3VycmVudClcbiAgICAgICAgY3VycmVudCA9ICcnXG4gICAgICB9XG4gICAgICBpbkJyYWNrZXRzID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gJ10nICYmIGluQnJhY2tldHMpIHtcbiAgICAgIC8vIEFsd2F5cyBwdXNoIHRoZSBjdXJyZW50IHZhbHVlIHdoZW4gY2xvc2luZyBicmFja2V0cywgZXZlbiBpZiBpdCdzIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgcGFydHMucHVzaChjdXJyZW50KVxuICAgICAgY3VycmVudCA9ICcnXG4gICAgICBpbkJyYWNrZXRzID0gZmFsc2VcbiAgICAgIGluUXVvdGVzID0gZmFsc2VcbiAgICB9IGVsc2UgaWYgKChjaGFyID09PSAnXCInIHx8IGNoYXIgPT09IFwiJ1wiKSAmJiBpbkJyYWNrZXRzKSB7XG4gICAgICBpZiAoIWluUXVvdGVzKSB7XG4gICAgICAgIGluUXVvdGVzID0gdHJ1ZVxuICAgICAgICBxdW90ZUNoYXIgPSBjaGFyXG4gICAgICB9IGVsc2UgaWYgKGNoYXIgPT09IHF1b3RlQ2hhcikge1xuICAgICAgICBpblF1b3RlcyA9IGZhbHNlXG4gICAgICAgIHF1b3RlQ2hhciA9ICcnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50ICs9IGNoYXJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCArPSBjaGFyXG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQpIHtcbiAgICBwYXJ0cy5wdXNoKGN1cnJlbnQpXG4gIH1cblxuICByZXR1cm4gcGFydHNcbn1cblxuZnVuY3Rpb24gc2V0VmFsdWUgKG9iaiwgcGFydHMsIHZhbHVlKSB7XG4gIGxldCBjdXJyZW50ID0gb2JqXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBwYXJ0c1tpXVxuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgdXNpbmcgJ2luJyBvcGVyYXRvclxuICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCB8fCAhKGtleSBpbiBjdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlIC8vIFBhdGggZG9lc24ndCBleGlzdCwgZG9uJ3QgY3JlYXRlIGl0XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3VycmVudFtrZXldICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50W2tleV0gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBQYXRoIGRvZXNuJ3QgZXhpc3QgcHJvcGVybHlcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRba2V5XVxuICB9XG5cbiAgY29uc3QgbGFzdEtleSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdXG4gIGlmIChsYXN0S2V5ID09PSAnKicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRbaV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBrZXkpKSB7XG4gICAgICAgICAgY3VycmVudFtrZXldID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHVzaW5nICdpbicgb3BlcmF0b3JcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwgJiYgbGFzdEtleSBpbiBjdXJyZW50ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBsYXN0S2V5KSkge1xuICAgICAgY3VycmVudFtsYXN0S2V5XSA9IHZhbHVlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUtleSAob2JqLCBwYXJ0cykge1xuICBsZXQgY3VycmVudCA9IG9ialxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcGFydHNbaV1cbiAgICAvLyBUeXBlIHNhZmV0eTogQ2hlY2sgaWYgY3VycmVudCBpcyBhbiBvYmplY3QgYmVmb3JlIHVzaW5nICdpbicgb3BlcmF0b3JcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwgfHwgIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZSAvLyBQYXRoIGRvZXNuJ3QgZXhpc3QsIGRvbid0IGNyZWF0ZSBpdFxuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1cnJlbnRba2V5XSAhPT0gJ29iamVjdCcgfHwgY3VycmVudFtrZXldID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gUGF0aCBkb2Vzbid0IGV4aXN0IHByb3Blcmx5XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50W2tleV1cbiAgfVxuXG4gIGNvbnN0IGxhc3RLZXkgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXVxuICBpZiAobGFzdEtleSA9PT0gJyonKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgIC8vIEZvciBhcnJheXMsIHdlIGNhbid0IHJlYWxseSBcInJlbW92ZVwiIGFsbCBpdGVtcyBhcyB0aGF0IHdvdWxkIGNoYW5nZSBpbmRpY2VzXG4gICAgICAvLyBJbnN0ZWFkLCB3ZSBzZXQgdGhlbSB0byB1bmRlZmluZWQgd2hpY2ggd2lsbCBiZSBvbWl0dGVkIGJ5IEpTT04uc3RyaW5naWZ5XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VycmVudFtpXSA9IHVuZGVmaW5lZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjdXJyZW50LCBrZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGN1cnJlbnRba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgdXNpbmcgJ2luJyBvcGVyYXRvclxuICAgIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCAmJiBsYXN0S2V5IGluIGN1cnJlbnQgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1cnJlbnQsIGxhc3RLZXkpKSB7XG4gICAgICBkZWxldGUgY3VycmVudFtsYXN0S2V5XVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBTZW50aW5lbCBvYmplY3QgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB1bmRlZmluZWQgdmFsdWUgYW5kIG5vbi1leGlzdGVudCBwYXRoXG5jb25zdCBQQVRIX05PVF9GT1VORCA9IFN5bWJvbCgnUEFUSF9OT1RfRk9VTkQnKVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUlmRXhpc3RzIChvYmosIHBhcnRzKSB7XG4gIGxldCBjdXJyZW50ID0gb2JqXG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gUEFUSF9OT1RfRk9VTkRcbiAgICB9XG4gICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSBwcm9wZXJ0eSBhY2Nlc3NcbiAgICBpZiAodHlwZW9mIGN1cnJlbnQgIT09ICdvYmplY3QnIHx8IGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBQQVRIX05PVF9GT1VORFxuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGJlZm9yZSBhY2Nlc3NpbmcgaXRcbiAgICBpZiAoIShwYXJ0IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gUEFUSF9OT1RfRk9VTkRcbiAgICB9XG4gICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF1cbiAgfVxuXG4gIHJldHVybiBjdXJyZW50XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlIChvYmosIHBhcnRzKSB7XG4gIGxldCBjdXJyZW50ID0gb2JqXG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIC8vIFR5cGUgc2FmZXR5OiBDaGVjayBpZiBjdXJyZW50IGlzIGFuIG9iamVjdCBiZWZvcmUgcHJvcGVydHkgYWNjZXNzXG4gICAgaWYgKHR5cGVvZiBjdXJyZW50ICE9PSAnb2JqZWN0JyB8fCBjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhcnRdXG4gIH1cblxuICByZXR1cm4gY3VycmVudFxufVxuXG5mdW5jdGlvbiByZWRhY3RQYXRocyAob2JqLCBwYXRocywgY2Vuc29yLCByZW1vdmUgPSBmYWxzZSkge1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHBhcnNlUGF0aChwYXRoKVxuXG4gICAgaWYgKHBhcnRzLmluY2x1ZGVzKCcqJykpIHtcbiAgICAgIHJlZGFjdFdpbGRjYXJkUGF0aChvYmosIHBhcnRzLCBjZW5zb3IsIHBhdGgsIHJlbW92ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICByZW1vdmVLZXkob2JqLCBwYXJ0cylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCB2YWx1ZSBvbmx5IGlmIHBhdGggZXhpc3RzIC0gc2luZ2xlIHRyYXZlcnNhbFxuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlSWZFeGlzdHMob2JqLCBwYXJ0cylcbiAgICAgICAgaWYgKHZhbHVlID09PSBQQVRIX05PVF9GT1VORCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY3R1YWxDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyBjZW5zb3IodmFsdWUsIHBhcnRzKVxuICAgICAgICAgIDogY2Vuc29yXG4gICAgICAgIHNldFZhbHVlKG9iaiwgcGFydHMsIGFjdHVhbENlbnNvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVkYWN0V2lsZGNhcmRQYXRoIChvYmosIHBhcnRzLCBjZW5zb3IsIG9yaWdpbmFsUGF0aCwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgY29uc3Qgd2lsZGNhcmRJbmRleCA9IHBhcnRzLmluZGV4T2YoJyonKVxuXG4gIGlmICh3aWxkY2FyZEluZGV4ID09PSBwYXJ0cy5sZW5ndGggLSAxKSB7XG4gICAgY29uc3QgcGFyZW50UGFydHMgPSBwYXJ0cy5zbGljZSgwLCAtMSlcbiAgICBsZXQgY3VycmVudCA9IG9ialxuXG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcmVudFBhcnRzKSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIC8vIEZvciBhcnJheXMsIHNldCBhbGwgaXRlbXMgdG8gdW5kZWZpbmVkIHdoaWNoIHdpbGwgYmUgb21pdHRlZCBieSBKU09OLnN0cmluZ2lmeVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjdXJyZW50W2ldID0gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4UGF0aCA9IFsuLi5wYXJlbnRQYXJ0cywgaS50b1N0cmluZygpXVxuICAgICAgICAgIGNvbnN0IGFjdHVhbENlbnNvciA9IHR5cGVvZiBjZW5zb3IgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gY2Vuc29yKGN1cnJlbnRbaV0sIGluZGV4UGF0aClcbiAgICAgICAgICAgIDogY2Vuc29yXG4gICAgICAgICAgY3VycmVudFtpXSA9IGFjdHVhbENlbnNvclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAvLyBDb2xsZWN0IGtleXMgdG8gZGVsZXRlIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGRlbGV0aW5nIGR1cmluZyBpdGVyYXRpb25cbiAgICAgICAgY29uc3Qga2V5c1RvRGVsZXRlID0gW11cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VycmVudCwga2V5KSkge1xuICAgICAgICAgICAga2V5c1RvRGVsZXRlLnB1c2goa2V5KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9EZWxldGUpIHtcbiAgICAgICAgICBkZWxldGUgY3VycmVudFtrZXldXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICBjb25zdCBrZXlQYXRoID0gWy4uLnBhcmVudFBhcnRzLCBrZXldXG4gICAgICAgICAgY29uc3QgYWN0dWFsQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjZW5zb3IoY3VycmVudFtrZXldLCBrZXlQYXRoKVxuICAgICAgICAgICAgOiBjZW5zb3JcbiAgICAgICAgICBjdXJyZW50W2tleV0gPSBhY3R1YWxDZW5zb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZWRhY3RJbnRlcm1lZGlhdGVXaWxkY2FyZChvYmosIHBhcnRzLCBjZW5zb3IsIHdpbGRjYXJkSW5kZXgsIG9yaWdpbmFsUGF0aCwgcmVtb3ZlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZGFjdEludGVybWVkaWF0ZVdpbGRjYXJkIChvYmosIHBhcnRzLCBjZW5zb3IsIHdpbGRjYXJkSW5kZXgsIG9yaWdpbmFsUGF0aCwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgY29uc3QgYmVmb3JlV2lsZGNhcmQgPSBwYXJ0cy5zbGljZSgwLCB3aWxkY2FyZEluZGV4KVxuICBjb25zdCBhZnRlcldpbGRjYXJkID0gcGFydHMuc2xpY2Uod2lsZGNhcmRJbmRleCArIDEpXG4gIGNvbnN0IHBhdGhBcnJheSA9IFtdIC8vIENhY2hlZCBhcnJheSB0byBhdm9pZCBhbGxvY2F0aW9uc1xuXG4gIGZ1bmN0aW9uIHRyYXZlcnNlIChjdXJyZW50LCBwYXRoTGVuZ3RoKSB7XG4gICAgaWYgKHBhdGhMZW5ndGggPT09IGJlZm9yZVdpbGRjYXJkLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGF0aEFycmF5W3BhdGhMZW5ndGhdID0gaS50b1N0cmluZygpXG4gICAgICAgICAgdHJhdmVyc2UoY3VycmVudFtpXSwgcGF0aExlbmd0aCArIDEpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnQgPT09ICdvYmplY3QnICYmIGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICAgIHBhdGhBcnJheVtwYXRoTGVuZ3RoXSA9IGtleVxuICAgICAgICAgIHRyYXZlcnNlKGN1cnJlbnRba2V5XSwgcGF0aExlbmd0aCArIDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBhdGhMZW5ndGggPCBiZWZvcmVXaWxkY2FyZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRLZXkgPSBiZWZvcmVXaWxkY2FyZFtwYXRoTGVuZ3RoXVxuICAgICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSB1c2luZyAnaW4nIG9wZXJhdG9yXG4gICAgICBpZiAoY3VycmVudCAmJiB0eXBlb2YgY3VycmVudCA9PT0gJ29iamVjdCcgJiYgY3VycmVudCAhPT0gbnVsbCAmJiBuZXh0S2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgcGF0aEFycmF5W3BhdGhMZW5ndGhdID0gbmV4dEtleVxuICAgICAgICB0cmF2ZXJzZShjdXJyZW50W25leHRLZXldLCBwYXRoTGVuZ3RoICsgMSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2hlY2sgaWYgYWZ0ZXJXaWxkY2FyZCBjb250YWlucyBtb3JlIHdpbGRjYXJkc1xuICAgICAgaWYgKGFmdGVyV2lsZGNhcmQuaW5jbHVkZXMoJyonKSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBoYW5kbGUgcmVtYWluaW5nIHdpbGRjYXJkc1xuICAgICAgICAvLyBXcmFwIGNlbnNvciB0byBwcmVwZW5kIGN1cnJlbnQgcGF0aCBjb250ZXh0XG4gICAgICAgIGNvbnN0IHdyYXBwZWRDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyAodmFsdWUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aEFycmF5LnNsaWNlKDAsIHBhdGhMZW5ndGgpLCAuLi5wYXRoXVxuICAgICAgICAgICAgICByZXR1cm4gY2Vuc29yKHZhbHVlLCBmdWxsUGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IGNlbnNvclxuICAgICAgICByZWRhY3RXaWxkY2FyZFBhdGgoY3VycmVudCwgYWZ0ZXJXaWxkY2FyZCwgd3JhcHBlZENlbnNvciwgb3JpZ2luYWxQYXRoLCByZW1vdmUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBtb3JlIHdpbGRjYXJkcywgYXBwbHkgdGhlIHJlZGFjdGlvbiBkaXJlY3RseVxuICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgcmVtb3ZlS2V5KGN1cnJlbnQsIGFmdGVyV2lsZGNhcmQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYWN0dWFsQ2Vuc29yID0gdHlwZW9mIGNlbnNvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBjZW5zb3IoZ2V0VmFsdWUoY3VycmVudCwgYWZ0ZXJXaWxkY2FyZCksIFsuLi5wYXRoQXJyYXkuc2xpY2UoMCwgcGF0aExlbmd0aCksIC4uLmFmdGVyV2lsZGNhcmRdKVxuICAgICAgICAgICAgOiBjZW5zb3JcbiAgICAgICAgICBzZXRWYWx1ZShjdXJyZW50LCBhZnRlcldpbGRjYXJkLCBhY3R1YWxDZW5zb3IpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoYmVmb3JlV2lsZGNhcmQubGVuZ3RoID09PSAwKSB7XG4gICAgdHJhdmVyc2Uob2JqLCAwKVxuICB9IGVsc2Uge1xuICAgIGxldCBjdXJyZW50ID0gb2JqXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiZWZvcmVXaWxkY2FyZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IGJlZm9yZVdpbGRjYXJkW2ldXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgICAgLy8gVHlwZSBzYWZldHk6IENoZWNrIGlmIGN1cnJlbnQgaXMgYW4gb2JqZWN0IGJlZm9yZSBwcm9wZXJ0eSBhY2Nlc3NcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcgfHwgY3VycmVudCA9PT0gbnVsbCkgcmV0dXJuXG4gICAgICBjdXJyZW50ID0gY3VycmVudFtwYXJ0XVxuICAgICAgcGF0aEFycmF5W2ldID0gcGFydFxuICAgIH1cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyYXZlcnNlKGN1cnJlbnQsIGJlZm9yZVdpbGRjYXJkLmxlbmd0aClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRQYXRoU3RydWN0dXJlIChwYXRoc1RvQ2xvbmUpIHtcbiAgaWYgKHBhdGhzVG9DbG9uZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbCAvLyBObyBwYXRocyB0byByZWRhY3RcbiAgfVxuXG4gIC8vIFBhcnNlIGFsbCBwYXRocyBhbmQgb3JnYW5pemUgYnkgZGVwdGhcbiAgY29uc3QgcGF0aFN0cnVjdHVyZSA9IG5ldyBNYXAoKVxuICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHNUb0Nsb25lKSB7XG4gICAgY29uc3QgcGFydHMgPSBwYXJzZVBhdGgocGF0aClcbiAgICBsZXQgY3VycmVudCA9IHBhdGhTdHJ1Y3R1cmVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV1cbiAgICAgIGlmICghY3VycmVudC5oYXMocGFydCkpIHtcbiAgICAgICAgY3VycmVudC5zZXQocGFydCwgbmV3IE1hcCgpKVxuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0KHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRoU3RydWN0dXJlXG59XG5cbmZ1bmN0aW9uIHNlbGVjdGl2ZUNsb25lIChvYmosIHBhdGhTdHJ1Y3R1cmUpIHtcbiAgaWYgKCFwYXRoU3RydWN0dXJlKSB7XG4gICAgcmV0dXJuIG9iaiAvLyBObyBwYXRocyB0byByZWRhY3QsIHJldHVybiBvcmlnaW5hbFxuICB9XG5cbiAgZnVuY3Rpb24gY2xvbmVTZWxlY3RpdmVseSAoc291cmNlLCBwYXRoTWFwLCBkZXB0aCA9IDApIHtcbiAgICBpZiAoIXBhdGhNYXAgfHwgcGF0aE1hcC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gc291cmNlIC8vIE5vIG1vcmUgcGF0aHMgdG8gY2xvbmUsIHJldHVybiByZWZlcmVuY2VcbiAgICB9XG5cbiAgICBpZiAoc291cmNlID09PSBudWxsIHx8IHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShzb3VyY2UuZ2V0VGltZSgpKVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIGNvbnN0IGNsb25lZCA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmRleFN0ciA9IGkudG9TdHJpbmcoKVxuICAgICAgICBpZiAocGF0aE1hcC5oYXMoaW5kZXhTdHIpIHx8IHBhdGhNYXAuaGFzKCcqJykpIHtcbiAgICAgICAgICBjbG9uZWRbaV0gPSBjbG9uZVNlbGVjdGl2ZWx5KHNvdXJjZVtpXSwgcGF0aE1hcC5nZXQoaW5kZXhTdHIpIHx8IHBhdGhNYXAuZ2V0KCcqJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkW2ldID0gc291cmNlW2ldIC8vIFNoYXJlIHJlZmVyZW5jZSBmb3Igbm9uLXJlZGFjdGVkIGl0ZW1zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0c1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNvdXJjZSkpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICBpZiAocGF0aE1hcC5oYXMoa2V5KSB8fCBwYXRoTWFwLmhhcygnKicpKSB7XG4gICAgICAgICAgY2xvbmVkW2tleV0gPSBjbG9uZVNlbGVjdGl2ZWx5KHNvdXJjZVtrZXldLCBwYXRoTWFwLmdldChrZXkpIHx8IHBhdGhNYXAuZ2V0KCcqJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvbmVkW2tleV0gPSBzb3VyY2Vba2V5XSAvLyBTaGFyZSByZWZlcmVuY2UgZm9yIG5vbi1yZWRhY3RlZCBwcm9wZXJ0aWVzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgcmV0dXJuIGNsb25lU2VsZWN0aXZlbHkob2JqLCBwYXRoU3RydWN0dXJlKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGggKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignUGF0aHMgbXVzdCBiZSAobm9uLWVtcHR5KSBzdHJpbmdzJylcbiAgfVxuXG4gIGlmIChwYXRoID09PSAnJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWRhY3Rpb24gcGF0aCAoKScpXG4gIH1cblxuICAvLyBDaGVjayBmb3IgZG91YmxlIGRvdHNcbiAgaWYgKHBhdGguaW5jbHVkZXMoJy4uJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVkYWN0aW9uIHBhdGggKCR7cGF0aH0pYClcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBjb21tYS1zZXBhcmF0ZWQgcGF0aHMgKGludmFsaWQgc3ludGF4KVxuICBpZiAocGF0aC5pbmNsdWRlcygnLCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZGFjdGlvbiBwYXRoICgke3BhdGh9KWApXG4gIH1cblxuICAvLyBDaGVjayBmb3IgdW5tYXRjaGVkIGJyYWNrZXRzXG4gIGxldCBicmFja2V0Q291bnQgPSAwXG4gIGxldCBpblF1b3RlcyA9IGZhbHNlXG4gIGxldCBxdW90ZUNoYXIgPSAnJ1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBwYXRoW2ldXG5cbiAgICBpZiAoKGNoYXIgPT09ICdcIicgfHwgY2hhciA9PT0gXCInXCIpICYmIGJyYWNrZXRDb3VudCA+IDApIHtcbiAgICAgIGlmICghaW5RdW90ZXMpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlXG4gICAgICAgIHF1b3RlQ2hhciA9IGNoYXJcbiAgICAgIH0gZWxzZSBpZiAoY2hhciA9PT0gcXVvdGVDaGFyKSB7XG4gICAgICAgIGluUXVvdGVzID0gZmFsc2VcbiAgICAgICAgcXVvdGVDaGFyID0gJydcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYXIgPT09ICdbJyAmJiAhaW5RdW90ZXMpIHtcbiAgICAgIGJyYWNrZXRDb3VudCsrXG4gICAgfSBlbHNlIGlmIChjaGFyID09PSAnXScgJiYgIWluUXVvdGVzKSB7XG4gICAgICBicmFja2V0Q291bnQtLVxuICAgICAgaWYgKGJyYWNrZXRDb3VudCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJlZGFjdGlvbiBwYXRoICgke3BhdGh9KWApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGJyYWNrZXRDb3VudCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZWRhY3Rpb24gcGF0aCAoJHtwYXRofSlgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aHMgKHBhdGhzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXRocykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRocyBtdXN0IGJlIGFuIGFycmF5JylcbiAgfVxuXG4gIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgIHZhbGlkYXRlUGF0aChwYXRoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNsb3dSZWRhY3QgKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGF0aHMgPSBbXSxcbiAgICBjZW5zb3IgPSAnW1JFREFDVEVEXScsXG4gICAgc2VyaWFsaXplID0gSlNPTi5zdHJpbmdpZnksXG4gICAgc3RyaWN0ID0gdHJ1ZSxcbiAgICByZW1vdmUgPSBmYWxzZVxuICB9ID0gb3B0aW9uc1xuXG4gIC8vIFZhbGlkYXRlIHBhdGhzIHVwZnJvbnQgdG8gbWF0Y2ggZmFzdC1yZWRhY3QgYmVoYXZpb3JcbiAgdmFsaWRhdGVQYXRocyhwYXRocylcblxuICAvLyBCdWlsZCBwYXRoIHN0cnVjdHVyZSBvbmNlIGR1cmluZyBzZXR1cCwgbm90IG9uIGV2ZXJ5IGNhbGxcbiAgY29uc3QgcGF0aFN0cnVjdHVyZSA9IGJ1aWxkUGF0aFN0cnVjdHVyZShwYXRocylcblxuICByZXR1cm4gZnVuY3Rpb24gcmVkYWN0IChvYmopIHtcbiAgICBpZiAoc3RyaWN0ICYmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpKSB7XG4gICAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUgPyBzZXJpYWxpemUob2JqKSA6IG9ialxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUgPyBzZXJpYWxpemUob2JqKSA6IG9ialxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9ubHkgY2xvbmUgcGF0aHMgdGhhdCBuZWVkIHJlZGFjdGlvblxuICAgIGNvbnN0IGNsb25lZCA9IHNlbGVjdGl2ZUNsb25lKG9iaiwgcGF0aFN0cnVjdHVyZSlcbiAgICBjb25zdCBvcmlnaW5hbCA9IG9iaiAvLyBLZWVwIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBmb3IgcmVzdG9yZVxuXG4gICAgbGV0IGFjdHVhbENlbnNvciA9IGNlbnNvclxuICAgIGlmICh0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhY3R1YWxDZW5zb3IgPSBjZW5zb3JcbiAgICB9XG5cbiAgICByZWRhY3RQYXRocyhjbG9uZWQsIHBhdGhzLCBhY3R1YWxDZW5zb3IsIHJlbW92ZSlcblxuICAgIGlmIChzZXJpYWxpemUgPT09IGZhbHNlKSB7XG4gICAgICBjbG9uZWQucmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBDbG9uZShvcmlnaW5hbCkgLy8gRnVsbCBjbG9uZSBvbmx5IHdoZW4gcmVzdG9yZSBpcyBjYWxsZWRcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNlcmlhbGl6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZShjbG9uZWQpXG4gICAgfVxuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNsb25lZClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNsb3dSZWRhY3RcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/slow-redact/index.js\n");

/***/ })

};
;