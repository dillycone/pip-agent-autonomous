"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/docxtemplater";
exports.ids = ["vendor-chunks/docxtemplater"];
exports.modules = {

/***/ "(rsc)/../../node_modules/docxtemplater/js/content-types.js":
/*!************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/content-types.js ***!
  \************************************************************/
/***/ ((module) => {

eval("\n\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar diagramDataContentType = \"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml\";\nvar diagramDrawingContentType = \"application/vnd.ms-office.drawingml.diagramDrawing+xml\";\nmodule.exports = {\n  settingsContentType: settingsContentType,\n  coreContentType: coreContentType,\n  appContentType: appContentType,\n  customContentType: customContentType,\n  diagramDataContentType: diagramDataContentType,\n  diagramDrawingContentType: diagramDrawingContentType\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvY29udGVudC10eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9jb250ZW50LXR5cGVzLmpzPzE1ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb3JlQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLmNvcmUtcHJvcGVydGllcyt4bWxcIjtcbnZhciBhcHBDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LmV4dGVuZGVkLXByb3BlcnRpZXMreG1sXCI7XG52YXIgY3VzdG9tQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5jdXN0b20tcHJvcGVydGllcyt4bWxcIjtcbnZhciBzZXR0aW5nc0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5zZXR0aW5ncyt4bWxcIjtcbnZhciBkaWFncmFtRGF0YUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuZHJhd2luZ21sLmRpYWdyYW1EYXRhK3htbFwiO1xudmFyIGRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2UuZHJhd2luZ21sLmRpYWdyYW1EcmF3aW5nK3htbFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldHRpbmdzQ29udGVudFR5cGU6IHNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZTogY29yZUNvbnRlbnRUeXBlLFxuICBhcHBDb250ZW50VHlwZTogYXBwQ29udGVudFR5cGUsXG4gIGN1c3RvbUNvbnRlbnRUeXBlOiBjdXN0b21Db250ZW50VHlwZSxcbiAgZGlhZ3JhbURhdGFDb250ZW50VHlwZTogZGlhZ3JhbURhdGFDb250ZW50VHlwZSxcbiAgZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZTogZGlhZ3JhbURyYXdpbmdDb250ZW50VHlwZVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/content-types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/doc-utils.js":
/*!********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/doc-utils.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! @xmldom/xmldom */ \"(rsc)/../../node_modules/@xmldom/xmldom/lib/index.js\"),\n  DOMParser = _require.DOMParser,\n  XMLSerializer = _require.XMLSerializer;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/utils.js\"),\n  last = _require3.last,\n  first = _require3.first;\nfunction isWhiteSpace(value) {\n  return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n      if (scope) {\n        return scope[tag];\n      }\n      return scope;\n    }\n  };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n  var regex;\n  // Stryker disable next-line all : because this is an optimisation\n  if (attrToRegex[attr]) {\n    regex = attrToRegex[attr];\n  } else {\n    regex = new RegExp(\"(<.* \".concat(attr, \"=\\\")([^\\\"]*)(\\\".*)$\"));\n    attrToRegex[attr] = regex;\n  }\n  if (regex.test(partValue)) {\n    return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n  }\n  var end = partValue.lastIndexOf(\"/>\");\n  if (end === -1) {\n    end = partValue.lastIndexOf(\">\");\n  }\n  return partValue.substr(0, end) + \" \".concat(attr, \"=\\\"\").concat(attrValue, \"\\\"\") + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n  var index = value.indexOf(\" \".concat(attributeName, \"=\\\"\"));\n  if (index === -1) {\n    return null;\n  }\n  var startIndex = value.substr(index).search(/[\"']/) + index;\n  var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n  return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\nfunction getDuplicates(arr) {\n  var duplicates = [];\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    } else {\n      duplicates.push(arr[i]);\n    }\n  }\n  return duplicates;\n}\nfunction uniq(arr) {\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nfunction chunkBy(parsed, f) {\n  var chunks = [[]];\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var p = parsed[_i2];\n    var currentChunk = chunks[chunks.length - 1];\n    var res = f(p);\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n  } // Remove empty chunks\n  var result = [];\n  for (var _i4 = 0; _i4 < chunks.length; _i4++) {\n    var chunk = chunks[_i4];\n    if (chunk.length > 0) {\n      result.push(chunk);\n    }\n  }\n  return result;\n}\nfunction getDefaults() {\n  return {\n    errorLogging: \"json\",\n    stripInvalidXMLChars: false,\n    paragraphLoop: false,\n    nullGetter: function nullGetter(part) {\n      return part.module ? \"\" : \"undefined\";\n    },\n    xmlFileNames: [\"[Content_Types].xml\"],\n    parser: parser,\n    linebreaks: false,\n    fileTypeConfig: null,\n    delimiters: {\n      start: \"{\",\n      end: \"}\"\n    },\n    syntax: {\n      changeDelimiterPrefix: \"=\"\n    }\n  };\n}\nfunction xml2str(xmlNode) {\n  return new XMLSerializer().serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n  return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    endChar = _ref2[0],\n    startChar = _ref2[1];\n  return {\n    rstart: new RegExp(startChar, \"g\"),\n    rend: new RegExp(endChar, \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\nfunction wordToUtf8(string) {\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    var r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n  return string;\n}\nfunction utf8ToWord(string) {\n  var _string;\n  if ((_string = string) !== null && _string !== void 0 && _string.toString) {\n    // To make sure that the object given is a string (this is a noop for strings).\n    string = string.toString();\n  } else {\n    string = \"\";\n  }\n  var r;\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n  return string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n  var result = [];\n  for (var _i6 = 0; _i6 < arrays.length; _i6++) {\n    var array = arrays[_i6];\n    for (var _i8 = 0; _i8 < array.length; _i8++) {\n      var el = array[_i8];\n      result.push(el);\n    }\n  }\n  return result;\n}\nfunction pushArray(array1, array2) {\n  if (!array2) {\n    return array1;\n  }\n  for (var i = 0, len = array2.length; i < len; i++) {\n    array1.push(array2[i]);\n  }\n  return array1;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n  /*\n   * Regex is a string, content is the content. It returns an array of all\n   * matches with their offset, for example:\n   *\n   * regex=la\n   * content=lolalolilala\n   *\n   * Returns:\n   *\n   * [\n   *    {array: {0: 'la'}, offset: 2},\n   *    {array: {0: 'la'}, offset: 8},\n   *    {array: {0: 'la'}, offset: 10}\n   * ]\n   */\n  var matchArray = [];\n  var match;\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n  return matchArray;\n}\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \", \"/\"].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    for (var _i0 = 0, _elements2 = elements; _i0 < _elements2.length; _i0++) {\n      var element = _elements2[_i0];\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n    for (var _i10 = 0, _elements4 = elements; _i10 < _elements4.length; _i10++) {\n      var element = _elements4[_i10];\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n/*\n * Stryker disable all : because those are functions that depend on the parsed\n * structure based and we don't want minimal code here, but rather code that\n * makes things clear.\n */\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n    tag = _ref3.tag,\n    position = _ref3.position;\n  return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagEnd(tagType, _ref4) {\n  var type = _ref4.type,\n    tag = _ref4.tag,\n    position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(_ref5) {\n  var type = _ref5.type,\n    tag = _ref5.tag,\n    position = _ref5.position;\n  return [\"w:p\", \"a:p\", \"text:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"start\";\n}\nfunction isParagraphEnd(_ref6) {\n  var type = _ref6.type,\n    tag = _ref6.tag,\n    position = _ref6.position;\n  return [\"w:p\", \"a:p\", \"text:p\"].indexOf(tag) !== -1 && type === \"tag\" && position === \"end\";\n}\nfunction isTextStart(_ref7) {\n  var type = _ref7.type,\n    position = _ref7.position,\n    text = _ref7.text;\n  return text && type === \"tag\" && position === \"start\";\n}\nfunction isTextEnd(_ref8) {\n  var type = _ref8.type,\n    position = _ref8.position,\n    text = _ref8.text;\n  return text && type === \"tag\" && position === \"end\";\n}\nfunction isContent(_ref9) {\n  var type = _ref9.type,\n    position = _ref9.position;\n  return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref0, modules) {\n  var module = _ref0.module,\n    type = _ref0.type;\n  if (!(modules instanceof Array)) {\n    modules = [modules];\n  }\n  return type === \"placeholder\" && modules.indexOf(module) !== -1;\n}\n// Stryker restore all\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/g;\n/*\n * 00    NUL '\\0' (null character)\n * 01    SOH (start of heading)\n * 02    STX (start of text)\n * 03    ETX (end of text)\n * 04    EOT (end of transmission)\n * 05    ENQ (enquiry)\n * 06    ACK (acknowledge)\n * 07    BEL '\\a' (bell)\n * 08    BS  '\\b' (backspace)\n * 0B    VT  '\\v' (vertical tab)\n * 0C    FF  '\\f' (form feed)\n * 0E    SO  (shift out)\n * 0F    SI  (shift in)\n * 10    DLE (data link escape)\n * 11    DC1 (device control 1)\n * 12    DC2 (device control 2)\n * 13    DC3 (device control 3)\n * 14    DC4 (device control 4)\n * 15    NAK (negative ack.)\n * 16    SYN (synchronous idle)\n * 17    ETB (end of trans. blk)\n * 18    CAN (cancel)\n * 19    EM  (end of medium)\n * 1A    SUB (substitute)\n * 1B    ESC (escape)\n * 1C    FS  (file separator)\n * 1D    GS  (group separator)\n * 1E    RS  (record separator)\n * 1F    US  (unit separator)\n */\nfunction hasCorruptCharacters(string) {\n  corruptCharacters.lastIndex = 0;\n  return corruptCharacters.test(string);\n}\nfunction removeCorruptCharacters(string) {\n  if (typeof string !== \"string\") {\n    string = String(string);\n  }\n  return string.replace(corruptCharacters, \"\");\n}\nfunction invertMap(map) {\n  var invertedMap = {};\n  for (var key in map) {\n    var value = map[key];\n    invertedMap[value] || (invertedMap[value] = []);\n    invertedMap[value].push(key);\n  }\n  return invertedMap;\n}\n/*\n * This ensures that the sort is stable. The default Array.sort of the browser\n * is not stable in firefox, as the JS spec does not enforce the sort to be\n * stable.\n */\nfunction stableSort(arr, compare) {\n  // Stryker disable all : in previous versions of Chrome, sort was not stable by itself, so we had to add this. This is to support older versions of JS runners.\n  return arr.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  }).sort(function (a, b) {\n    return compare(a.item, b.item) || a.index - b.index;\n  }).map(function (_ref1) {\n    var item = _ref1.item;\n    return item;\n  });\n  // Stryker restore all\n}\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  isStarting: isStarting,\n  isEnding: isEnding,\n  isModule: isModule,\n  uniq: uniq,\n  getDuplicates: getDuplicates,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  removeCorruptCharacters: removeCorruptCharacters,\n  getDefaults: getDefaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  pushArray: pushArray,\n  invertMap: invertMap,\n  charMap: charMap,\n  getSingleAttribute: getSingleAttribute,\n  setSingleAttribute: setSingleAttribute,\n  isWhiteSpace: isWhiteSpace,\n  stableSort: stableSort\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jLXV0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsNkNBQTZDLFNBQVMsMERBQTBELFVBQVUsZ0NBQWdDO0FBQzFKLG1DQUFtQywrQ0FBK0MsOEJBQThCLE9BQU8sa0JBQWtCO0FBQ3pJLHVDQUF1QyxrR0FBa0csaUJBQWlCLHdDQUF3QyxNQUFNLHlDQUF5Qyw2QkFBNkIsVUFBVSxZQUFZLGtFQUFrRSxXQUFXLFlBQVksaUJBQWlCLFVBQVUsTUFBTSxpRkFBaUYsVUFBVSxvQkFBb0I7QUFDN2dCLDhCQUE4QjtBQUM5QixlQUFlLG1CQUFPLENBQUMsNEVBQWdCO0FBQ3ZDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUNyQztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlLGVBQWUsaUJBQWlCLGlCQUFpQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsUUFBUSxRQUFRLFlBQVk7QUFDckMsU0FBUyxRQUFRLFFBQVEsWUFBWTtBQUNyQyxTQUFTLFFBQVEsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0EsNkNBQTZDLHlCQUF5QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2RvYy11dGlscy5qcz84OTg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiQHhtbGRvbS94bWxkb21cIiksXG4gIERPTVBhcnNlciA9IF9yZXF1aXJlLkRPTVBhcnNlcixcbiAgWE1MU2VyaWFsaXplciA9IF9yZXF1aXJlLlhNTFNlcmlhbGl6ZXI7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1htbFRhZ05vdEZvdW5kID0gX3JlcXVpcmUyLnRocm93WG1sVGFnTm90Rm91bmQ7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIiksXG4gIGxhc3QgPSBfcmVxdWlyZTMubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZTMuZmlyc3Q7XG5mdW5jdGlvbiBpc1doaXRlU3BhY2UodmFsdWUpIHtcbiAgcmV0dXJuIC9eWyBcXG5cXHJcXHRdKyQvLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2VyKHRhZykge1xuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KHNjb3BlKSB7XG4gICAgICBpZiAodGFnID09PSBcIi5cIikge1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlW3RhZ107XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICB9O1xufVxudmFyIGF0dHJUb1JlZ2V4ID0ge307XG5mdW5jdGlvbiBzZXRTaW5nbGVBdHRyaWJ1dGUocGFydFZhbHVlLCBhdHRyLCBhdHRyVmFsdWUpIHtcbiAgdmFyIHJlZ2V4O1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgbmV4dC1saW5lIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhbiBvcHRpbWlzYXRpb25cbiAgaWYgKGF0dHJUb1JlZ2V4W2F0dHJdKSB7XG4gICAgcmVnZXggPSBhdHRyVG9SZWdleFthdHRyXTtcbiAgfSBlbHNlIHtcbiAgICByZWdleCA9IG5ldyBSZWdFeHAoXCIoPC4qIFwiLmNvbmNhdChhdHRyLCBcIj1cXFwiKShbXlxcXCJdKikoXFxcIi4qKSRcIikpO1xuICAgIGF0dHJUb1JlZ2V4W2F0dHJdID0gcmVnZXg7XG4gIH1cbiAgaWYgKHJlZ2V4LnRlc3QocGFydFZhbHVlKSkge1xuICAgIHJldHVybiBwYXJ0VmFsdWUucmVwbGFjZShyZWdleCwgXCIkMVwiLmNvbmNhdChhdHRyVmFsdWUsIFwiJDNcIikpO1xuICB9XG4gIHZhciBlbmQgPSBwYXJ0VmFsdWUubGFzdEluZGV4T2YoXCIvPlwiKTtcbiAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICBlbmQgPSBwYXJ0VmFsdWUubGFzdEluZGV4T2YoXCI+XCIpO1xuICB9XG4gIHJldHVybiBwYXJ0VmFsdWUuc3Vic3RyKDAsIGVuZCkgKyBcIiBcIi5jb25jYXQoYXR0ciwgXCI9XFxcIlwiKS5jb25jYXQoYXR0clZhbHVlLCBcIlxcXCJcIikgKyBwYXJ0VmFsdWUuc3Vic3RyKGVuZCk7XG59XG5mdW5jdGlvbiBnZXRTaW5nbGVBdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIGluZGV4ID0gdmFsdWUuaW5kZXhPZihcIiBcIi5jb25jYXQoYXR0cmlidXRlTmFtZSwgXCI9XFxcIlwiKSk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3RhcnRJbmRleCA9IHZhbHVlLnN1YnN0cihpbmRleCkuc2VhcmNoKC9bXCInXS8pICsgaW5kZXg7XG4gIHZhciBlbmRJbmRleCA9IHZhbHVlLnN1YnN0cihzdGFydEluZGV4ICsgMSkuc2VhcmNoKC9bXCInXS8pICsgc3RhcnRJbmRleDtcbiAgcmV0dXJuIHZhbHVlLnN1YnN0cihzdGFydEluZGV4ICsgMSwgZW5kSW5kZXggLSBzdGFydEluZGV4KTtcbn1cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc3VmZml4KSB7XG4gIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgcHJlZml4KSB7XG4gIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHByZWZpeC5sZW5ndGgpID09PSBwcmVmaXg7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVzKGFycikge1xuICB2YXIgZHVwbGljYXRlcyA9IFtdO1xuICB2YXIgaGFzaCA9IHt9LFxuICAgIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoIWhhc2hbYXJyW2ldXSkge1xuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGR1cGxpY2F0ZXMucHVzaChhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHVwbGljYXRlcztcbn1cbmZ1bmN0aW9uIHVuaXEoYXJyKSB7XG4gIHZhciBoYXNoID0ge30sXG4gICAgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmICghaGFzaFthcnJbaV1dKSB7XG4gICAgICBoYXNoW2FycltpXV0gPSB0cnVlO1xuICAgICAgcmVzdWx0LnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNodW5rQnkocGFyc2VkLCBmKSB7XG4gIHZhciBjaHVua3MgPSBbW11dO1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBwID0gcGFyc2VkW19pMl07XG4gICAgdmFyIGN1cnJlbnRDaHVuayA9IGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJlcyA9IGYocCk7XG4gICAgaWYgKHJlcyA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBjaHVua3MucHVzaChbcF0pO1xuICAgIH0gZWxzZSBpZiAocmVzID09PSBcImVuZFwiKSB7XG4gICAgICBjdXJyZW50Q2h1bmsucHVzaChwKTtcbiAgICAgIGNodW5rcy5wdXNoKFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENodW5rLnB1c2gocCk7XG4gICAgfVxuICB9IC8vIFJlbW92ZSBlbXB0eSBjaHVua3NcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBjaHVua3MubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBjaHVuayA9IGNodW5rc1tfaTRdO1xuICAgIGlmIChjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICByZXN1bHQucHVzaChjaHVuayk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0cygpIHtcbiAgcmV0dXJuIHtcbiAgICBlcnJvckxvZ2dpbmc6IFwianNvblwiLFxuICAgIHN0cmlwSW52YWxpZFhNTENoYXJzOiBmYWxzZSxcbiAgICBwYXJhZ3JhcGhMb29wOiBmYWxzZSxcbiAgICBudWxsR2V0dGVyOiBmdW5jdGlvbiBudWxsR2V0dGVyKHBhcnQpIHtcbiAgICAgIHJldHVybiBwYXJ0Lm1vZHVsZSA/IFwiXCIgOiBcInVuZGVmaW5lZFwiO1xuICAgIH0sXG4gICAgeG1sRmlsZU5hbWVzOiBbXCJbQ29udGVudF9UeXBlc10ueG1sXCJdLFxuICAgIHBhcnNlcjogcGFyc2VyLFxuICAgIGxpbmVicmVha3M6IGZhbHNlLFxuICAgIGZpbGVUeXBlQ29uZmlnOiBudWxsLFxuICAgIGRlbGltaXRlcnM6IHtcbiAgICAgIHN0YXJ0OiBcIntcIixcbiAgICAgIGVuZDogXCJ9XCJcbiAgICB9LFxuICAgIHN5bnRheDoge1xuICAgICAgY2hhbmdlRGVsaW1pdGVyUHJlZml4OiBcIj1cIlxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHhtbDJzdHIoeG1sTm9kZSkge1xuICByZXR1cm4gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyh4bWxOb2RlKS5yZXBsYWNlKC94bWxucyg6W2EtejAtOV0rKT89XCJcIiA/L2csIFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyMnhtbChzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQ29kZUF0KDApID09PSA2NTI3OSkge1xuICAgIC8vIEJPTSBzZXF1ZW5jZVxuICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3RyLCBcInRleHQveG1sXCIpO1xufVxudmFyIGNoYXJNYXAgPSBbW1wiJlwiLCBcIiZhbXA7XCJdLCBbXCI8XCIsIFwiJmx0O1wiXSwgW1wiPlwiLCBcIiZndDtcIl0sIFsnXCInLCBcIiZxdW90O1wiXSwgW1wiJ1wiLCBcIiZhcG9zO1wiXV07XG52YXIgY2hhck1hcFJlZ2V4ZXMgPSBjaGFyTWFwLm1hcChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKSxcbiAgICBlbmRDaGFyID0gX3JlZjJbMF0sXG4gICAgc3RhcnRDaGFyID0gX3JlZjJbMV07XG4gIHJldHVybiB7XG4gICAgcnN0YXJ0OiBuZXcgUmVnRXhwKHN0YXJ0Q2hhciwgXCJnXCIpLFxuICAgIHJlbmQ6IG5ldyBSZWdFeHAoZW5kQ2hhciwgXCJnXCIpLFxuICAgIHN0YXJ0OiBzdGFydENoYXIsXG4gICAgZW5kOiBlbmRDaGFyXG4gIH07XG59KTtcbmZ1bmN0aW9uIHdvcmRUb1V0Zjgoc3RyaW5nKSB7XG4gIGZvciAodmFyIGkgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yc3RhcnQsIHIuZW5kKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuZnVuY3Rpb24gdXRmOFRvV29yZChzdHJpbmcpIHtcbiAgdmFyIF9zdHJpbmc7XG4gIGlmICgoX3N0cmluZyA9IHN0cmluZykgIT09IG51bGwgJiYgX3N0cmluZyAhPT0gdm9pZCAwICYmIF9zdHJpbmcudG9TdHJpbmcpIHtcbiAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB0aGUgb2JqZWN0IGdpdmVuIGlzIGEgc3RyaW5nICh0aGlzIGlzIGEgbm9vcCBmb3Igc3RyaW5ncykuXG4gICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgc3RyaW5nID0gXCJcIjtcbiAgfVxuICB2YXIgcjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGFyTWFwUmVnZXhlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICByID0gY2hhck1hcFJlZ2V4ZXNbaV07XG4gICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2Uoci5yZW5kLCByLnN0YXJ0KTtcbiAgfVxuICByZXR1cm4gc3RyaW5nO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHdyaXR0ZW4gd2l0aCBmb3IgbG9vcHMgZm9yIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBjb25jYXRBcnJheXMoYXJyYXlzKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYXJyYXlzLmxlbmd0aDsgX2k2KyspIHtcbiAgICB2YXIgYXJyYXkgPSBhcnJheXNbX2k2XTtcbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBhcnJheS5sZW5ndGg7IF9pOCsrKSB7XG4gICAgICB2YXIgZWwgPSBhcnJheVtfaThdO1xuICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcHVzaEFycmF5KGFycmF5MSwgYXJyYXkyKSB7XG4gIGlmICghYXJyYXkyKSB7XG4gICAgcmV0dXJuIGFycmF5MTtcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkxLnB1c2goYXJyYXkyW2ldKTtcbiAgfVxuICByZXR1cm4gYXJyYXkxO1xufVxudmFyIHNwYWNlUmVnZXhwID0gbmV3IFJlZ0V4cChTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksIFwiZ1wiKTtcbmZ1bmN0aW9uIGNvbnZlcnRTcGFjZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKHNwYWNlUmVnZXhwLCBcIiBcIik7XG59XG5mdW5jdGlvbiBwcmVnTWF0Y2hBbGwocmVnZXgsIGNvbnRlbnQpIHtcbiAgLypcbiAgICogUmVnZXggaXMgYSBzdHJpbmcsIGNvbnRlbnQgaXMgdGhlIGNvbnRlbnQuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgYWxsXG4gICAqIG1hdGNoZXMgd2l0aCB0aGVpciBvZmZzZXQsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiByZWdleD1sYVxuICAgKiBjb250ZW50PWxvbGFsb2xpbGFsYVxuICAgKlxuICAgKiBSZXR1cm5zOlxuICAgKlxuICAgKiBbXG4gICAqICAgIHthcnJheTogezA6ICdsYSd9LCBvZmZzZXQ6IDJ9LFxuICAgKiAgICB7YXJyYXk6IHswOiAnbGEnfSwgb2Zmc2V0OiA4fSxcbiAgICogICAge2FycmF5OiB7MDogJ2xhJ30sIG9mZnNldDogMTB9XG4gICAqIF1cbiAgICovXG4gIHZhciBtYXRjaEFycmF5ID0gW107XG4gIHZhciBtYXRjaDtcbiAgd2hpbGUgKChtYXRjaCA9IHJlZ2V4LmV4ZWMoY29udGVudCkpICE9IG51bGwpIHtcbiAgICBtYXRjaEFycmF5LnB1c2goe1xuICAgICAgYXJyYXk6IG1hdGNoLFxuICAgICAgb2Zmc2V0OiBtYXRjaC5pbmRleFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBtYXRjaEFycmF5O1xufVxuZnVuY3Rpb24gaXNFbmRpbmcodmFsdWUsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIjwvXCIgKyBlbGVtZW50ICsgXCI+XCI7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aW5nKHZhbHVlLCBlbGVtZW50KSB7XG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKFwiPFwiICsgZWxlbWVudCkgPT09IDAgJiYgW1wiPlwiLCBcIiBcIiwgXCIvXCJdLmluZGV4T2YodmFsdWVbZWxlbWVudC5sZW5ndGggKyAxXSkgIT09IC0xO1xufVxuZnVuY3Rpb24gZ2V0UmlnaHQocGFyc2VkLCBlbGVtZW50LCBpbmRleCkge1xuICB2YXIgdmFsID0gZ2V0UmlnaHRPck51bGwocGFyc2VkLCBlbGVtZW50LCBpbmRleCk7XG4gIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93WG1sVGFnTm90Rm91bmQoe1xuICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSaWdodE9yTnVsbChwYXJzZWQsIGVsZW1lbnRzLCBpbmRleCkge1xuICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuICB9XG4gIHZhciBsZXZlbCA9IDE7XG4gIGZvciAodmFyIGkgPSBpbmRleCwgbCA9IHBhcnNlZC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtpXTtcbiAgICBmb3IgKHZhciBfaTAgPSAwLCBfZWxlbWVudHMyID0gZWxlbWVudHM7IF9pMCA8IF9lbGVtZW50czIubGVuZ3RoOyBfaTArKykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBfZWxlbWVudHMyW19pMF07XG4gICAgICBpZiAoaXNFbmRpbmcocGFydC52YWx1ZSwgZWxlbWVudCkpIHtcbiAgICAgICAgbGV2ZWwtLTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1N0YXJ0aW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0TGVmdChwYXJzZWQsIGVsZW1lbnQsIGluZGV4KSB7XG4gIHZhciB2YWwgPSBnZXRMZWZ0T3JOdWxsKHBhcnNlZCwgZWxlbWVudCwgaW5kZXgpO1xuICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0aHJvd1htbFRhZ05vdEZvdW5kKHtcbiAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBpbmRleDogaW5kZXhcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRMZWZ0T3JOdWxsKHBhcnNlZCwgZWxlbWVudHMsIGluZGV4KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gIH1cbiAgdmFyIGxldmVsID0gMTtcbiAgZm9yICh2YXIgaSA9IGluZGV4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gcGFyc2VkW2ldO1xuICAgIGZvciAodmFyIF9pMTAgPSAwLCBfZWxlbWVudHM0ID0gZWxlbWVudHM7IF9pMTAgPCBfZWxlbWVudHM0Lmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IF9lbGVtZW50czRbX2kxMF07XG4gICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LnZhbHVlLCBlbGVtZW50KSkge1xuICAgICAgICBsZXZlbC0tO1xuICAgICAgfVxuICAgICAgaWYgKGlzRW5kaW5nKHBhcnQudmFsdWUsIGVsZW1lbnQpKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKlxuICogU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhvc2UgYXJlIGZ1bmN0aW9ucyB0aGF0IGRlcGVuZCBvbiB0aGUgcGFyc2VkXG4gKiBzdHJ1Y3R1cmUgYmFzZWQgYW5kIHdlIGRvbid0IHdhbnQgbWluaW1hbCBjb2RlIGhlcmUsIGJ1dCByYXRoZXIgY29kZSB0aGF0XG4gKiBtYWtlcyB0aGluZ3MgY2xlYXIuXG4gKi9cbmZ1bmN0aW9uIGlzVGFnU3RhcnQodGFnVHlwZSwgX3JlZjMpIHtcbiAgdmFyIHR5cGUgPSBfcmVmMy50eXBlLFxuICAgIHRhZyA9IF9yZWYzLnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWYzLnBvc2l0aW9uO1xuICByZXR1cm4gdHlwZSA9PT0gXCJ0YWdcIiAmJiB0YWcgPT09IHRhZ1R5cGUgJiYgKHBvc2l0aW9uID09PSBcInN0YXJ0XCIgfHwgcG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIik7XG59XG5mdW5jdGlvbiBpc1RhZ0VuZCh0YWdUeXBlLCBfcmVmNCkge1xuICB2YXIgdHlwZSA9IF9yZWY0LnR5cGUsXG4gICAgdGFnID0gX3JlZjQudGFnLFxuICAgIHBvc2l0aW9uID0gX3JlZjQucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInRhZ1wiICYmIHRhZyA9PT0gdGFnVHlwZSAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzUGFyYWdyYXBoU3RhcnQoX3JlZjUpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNS50eXBlLFxuICAgIHRhZyA9IF9yZWY1LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY1LnBvc2l0aW9uO1xuICByZXR1cm4gW1widzpwXCIsIFwiYTpwXCIsIFwidGV4dDpwXCJdLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xufVxuZnVuY3Rpb24gaXNQYXJhZ3JhcGhFbmQoX3JlZjYpIHtcbiAgdmFyIHR5cGUgPSBfcmVmNi50eXBlLFxuICAgIHRhZyA9IF9yZWY2LnRhZyxcbiAgICBwb3NpdGlvbiA9IF9yZWY2LnBvc2l0aW9uO1xuICByZXR1cm4gW1widzpwXCIsIFwiYTpwXCIsIFwidGV4dDpwXCJdLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdHlwZSA9PT0gXCJ0YWdcIiAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIjtcbn1cbmZ1bmN0aW9uIGlzVGV4dFN0YXJ0KF9yZWY3KSB7XG4gIHZhciB0eXBlID0gX3JlZjcudHlwZSxcbiAgICBwb3NpdGlvbiA9IF9yZWY3LnBvc2l0aW9uLFxuICAgIHRleHQgPSBfcmVmNy50ZXh0O1xuICByZXR1cm4gdGV4dCAmJiB0eXBlID09PSBcInRhZ1wiICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBpc1RleHRFbmQoX3JlZjgpIHtcbiAgdmFyIHR5cGUgPSBfcmVmOC50eXBlLFxuICAgIHBvc2l0aW9uID0gX3JlZjgucG9zaXRpb24sXG4gICAgdGV4dCA9IF9yZWY4LnRleHQ7XG4gIHJldHVybiB0ZXh0ICYmIHR5cGUgPT09IFwidGFnXCIgJiYgcG9zaXRpb24gPT09IFwiZW5kXCI7XG59XG5mdW5jdGlvbiBpc0NvbnRlbnQoX3JlZjkpIHtcbiAgdmFyIHR5cGUgPSBfcmVmOS50eXBlLFxuICAgIHBvc2l0aW9uID0gX3JlZjkucG9zaXRpb247XG4gIHJldHVybiB0eXBlID09PSBcInBsYWNlaG9sZGVyXCIgfHwgdHlwZSA9PT0gXCJjb250ZW50XCIgJiYgcG9zaXRpb24gPT09IFwiaW5zaWRldGFnXCI7XG59XG5mdW5jdGlvbiBpc01vZHVsZShfcmVmMCwgbW9kdWxlcykge1xuICB2YXIgbW9kdWxlID0gX3JlZjAubW9kdWxlLFxuICAgIHR5cGUgPSBfcmVmMC50eXBlO1xuICBpZiAoIShtb2R1bGVzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgbW9kdWxlcyA9IFttb2R1bGVzXTtcbiAgfVxuICByZXR1cm4gdHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiICYmIG1vZHVsZXMuaW5kZXhPZihtb2R1bGUpICE9PSAtMTtcbn1cbi8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcblxudmFyIGNvcnJ1cHRDaGFyYWN0ZXJzID0gL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRl0vZztcbi8qXG4gKiAwMCAgICBOVUwgJ1xcMCcgKG51bGwgY2hhcmFjdGVyKVxuICogMDEgICAgU09IIChzdGFydCBvZiBoZWFkaW5nKVxuICogMDIgICAgU1RYIChzdGFydCBvZiB0ZXh0KVxuICogMDMgICAgRVRYIChlbmQgb2YgdGV4dClcbiAqIDA0ICAgIEVPVCAoZW5kIG9mIHRyYW5zbWlzc2lvbilcbiAqIDA1ICAgIEVOUSAoZW5xdWlyeSlcbiAqIDA2ICAgIEFDSyAoYWNrbm93bGVkZ2UpXG4gKiAwNyAgICBCRUwgJ1xcYScgKGJlbGwpXG4gKiAwOCAgICBCUyAgJ1xcYicgKGJhY2tzcGFjZSlcbiAqIDBCICAgIFZUICAnXFx2JyAodmVydGljYWwgdGFiKVxuICogMEMgICAgRkYgICdcXGYnIChmb3JtIGZlZWQpXG4gKiAwRSAgICBTTyAgKHNoaWZ0IG91dClcbiAqIDBGICAgIFNJICAoc2hpZnQgaW4pXG4gKiAxMCAgICBETEUgKGRhdGEgbGluayBlc2NhcGUpXG4gKiAxMSAgICBEQzEgKGRldmljZSBjb250cm9sIDEpXG4gKiAxMiAgICBEQzIgKGRldmljZSBjb250cm9sIDIpXG4gKiAxMyAgICBEQzMgKGRldmljZSBjb250cm9sIDMpXG4gKiAxNCAgICBEQzQgKGRldmljZSBjb250cm9sIDQpXG4gKiAxNSAgICBOQUsgKG5lZ2F0aXZlIGFjay4pXG4gKiAxNiAgICBTWU4gKHN5bmNocm9ub3VzIGlkbGUpXG4gKiAxNyAgICBFVEIgKGVuZCBvZiB0cmFucy4gYmxrKVxuICogMTggICAgQ0FOIChjYW5jZWwpXG4gKiAxOSAgICBFTSAgKGVuZCBvZiBtZWRpdW0pXG4gKiAxQSAgICBTVUIgKHN1YnN0aXR1dGUpXG4gKiAxQiAgICBFU0MgKGVzY2FwZSlcbiAqIDFDICAgIEZTICAoZmlsZSBzZXBhcmF0b3IpXG4gKiAxRCAgICBHUyAgKGdyb3VwIHNlcGFyYXRvcilcbiAqIDFFICAgIFJTICAocmVjb3JkIHNlcGFyYXRvcilcbiAqIDFGICAgIFVTICAodW5pdCBzZXBhcmF0b3IpXG4gKi9cbmZ1bmN0aW9uIGhhc0NvcnJ1cHRDaGFyYWN0ZXJzKHN0cmluZykge1xuICBjb3JydXB0Q2hhcmFjdGVycy5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gY29ycnVwdENoYXJhY3RlcnMudGVzdChzdHJpbmcpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMoc3RyaW5nKSB7XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgc3RyaW5nID0gU3RyaW5nKHN0cmluZyk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGNvcnJ1cHRDaGFyYWN0ZXJzLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIGludmVydE1hcChtYXApIHtcbiAgdmFyIGludmVydGVkTWFwID0ge307XG4gIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICB2YXIgdmFsdWUgPSBtYXBba2V5XTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0gfHwgKGludmVydGVkTWFwW3ZhbHVlXSA9IFtdKTtcbiAgICBpbnZlcnRlZE1hcFt2YWx1ZV0ucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBpbnZlcnRlZE1hcDtcbn1cbi8qXG4gKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgc29ydCBpcyBzdGFibGUuIFRoZSBkZWZhdWx0IEFycmF5LnNvcnQgb2YgdGhlIGJyb3dzZXJcbiAqIGlzIG5vdCBzdGFibGUgaW4gZmlyZWZveCwgYXMgdGhlIEpTIHNwZWMgZG9lcyBub3QgZW5mb3JjZSB0aGUgc29ydCB0byBiZVxuICogc3RhYmxlLlxuICovXG5mdW5jdGlvbiBzdGFibGVTb3J0KGFyciwgY29tcGFyZSkge1xuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogaW4gcHJldmlvdXMgdmVyc2lvbnMgb2YgQ2hyb21lLCBzb3J0IHdhcyBub3Qgc3RhYmxlIGJ5IGl0c2VsZiwgc28gd2UgaGFkIHRvIGFkZCB0aGlzLiBUaGlzIGlzIHRvIHN1cHBvcnQgb2xkZXIgdmVyc2lvbnMgb2YgSlMgcnVubmVycy5cbiAgcmV0dXJuIGFyci5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9O1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYS5pdGVtLCBiLml0ZW0pIHx8IGEuaW5kZXggLSBiLmluZGV4O1xuICB9KS5tYXAoZnVuY3Rpb24gKF9yZWYxKSB7XG4gICAgdmFyIGl0ZW0gPSBfcmVmMS5pdGVtO1xuICAgIHJldHVybiBpdGVtO1xuICB9KTtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuZHNXaXRoOiBlbmRzV2l0aCxcbiAgc3RhcnRzV2l0aDogc3RhcnRzV2l0aCxcbiAgaXNDb250ZW50OiBpc0NvbnRlbnQsXG4gIGlzUGFyYWdyYXBoU3RhcnQ6IGlzUGFyYWdyYXBoU3RhcnQsXG4gIGlzUGFyYWdyYXBoRW5kOiBpc1BhcmFncmFwaEVuZCxcbiAgaXNUYWdTdGFydDogaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQ6IGlzVGFnRW5kLFxuICBpc1RleHRTdGFydDogaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZDogaXNUZXh0RW5kLFxuICBpc1N0YXJ0aW5nOiBpc1N0YXJ0aW5nLFxuICBpc0VuZGluZzogaXNFbmRpbmcsXG4gIGlzTW9kdWxlOiBpc01vZHVsZSxcbiAgdW5pcTogdW5pcSxcbiAgZ2V0RHVwbGljYXRlczogZ2V0RHVwbGljYXRlcyxcbiAgY2h1bmtCeTogY2h1bmtCeSxcbiAgbGFzdDogbGFzdCxcbiAgZmlyc3Q6IGZpcnN0LFxuICB4bWwyc3RyOiB4bWwyc3RyLFxuICBzdHIyeG1sOiBzdHIyeG1sLFxuICBnZXRSaWdodE9yTnVsbDogZ2V0UmlnaHRPck51bGwsXG4gIGdldFJpZ2h0OiBnZXRSaWdodCxcbiAgZ2V0TGVmdE9yTnVsbDogZ2V0TGVmdE9yTnVsbCxcbiAgZ2V0TGVmdDogZ2V0TGVmdCxcbiAgcHJlZ01hdGNoQWxsOiBwcmVnTWF0Y2hBbGwsXG4gIGNvbnZlcnRTcGFjZXM6IGNvbnZlcnRTcGFjZXMsXG4gIGNoYXJNYXBSZWdleGVzOiBjaGFyTWFwUmVnZXhlcyxcbiAgaGFzQ29ycnVwdENoYXJhY3RlcnM6IGhhc0NvcnJ1cHRDaGFyYWN0ZXJzLFxuICByZW1vdmVDb3JydXB0Q2hhcmFjdGVyczogcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMsXG4gIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgd29yZFRvVXRmODogd29yZFRvVXRmOCxcbiAgdXRmOFRvV29yZDogdXRmOFRvV29yZCxcbiAgY29uY2F0QXJyYXlzOiBjb25jYXRBcnJheXMsXG4gIHB1c2hBcnJheTogcHVzaEFycmF5LFxuICBpbnZlcnRNYXA6IGludmVydE1hcCxcbiAgY2hhck1hcDogY2hhck1hcCxcbiAgZ2V0U2luZ2xlQXR0cmlidXRlOiBnZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIHNldFNpbmdsZUF0dHJpYnV0ZTogc2V0U2luZ2xlQXR0cmlidXRlLFxuICBpc1doaXRlU3BhY2U6IGlzV2hpdGVTcGFjZSxcbiAgc3RhYmxlU29ydDogc3RhYmxlU29ydFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/docxtemplater.js":
/*!************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/docxtemplater.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _excluded = [\"modules\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar DocUtils = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\");\nvar z = __webpack_require__(/*! ./minizod.js */ \"(rsc)/../../node_modules/docxtemplater/js/minizod.js\");\n\n// Schema definitions for DXT.ConstructorOptions\nvar dxtSyntaxSchema = z.object({\n  allowUnopenedTag: z[\"boolean\"]().optional(),\n  allowUnclosedTag: z[\"boolean\"]().optional(),\n  allowUnbalancedLoops: z[\"boolean\"]().optional(),\n  changeDelimiterPrefix: z.string().optional().nullable()\n});\nvar dxtOptionsSchema = z.object({\n  delimiters: z.object({\n    start: z.string().nullable(),\n    end: z.string().nullable()\n  }).strict().optional(),\n  fileTypeConfig: z.object({}).optional(),\n  paragraphLoop: z[\"boolean\"]().optional(),\n  parser: z[\"function\"]().optional(),\n  errorLogging: z.union([z[\"boolean\"](), z.string()]).optional(),\n  linebreaks: z[\"boolean\"]().optional(),\n  nullGetter: z[\"function\"]().optional(),\n  syntax: dxtSyntaxSchema.optional(),\n  stripInvalidXMLChars: z[\"boolean\"]().optional()\n}).strict();\nvar _require = __webpack_require__(/*! ./get-relation-types.js */ \"(rsc)/../../node_modules/docxtemplater/js/get-relation-types.js\"),\n  getRelsTypes = _require.getRelsTypes;\nvar _require2 = __webpack_require__(/*! ./get-content-types.js */ \"(rsc)/../../node_modules/docxtemplater/js/get-content-types.js\"),\n  collectContentTypes = _require2.collectContentTypes,\n  getContentTypes = _require2.getContentTypes;\nvar moduleWrapper = __webpack_require__(/*! ./module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar traits = __webpack_require__(/*! ./traits.js */ \"(rsc)/../../node_modules/docxtemplater/js/traits.js\");\nvar commonModule = __webpack_require__(/*! ./modules/common.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/common.js\");\nvar createScope = __webpack_require__(/*! ./scope-manager.js */ \"(rsc)/../../node_modules/docxtemplater/js/scope-manager.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/../../node_modules/docxtemplater/js/lexer.js\");\nvar _require3 = __webpack_require__(/*! ./get-tags.js */ \"(rsc)/../../node_modules/docxtemplater/js/get-tags.js\"),\n  _getTags = _require3.getTags;\nvar logErrors = __webpack_require__(/*! ./error-logger.js */ \"(rsc)/../../node_modules/docxtemplater/js/error-logger.js\");\nvar _require4 = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  throwMultiError = _require4.throwMultiError,\n  throwResolveBeforeCompile = _require4.throwResolveBeforeCompile,\n  throwRenderInvalidTemplate = _require4.throwRenderInvalidTemplate,\n  throwRenderTwice = _require4.throwRenderTwice,\n  XTInternalError = _require4.XTInternalError,\n  XTTemplateError = _require4.XTTemplateError,\n  throwFileTypeNotIdentified = _require4.throwFileTypeNotIdentified,\n  throwFileTypeNotHandled = _require4.throwFileTypeNotHandled,\n  throwApiVersionError = _require4.throwApiVersionError;\nDocUtils.getRelsTypes = getRelsTypes;\nDocUtils.traits = traits;\nDocUtils.moduleWrapper = moduleWrapper;\nDocUtils.collectContentTypes = collectContentTypes;\nDocUtils.getContentTypes = getContentTypes;\nvar getDefaults = DocUtils.getDefaults,\n  str2xml = DocUtils.str2xml,\n  xml2str = DocUtils.xml2str,\n  concatArrays = DocUtils.concatArrays,\n  uniq = DocUtils.uniq,\n  getDuplicates = DocUtils.getDuplicates,\n  stableSort = DocUtils.stableSort,\n  pushArray = DocUtils.pushArray,\n  utf8ToWord = DocUtils.utf8ToWord,\n  invertMap = DocUtils.invertMap;\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar currentModuleApiVersion = [3, 47, 2];\nfunction throwIfDuplicateModules(modules) {\n  var duplicates = getDuplicates(modules.map(function (_ref) {\n    var name = _ref.name;\n    return name;\n  }));\n  if (duplicates.length > 0) {\n    throw new XTInternalError(\"Detected duplicate module \\\"\".concat(duplicates[0], \"\\\"\"));\n  }\n}\nfunction addXmlFileNamesFromXmlContentType(doc) {\n  for (var _i2 = 0, _doc$modules2 = doc.modules; _i2 < _doc$modules2.length; _i2++) {\n    var _module = _doc$modules2[_i2];\n    for (var _i4 = 0, _ref3 = _module.xmlContentTypes || []; _i4 < _ref3.length; _i4++) {\n      var contentType = _ref3[_i4];\n      var candidates = doc.invertedContentTypes[contentType] || [];\n      for (var _i6 = 0; _i6 < candidates.length; _i6++) {\n        var candidate = candidates[_i6];\n        if (doc.zip.files[candidate]) {\n          doc.options.xmlFileNames.push(candidate);\n        }\n      }\n    }\n  }\n}\nfunction reorderModules(modules) {\n  /**\n   * Modules will be sorted according to priority.\n   *\n   * Input example:\n   * [\n   *   { priority: 1, name: \"FooMod\" },\n   *   { priority: -1, name: \"XMod\" },\n   *   { priority: 4, name: \"OtherMod\" }\n   * ]\n   *\n   * Output example (sorted by priority in descending order):\n   * [\n   *   { priority: 4, name: \"OtherMod\" },\n   *   { priority: 1, name: \"FooMod\" },\n   *   { priority: -1, name: \"XMod\" }\n   * ]\n   * Tested in #test-reorder-modules\n   */\n  return stableSort(modules, function (m1, m2) {\n    return (m2.priority || 0) - (m1.priority || 0);\n  });\n}\nfunction zipFileOrder(files) {\n  var allFiles = [];\n  for (var name in files) {\n    allFiles.push(name);\n  }\n  /*\n   * The first files that need to be put in the zip file are :\n   * [Content_Types].xml and _rels/.rels\n   */\n  var resultFiles = [ctXML, relsFile];\n\n  /*\n   * The next files that should be in the zip file are :\n   *\n   * - word/* (ie word/document.xml, word/header1.xml, ...)\n   * - xl/* (ie xl/worksheets/sheet1.xml)\n   * - ppt/* (ie ppt/slides/slide1.xml)\n   */\n  var prefixes = [\"word/\", \"xl/\", \"ppt/\"];\n  for (var _i8 = 0; _i8 < allFiles.length; _i8++) {\n    var _name = allFiles[_i8];\n    for (var _i0 = 0; _i0 < prefixes.length; _i0++) {\n      var prefix = prefixes[_i0];\n      if (_name.indexOf(\"\".concat(prefix)) === 0) {\n        resultFiles.push(_name);\n      }\n    }\n  }\n  /*\n   * Push the rest of files, such as docProps/core.xml and docProps/app.xml\n   */\n  for (var _i10 = 0; _i10 < allFiles.length; _i10++) {\n    var _name2 = allFiles[_i10];\n    if (resultFiles.indexOf(_name2) === -1) {\n      resultFiles.push(_name2);\n    }\n  }\n  return resultFiles;\n}\nfunction deprecatedMessage(obj, message) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  // eslint-disable-next-line no-console\n  console.warn(message);\n}\nfunction deprecatedMethod(obj, method) {\n  if (obj.hideDeprecations === true) {\n    return;\n  }\n  return deprecatedMessage(obj, \"Deprecated method \\\".\".concat(method, \"\\\", view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \").concat(new Error().stack));\n}\nfunction dropUnsupportedFileTypesModules(doc) {\n  doc.modules = doc.modules.filter(function (module) {\n    if (!module.supportedFileTypes) {\n      return true;\n    }\n    if (!Array.isArray(module.supportedFileTypes)) {\n      throw new Error(\"The supportedFileTypes field of the module must be an array\");\n    }\n    var isSupportedModule = module.supportedFileTypes.includes(doc.fileType);\n    if (!isSupportedModule) {\n      module.on(\"detached\");\n    }\n    return isSupportedModule;\n  });\n}\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  doc.errors = concatArrays(Object.keys(compiled).map(function (name) {\n    return compiled[name].allErrors;\n  }));\n  if (doc.errors.length !== 0) {\n    if (doc.options.errorLogging) {\n      logErrors(doc.errors, doc.options.errorLogging);\n    }\n    throwMultiError(doc.errors);\n  }\n}\nfunction isBuffer(v) {\n  return typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer === \"function\" && Buffer.isBuffer(v);\n}\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref4$modules = _ref4.modules,\n      modules = _ref4$modules === void 0 ? [] : _ref4$modules,\n      options = _objectWithoutProperties(_ref4, _excluded);\n    _classCallCheck(this, Docxtemplater);\n    this.targets = [];\n    this.rendered = false;\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.xmlDocuments = {};\n    if (arguments.length === 0) {\n      deprecatedMessage(this, \"Deprecated docxtemplater constructor with no arguments, view upgrade guide : https://docxtemplater.com/docs/api/#upgrade-guide, stack : \".concat(new Error().stack));\n      this.hideDeprecations = true;\n      this.setOptions(options);\n    } else {\n      this.hideDeprecations = true;\n      this.setOptions(options);\n      if (isBuffer(zip)) {\n        throw new Error(\"You passed a Buffer to the Docxtemplater constructor. The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      if (!Array.isArray(modules)) {\n        throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n      }\n      for (var _i12 = 0; _i12 < modules.length; _i12++) {\n        var _module2 = modules[_i12];\n        this.attachModule(_module2);\n      }\n      this.loadZip(zip);\n      this.compile();\n      this.v4Constructor = true;\n    }\n    this.hideDeprecations = false;\n  }\n  return _createClass(Docxtemplater, [{\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i14 = 0, _this$modules2 = this.modules; _i14 < _this$modules2.length; _i14++) {\n        var _module3 = _this$modules2[_i14];\n        _module3.set(obj);\n      }\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      for (var _i16 = 0, _this$modules4 = this.modules; _i16 < _this$modules4.length; _i16++) {\n        var _module4 = _this$modules4[_i16];\n        _module4.on(eventName);\n      }\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      if (this.v4Constructor) {\n        throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"attachModule\");\n      var moduleType = _typeof(module);\n      if (moduleType === \"function\") {\n        throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n      }\n      if (!module || moduleType !== \"object\") {\n        throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n      }\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n      if (module.attached === true) {\n        if (typeof module.clone === \"function\") {\n          module = module.clone();\n        } else {\n          throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n        }\n      }\n      module.attached = true;\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      if (this.fileType) {\n        dropUnsupportedFileTypesModules(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"findModule\",\n    value: function findModule(name) {\n      for (var _i18 = 0, _this$modules6 = this.modules; _i18 < _this$modules6.length; _i18++) {\n        var _module5 = _this$modules6[_i18];\n        if (_module5.name === name) {\n          return _module5;\n        }\n      }\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this$delimiters, _this$delimiters2;\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n      var result = dxtOptionsSchema.validate(options);\n      if (result.success === false) {\n        throw new Error(result.error);\n      }\n      deprecatedMethod(this, \"setOptions\");\n      this.options = {};\n      var defaults = getDefaults();\n      for (var key in defaults) {\n        var defaultValue = defaults[key];\n        this.options[key] = options[key] != null ? options[key] : this[key] || defaultValue;\n        this[key] = this.options[key];\n      }\n      (_this$delimiters = this.delimiters).start && (_this$delimiters.start = utf8ToWord(this.delimiters.start));\n      (_this$delimiters2 = this.delimiters).end && (_this$delimiters2.end = utf8ToWord(this.delimiters.end));\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (this.v4Constructor) {\n        throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n      }\n      deprecatedMethod(this, \"loadZip\");\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      for (var _i20 = 0, _this$modules8 = this.modules; _i20 < _this$modules8.length; _i20++) {\n        var _module6 = _this$modules8[_i20];\n        _module6.zip = this.zip;\n        _module6.docxtemplater = this;\n        _module6.fileTypeConfig = this.fileTypeConfig;\n        _module6.fileType = this.fileType;\n        _module6.xtOptions = this.options;\n        _module6.modules = this.modules;\n      }\n      dropUnsupportedFileTypesModules(this);\n      return this;\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      var _this$scopeManagers;\n      (_this$scopeManagers = this.scopeManagers)[to] || (_this$scopeManagers[to] = createScope({\n        tags: tags,\n        parser: this.parser,\n        cachedParsers: currentFile.cachedParsers\n      }));\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this = this;\n      deprecatedMethod(this, \"resolveData\");\n      var errors = [];\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n      return Promise.resolve(data).then(function (data) {\n        _this.data = data;\n        _this.setModules({\n          data: _this.data,\n          Lexer: Lexer\n        });\n        _this.mapper = _this.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this.mapper).map(function (to) {\n          var _this$mapper$to = _this.mapper[to],\n            from = _this$mapper$to.from,\n            data = _this$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this.getScopeManager(to, currentFile, data);\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              pushArray(errors, errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            if (_this.options.errorLogging) {\n              logErrors(errors, _this.options.errorLogging);\n            }\n            throwMultiError(errors);\n          }\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      deprecatedMethod(this, \"compile\");\n      this.updateFileTypeConfig();\n      throwIfDuplicateModules(this.modules);\n      this.modules = reorderModules(this.modules);\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n      var options = this.options;\n      for (var _i22 = 0, _this$modules0 = this.modules; _i22 < _this$modules0.length; _i22++) {\n        var _module7 = _this$modules0[_i22];\n        options = _module7.optionsTransformer(options, this);\n      }\n      this.options = options;\n      this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n      for (var _i24 = 0, _this$options$xmlFile2 = this.options.xmlFileNames; _i24 < _this$options$xmlFile2.length; _i24++) {\n        var fileName = _this$options$xmlFile2[_i24];\n        var content = this.zip.files[fileName].asText();\n        this.xmlDocuments[fileName] = str2xml(content);\n      }\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      for (var _i26 = 0, _this$modules10 = this.modules; _i26 < _this$modules10.length; _i26++) {\n        var _module8 = _this$modules10[_i26];\n        _module8.xmlDocuments = this.xmlDocuments;\n      }\n      this.getTemplatedFiles();\n      /*\n       * Loop inside all templatedFiles (ie xml files with content).\n       * Sometimes they don't exist (footer.xml for example)\n       */\n      this.sendEvent(\"before-preparse\");\n      for (var _i28 = 0, _this$templatedFiles2 = this.templatedFiles; _i28 < _this$templatedFiles2.length; _i28++) {\n        var _fileName = _this$templatedFiles2[_i28];\n        if (this.zip.files[_fileName] != null) {\n          this.precompileFile(_fileName);\n        }\n      }\n      this.sendEvent(\"after-preparse\");\n      for (var _i30 = 0, _this$templatedFiles4 = this.templatedFiles; _i30 < _this$templatedFiles4.length; _i30++) {\n        var _fileName2 = _this$templatedFiles4[_i30];\n        if (this.zip.files[_fileName2] != null) {\n          this.compiled[_fileName2].parse({\n            noPostParse: true\n          });\n        }\n      }\n      this.sendEvent(\"after-parse\");\n      for (var _i32 = 0, _this$templatedFiles6 = this.templatedFiles; _i32 < _this$templatedFiles6.length; _i32++) {\n        var _fileName3 = _this$templatedFiles6[_i32];\n        if (this.zip.files[_fileName3] != null) {\n          this.compiled[_fileName3].postparse();\n        }\n      }\n      this.sendEvent(\"after-postparse\");\n      this.setModules({\n        compiled: this.compiled\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      this.relsTypes = getRelsTypes(this.zip);\n      var _getContentTypes = getContentTypes(this.zip),\n        overrides = _getContentTypes.overrides,\n        defaults = _getContentTypes.defaults,\n        contentTypes = _getContentTypes.contentTypes,\n        contentTypeXml = _getContentTypes.contentTypeXml;\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n      var fileType;\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n      for (var _i34 = 0, _this$modules12 = this.modules; _i34 < _this$modules12.length; _i34++) {\n        var _module9 = _this$modules12[_i34];\n        fileType = _module9.getFileType({\n          zip: this.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: this\n        }) || fileType;\n      }\n      this.fileType = fileType;\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n      if (!fileType) {\n        throwFileTypeNotIdentified(this.zip);\n      }\n      addXmlFileNamesFromXmlContentType(this);\n      dropUnsupportedFileTypesModules(this);\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig;\n      if (!this.fileTypeConfig) {\n        if (Docxtemplater.FileTypeConfig[this.fileType]) {\n          this.fileTypeConfig = Docxtemplater.FileTypeConfig[this.fileType]();\n        } else {\n          /*\n           * Error case handled since v3.60.2\n           * Throw specific error when trying to template xlsx file without xlsxmodule\n           */\n          var message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is not supported\");\n          var id = \"filetype_not_supported\";\n          if (this.fileType === \"xlsx\") {\n            message = \"Filetype \\\"\".concat(this.fileType, \"\\\" is supported only with the paid XlsxModule\");\n            id = \"xlsx_filetype_needs_xlsx_module\";\n          }\n          var err = new XTTemplateError(message);\n          err.properties = {\n            id: id,\n            explanation: message\n          };\n          throw err;\n        }\n      }\n      return this;\n    }\n  }, {\n    key: \"renderAsync\",\n    value: function renderAsync(data) {\n      var _this2 = this;\n      this.hideDeprecations = true;\n      var promise = this.resolveData(data);\n      this.hideDeprecations = false;\n      return promise.then(function () {\n        return _this2.render();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(data) {\n      if (this.rendered) {\n        throwRenderTwice();\n      }\n      this.rendered = true;\n      if (Object.keys(this.compiled).length === 0) {\n        this.compile();\n      }\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n      if (arguments.length > 0) {\n        this.data = data;\n      }\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper || (this.mapper = this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {}));\n      var output = [];\n      for (var to in this.mapper) {\n        var _this$mapper$to2 = this.mapper[to],\n          from = _this$mapper$to2.from,\n          _data = _this$mapper$to2.data;\n        var currentFile = this.compiled[from];\n        currentFile.scopeManager = this.getScopeManager(to, currentFile, _data);\n        currentFile.render(to);\n        output.push([to, currentFile.content, currentFile]);\n        delete currentFile.content;\n      }\n      for (var _i36 = 0; _i36 < output.length; _i36++) {\n        var outputPart = output[_i36];\n        var _outputPart = _slicedToArray(outputPart, 3),\n          content = _outputPart[1],\n          _currentFile = _outputPart[2];\n        for (var _i38 = 0, _this$modules14 = this.modules; _i38 < _this$modules14.length; _i38++) {\n          var _module0 = _this$modules14[_i38];\n          if (_module0.preZip) {\n            var result = _module0.preZip(content, _currentFile);\n            if (typeof result === \"string\") {\n              outputPart[1] = result;\n            }\n          }\n        }\n      }\n      for (var _i40 = 0; _i40 < output.length; _i40++) {\n        var _output$_i = _slicedToArray(output[_i40], 2),\n          _to = _output$_i[0],\n          _content = _output$_i[1];\n        this.zip.file(_to, _content, {\n          createFolders: true\n        });\n      }\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      // The synced-zip event is used in the subtemplate module for example\n      this.sendEvent(\"synced-zip\");\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      for (var fileName in this.xmlDocuments) {\n        this.zip.remove(fileName);\n        var content = xml2str(this.xmlDocuments[fileName]);\n        this.zip.file(fileName, content, {\n          createFolders: true\n        });\n      }\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      deprecatedMethod(this, \"setData\");\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath],\n        relsType: this.relsTypes[filePath]\n      };\n      var defaults = getDefaults();\n      var defaultKeys = pushArray(Object.keys(defaults), [\"filesContentTypes\", \"fileTypeConfig\", \"fileType\", \"modules\"]);\n      for (var _i42 = 0; _i42 < defaultKeys.length; _i42++) {\n        var key = defaultKeys[_i42];\n        xmltOptions[key] = this[key];\n      }\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      pushArray(this.templatedFiles, this.targets);\n      this.templatedFiles = uniq(this.templatedFiles);\n      return this.templatedFiles;\n    }\n  }, {\n    key: \"getTags\",\n    value: function getTags() {\n      var result = {\n        headers: [],\n        footers: []\n      };\n      for (var key in this.compiled) {\n        var contentType = this.filesContentTypes[key];\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\") {\n          result.document = {\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          };\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\") {\n          result.headers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n        if (contentType === \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\") {\n          result.footers.push({\n            target: key,\n            tags: _getTags(this.compiled[key].postparsed)\n          });\n        }\n      }\n      return result;\n    }\n\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"nodebuffer\"\n      }));\n    }\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBlob\",\n    value: function toBlob(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"blob\"\n      }));\n    }\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toBase64\",\n    value: function toBase64(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"base64\"\n      }));\n    }\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toUint8Array\",\n    value: function toUint8Array(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"uint8array\"\n      }));\n    }\n    /* Export functions, present since 3.62.0 */\n  }, {\n    key: \"toArrayBuffer\",\n    value: function toArrayBuffer(options) {\n      return this.zip.generate(_objectSpread(_objectSpread({\n        compression: \"DEFLATE\",\n        fileOrder: zipFileOrder\n      }, options), {}, {\n        type: \"arraybuffer\"\n      }));\n    }\n  }]);\n}();\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\");\nDocxtemplater.XmlTemplater = __webpack_require__(/*! ./xml-templater.js */ \"(rsc)/../../node_modules/docxtemplater/js/xml-templater.js\");\nDocxtemplater.FileTypeConfig = __webpack_require__(/*! ./file-type-config.js */ \"(rsc)/../../node_modules/docxtemplater/js/file-type-config.js\");\nDocxtemplater.XmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/../../node_modules/docxtemplater/js/xml-matcher.js\");\nmodule.exports = Docxtemplater;\nmodule.exports[\"default\"] = Docxtemplater;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZG9jeHRlbXBsYXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsMENBQTBDLDBCQUEwQixtREFBbUQsb0NBQW9DLHlDQUF5QyxZQUFZLGNBQWMsd0NBQXdDLHFEQUFxRDtBQUMzVCwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4QixtQ0FBbUMsZUFBZTtBQUM1TCxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QyxRQUFRLG1CQUFPLENBQUMsMEVBQWM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZSxtQkFBTyxDQUFDLGdHQUF5QjtBQUNoRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDhGQUF3QjtBQUNoRDtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsd0ZBQXFCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyx3RUFBYTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsc0ZBQW9CO0FBQzlDLFlBQVksbUJBQU8sQ0FBQyxzRUFBWTtBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUN2QztBQUNBLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDRCQUE0QjtBQUM3RTtBQUNBLDZEQUE2RCxvQkFBb0I7QUFDakY7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDLFNBQVMsNEJBQTRCO0FBQ3JDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDLFNBQVMsNkJBQTZCO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQSxzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0NBQXNDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlEQUF5RCwrQkFBK0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFDQUFxQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UscUNBQXFDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxxQ0FBcUM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELCtCQUErQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTyxJQUFJO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsK0JBQStCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGNBQWM7QUFDckI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sY0FBYztBQUNyQjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGNBQWM7QUFDckI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxjQUFjO0FBQ3JCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFhO0FBQzVDLDZCQUE2QixtQkFBTyxDQUFDLHNGQUFvQjtBQUN6RCwrQkFBK0IsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDOUQsMkJBQTJCLG1CQUFPLENBQUMsa0ZBQWtCO0FBQ3JEO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9kb2N4dGVtcGxhdGVyLmpzPzBhMjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJtb2R1bGVzXCJdO1xuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7IGlmIChudWxsID09IGUpIHJldHVybiB7fTsgdmFyIG8sIHIsIGkgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyBmb3IgKHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykgbyA9IG5bcl0sIC0xID09PSB0LmluZGV4T2YobykgJiYge30ucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLCBvKSAmJiAoaVtvXSA9IGVbb10pOyB9IHJldHVybiBpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7IGlmIChudWxsID09IHIpIHJldHVybiB7fTsgdmFyIHQgPSB7fTsgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkgeyBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7IHRbbl0gPSByW25dOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgRG9jVXRpbHMgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIik7XG52YXIgeiA9IHJlcXVpcmUoXCIuL21pbml6b2QuanNcIik7XG5cbi8vIFNjaGVtYSBkZWZpbml0aW9ucyBmb3IgRFhULkNvbnN0cnVjdG9yT3B0aW9uc1xudmFyIGR4dFN5bnRheFNjaGVtYSA9IHoub2JqZWN0KHtcbiAgYWxsb3dVbm9wZW5lZFRhZzogeltcImJvb2xlYW5cIl0oKS5vcHRpb25hbCgpLFxuICBhbGxvd1VuY2xvc2VkVGFnOiB6W1wiYm9vbGVhblwiXSgpLm9wdGlvbmFsKCksXG4gIGFsbG93VW5iYWxhbmNlZExvb3BzOiB6W1wiYm9vbGVhblwiXSgpLm9wdGlvbmFsKCksXG4gIGNoYW5nZURlbGltaXRlclByZWZpeDogei5zdHJpbmcoKS5vcHRpb25hbCgpLm51bGxhYmxlKClcbn0pO1xudmFyIGR4dE9wdGlvbnNTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIGRlbGltaXRlcnM6IHoub2JqZWN0KHtcbiAgICBzdGFydDogei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICAgIGVuZDogei5zdHJpbmcoKS5udWxsYWJsZSgpXG4gIH0pLnN0cmljdCgpLm9wdGlvbmFsKCksXG4gIGZpbGVUeXBlQ29uZmlnOiB6Lm9iamVjdCh7fSkub3B0aW9uYWwoKSxcbiAgcGFyYWdyYXBoTG9vcDogeltcImJvb2xlYW5cIl0oKS5vcHRpb25hbCgpLFxuICBwYXJzZXI6IHpbXCJmdW5jdGlvblwiXSgpLm9wdGlvbmFsKCksXG4gIGVycm9yTG9nZ2luZzogei51bmlvbihbeltcImJvb2xlYW5cIl0oKSwgei5zdHJpbmcoKV0pLm9wdGlvbmFsKCksXG4gIGxpbmVicmVha3M6IHpbXCJib29sZWFuXCJdKCkub3B0aW9uYWwoKSxcbiAgbnVsbEdldHRlcjogeltcImZ1bmN0aW9uXCJdKCkub3B0aW9uYWwoKSxcbiAgc3ludGF4OiBkeHRTeW50YXhTY2hlbWEub3B0aW9uYWwoKSxcbiAgc3RyaXBJbnZhbGlkWE1MQ2hhcnM6IHpbXCJib29sZWFuXCJdKCkub3B0aW9uYWwoKVxufSkuc3RyaWN0KCk7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9nZXQtcmVsYXRpb24tdHlwZXMuanNcIiksXG4gIGdldFJlbHNUeXBlcyA9IF9yZXF1aXJlLmdldFJlbHNUeXBlcztcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9nZXQtY29udGVudC10eXBlcy5qc1wiKSxcbiAgY29sbGVjdENvbnRlbnRUeXBlcyA9IF9yZXF1aXJlMi5jb2xsZWN0Q29udGVudFR5cGVzLFxuICBnZXRDb250ZW50VHlwZXMgPSBfcmVxdWlyZTIuZ2V0Q29udGVudFR5cGVzO1xudmFyIG1vZHVsZVdyYXBwZXIgPSByZXF1aXJlKFwiLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciB0cmFpdHMgPSByZXF1aXJlKFwiLi90cmFpdHMuanNcIik7XG52YXIgY29tbW9uTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9jb21tb24uanNcIik7XG52YXIgY3JlYXRlU2NvcGUgPSByZXF1aXJlKFwiLi9zY29wZS1tYW5hZ2VyLmpzXCIpO1xudmFyIExleGVyID0gcmVxdWlyZShcIi4vbGV4ZXIuanNcIik7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4vZ2V0LXRhZ3MuanNcIiksXG4gIF9nZXRUYWdzID0gX3JlcXVpcmUzLmdldFRhZ3M7XG52YXIgbG9nRXJyb3JzID0gcmVxdWlyZShcIi4vZXJyb3ItbG9nZ2VyLmpzXCIpO1xudmFyIF9yZXF1aXJlNCA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dNdWx0aUVycm9yID0gX3JlcXVpcmU0LnRocm93TXVsdGlFcnJvcixcbiAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSA9IF9yZXF1aXJlNC50aHJvd1Jlc29sdmVCZWZvcmVDb21waWxlLFxuICB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSA9IF9yZXF1aXJlNC50aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSxcbiAgdGhyb3dSZW5kZXJUd2ljZSA9IF9yZXF1aXJlNC50aHJvd1JlbmRlclR3aWNlLFxuICBYVEludGVybmFsRXJyb3IgPSBfcmVxdWlyZTQuWFRJbnRlcm5hbEVycm9yLFxuICBYVFRlbXBsYXRlRXJyb3IgPSBfcmVxdWlyZTQuWFRUZW1wbGF0ZUVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCA9IF9yZXF1aXJlNC50aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCxcbiAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQgPSBfcmVxdWlyZTQudGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQsXG4gIHRocm93QXBpVmVyc2lvbkVycm9yID0gX3JlcXVpcmU0LnRocm93QXBpVmVyc2lvbkVycm9yO1xuRG9jVXRpbHMuZ2V0UmVsc1R5cGVzID0gZ2V0UmVsc1R5cGVzO1xuRG9jVXRpbHMudHJhaXRzID0gdHJhaXRzO1xuRG9jVXRpbHMubW9kdWxlV3JhcHBlciA9IG1vZHVsZVdyYXBwZXI7XG5Eb2NVdGlscy5jb2xsZWN0Q29udGVudFR5cGVzID0gY29sbGVjdENvbnRlbnRUeXBlcztcbkRvY1V0aWxzLmdldENvbnRlbnRUeXBlcyA9IGdldENvbnRlbnRUeXBlcztcbnZhciBnZXREZWZhdWx0cyA9IERvY1V0aWxzLmdldERlZmF1bHRzLFxuICBzdHIyeG1sID0gRG9jVXRpbHMuc3RyMnhtbCxcbiAgeG1sMnN0ciA9IERvY1V0aWxzLnhtbDJzdHIsXG4gIGNvbmNhdEFycmF5cyA9IERvY1V0aWxzLmNvbmNhdEFycmF5cyxcbiAgdW5pcSA9IERvY1V0aWxzLnVuaXEsXG4gIGdldER1cGxpY2F0ZXMgPSBEb2NVdGlscy5nZXREdXBsaWNhdGVzLFxuICBzdGFibGVTb3J0ID0gRG9jVXRpbHMuc3RhYmxlU29ydCxcbiAgcHVzaEFycmF5ID0gRG9jVXRpbHMucHVzaEFycmF5LFxuICB1dGY4VG9Xb3JkID0gRG9jVXRpbHMudXRmOFRvV29yZCxcbiAgaW52ZXJ0TWFwID0gRG9jVXRpbHMuaW52ZXJ0TWFwO1xudmFyIGN0WE1MID0gXCJbQ29udGVudF9UeXBlc10ueG1sXCI7XG52YXIgcmVsc0ZpbGUgPSBcIl9yZWxzLy5yZWxzXCI7XG52YXIgY3VycmVudE1vZHVsZUFwaVZlcnNpb24gPSBbMywgNDcsIDJdO1xuZnVuY3Rpb24gdGhyb3dJZkR1cGxpY2F0ZU1vZHVsZXMobW9kdWxlcykge1xuICB2YXIgZHVwbGljYXRlcyA9IGdldER1cGxpY2F0ZXMobW9kdWxlcy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfSkpO1xuICBpZiAoZHVwbGljYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkRldGVjdGVkIGR1cGxpY2F0ZSBtb2R1bGUgXFxcIlwiLmNvbmNhdChkdXBsaWNhdGVzWzBdLCBcIlxcXCJcIikpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRYbWxGaWxlTmFtZXNGcm9tWG1sQ29udGVudFR5cGUoZG9jKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9kb2MkbW9kdWxlczIgPSBkb2MubW9kdWxlczsgX2kyIDwgX2RvYyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfZG9jJG1vZHVsZXMyW19pMl07XG4gICAgZm9yICh2YXIgX2k0ID0gMCwgX3JlZjMgPSBfbW9kdWxlLnhtbENvbnRlbnRUeXBlcyB8fCBbXTsgX2k0IDwgX3JlZjMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjNbX2k0XTtcbiAgICAgIHZhciBjYW5kaWRhdGVzID0gZG9jLmludmVydGVkQ29udGVudFR5cGVzW2NvbnRlbnRUeXBlXSB8fCBbXTtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNhbmRpZGF0ZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tfaTZdO1xuICAgICAgICBpZiAoZG9jLnppcC5maWxlc1tjYW5kaWRhdGVdKSB7XG4gICAgICAgICAgZG9jLm9wdGlvbnMueG1sRmlsZU5hbWVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVvcmRlck1vZHVsZXMobW9kdWxlcykge1xuICAvKipcbiAgICogTW9kdWxlcyB3aWxsIGJlIHNvcnRlZCBhY2NvcmRpbmcgdG8gcHJpb3JpdHkuXG4gICAqXG4gICAqIElucHV0IGV4YW1wbGU6XG4gICAqIFtcbiAgICogICB7IHByaW9yaXR5OiAxLCBuYW1lOiBcIkZvb01vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogLTEsIG5hbWU6IFwiWE1vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH1cbiAgICogXVxuICAgKlxuICAgKiBPdXRwdXQgZXhhbXBsZSAoc29ydGVkIGJ5IHByaW9yaXR5IGluIGRlc2NlbmRpbmcgb3JkZXIpOlxuICAgKiBbXG4gICAqICAgeyBwcmlvcml0eTogNCwgbmFtZTogXCJPdGhlck1vZFwiIH0sXG4gICAqICAgeyBwcmlvcml0eTogMSwgbmFtZTogXCJGb29Nb2RcIiB9LFxuICAgKiAgIHsgcHJpb3JpdHk6IC0xLCBuYW1lOiBcIlhNb2RcIiB9XG4gICAqIF1cbiAgICogVGVzdGVkIGluICN0ZXN0LXJlb3JkZXItbW9kdWxlc1xuICAgKi9cbiAgcmV0dXJuIHN0YWJsZVNvcnQobW9kdWxlcywgZnVuY3Rpb24gKG0xLCBtMikge1xuICAgIHJldHVybiAobTIucHJpb3JpdHkgfHwgMCkgLSAobTEucHJpb3JpdHkgfHwgMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gemlwRmlsZU9yZGVyKGZpbGVzKSB7XG4gIHZhciBhbGxGaWxlcyA9IFtdO1xuICBmb3IgKHZhciBuYW1lIGluIGZpbGVzKSB7XG4gICAgYWxsRmlsZXMucHVzaChuYW1lKTtcbiAgfVxuICAvKlxuICAgKiBUaGUgZmlyc3QgZmlsZXMgdGhhdCBuZWVkIHRvIGJlIHB1dCBpbiB0aGUgemlwIGZpbGUgYXJlIDpcbiAgICogW0NvbnRlbnRfVHlwZXNdLnhtbCBhbmQgX3JlbHMvLnJlbHNcbiAgICovXG4gIHZhciByZXN1bHRGaWxlcyA9IFtjdFhNTCwgcmVsc0ZpbGVdO1xuXG4gIC8qXG4gICAqIFRoZSBuZXh0IGZpbGVzIHRoYXQgc2hvdWxkIGJlIGluIHRoZSB6aXAgZmlsZSBhcmUgOlxuICAgKlxuICAgKiAtIHdvcmQvKiAoaWUgd29yZC9kb2N1bWVudC54bWwsIHdvcmQvaGVhZGVyMS54bWwsIC4uLilcbiAgICogLSB4bC8qIChpZSB4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWwpXG4gICAqIC0gcHB0LyogKGllIHBwdC9zbGlkZXMvc2xpZGUxLnhtbClcbiAgICovXG4gIHZhciBwcmVmaXhlcyA9IFtcIndvcmQvXCIsIFwieGwvXCIsIFwicHB0L1wiXTtcbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgYWxsRmlsZXMubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBfbmFtZSA9IGFsbEZpbGVzW19pOF07XG4gICAgZm9yICh2YXIgX2kwID0gMDsgX2kwIDwgcHJlZml4ZXMubGVuZ3RoOyBfaTArKykge1xuICAgICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW19pMF07XG4gICAgICBpZiAoX25hbWUuaW5kZXhPZihcIlwiLmNvbmNhdChwcmVmaXgpKSA9PT0gMCkge1xuICAgICAgICByZXN1bHRGaWxlcy5wdXNoKF9uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLypcbiAgICogUHVzaCB0aGUgcmVzdCBvZiBmaWxlcywgc3VjaCBhcyBkb2NQcm9wcy9jb3JlLnhtbCBhbmQgZG9jUHJvcHMvYXBwLnhtbFxuICAgKi9cbiAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBhbGxGaWxlcy5sZW5ndGg7IF9pMTArKykge1xuICAgIHZhciBfbmFtZTIgPSBhbGxGaWxlc1tfaTEwXTtcbiAgICBpZiAocmVzdWx0RmlsZXMuaW5kZXhPZihfbmFtZTIpID09PSAtMSkge1xuICAgICAgcmVzdWx0RmlsZXMucHVzaChfbmFtZTIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0RmlsZXM7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkTWVzc2FnZShvYmosIG1lc3NhZ2UpIHtcbiAgaWYgKG9iai5oaWRlRGVwcmVjYXRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGRlcHJlY2F0ZWRNZXRob2Qob2JqLCBtZXRob2QpIHtcbiAgaWYgKG9iai5oaWRlRGVwcmVjYXRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBkZXByZWNhdGVkTWVzc2FnZShvYmosIFwiRGVwcmVjYXRlZCBtZXRob2QgXFxcIi5cIi5jb25jYXQobWV0aG9kLCBcIlxcXCIsIHZpZXcgdXBncmFkZSBndWlkZSA6IGh0dHBzOi8vZG9jeHRlbXBsYXRlci5jb20vZG9jcy9hcGkvI3VwZ3JhZGUtZ3VpZGUsIHN0YWNrIDogXCIpLmNvbmNhdChuZXcgRXJyb3IoKS5zdGFjaykpO1xufVxuZnVuY3Rpb24gZHJvcFVuc3VwcG9ydGVkRmlsZVR5cGVzTW9kdWxlcyhkb2MpIHtcbiAgZG9jLm1vZHVsZXMgPSBkb2MubW9kdWxlcy5maWx0ZXIoZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgIGlmICghbW9kdWxlLnN1cHBvcnRlZEZpbGVUeXBlcykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGUuc3VwcG9ydGVkRmlsZVR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN1cHBvcnRlZEZpbGVUeXBlcyBmaWVsZCBvZiB0aGUgbW9kdWxlIG11c3QgYmUgYW4gYXJyYXlcIik7XG4gICAgfVxuICAgIHZhciBpc1N1cHBvcnRlZE1vZHVsZSA9IG1vZHVsZS5zdXBwb3J0ZWRGaWxlVHlwZXMuaW5jbHVkZXMoZG9jLmZpbGVUeXBlKTtcbiAgICBpZiAoIWlzU3VwcG9ydGVkTW9kdWxlKSB7XG4gICAgICBtb2R1bGUub24oXCJkZXRhY2hlZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzU3VwcG9ydGVkTW9kdWxlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeUVycm9ycyhkb2MpIHtcbiAgdmFyIGNvbXBpbGVkID0gZG9jLmNvbXBpbGVkO1xuICBkb2MuZXJyb3JzID0gY29uY2F0QXJyYXlzKE9iamVjdC5rZXlzKGNvbXBpbGVkKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gY29tcGlsZWRbbmFtZV0uYWxsRXJyb3JzO1xuICB9KSk7XG4gIGlmIChkb2MuZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgIGlmIChkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpIHtcbiAgICAgIGxvZ0Vycm9ycyhkb2MuZXJyb3JzLCBkb2Mub3B0aW9ucy5lcnJvckxvZ2dpbmcpO1xuICAgIH1cbiAgICB0aHJvd011bHRpRXJyb3IoZG9jLmVycm9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIEJ1ZmZlci5pc0J1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEJ1ZmZlci5pc0J1ZmZlcih2KTtcbn1cbnZhciBEb2N4dGVtcGxhdGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG9jeHRlbXBsYXRlcih6aXApIHtcbiAgICB2YXIgX3JlZjQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgX3JlZjQkbW9kdWxlcyA9IF9yZWY0Lm1vZHVsZXMsXG4gICAgICBtb2R1bGVzID0gX3JlZjQkbW9kdWxlcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmNCRtb2R1bGVzLFxuICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmNCwgX2V4Y2x1ZGVkKTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9jeHRlbXBsYXRlcik7XG4gICAgdGhpcy50YXJnZXRzID0gW107XG4gICAgdGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGVNYW5hZ2VycyA9IHt9O1xuICAgIHRoaXMuY29tcGlsZWQgPSB7fTtcbiAgICB0aGlzLm1vZHVsZXMgPSBbY29tbW9uTW9kdWxlKCldO1xuICAgIHRoaXMueG1sRG9jdW1lbnRzID0ge307XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlcHJlY2F0ZWRNZXNzYWdlKHRoaXMsIFwiRGVwcmVjYXRlZCBkb2N4dGVtcGxhdGVyIGNvbnN0cnVjdG9yIHdpdGggbm8gYXJndW1lbnRzLCB2aWV3IHVwZ3JhZGUgZ3VpZGUgOiBodHRwczovL2RvY3h0ZW1wbGF0ZXIuY29tL2RvY3MvYXBpLyN1cGdyYWRlLWd1aWRlLCBzdGFjayA6IFwiLmNvbmNhdChuZXcgRXJyb3IoKS5zdGFjaykpO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIGlmIChpc0J1ZmZlcih6aXApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBwYXNzZWQgYSBCdWZmZXIgdG8gdGhlIERvY3h0ZW1wbGF0ZXIgY29uc3RydWN0b3IuIFRoZSBmaXJzdCBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhIHZhbGlkIHppcCBmaWxlIChqc3ppcCB2MiBvciBwaXp6aXAgdjMpXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF6aXAgfHwgIXppcC5maWxlcyB8fCB0eXBlb2YgemlwLmZpbGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgb2YgZG9jeHRlbXBsYXRlcidzIGNvbnN0cnVjdG9yIG11c3QgYmUgYSB2YWxpZCB6aXAgZmlsZSAoanN6aXAgdjIgb3IgcGl6emlwIHYzKVwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtb2R1bGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbW9kdWxlcyBhcmd1bWVudCBvZiBkb2N4dGVtcGxhdGVyJ3MgY29uc3RydWN0b3IgbXVzdCBiZSBhbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMTIrKykge1xuICAgICAgICB2YXIgX21vZHVsZTIgPSBtb2R1bGVzW19pMTJdO1xuICAgICAgICB0aGlzLmF0dGFjaE1vZHVsZShfbW9kdWxlMik7XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRaaXAoemlwKTtcbiAgICAgIHRoaXMuY29tcGlsZSgpO1xuICAgICAgdGhpcy52NENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhEb2N4dGVtcGxhdGVyLCBbe1xuICAgIGtleTogXCJ2ZXJpZnlBcGlWZXJzaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeUFwaVZlcnNpb24obmVlZGVkVmVyc2lvbikge1xuICAgICAgbmVlZGVkVmVyc2lvbiA9IG5lZWRlZFZlcnNpb24uc3BsaXQoXCIuXCIpLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaSwgMTApO1xuICAgICAgfSk7XG4gICAgICBpZiAobmVlZGVkVmVyc2lvbi5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJuZWVkZWRWZXJzaW9uIGlzIG5vdCBhIHZhbGlkIHZlcnNpb25cIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwidGhlIG5lZWRlZFZlcnNpb24gbXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggM1wiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMF0gIT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzBdKSB7XG4gICAgICAgIHRocm93QXBpVmVyc2lvbkVycm9yKFwiVGhlIG1ham9yIGFwaSB2ZXJzaW9uIGRvIG5vdCBtYXRjaCwgeW91IHByb2JhYmx5IGhhdmUgdG8gdXBkYXRlIGRvY3h0ZW1wbGF0ZXIgd2l0aCBucG0gaW5zdGFsbCAtLXNhdmUgZG9jeHRlbXBsYXRlclwiLCB7XG4gICAgICAgICAgbmVlZGVkVmVyc2lvbjogbmVlZGVkVmVyc2lvbixcbiAgICAgICAgICBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbjogY3VycmVudE1vZHVsZUFwaVZlcnNpb24sXG4gICAgICAgICAgZXhwbGFuYXRpb246IFwibW9kdWxlQVBJVmVyc2lvbk1pc21hdGNoIDogbmVlZGVkPVwiLmNvbmNhdChuZWVkZWRWZXJzaW9uLmpvaW4oXCIuXCIpLCBcIiwgY3VycmVudD1cIikuY29uY2F0KGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLmpvaW4oXCIuXCIpKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkZWRWZXJzaW9uWzFdID4gY3VycmVudE1vZHVsZUFwaVZlcnNpb25bMV0pIHtcbiAgICAgICAgdGhyb3dBcGlWZXJzaW9uRXJyb3IoXCJUaGUgbWlub3IgYXBpIHZlcnNpb24gaXMgbm90IHVwdG9kYXRlLCB5b3UgcHJvYmFibHkgaGF2ZSB0byB1cGRhdGUgZG9jeHRlbXBsYXRlciB3aXRoIG5wbSBpbnN0YWxsIC0tc2F2ZSBkb2N4dGVtcGxhdGVyXCIsIHtcbiAgICAgICAgICBuZWVkZWRWZXJzaW9uOiBuZWVkZWRWZXJzaW9uLFxuICAgICAgICAgIGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uOiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvbixcbiAgICAgICAgICBleHBsYW5hdGlvbjogXCJtb2R1bGVBUElWZXJzaW9uTWlzbWF0Y2ggOiBuZWVkZWQ9XCIuY29uY2F0KG5lZWRlZFZlcnNpb24uam9pbihcIi5cIiksIFwiLCBjdXJyZW50PVwiKS5jb25jYXQoY3VycmVudE1vZHVsZUFwaVZlcnNpb24uam9pbihcIi5cIikpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRlZFZlcnNpb25bMV0gPT09IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uWzFdICYmIG5lZWRlZFZlcnNpb25bMl0gPiBjdXJyZW50TW9kdWxlQXBpVmVyc2lvblsyXSkge1xuICAgICAgICB0aHJvd0FwaVZlcnNpb25FcnJvcihcIlRoZSBwYXRjaCBhcGkgdmVyc2lvbiBpcyBub3QgdXB0b2RhdGUsIHlvdSBwcm9iYWJseSBoYXZlIHRvIHVwZGF0ZSBkb2N4dGVtcGxhdGVyIHdpdGggbnBtIGluc3RhbGwgLS1zYXZlIGRvY3h0ZW1wbGF0ZXJcIiwge1xuICAgICAgICAgIG5lZWRlZFZlcnNpb246IG5lZWRlZFZlcnNpb24sXG4gICAgICAgICAgY3VycmVudE1vZHVsZUFwaVZlcnNpb246IGN1cnJlbnRNb2R1bGVBcGlWZXJzaW9uLFxuICAgICAgICAgIGV4cGxhbmF0aW9uOiBcIm1vZHVsZUFQSVZlcnNpb25NaXNtYXRjaCA6IG5lZWRlZD1cIi5jb25jYXQobmVlZGVkVmVyc2lvbi5qb2luKFwiLlwiKSwgXCIsIGN1cnJlbnQ9XCIpLmNvbmNhdChjdXJyZW50TW9kdWxlQXBpVmVyc2lvbi5qb2luKFwiLlwiKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0TW9kdWxlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNb2R1bGVzKG9iaikge1xuICAgICAgZm9yICh2YXIgX2kxNCA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTE0IDwgX3RoaXMkbW9kdWxlczIubGVuZ3RoOyBfaTE0KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUzID0gX3RoaXMkbW9kdWxlczJbX2kxNF07XG4gICAgICAgIF9tb2R1bGUzLnNldChvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kRXZlbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZEV2ZW50KGV2ZW50TmFtZSkge1xuICAgICAgZm9yICh2YXIgX2kxNiA9IDAsIF90aGlzJG1vZHVsZXM0ID0gdGhpcy5tb2R1bGVzOyBfaTE2IDwgX3RoaXMkbW9kdWxlczQubGVuZ3RoOyBfaTE2KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gX3RoaXMkbW9kdWxlczRbX2kxNl07XG4gICAgICAgIF9tb2R1bGU0Lm9uKGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImF0dGFjaE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hNb2R1bGUobW9kdWxlKSB7XG4gICAgICBpZiAodGhpcy52NENvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJhdHRhY2hNb2R1bGUoKSBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSB3aGVuIHVzaW5nIHRoZSB2NCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgIH1cbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJhdHRhY2hNb2R1bGVcIik7XG4gICAgICB2YXIgbW9kdWxlVHlwZSA9IF90eXBlb2YobW9kdWxlKTtcbiAgICAgIGlmIChtb2R1bGVUeXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFhUSW50ZXJuYWxFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBjbGFzcy9mdW5jdGlvbiBhcyBhIG1vZHVsZS4gTW9zdCBwcm9iYWJseSB5b3UgZm9yZ290IHRvIGluc3RhbnRpYXRlIHRoZSBtb2R1bGUgYnkgdXNpbmcgYG5ld2Agb24gdGhlIG1vZHVsZS5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIW1vZHVsZSB8fCBtb2R1bGVUeXBlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBYVEludGVybmFsRXJyb3IoXCJDYW5ub3QgYXR0YWNoTW9kdWxlIHdpdGggYSBmYWxzeSB2YWx1ZVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyaWZ5QXBpVmVyc2lvbihtb2R1bGUucmVxdWlyZWRBUElWZXJzaW9uKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2R1bGUuYXR0YWNoZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG1vZHVsZSA9IG1vZHVsZS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhdHRhY2ggYSBtb2R1bGUgdGhhdCB3YXMgYWxyZWFkeSBhdHRhY2hlZCA6IFxcXCJcIi5jb25jYXQobW9kdWxlLm5hbWUsIFwiXFxcIi4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgeW91IGFyZSBpbnN0YW50aWF0aW5nIHRoZSBtb2R1bGUgYXQgdGhlIHJvb3QgbGV2ZWwsIGFuZCB1c2luZyBpdCBmb3IgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIERvY3h0ZW1wbGF0ZXJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2R1bGUuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdmFyIHdyYXBwZWRNb2R1bGUgPSBtb2R1bGVXcmFwcGVyKG1vZHVsZSk7XG4gICAgICB0aGlzLm1vZHVsZXMucHVzaCh3cmFwcGVkTW9kdWxlKTtcbiAgICAgIHdyYXBwZWRNb2R1bGUub24oXCJhdHRhY2hlZFwiKTtcbiAgICAgIGlmICh0aGlzLmZpbGVUeXBlKSB7XG4gICAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTW9kdWxlKG5hbWUpIHtcbiAgICAgIGZvciAodmFyIF9pMTggPSAwLCBfdGhpcyRtb2R1bGVzNiA9IHRoaXMubW9kdWxlczsgX2kxOCA8IF90aGlzJG1vZHVsZXM2Lmxlbmd0aDsgX2kxOCsrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNSA9IF90aGlzJG1vZHVsZXM2W19pMThdO1xuICAgICAgICBpZiAoX21vZHVsZTUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiBfbW9kdWxlNTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzJGRlbGltaXRlcnMsIF90aGlzJGRlbGltaXRlcnMyO1xuICAgICAgaWYgKHRoaXMudjRDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRPcHRpb25zKCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgd2hlbiB1c2luZyB0aGUgdjQgY29uc3RydWN0b3JcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0T3B0aW9ucyBzaG91bGQgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IGFzIGZpcnN0IHBhcmFtZXRlclwiKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBkeHRPcHRpb25zU2NoZW1hLnZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzdWx0LmVycm9yKTtcbiAgICAgIH1cbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJzZXRPcHRpb25zXCIpO1xuICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0c1trZXldO1xuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XSAhPSBudWxsID8gb3B0aW9uc1trZXldIDogdGhpc1trZXldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpc1trZXldID0gdGhpcy5vcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgICAoX3RoaXMkZGVsaW1pdGVycyA9IHRoaXMuZGVsaW1pdGVycykuc3RhcnQgJiYgKF90aGlzJGRlbGltaXRlcnMuc3RhcnQgPSB1dGY4VG9Xb3JkKHRoaXMuZGVsaW1pdGVycy5zdGFydCkpO1xuICAgICAgKF90aGlzJGRlbGltaXRlcnMyID0gdGhpcy5kZWxpbWl0ZXJzKS5lbmQgJiYgKF90aGlzJGRlbGltaXRlcnMyLmVuZCA9IHV0ZjhUb1dvcmQodGhpcy5kZWxpbWl0ZXJzLmVuZCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRaaXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZFppcCh6aXApIHtcbiAgICAgIGlmICh0aGlzLnY0Q29uc3RydWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFppcCgpIHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IHdoZW4gdXNpbmcgdGhlIHY0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgfVxuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImxvYWRaaXBcIik7XG4gICAgICBpZiAoemlwLmxvYWRBc3luYykge1xuICAgICAgICB0aHJvdyBuZXcgWFRJbnRlcm5hbEVycm9yKFwiRG9jeHRlbXBsYXRlciBkb2Vzbid0IGhhbmRsZSBKU1ppcCB2ZXJzaW9uID49MywgcGxlYXNlIHVzZSBwaXp6aXBcIik7XG4gICAgICB9XG4gICAgICB0aGlzLnppcCA9IHppcDtcbiAgICAgIHRoaXMudXBkYXRlRmlsZVR5cGVDb25maWcoKTtcbiAgICAgIHRoaXMubW9kdWxlcyA9IGNvbmNhdEFycmF5cyhbdGhpcy5maWxlVHlwZUNvbmZpZy5iYXNlTW9kdWxlcy5tYXAoZnVuY3Rpb24gKG1vZHVsZUZ1bmN0aW9uKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGVGdW5jdGlvbigpO1xuICAgICAgfSksIHRoaXMubW9kdWxlc10pO1xuICAgICAgZm9yICh2YXIgX2kyMCA9IDAsIF90aGlzJG1vZHVsZXM4ID0gdGhpcy5tb2R1bGVzOyBfaTIwIDwgX3RoaXMkbW9kdWxlczgubGVuZ3RoOyBfaTIwKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU2ID0gX3RoaXMkbW9kdWxlczhbX2kyMF07XG4gICAgICAgIF9tb2R1bGU2LnppcCA9IHRoaXMuemlwO1xuICAgICAgICBfbW9kdWxlNi5kb2N4dGVtcGxhdGVyID0gdGhpcztcbiAgICAgICAgX21vZHVsZTYuZmlsZVR5cGVDb25maWcgPSB0aGlzLmZpbGVUeXBlQ29uZmlnO1xuICAgICAgICBfbW9kdWxlNi5maWxlVHlwZSA9IHRoaXMuZmlsZVR5cGU7XG4gICAgICAgIF9tb2R1bGU2Lnh0T3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgX21vZHVsZTYubW9kdWxlcyA9IHRoaXMubW9kdWxlcztcbiAgICAgIH1cbiAgICAgIGRyb3BVbnN1cHBvcnRlZEZpbGVUeXBlc01vZHVsZXModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHZhciBjdXJyZW50RmlsZSA9IHRoaXMuY3JlYXRlVGVtcGxhdGVDbGFzcyhmaWxlTmFtZSk7XG4gICAgICBjdXJyZW50RmlsZS5wcmVwYXJzZSgpO1xuICAgICAgdGhpcy5jb21waWxlZFtmaWxlTmFtZV0gPSBjdXJyZW50RmlsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZUZpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZUZpbGUoZmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuY29tcGlsZWRbZmlsZU5hbWVdLnBhcnNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCB0YWdzKSB7XG4gICAgICB2YXIgX3RoaXMkc2NvcGVNYW5hZ2VycztcbiAgICAgIChfdGhpcyRzY29wZU1hbmFnZXJzID0gdGhpcy5zY29wZU1hbmFnZXJzKVt0b10gfHwgKF90aGlzJHNjb3BlTWFuYWdlcnNbdG9dID0gY3JlYXRlU2NvcGUoe1xuICAgICAgICB0YWdzOiB0YWdzLFxuICAgICAgICBwYXJzZXI6IHRoaXMucGFyc2VyLFxuICAgICAgICBjYWNoZWRQYXJzZXJzOiBjdXJyZW50RmlsZS5jYWNoZWRQYXJzZXJzXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdGhpcy5zY29wZU1hbmFnZXJzW3RvXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZURhdGEoZGF0YSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGRlcHJlY2F0ZWRNZXRob2QodGhpcywgXCJyZXNvbHZlRGF0YVwiKTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5jb21waWxlZCkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93UmVzb2x2ZUJlZm9yZUNvbXBpbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgX3RoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgZGF0YTogX3RoaXMuZGF0YSxcbiAgICAgICAgICBMZXhlcjogTGV4ZXJcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm1hcHBlciA9IF90aGlzLm1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uICh2YWx1ZSwgbW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRSZW5kZXJlZE1hcCh2YWx1ZSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF90aGlzLm1hcHBlcikubWFwKGZ1bmN0aW9uICh0bykge1xuICAgICAgICAgIHZhciBfdGhpcyRtYXBwZXIkdG8gPSBfdGhpcy5tYXBwZXJbdG9dLFxuICAgICAgICAgICAgZnJvbSA9IF90aGlzJG1hcHBlciR0by5mcm9tLFxuICAgICAgICAgICAgZGF0YSA9IF90aGlzJG1hcHBlciR0by5kYXRhO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGF0YSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gX3RoaXMuY29tcGlsZWRbZnJvbV07XG4gICAgICAgICAgICBjdXJyZW50RmlsZS5maWxlUGF0aCA9IHRvO1xuICAgICAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyID0gX3RoaXMuZ2V0U2NvcGVNYW5hZ2VyKHRvLCBjdXJyZW50RmlsZSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudEZpbGUucmVzb2x2ZVRhZ3MoZGF0YSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRGaWxlLnNjb3BlTWFuYWdlci5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJycykge1xuICAgICAgICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBlcnJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKSB7XG4gICAgICAgICAgICAgIGxvZ0Vycm9ycyhlcnJvcnMsIF90aGlzLm9wdGlvbnMuZXJyb3JMb2dnaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93TXVsdGlFcnJvcihlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29uY2F0QXJyYXlzKHJlc29sdmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKCkge1xuICAgICAgZGVwcmVjYXRlZE1ldGhvZCh0aGlzLCBcImNvbXBpbGVcIik7XG4gICAgICB0aGlzLnVwZGF0ZUZpbGVUeXBlQ29uZmlnKCk7XG4gICAgICB0aHJvd0lmRHVwbGljYXRlTW9kdWxlcyh0aGlzLm1vZHVsZXMpO1xuICAgICAgdGhpcy5tb2R1bGVzID0gcmVvcmRlck1vZHVsZXModGhpcy5tb2R1bGVzKTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbXBpbGVkKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfdGhpcyRtb2R1bGVzMCA9IHRoaXMubW9kdWxlczsgX2kyMiA8IF90aGlzJG1vZHVsZXMwLmxlbmd0aDsgX2kyMisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlNyA9IF90aGlzJG1vZHVsZXMwW19pMjJdO1xuICAgICAgICBvcHRpb25zID0gX21vZHVsZTcub3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMgPSB1bmlxKHRoaXMub3B0aW9ucy54bWxGaWxlTmFtZXMpO1xuICAgICAgZm9yICh2YXIgX2kyNCA9IDAsIF90aGlzJG9wdGlvbnMkeG1sRmlsZTIgPSB0aGlzLm9wdGlvbnMueG1sRmlsZU5hbWVzOyBfaTI0IDwgX3RoaXMkb3B0aW9ucyR4bWxGaWxlMi5sZW5ndGg7IF9pMjQrKykge1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBfdGhpcyRvcHRpb25zJHhtbEZpbGUyW19pMjRdO1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuemlwLmZpbGVzW2ZpbGVOYW1lXS5hc1RleHQoKTtcbiAgICAgICAgdGhpcy54bWxEb2N1bWVudHNbZmlsZU5hbWVdID0gc3RyMnhtbChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIHppcDogdGhpcy56aXAsXG4gICAgICAgIHhtbERvY3VtZW50czogdGhpcy54bWxEb2N1bWVudHNcbiAgICAgIH0pO1xuICAgICAgZm9yICh2YXIgX2kyNiA9IDAsIF90aGlzJG1vZHVsZXMxMCA9IHRoaXMubW9kdWxlczsgX2kyNiA8IF90aGlzJG1vZHVsZXMxMC5sZW5ndGg7IF9pMjYrKykge1xuICAgICAgICB2YXIgX21vZHVsZTggPSBfdGhpcyRtb2R1bGVzMTBbX2kyNl07XG4gICAgICAgIF9tb2R1bGU4LnhtbERvY3VtZW50cyA9IHRoaXMueG1sRG9jdW1lbnRzO1xuICAgICAgfVxuICAgICAgdGhpcy5nZXRUZW1wbGF0ZWRGaWxlcygpO1xuICAgICAgLypcbiAgICAgICAqIExvb3AgaW5zaWRlIGFsbCB0ZW1wbGF0ZWRGaWxlcyAoaWUgeG1sIGZpbGVzIHdpdGggY29udGVudCkuXG4gICAgICAgKiBTb21ldGltZXMgdGhleSBkb24ndCBleGlzdCAoZm9vdGVyLnhtbCBmb3IgZXhhbXBsZSlcbiAgICAgICAqL1xuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJiZWZvcmUtcHJlcGFyc2VcIik7XG4gICAgICBmb3IgKHZhciBfaTI4ID0gMCwgX3RoaXMkdGVtcGxhdGVkRmlsZXMyID0gdGhpcy50ZW1wbGF0ZWRGaWxlczsgX2kyOCA8IF90aGlzJHRlbXBsYXRlZEZpbGVzMi5sZW5ndGg7IF9pMjgrKykge1xuICAgICAgICB2YXIgX2ZpbGVOYW1lID0gX3RoaXMkdGVtcGxhdGVkRmlsZXMyW19pMjhdO1xuICAgICAgICBpZiAodGhpcy56aXAuZmlsZXNbX2ZpbGVOYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5wcmVjb21waWxlRmlsZShfZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNlbmRFdmVudChcImFmdGVyLXByZXBhcnNlXCIpO1xuICAgICAgZm9yICh2YXIgX2kzMCA9IDAsIF90aGlzJHRlbXBsYXRlZEZpbGVzNCA9IHRoaXMudGVtcGxhdGVkRmlsZXM7IF9pMzAgPCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczQubGVuZ3RoOyBfaTMwKyspIHtcbiAgICAgICAgdmFyIF9maWxlTmFtZTIgPSBfdGhpcyR0ZW1wbGF0ZWRGaWxlczRbX2kzMF07XG4gICAgICAgIGlmICh0aGlzLnppcC5maWxlc1tfZmlsZU5hbWUyXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlZFtfZmlsZU5hbWUyXS5wYXJzZSh7XG4gICAgICAgICAgICBub1Bvc3RQYXJzZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNlbmRFdmVudChcImFmdGVyLXBhcnNlXCIpO1xuICAgICAgZm9yICh2YXIgX2kzMiA9IDAsIF90aGlzJHRlbXBsYXRlZEZpbGVzNiA9IHRoaXMudGVtcGxhdGVkRmlsZXM7IF9pMzIgPCBfdGhpcyR0ZW1wbGF0ZWRGaWxlczYubGVuZ3RoOyBfaTMyKyspIHtcbiAgICAgICAgdmFyIF9maWxlTmFtZTMgPSBfdGhpcyR0ZW1wbGF0ZWRGaWxlczZbX2kzMl07XG4gICAgICAgIGlmICh0aGlzLnppcC5maWxlc1tfZmlsZU5hbWUzXSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jb21waWxlZFtfZmlsZU5hbWUzXS5wb3N0cGFyc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZW5kRXZlbnQoXCJhZnRlci1wb3N0cGFyc2VcIik7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBjb21waWxlZDogdGhpcy5jb21waWxlZFxuICAgICAgfSk7XG4gICAgICB2ZXJpZnlFcnJvcnModGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRmlsZVR5cGVDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRmlsZVR5cGVDb25maWcoKSB7XG4gICAgICB0aGlzLnJlbHNUeXBlcyA9IGdldFJlbHNUeXBlcyh0aGlzLnppcCk7XG4gICAgICB2YXIgX2dldENvbnRlbnRUeXBlcyA9IGdldENvbnRlbnRUeXBlcyh0aGlzLnppcCksXG4gICAgICAgIG92ZXJyaWRlcyA9IF9nZXRDb250ZW50VHlwZXMub3ZlcnJpZGVzLFxuICAgICAgICBkZWZhdWx0cyA9IF9nZXRDb250ZW50VHlwZXMuZGVmYXVsdHMsXG4gICAgICAgIGNvbnRlbnRUeXBlcyA9IF9nZXRDb250ZW50VHlwZXMuY29udGVudFR5cGVzLFxuICAgICAgICBjb250ZW50VHlwZVhtbCA9IF9nZXRDb250ZW50VHlwZXMuY29udGVudFR5cGVYbWw7XG4gICAgICBpZiAoY29udGVudFR5cGVYbWwpIHtcbiAgICAgICAgdGhpcy5maWxlc0NvbnRlbnRUeXBlcyA9IGNvbGxlY3RDb250ZW50VHlwZXMob3ZlcnJpZGVzLCBkZWZhdWx0cywgdGhpcy56aXApO1xuICAgICAgICB0aGlzLmludmVydGVkQ29udGVudFR5cGVzID0gaW52ZXJ0TWFwKHRoaXMuZmlsZXNDb250ZW50VHlwZXMpO1xuICAgICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICAgIGNvbnRlbnRUeXBlczogdGhpcy5jb250ZW50VHlwZXMsXG4gICAgICAgICAgaW52ZXJ0ZWRDb250ZW50VHlwZXM6IHRoaXMuaW52ZXJ0ZWRDb250ZW50VHlwZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgZmlsZVR5cGU7XG4gICAgICBpZiAodGhpcy56aXAuZmlsZXMubWltZXR5cGUpIHtcbiAgICAgICAgZmlsZVR5cGUgPSBcIm9kdFwiO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kzNCA9IDAsIF90aGlzJG1vZHVsZXMxMiA9IHRoaXMubW9kdWxlczsgX2kzNCA8IF90aGlzJG1vZHVsZXMxMi5sZW5ndGg7IF9pMzQrKykge1xuICAgICAgICB2YXIgX21vZHVsZTkgPSBfdGhpcyRtb2R1bGVzMTJbX2kzNF07XG4gICAgICAgIGZpbGVUeXBlID0gX21vZHVsZTkuZ2V0RmlsZVR5cGUoe1xuICAgICAgICAgIHppcDogdGhpcy56aXAsXG4gICAgICAgICAgY29udGVudFR5cGVzOiBjb250ZW50VHlwZXMsXG4gICAgICAgICAgY29udGVudFR5cGVYbWw6IGNvbnRlbnRUeXBlWG1sLFxuICAgICAgICAgIG92ZXJyaWRlczogb3ZlcnJpZGVzLFxuICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyxcbiAgICAgICAgICBkb2M6IHRoaXNcbiAgICAgICAgfSkgfHwgZmlsZVR5cGU7XG4gICAgICB9XG4gICAgICB0aGlzLmZpbGVUeXBlID0gZmlsZVR5cGU7XG4gICAgICBpZiAoZmlsZVR5cGUgPT09IFwib2R0XCIpIHtcbiAgICAgICAgdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQoZmlsZVR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmaWxlVHlwZSkge1xuICAgICAgICB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh0aGlzLnppcCk7XG4gICAgICB9XG4gICAgICBhZGRYbWxGaWxlTmFtZXNGcm9tWG1sQ29udGVudFR5cGUodGhpcyk7XG4gICAgICBkcm9wVW5zdXBwb3J0ZWRGaWxlVHlwZXNNb2R1bGVzKHRoaXMpO1xuICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IHRoaXMub3B0aW9ucy5maWxlVHlwZUNvbmZpZyB8fCB0aGlzLmZpbGVUeXBlQ29uZmlnO1xuICAgICAgaWYgKCF0aGlzLmZpbGVUeXBlQ29uZmlnKSB7XG4gICAgICAgIGlmIChEb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnW3RoaXMuZmlsZVR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5maWxlVHlwZUNvbmZpZyA9IERvY3h0ZW1wbGF0ZXIuRmlsZVR5cGVDb25maWdbdGhpcy5maWxlVHlwZV0oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIEVycm9yIGNhc2UgaGFuZGxlZCBzaW5jZSB2My42MC4yXG4gICAgICAgICAgICogVGhyb3cgc3BlY2lmaWMgZXJyb3Igd2hlbiB0cnlpbmcgdG8gdGVtcGxhdGUgeGxzeCBmaWxlIHdpdGhvdXQgeGxzeG1vZHVsZVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJGaWxldHlwZSBcXFwiXCIuY29uY2F0KHRoaXMuZmlsZVR5cGUsIFwiXFxcIiBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgIHZhciBpZCA9IFwiZmlsZXR5cGVfbm90X3N1cHBvcnRlZFwiO1xuICAgICAgICAgIGlmICh0aGlzLmZpbGVUeXBlID09PSBcInhsc3hcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiRmlsZXR5cGUgXFxcIlwiLmNvbmNhdCh0aGlzLmZpbGVUeXBlLCBcIlxcXCIgaXMgc3VwcG9ydGVkIG9ubHkgd2l0aCB0aGUgcGFpZCBYbHN4TW9kdWxlXCIpO1xuICAgICAgICAgICAgaWQgPSBcInhsc3hfZmlsZXR5cGVfbmVlZHNfeGxzeF9tb2R1bGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBleHBsYW5hdGlvbjogbWVzc2FnZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyQXN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQXN5bmMoZGF0YSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmhpZGVEZXByZWNhdGlvbnMgPSB0cnVlO1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnJlc29sdmVEYXRhKGRhdGEpO1xuICAgICAgdGhpcy5oaWRlRGVwcmVjYXRpb25zID0gZmFsc2U7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgIHRocm93UmVuZGVyVHdpY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29tcGlsZWQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgTGV4ZXI6IExleGVyXG4gICAgICB9KTtcbiAgICAgIHRoaXMubWFwcGVyIHx8ICh0aGlzLm1hcHBlciA9IHRoaXMubW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKHZhbHVlLCBtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRSZW5kZXJlZE1hcCh2YWx1ZSk7XG4gICAgICB9LCB7fSkpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgZm9yICh2YXIgdG8gaW4gdGhpcy5tYXBwZXIpIHtcbiAgICAgICAgdmFyIF90aGlzJG1hcHBlciR0bzIgPSB0aGlzLm1hcHBlclt0b10sXG4gICAgICAgICAgZnJvbSA9IF90aGlzJG1hcHBlciR0bzIuZnJvbSxcbiAgICAgICAgICBfZGF0YSA9IF90aGlzJG1hcHBlciR0bzIuZGF0YTtcbiAgICAgICAgdmFyIGN1cnJlbnRGaWxlID0gdGhpcy5jb21waWxlZFtmcm9tXTtcbiAgICAgICAgY3VycmVudEZpbGUuc2NvcGVNYW5hZ2VyID0gdGhpcy5nZXRTY29wZU1hbmFnZXIodG8sIGN1cnJlbnRGaWxlLCBfZGF0YSk7XG4gICAgICAgIGN1cnJlbnRGaWxlLnJlbmRlcih0byk7XG4gICAgICAgIG91dHB1dC5wdXNoKFt0bywgY3VycmVudEZpbGUuY29udGVudCwgY3VycmVudEZpbGVdKTtcbiAgICAgICAgZGVsZXRlIGN1cnJlbnRGaWxlLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTM2ID0gMDsgX2kzNiA8IG91dHB1dC5sZW5ndGg7IF9pMzYrKykge1xuICAgICAgICB2YXIgb3V0cHV0UGFydCA9IG91dHB1dFtfaTM2XTtcbiAgICAgICAgdmFyIF9vdXRwdXRQYXJ0ID0gX3NsaWNlZFRvQXJyYXkob3V0cHV0UGFydCwgMyksXG4gICAgICAgICAgY29udGVudCA9IF9vdXRwdXRQYXJ0WzFdLFxuICAgICAgICAgIF9jdXJyZW50RmlsZSA9IF9vdXRwdXRQYXJ0WzJdO1xuICAgICAgICBmb3IgKHZhciBfaTM4ID0gMCwgX3RoaXMkbW9kdWxlczE0ID0gdGhpcy5tb2R1bGVzOyBfaTM4IDwgX3RoaXMkbW9kdWxlczE0Lmxlbmd0aDsgX2kzOCsrKSB7XG4gICAgICAgICAgdmFyIF9tb2R1bGUwID0gX3RoaXMkbW9kdWxlczE0W19pMzhdO1xuICAgICAgICAgIGlmIChfbW9kdWxlMC5wcmVaaXApIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBfbW9kdWxlMC5wcmVaaXAoY29udGVudCwgX2N1cnJlbnRGaWxlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIG91dHB1dFBhcnRbMV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTQwID0gMDsgX2k0MCA8IG91dHB1dC5sZW5ndGg7IF9pNDArKykge1xuICAgICAgICB2YXIgX291dHB1dCRfaSA9IF9zbGljZWRUb0FycmF5KG91dHB1dFtfaTQwXSwgMiksXG4gICAgICAgICAgX3RvID0gX291dHB1dCRfaVswXSxcbiAgICAgICAgICBfY29udGVudCA9IF9vdXRwdXQkX2lbMV07XG4gICAgICAgIHRoaXMuemlwLmZpbGUoX3RvLCBfY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2ZXJpZnlFcnJvcnModGhpcyk7XG4gICAgICB0aGlzLnNlbmRFdmVudChcInN5bmNpbmctemlwXCIpO1xuICAgICAgdGhpcy5zeW5jWmlwKCk7XG4gICAgICAvLyBUaGUgc3luY2VkLXppcCBldmVudCBpcyB1c2VkIGluIHRoZSBzdWJ0ZW1wbGF0ZSBtb2R1bGUgZm9yIGV4YW1wbGVcbiAgICAgIHRoaXMuc2VuZEV2ZW50KFwic3luY2VkLXppcFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzeW5jWmlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmNaaXAoKSB7XG4gICAgICBmb3IgKHZhciBmaWxlTmFtZSBpbiB0aGlzLnhtbERvY3VtZW50cykge1xuICAgICAgICB0aGlzLnppcC5yZW1vdmUoZmlsZU5hbWUpO1xuICAgICAgICB2YXIgY29udGVudCA9IHhtbDJzdHIodGhpcy54bWxEb2N1bWVudHNbZmlsZU5hbWVdKTtcbiAgICAgICAgdGhpcy56aXAuZmlsZShmaWxlTmFtZSwgY29udGVudCwge1xuICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShkYXRhKSB7XG4gICAgICBkZXByZWNhdGVkTWV0aG9kKHRoaXMsIFwic2V0RGF0YVwiKTtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0WmlwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFppcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlVGVtcGxhdGVDbGFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzKHBhdGgpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy56aXAuZmlsZXNbcGF0aF0uYXNUZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgcGF0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRlbXBsYXRlQ2xhc3NGcm9tQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZW1wbGF0ZUNsYXNzRnJvbUNvbnRlbnQoY29udGVudCwgZmlsZVBhdGgpIHtcbiAgICAgIHZhciB4bWx0T3B0aW9ucyA9IHtcbiAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoLFxuICAgICAgICBjb250ZW50VHlwZTogdGhpcy5maWxlc0NvbnRlbnRUeXBlc1tmaWxlUGF0aF0sXG4gICAgICAgIHJlbHNUeXBlOiB0aGlzLnJlbHNUeXBlc1tmaWxlUGF0aF1cbiAgICAgIH07XG4gICAgICB2YXIgZGVmYXVsdHMgPSBnZXREZWZhdWx0cygpO1xuICAgICAgdmFyIGRlZmF1bHRLZXlzID0gcHVzaEFycmF5KE9iamVjdC5rZXlzKGRlZmF1bHRzKSwgW1wiZmlsZXNDb250ZW50VHlwZXNcIiwgXCJmaWxlVHlwZUNvbmZpZ1wiLCBcImZpbGVUeXBlXCIsIFwibW9kdWxlc1wiXSk7XG4gICAgICBmb3IgKHZhciBfaTQyID0gMDsgX2k0MiA8IGRlZmF1bHRLZXlzLmxlbmd0aDsgX2k0MisrKSB7XG4gICAgICAgIHZhciBrZXkgPSBkZWZhdWx0S2V5c1tfaTQyXTtcbiAgICAgICAgeG1sdE9wdGlvbnNba2V5XSA9IHRoaXNba2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRG9jeHRlbXBsYXRlci5YbWxUZW1wbGF0ZXIoY29udGVudCwgeG1sdE9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsVGV4dChwYXRoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZW1wbGF0ZUNsYXNzKHBhdGggfHwgdGhpcy5maWxlVHlwZUNvbmZpZy50ZXh0UGF0aCh0aGlzKSkuZ2V0RnVsbFRleHQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGVtcGxhdGVkRmlsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGVtcGxhdGVkRmlsZXMoKSB7XG4gICAgICB0aGlzLnRlbXBsYXRlZEZpbGVzID0gdGhpcy5maWxlVHlwZUNvbmZpZy5nZXRUZW1wbGF0ZWRGaWxlcyh0aGlzLnppcCk7XG4gICAgICBwdXNoQXJyYXkodGhpcy50ZW1wbGF0ZWRGaWxlcywgdGhpcy50YXJnZXRzKTtcbiAgICAgIHRoaXMudGVtcGxhdGVkRmlsZXMgPSB1bmlxKHRoaXMudGVtcGxhdGVkRmlsZXMpO1xuICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVkRmlsZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFncygpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGhlYWRlcnM6IFtdLFxuICAgICAgICBmb290ZXJzOiBbXVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNvbXBpbGVkKSB7XG4gICAgICAgIHZhciBjb250ZW50VHlwZSA9IHRoaXMuZmlsZXNDb250ZW50VHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lm1haW4reG1sXCIpIHtcbiAgICAgICAgICByZXN1bHQuZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmhlYWRlcit4bWxcIikge1xuICAgICAgICAgIHJlc3VsdC5oZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgdGFyZ2V0OiBrZXksXG4gICAgICAgICAgICB0YWdzOiBfZ2V0VGFncyh0aGlzLmNvbXBpbGVkW2tleV0ucG9zdHBhcnNlZClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZm9vdGVyK3htbFwiKSB7XG4gICAgICAgICAgcmVzdWx0LmZvb3RlcnMucHVzaCh7XG4gICAgICAgICAgICB0YXJnZXQ6IGtleSxcbiAgICAgICAgICAgIHRhZ3M6IF9nZXRUYWdzKHRoaXMuY29tcGlsZWRba2V5XS5wb3N0cGFyc2VkKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qIEV4cG9ydCBmdW5jdGlvbnMsIHByZXNlbnQgc2luY2UgMy42Mi4wICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuemlwLmdlbmVyYXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIixcbiAgICAgICAgZmlsZU9yZGVyOiB6aXBGaWxlT3JkZXJcbiAgICAgIH0sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICB0eXBlOiBcIm5vZGVidWZmZXJcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiBFeHBvcnQgZnVuY3Rpb25zLCBwcmVzZW50IHNpbmNlIDMuNjIuMCAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvQmxvYlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0Jsb2Iob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuemlwLmdlbmVyYXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIixcbiAgICAgICAgZmlsZU9yZGVyOiB6aXBGaWxlT3JkZXJcbiAgICAgIH0sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICB0eXBlOiBcImJsb2JcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiBFeHBvcnQgZnVuY3Rpb25zLCBwcmVzZW50IHNpbmNlIDMuNjIuMCAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvQmFzZTY0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvQmFzZTY0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnppcC5nZW5lcmF0ZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBjb21wcmVzc2lvbjogXCJERUZMQVRFXCIsXG4gICAgICAgIGZpbGVPcmRlcjogemlwRmlsZU9yZGVyXG4gICAgICB9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgdHlwZTogXCJiYXNlNjRcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiBFeHBvcnQgZnVuY3Rpb25zLCBwcmVzZW50IHNpbmNlIDMuNjIuMCAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvVWludDhBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1VpbnQ4QXJyYXkob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuemlwLmdlbmVyYXRlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGNvbXByZXNzaW9uOiBcIkRFRkxBVEVcIixcbiAgICAgICAgZmlsZU9yZGVyOiB6aXBGaWxlT3JkZXJcbiAgICAgIH0sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICB0eXBlOiBcInVpbnQ4YXJyYXlcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgICAvKiBFeHBvcnQgZnVuY3Rpb25zLCBwcmVzZW50IHNpbmNlIDMuNjIuMCAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy56aXAuZ2VuZXJhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgY29tcHJlc3Npb246IFwiREVGTEFURVwiLFxuICAgICAgICBmaWxlT3JkZXI6IHppcEZpbGVPcmRlclxuICAgICAgfSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlidWZmZXJcIlxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuRG9jeHRlbXBsYXRlci5Eb2NVdGlscyA9IERvY1V0aWxzO1xuRG9jeHRlbXBsYXRlci5FcnJvcnMgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIik7XG5Eb2N4dGVtcGxhdGVyLlhtbFRlbXBsYXRlciA9IHJlcXVpcmUoXCIuL3htbC10ZW1wbGF0ZXIuanNcIik7XG5Eb2N4dGVtcGxhdGVyLkZpbGVUeXBlQ29uZmlnID0gcmVxdWlyZShcIi4vZmlsZS10eXBlLWNvbmZpZy5qc1wiKTtcbkRvY3h0ZW1wbGF0ZXIuWG1sTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3htbC1tYXRjaGVyLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBEb2N4dGVtcGxhdGVyO1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gRG9jeHRlbXBsYXRlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/docxtemplater.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/error-logger.js":
/*!***********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/error-logger.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n  if (value instanceof Error) {\n    return pushArray(Object.getOwnPropertyNames(value), [\"stack\"]).reduce(function (error, key) {\n      error[key] = value[key];\n      if (key === \"stack\") {\n        // This is used because in Firefox, stack is not an own property\n        error[key] = value[key].toString();\n      }\n      return error;\n    }, {});\n  }\n  return value;\n}\nfunction logger(error, logging) {\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify({\n    error: error\n  }, replaceErrors, logging === \"json\" ? 2 : null));\n  if (error.properties && error.properties.errors instanceof Array) {\n    var errorMessages = error.properties.errors.map(function (error) {\n      return error.properties.explanation;\n    }).join(\"\\n\");\n    // eslint-disable-next-line no-console\n    console.log(\"errorMessages\", errorMessages);\n    /*\n     * errorMessages is a humanly readable message looking like this :\n     * 'The tag beginning with \"foobar\" is unopened'\n     */\n  }\n}\nmodule.exports = logger;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3ItbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw4RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2Vycm9yLWxvZ2dlci5qcz84ZDk4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheTtcbi8vIFRoZSBlcnJvciB0aHJvd24gaGVyZSBjb250YWlucyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdoZW4gbG9nZ2VkIHdpdGggSlNPTi5zdHJpbmdpZnkgKGl0IGNvbnRhaW5zIGEgcHJvcGVydGllcyBvYmplY3QgY29udGFpbmluZyBhbGwgc3ViZXJyb3JzKS5cbmZ1bmN0aW9uIHJlcGxhY2VFcnJvcnMoa2V5LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBwdXNoQXJyYXkoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLCBbXCJzdGFja1wiXSkucmVkdWNlKGZ1bmN0aW9uIChlcnJvciwga2V5KSB7XG4gICAgICBlcnJvcltrZXldID0gdmFsdWVba2V5XTtcbiAgICAgIGlmIChrZXkgPT09IFwic3RhY2tcIikge1xuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYmVjYXVzZSBpbiBGaXJlZm94LCBzdGFjayBpcyBub3QgYW4gb3duIHByb3BlcnR5XG4gICAgICAgIGVycm9yW2tleV0gPSB2YWx1ZVtrZXldLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSwge30pO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGxvZ2dlcihlcnJvciwgbG9nZ2luZykge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh7XG4gICAgZXJyb3I6IGVycm9yXG4gIH0sIHJlcGxhY2VFcnJvcnMsIGxvZ2dpbmcgPT09IFwianNvblwiID8gMiA6IG51bGwpKTtcbiAgaWYgKGVycm9yLnByb3BlcnRpZXMgJiYgZXJyb3IucHJvcGVydGllcy5lcnJvcnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2VzID0gZXJyb3IucHJvcGVydGllcy5lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yLnByb3BlcnRpZXMuZXhwbGFuYXRpb247XG4gICAgfSkuam9pbihcIlxcblwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKFwiZXJyb3JNZXNzYWdlc1wiLCBlcnJvck1lc3NhZ2VzKTtcbiAgICAvKlxuICAgICAqIGVycm9yTWVzc2FnZXMgaXMgYSBodW1hbmx5IHJlYWRhYmxlIG1lc3NhZ2UgbG9va2luZyBsaWtlIHRoaXMgOlxuICAgICAqICdUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFwiZm9vYmFyXCIgaXMgdW5vcGVuZWQnXG4gICAgICovXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gbG9nZ2VyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/error-logger.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/errors.js":
/*!*****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/utils.js\"),\n  last = _require.last,\n  first = _require.first;\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n    value = _ref.value,\n    offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field \".concat(tag)\n  };\n  return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n  var tag = _ref2.tag,\n    value = _ref2.value,\n    offset = _ref2.offset;\n  var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n  err.properties = {\n    id: \"invalid_raw_xml_value\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n  };\n  return err;\n}\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n    value = _options$part.value,\n    offset = _options$part.offset,\n    _options$id = options.id,\n    id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n    _options$message = options.message,\n    message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n    explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n    offset = part.offset,\n    square = part.square;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  if (square) {\n    err.properties.square = square;\n  }\n  return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n  var tags = _ref3.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  if (first(tags).square) {\n    err.properties.square = [first(tags).square, last(tags).square];\n  }\n  return err;\n}\nfunction getScopeCompilationError(_ref4) {\n  var tag = _ref4.tag,\n    rootError = _ref4.rootError,\n    offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    xtag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n  var tag = _ref5.tag,\n    scope = _ref5.scope,\n    error = _ref5.error,\n    offset = _ref5.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    xtag: tag,\n    rootError: error\n  };\n  return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n  var tag = _ref6.tag,\n    offset = _ref6.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    xtag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\nfunction throwMalformedXml() {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    explanation: \"The template contains malformed xml\",\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\",\n    explanation: \"You must run `.compile()` before running `.resolveData()`\"\n  };\n  throw err;\n}\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\",\n    explanation: \"You should not call .render on a document that had compilation errors\"\n  };\n  throw err;\n}\nfunction throwRenderTwice() {\n  var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n  err.properties = {\n    id: \"render_twice\",\n    explanation: \"You should not call .render twice on the same docxtemplater instance\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotIdentified(zip) {\n  var files = Object.keys(zip.files).slice(0, 10);\n  var msg = \"\";\n  if (files.length === 0) {\n    msg = \"Empty zip file\";\n  } else {\n    msg = \"Zip file contains : \".concat(files.join(\",\"));\n  }\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg));\n  err.properties = {\n    id: \"filetype_not_identified\",\n    explanation: \"The filetype for this file could not be identified, is this file corrupted ? \".concat(msg)\n  };\n  throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n  throwRenderTwice: throwRenderTwice\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsc0VBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CLHFCQUFxQixpQkFBaUIsZ0JBQWdCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2Vycm9ycy5qcz9iM2ZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpLFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZS5maXJzdDtcbmZ1bmN0aW9uIFhURXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkdlbmVyaWNFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5mdW5jdGlvbiBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIlRlbXBsYXRlRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUVGVtcGxhdGVFcnJvci5wcm90b3R5cGUgPSBuZXcgWFRFcnJvcigpO1xuZnVuY3Rpb24gWFRSZW5kZXJpbmdFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiUmVuZGVyaW5nRXJyb3JcIjtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjaztcbn1cblhUUmVuZGVyaW5nRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIFhUU2NvcGVQYXJzZXJFcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiU2NvcGVQYXJzZXJFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRTY29wZVBhcnNlckVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVEludGVybmFsRXJyb3IobWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkludGVybmFsRXJyb3JcIjtcbiAgdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgIGV4cGxhbmF0aW9uOiBcIkludGVybmFsRXJyb3JcIlxuICB9O1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRJbnRlcm5hbEVycm9yLnByb3RvdHlwZSA9IG5ldyBYVEVycm9yKCk7XG5mdW5jdGlvbiBYVEFQSVZlcnNpb25FcnJvcihtZXNzYWdlKSB7XG4gIHRoaXMubmFtZSA9IFwiQVBJVmVyc2lvbkVycm9yXCI7XG4gIHRoaXMucHJvcGVydGllcyA9IHtcbiAgICBleHBsYW5hdGlvbjogXCJBUElWZXJzaW9uRXJyb3JcIlxuICB9O1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO1xufVxuWFRBUElWZXJzaW9uRXJyb3IucHJvdG90eXBlID0gbmV3IFhURXJyb3IoKTtcbmZ1bmN0aW9uIHRocm93QXBpVmVyc2lvbkVycm9yKG1zZywgcHJvcGVydGllcykge1xuICB2YXIgZXJyID0gbmV3IFhUQVBJVmVyc2lvbkVycm9yKG1zZyk7XG4gIGVyci5wcm9wZXJ0aWVzID0gX29iamVjdFNwcmVhZCh7XG4gICAgaWQ6IFwiYXBpX3ZlcnNpb25fZXJyb3JcIlxuICB9LCBwcm9wZXJ0aWVzKTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dNdWx0aUVycm9yKGVycm9ycykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk11bHRpIGVycm9yXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBlcnJvcnM6IGVycm9ycyxcbiAgICBpZDogXCJtdWx0aV9lcnJvclwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0ZW1wbGF0ZSBoYXMgbXVsdGlwbGUgZXJyb3JzXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlVub3BlbmVkIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogbGFzdChvcHRpb25zLnh0YWcuc3BsaXQoXCIgXCIpKSxcbiAgICBpZDogXCJ1bm9wZW5lZF90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgYmVnaW5uaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGlzIHVub3BlbmVkXCIpXG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJEdXBsaWNhdGUgb3BlbiB0YWcsIGV4cGVjdGVkIG9uZSBvcGVuIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSksXG4gICAgaWQ6IFwiZHVwbGljYXRlX29wZW5fdGFnXCIsXG4gICAgY29udGV4dDogb3B0aW9ucy54dGFnLFxuICAgIG9mZnNldDogb3B0aW9ucy5vZmZzZXQsXG4gICAgbEluZGV4OiBvcHRpb25zLmxJbmRleCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFnIGJlZ2lubmluZyB3aXRoIFxcXCJcIi5jb25jYXQob3B0aW9ucy54dGFnLnN1YnN0cigwLCAxMCksIFwiXFxcIiBoYXMgZHVwbGljYXRlIG9wZW4gdGFnc1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIkR1cGxpY2F0ZSBjbG9zZSB0YWcsIGV4cGVjdGVkIG9uZSBjbG9zZSB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IGZpcnN0KG9wdGlvbnMueHRhZy5zcGxpdChcIiBcIikpLFxuICAgIGlkOiBcImR1cGxpY2F0ZV9jbG9zZV90YWdcIixcbiAgICBjb250ZXh0OiBvcHRpb25zLnh0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLm9mZnNldCxcbiAgICBsSW5kZXg6IG9wdGlvbnMubEluZGV4LFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSB0YWcgZW5kaW5nIHdpdGggXFxcIlwiLmNvbmNhdChvcHRpb25zLnh0YWcuc3Vic3RyKDAsIDEwKSwgXCJcXFwiIGhhcyBkdXBsaWNhdGUgY2xvc2UgdGFnc1wiKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24ob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlVuY2xvc2VkIHRhZ1wiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgeHRhZzogZmlyc3Qob3B0aW9ucy54dGFnLnNwbGl0KFwiIFwiKSkuc3Vic3RyKDEpLFxuICAgIGlkOiBcInVuY2xvc2VkX3RhZ1wiLFxuICAgIGNvbnRleHQ6IG9wdGlvbnMueHRhZyxcbiAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LFxuICAgIGxJbmRleDogb3B0aW9ucy5sSW5kZXgsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBiZWdpbm5pbmcgd2l0aCBcXFwiXCIuY29uY2F0KG9wdGlvbnMueHRhZy5zdWJzdHIoMCwgMTApLCBcIlxcXCIgaXMgdW5jbG9zZWRcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93WG1sVGFnTm90Rm91bmQob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5vIHRhZyBcXFwiXCIuY29uY2F0KG9wdGlvbnMuZWxlbWVudCwgXCJcXFwiIHdhcyBmb3VuZCBhdCB0aGUgXCIpLmNvbmNhdChvcHRpb25zLnBvc2l0aW9uKSk7XG4gIHZhciBwYXJ0ID0gb3B0aW9ucy5wYXJzZWRbb3B0aW9ucy5pbmRleF07XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcIm5vX3htbF90YWdfZm91bmRfYXRfXCIuY29uY2F0KG9wdGlvbnMucG9zaXRpb24pLFxuICAgIGV4cGxhbmF0aW9uOiBcIk5vIHRhZyBcXFwiXCIuY29uY2F0KG9wdGlvbnMuZWxlbWVudCwgXCJcXFwiIHdhcyBmb3VuZCBhdCB0aGUgXCIpLmNvbmNhdChvcHRpb25zLnBvc2l0aW9uKSxcbiAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0LFxuICAgIHBhcnQ6IHBhcnQsXG4gICAgcGFyc2VkOiBvcHRpb25zLnBhcnNlZCxcbiAgICBpbmRleDogb3B0aW9ucy5pbmRleCxcbiAgICBlbGVtZW50OiBvcHRpb25zLmVsZW1lbnRcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb24oX3JlZikge1xuICB2YXIgdGFnID0gX3JlZi50YWcsXG4gICAgdmFsdWUgPSBfcmVmLnZhbHVlLFxuICAgIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUUmVuZGVyaW5nRXJyb3IoXCJUaGVyZSBhcmUgc29tZSBYTUwgY29ycnVwdCBjaGFyYWN0ZXJzXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJpbnZhbGlkX3htbF9jaGFyYWN0ZXJzXCIsXG4gICAgeHRhZzogdGFnLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBleHBsYW5hdGlvbjogXCJUaGVyZSBhcmUgc29tZSBjb3JydXB0IGNoYXJhY3RlcnMgZm9yIHRoZSBmaWVsZCBcIi5jb25jYXQodGFnKVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uKF9yZWYyKSB7XG4gIHZhciB0YWcgPSBfcmVmMi50YWcsXG4gICAgdmFsdWUgPSBfcmVmMi52YWx1ZSxcbiAgICBvZmZzZXQgPSBfcmVmMi5vZmZzZXQ7XG4gIHZhciBlcnIgPSBuZXcgWFRSZW5kZXJpbmdFcnJvcihcIk5vbiBzdHJpbmcgdmFsdWVzIGFyZSBub3QgYWxsb3dlZCBmb3IgcmF3WE1MIHRhZ3NcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImludmFsaWRfcmF3X3htbF92YWx1ZVwiLFxuICAgIHh0YWc6IHRhZyxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHZhbHVlIG9mIHRoZSByYXcgdGFnIDogJ1wiLmNvbmNhdCh0YWcsIFwiJyBpcyBub3QgYSBzdHJpbmdcIilcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIHRocm93RXhwYW5kTm90Rm91bmQob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkcGFydCA9IG9wdGlvbnMucGFydCxcbiAgICB2YWx1ZSA9IF9vcHRpb25zJHBhcnQudmFsdWUsXG4gICAgb2Zmc2V0ID0gX29wdGlvbnMkcGFydC5vZmZzZXQsXG4gICAgX29wdGlvbnMkaWQgPSBvcHRpb25zLmlkLFxuICAgIGlkID0gX29wdGlvbnMkaWQgPT09IHZvaWQgMCA/IFwicmF3X3RhZ19vdXRlcnhtbF9pbnZhbGlkXCIgOiBfb3B0aW9ucyRpZCxcbiAgICBfb3B0aW9ucyRtZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLFxuICAgIG1lc3NhZ2UgPSBfb3B0aW9ucyRtZXNzYWdlID09PSB2b2lkIDAgPyBcIlJhdyB0YWcgbm90IGluIHBhcmFncmFwaFwiIDogX29wdGlvbnMkbWVzc2FnZTtcbiAgdmFyIHBhcnQgPSBvcHRpb25zLnBhcnQ7XG4gIHZhciBfb3B0aW9ucyRleHBsYW5hdGlvbiA9IG9wdGlvbnMuZXhwbGFuYXRpb24sXG4gICAgZXhwbGFuYXRpb24gPSBfb3B0aW9ucyRleHBsYW5hdGlvbiA9PT0gdm9pZCAwID8gXCJUaGUgdGFnIFxcXCJcIi5jb25jYXQodmFsdWUsIFwiXFxcIiBpcyBub3QgaW5zaWRlIGEgcGFyYWdyYXBoXCIpIDogX29wdGlvbnMkZXhwbGFuYXRpb247XG4gIGlmICh0eXBlb2YgZXhwbGFuYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGV4cGxhbmF0aW9uID0gZXhwbGFuYXRpb24ocGFydCk7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IobWVzc2FnZSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBpZCxcbiAgICBleHBsYW5hdGlvbjogZXhwbGFuYXRpb24sXG4gICAgcm9vdEVycm9yOiBvcHRpb25zLnJvb3RFcnJvcixcbiAgICB4dGFnOiB2YWx1ZSxcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBwb3N0cGFyc2VkOiBvcHRpb25zLnBvc3RwYXJzZWQsXG4gICAgZXhwYW5kVG86IG9wdGlvbnMuZXhwYW5kVG8sXG4gICAgaW5kZXg6IG9wdGlvbnMuaW5kZXhcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgob3B0aW9ucykge1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlJhdyB0YWcgc2hvdWxkIGJlIHRoZSBvbmx5IHRleHQgaW4gcGFyYWdyYXBoXCIpO1xuICB2YXIgdGFnID0gb3B0aW9ucy5wYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJyYXdfeG1sX3RhZ19zaG91bGRfYmVfb25seV90ZXh0X2luX3BhcmFncmFwaFwiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlRoZSByYXcgdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgc2hvdWxkIGJlIHRoZSBvbmx5IHRleHQgaW4gdGhpcyBwYXJhZ3JhcGguIFRoaXMgbWVhbnMgdGhhdCB0aGlzIHRhZyBzaG91bGQgbm90IGJlIHN1cnJvdW5kZWQgYnkgYW55IHRleHQgb3Igc3BhY2VzLlwiKSxcbiAgICB4dGFnOiB0YWcsXG4gICAgb2Zmc2V0OiBvcHRpb25zLnBhcnQub2Zmc2V0LFxuICAgIHBhcmFncmFwaFBhcnRzOiBvcHRpb25zLnBhcmFncmFwaFBhcnRzXG4gIH07XG4gIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24ocGFydCkge1xuICB2YXIgbG9jYXRpb24gPSBwYXJ0LmxvY2F0aW9uLFxuICAgIG9mZnNldCA9IHBhcnQub2Zmc2V0LFxuICAgIHNxdWFyZSA9IHBhcnQuc3F1YXJlO1xuICB2YXIgdCA9IGxvY2F0aW9uID09PSBcInN0YXJ0XCIgPyBcInVuY2xvc2VkXCIgOiBcInVub3BlbmVkXCI7XG4gIHZhciBUID0gbG9jYXRpb24gPT09IFwic3RhcnRcIiA/IFwiVW5jbG9zZWRcIiA6IFwiVW5vcGVuZWRcIjtcbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoXCJcIi5jb25jYXQoVCwgXCIgbG9vcFwiKSk7XG4gIHZhciB0YWcgPSBwYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJcIi5jb25jYXQodCwgXCJfbG9vcFwiKSxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgbG9vcCB3aXRoIHRhZyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGlzIFwiKS5jb25jYXQodCksXG4gICAgeHRhZzogdGFnLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIGlmIChzcXVhcmUpIHtcbiAgICBlcnIucHJvcGVydGllcy5zcXVhcmUgPSBzcXVhcmU7XG4gIH1cbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uKHBhaXIsIGxhc3RQYWlyKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiVW5iYWxhbmNlZCBsb29wIHRhZ1wiKTtcbiAgdmFyIGxhc3RMID0gbGFzdFBhaXJbMF0ucGFydC52YWx1ZTtcbiAgdmFyIGxhc3RSID0gbGFzdFBhaXJbMV0ucGFydC52YWx1ZTtcbiAgdmFyIGwgPSBwYWlyWzBdLnBhcnQudmFsdWU7XG4gIHZhciByID0gcGFpclsxXS5wYXJ0LnZhbHVlO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJ1bmJhbGFuY2VkX2xvb3BfdGFnc1wiLFxuICAgIGV4cGxhbmF0aW9uOiBcIlVuYmFsYW5jZWQgbG9vcCB0YWdzIHsjXCIuY29uY2F0KGxhc3RMLCBcIn17L1wiKS5jb25jYXQobGFzdFIsIFwifXsjXCIpLmNvbmNhdChsLCBcIn17L1wiKS5jb25jYXQociwgXCJ9XCIpLFxuICAgIG9mZnNldDogW2xhc3RQYWlyWzBdLnBhcnQub2Zmc2V0LCBwYWlyWzFdLnBhcnQub2Zmc2V0XSxcbiAgICBsYXN0UGFpcjoge1xuICAgICAgbGVmdDogbGFzdFBhaXJbMF0ucGFydC52YWx1ZSxcbiAgICAgIHJpZ2h0OiBsYXN0UGFpclsxXS5wYXJ0LnZhbHVlXG4gICAgfSxcbiAgICBwYWlyOiB7XG4gICAgICBsZWZ0OiBwYWlyWzBdLnBhcnQudmFsdWUsXG4gICAgICByaWdodDogcGFpclsxXS5wYXJ0LnZhbHVlXG4gICAgfVxuICB9O1xuICByZXR1cm4gZXJyO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyhfcmVmMykge1xuICB2YXIgdGFncyA9IF9yZWYzLnRhZ3M7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiQ2xvc2luZyB0YWcgZG9lcyBub3QgbWF0Y2ggb3BlbmluZyB0YWdcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImNsb3NpbmdfdGFnX2RvZXNfbm90X21hdGNoX29wZW5pbmdfdGFnXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRhZyBcXFwiXCIuY29uY2F0KHRhZ3NbMF0udmFsdWUsIFwiXFxcIiBpcyBjbG9zZWQgYnkgdGhlIHRhZyBcXFwiXCIpLmNvbmNhdCh0YWdzWzFdLnZhbHVlLCBcIlxcXCJcIiksXG4gICAgb3BlbmluZ3RhZzogZmlyc3QodGFncykudmFsdWUsXG4gICAgb2Zmc2V0OiBbZmlyc3QodGFncykub2Zmc2V0LCBsYXN0KHRhZ3MpLm9mZnNldF0sXG4gICAgY2xvc2luZ3RhZzogbGFzdCh0YWdzKS52YWx1ZVxuICB9O1xuICBpZiAoZmlyc3QodGFncykuc3F1YXJlKSB7XG4gICAgZXJyLnByb3BlcnRpZXMuc3F1YXJlID0gW2ZpcnN0KHRhZ3MpLnNxdWFyZSwgbGFzdCh0YWdzKS5zcXVhcmVdO1xuICB9XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IoX3JlZjQpIHtcbiAgdmFyIHRhZyA9IF9yZWY0LnRhZyxcbiAgICByb290RXJyb3IgPSBfcmVmNC5yb290RXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjQub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBjb21waWxhdGlvbiBmYWlsZWRcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInNjb3BlcGFyc2VyX2NvbXBpbGF0aW9uX2ZhaWxlZFwiLFxuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHh0YWc6IHRhZyxcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgc2NvcGUgcGFyc2VyIGZvciB0aGUgdGFnIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgZmFpbGVkIHRvIGNvbXBpbGVcIiksXG4gICAgcm9vdEVycm9yOiByb290RXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IoX3JlZjUpIHtcbiAgdmFyIHRhZyA9IF9yZWY1LnRhZyxcbiAgICBzY29wZSA9IF9yZWY1LnNjb3BlLFxuICAgIGVycm9yID0gX3JlZjUuZXJyb3IsXG4gICAgb2Zmc2V0ID0gX3JlZjUub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUU2NvcGVQYXJzZXJFcnJvcihcIlNjb3BlIHBhcnNlciBleGVjdXRpb24gZmFpbGVkXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJzY29wZXBhcnNlcl9leGVjdXRpb25fZmFpbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHNjb3BlIHBhcnNlciBmb3IgdGhlIHRhZyBcIi5jb25jYXQodGFnLCBcIiBmYWlsZWQgdG8gZXhlY3V0ZVwiKSxcbiAgICBzY29wZTogc2NvcGUsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgeHRhZzogdGFnLFxuICAgIHJvb3RFcnJvcjogZXJyb3JcbiAgfTtcbiAgcmV0dXJuIGVycjtcbn1cbmZ1bmN0aW9uIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yKF9yZWY2KSB7XG4gIHZhciB0YWcgPSBfcmVmNi50YWcsXG4gICAgb2Zmc2V0ID0gX3JlZjYub2Zmc2V0O1xuICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbG9vcCB0YWdzIFxcXCJcIi5jb25jYXQodGFnLCBcIlxcXCIgd291bGQgcHJvZHVjZSBpbnZhbGlkIFhNTFwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIHh0YWc6IHRhZyxcbiAgICBpZDogXCJsb29wX3Bvc2l0aW9uX2ludmFsaWRcIixcbiAgICBleHBsYW5hdGlvbjogXCJUaGUgdGFncyBcXFwiXCIuY29uY2F0KHRhZywgXCJcXFwiIGFyZSBtaXNwbGFjZWQgaW4gdGhlIGRvY3VtZW50LCBmb3IgZXhhbXBsZSBvbmUgb2YgdGhlbSBpcyBpbiBhIHRhYmxlIGFuZCB0aGUgb3RoZXIgb25lIG91dHNpZGUgdGhlIHRhYmxlXCIpLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIHJldHVybiBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlKHBhcnQsIGluZGV4KSB7XG4gIHZhciBlcnJvck1zZyA9IFwiVW5pbXBsZW1lbnRlZCB0YWcgdHlwZSBcXFwiXCIuY29uY2F0KHBhcnQudHlwZSwgXCJcXFwiXCIpO1xuICBpZiAocGFydC5tb2R1bGUpIHtcbiAgICBlcnJvck1zZyArPSBcIiBcXFwiXCIuY29uY2F0KHBhcnQubW9kdWxlLCBcIlxcXCJcIik7XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBYVFRlbXBsYXRlRXJyb3IoZXJyb3JNc2cpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBwYXJ0OiBwYXJ0LFxuICAgIGluZGV4OiBpbmRleCxcbiAgICBpZDogXCJ1bmltcGxlbWVudGVkX3RhZ190eXBlXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dNYWxmb3JtZWRYbWwoKSB7XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiTWFsZm9ybWVkIHhtbFwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgZXhwbGFuYXRpb246IFwiVGhlIHRlbXBsYXRlIGNvbnRhaW5zIG1hbGZvcm1lZCB4bWxcIixcbiAgICBpZDogXCJtYWxmb3JtZWRfeG1sXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlc29sdmVfYmVmb3JlX2NvbXBpbGVcIixcbiAgICBleHBsYW5hdGlvbjogXCJZb3UgbXVzdCBydW4gYC5jb21waWxlKClgIGJlZm9yZSBydW5uaW5nIGAucmVzb2x2ZURhdGEoKWBcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1JlbmRlckludmFsaWRUZW1wbGF0ZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgb24gYSBkb2N1bWVudCB0aGF0IGhhZCBjb21waWxhdGlvbiBlcnJvcnNcIik7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcInJlbmRlcl9vbl9pbnZhbGlkX3RlbXBsYXRlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIG9uIGEgZG9jdW1lbnQgdGhhdCBoYWQgY29tcGlsYXRpb24gZXJyb3JzXCJcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gdGhyb3dSZW5kZXJUd2ljZSgpIHtcbiAgdmFyIGVyciA9IG5ldyBYVEludGVybmFsRXJyb3IoXCJZb3Ugc2hvdWxkIG5vdCBjYWxsIC5yZW5kZXIgdHdpY2Ugb24gdGhlIHNhbWUgZG9jeHRlbXBsYXRlciBpbnN0YW5jZVwiKTtcbiAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgaWQ6IFwicmVuZGVyX3R3aWNlXCIsXG4gICAgZXhwbGFuYXRpb246IFwiWW91IHNob3VsZCBub3QgY2FsbCAucmVuZGVyIHR3aWNlIG9uIHRoZSBzYW1lIGRvY3h0ZW1wbGF0ZXIgaW5zdGFuY2VcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCh6aXApIHtcbiAgdmFyIGZpbGVzID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5zbGljZSgwLCAxMCk7XG4gIHZhciBtc2cgPSBcIlwiO1xuICBpZiAoZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgbXNnID0gXCJFbXB0eSB6aXAgZmlsZVwiO1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IFwiWmlwIGZpbGUgY29udGFpbnMgOiBcIi5jb25jYXQoZmlsZXMuam9pbihcIixcIikpO1xuICB9XG4gIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9pZGVudGlmaWVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGV0eXBlIGZvciB0aGlzIGZpbGUgY291bGQgbm90IGJlIGlkZW50aWZpZWQsIGlzIHRoaXMgZmlsZSBjb3JydXB0ZWQgPyBcIi5jb25jYXQobXNnKVxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd1htbEludmFsaWQoY29udGVudCwgb2Zmc2V0KSB7XG4gIHZhciBlcnIgPSBuZXcgWFRUZW1wbGF0ZUVycm9yKFwiQW4gWE1MIGZpbGUgaGFzIGludmFsaWQgeG1sXCIpO1xuICBlcnIucHJvcGVydGllcyA9IHtcbiAgICBpZDogXCJmaWxlX2hhc19pbnZhbGlkX3htbFwiLFxuICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGRvY3ggY29udGFpbnMgaW52YWxpZCBYTUwsIGl0IGlzIG1vc3QgbGlrZWx5IGNvcnJ1cHRcIlxuICB9O1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZChmaWxlVHlwZSkge1xuICB2YXIgZXJyID0gbmV3IFhUSW50ZXJuYWxFcnJvcihcIlRoZSBmaWxldHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIgaXMgbm90IGhhbmRsZWQgYnkgZG9jeHRlbXBsYXRlclwiKSk7XG4gIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgIGlkOiBcImZpbGV0eXBlX25vdF9oYW5kbGVkXCIsXG4gICAgZXhwbGFuYXRpb246IFwiVGhlIGZpbGUgeW91IGFyZSB0cnlpbmcgdG8gZ2VuZXJhdGUgaXMgb2YgdHlwZSBcXFwiXCIuY29uY2F0KGZpbGVUeXBlLCBcIlxcXCIsIGJ1dCBvbmx5IGRvY3ggYW5kIHBwdHggZm9ybWF0cyBhcmUgaGFuZGxlZFwiKSxcbiAgICBmaWxlVHlwZTogZmlsZVR5cGVcbiAgfTtcbiAgdGhyb3cgZXJyO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhURXJyb3I6IFhURXJyb3IsXG4gIFhUVGVtcGxhdGVFcnJvcjogWFRUZW1wbGF0ZUVycm9yLFxuICBYVEludGVybmFsRXJyb3I6IFhUSW50ZXJuYWxFcnJvcixcbiAgWFRTY29wZVBhcnNlckVycm9yOiBYVFNjb3BlUGFyc2VyRXJyb3IsXG4gIFhUQVBJVmVyc2lvbkVycm9yOiBYVEFQSVZlcnNpb25FcnJvcixcbiAgLy8gUmVtb3ZlIHRoaXMgYWxpYXMgaW4gdjRcbiAgUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIFhUUmVuZGVyaW5nRXJyb3I6IFhUUmVuZGVyaW5nRXJyb3IsXG4gIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWc6IGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcsXG4gIGdldExvb3BQb3NpdGlvblByb2R1Y2VzSW52YWxpZFhNTEVycm9yOiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcixcbiAgZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yOiBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IsXG4gIGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3I6IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3IsXG4gIGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uOiBnZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb246IGdldFVub3BlbmVkVGFnRXhjZXB0aW9uLFxuICBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uOiBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uLFxuICBnZXREdXBsaWNhdGVDbG9zZVRhZ0V4Y2VwdGlvbjogZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb246IGdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24sXG4gIGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uOiBnZXRDb3JydXB0Q2hhcmFjdGVyc0V4Y2VwdGlvbixcbiAgZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uOiBnZXRJbnZhbGlkUmF3WE1MVmFsdWVFeGNlcHRpb24sXG4gIGdldFVuYmFsYW5jZWRMb29wRXhjZXB0aW9uOiBnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbixcbiAgdGhyb3dBcGlWZXJzaW9uRXJyb3I6IHRocm93QXBpVmVyc2lvbkVycm9yLFxuICB0aHJvd0ZpbGVUeXBlTm90SGFuZGxlZDogdGhyb3dGaWxlVHlwZU5vdEhhbmRsZWQsXG4gIHRocm93RmlsZVR5cGVOb3RJZGVudGlmaWVkOiB0aHJvd0ZpbGVUeXBlTm90SWRlbnRpZmllZCxcbiAgdGhyb3dNYWxmb3JtZWRYbWw6IHRocm93TWFsZm9ybWVkWG1sLFxuICB0aHJvd011bHRpRXJyb3I6IHRocm93TXVsdGlFcnJvcixcbiAgdGhyb3dFeHBhbmROb3RGb3VuZDogdGhyb3dFeHBhbmROb3RGb3VuZCxcbiAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGg6IHRocm93UmF3VGFnU2hvdWxkQmVPbmx5VGV4dEluUGFyYWdyYXBoLFxuICB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlOiB0aHJvd1VuaW1wbGVtZW50ZWRUYWdUeXBlLFxuICB0aHJvd1htbFRhZ05vdEZvdW5kOiB0aHJvd1htbFRhZ05vdEZvdW5kLFxuICB0aHJvd1htbEludmFsaWQ6IHRocm93WG1sSW52YWxpZCxcbiAgdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZTogdGhyb3dSZXNvbHZlQmVmb3JlQ29tcGlsZSxcbiAgdGhyb3dSZW5kZXJJbnZhbGlkVGVtcGxhdGU6IHRocm93UmVuZGVySW52YWxpZFRlbXBsYXRlLFxuICB0aHJvd1JlbmRlclR3aWNlOiB0aHJvd1JlbmRlclR3aWNlXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/errors.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/file-type-config.js":
/*!***************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/file-type-config.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar loopModule = __webpack_require__(/*! ./modules/loop.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/loop.js\");\nvar spacePreserveModule = __webpack_require__(/*! ./modules/space-preserve.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/space-preserve.js\");\nvar rawXmlModule = __webpack_require__(/*! ./modules/rawxml.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/rawxml.js\");\nvar expandPairTrait = __webpack_require__(/*! ./modules/expand-pair-trait.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/expand-pair-trait.js\");\nvar render = __webpack_require__(/*! ./modules/render.js */ \"(rsc)/../../node_modules/docxtemplater/js/modules/render.js\");\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"cp:contentStatus\", \"w:t\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:tbl\", \"w:ftr\", \"w:hdr\", \"w:body\", \"w:document\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:sdt\", \"w:drawing\", \"w:sectPr\", \"w:type\", \"w:headerReference\", \"w:footerReference\", \"w:bookmarkStart\", \"w:bookmarkEnd\", \"w:commentRangeStart\", \"w:commentRangeEnd\", \"w:commentReference\"],\n    droppedTagsInsidePlaceholder: [\"w:p\", \"w:br\", \"w:bookmarkStart\", \"w:bookmarkEnd\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\", \"w:commentRangeStart\", \"w:sdt\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:tr\",\n      shouldContain: [\"w:tc\"],\n      drop: true\n    }, {\n      tag: \"w:tbl\",\n      shouldContain: [\"w:tr\"],\n      drop: true\n    }]\n  };\n}\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:tbl\", \"a:graphicData\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\", \"a:off\", \"a:ext\", \"p:graphicFrame\", \"p:xfrm\", \"a16:rowId\", \"a:endParaRPr\"],\n    droppedTagsInsidePlaceholder: [\"a:p\", \"a:endParaRPr\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"a:tbl\",\n      shouldContain: [\"a:tr\"],\n      dropParent: \"p:graphicFrame\"\n    }, {\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZS10eXBlLWNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBbUI7QUFDNUMsMEJBQTBCLG1CQUFPLENBQUMsd0dBQTZCO0FBQy9ELG1CQUFtQixtQkFBTyxDQUFDLHdGQUFxQjtBQUNoRCxzQkFBc0IsbUJBQU8sQ0FBQyw4R0FBZ0M7QUFDOUQsYUFBYSxtQkFBTyxDQUFDLHdGQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZS10eXBlLWNvbmZpZy5qcz9lMmVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgbG9vcE1vZHVsZSA9IHJlcXVpcmUoXCIuL21vZHVsZXMvbG9vcC5qc1wiKTtcbnZhciBzcGFjZVByZXNlcnZlTW9kdWxlID0gcmVxdWlyZShcIi4vbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qc1wiKTtcbnZhciByYXdYbWxNb2R1bGUgPSByZXF1aXJlKFwiLi9tb2R1bGVzL3Jhd3htbC5qc1wiKTtcbnZhciBleHBhbmRQYWlyVHJhaXQgPSByZXF1aXJlKFwiLi9tb2R1bGVzL2V4cGFuZC1wYWlyLXRyYWl0LmpzXCIpO1xudmFyIHJlbmRlciA9IHJlcXVpcmUoXCIuL21vZHVsZXMvcmVuZGVyLmpzXCIpO1xuZnVuY3Rpb24gRG9jWEZpbGVUeXBlQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdldFRlbXBsYXRlZEZpbGVzOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MudGV4dFRhcmdldDtcbiAgICB9LFxuICAgIHRhZ3NYbWxUZXh0QXJyYXk6IFtcIkNvbXBhbnlcIiwgXCJIeXBlcmxpbmtCYXNlXCIsIFwiTWFuYWdlclwiLCBcImNwOmNhdGVnb3J5XCIsIFwiY3A6a2V5d29yZHNcIiwgXCJkYzpjcmVhdG9yXCIsIFwiZGM6ZGVzY3JpcHRpb25cIiwgXCJkYzpzdWJqZWN0XCIsIFwiZGM6dGl0bGVcIiwgXCJjcDpjb250ZW50U3RhdHVzXCIsIFwidzp0XCIsIFwiYTp0XCIsIFwibTp0XCIsIFwidnQ6bHBzdHJcIiwgXCJ2dDpscHdzdHJcIl0sXG4gICAgdGFnc1htbExleGVkQXJyYXk6IFtcInc6cHJvb2ZTdGF0ZVwiLCBcInc6dGNcIiwgXCJ3OnRyXCIsIFwidzp0YmxcIiwgXCJ3OmZ0clwiLCBcInc6aGRyXCIsIFwidzpib2R5XCIsIFwidzpkb2N1bWVudFwiLCBcInc6cFwiLCBcInc6clwiLCBcInc6YnJcIiwgXCJ3OnJQclwiLCBcInc6cFByXCIsIFwidzpzcGFjaW5nXCIsIFwidzpzZHRDb250ZW50XCIsIFwidzpzZHRcIiwgXCJ3OmRyYXdpbmdcIiwgXCJ3OnNlY3RQclwiLCBcInc6dHlwZVwiLCBcInc6aGVhZGVyUmVmZXJlbmNlXCIsIFwidzpmb290ZXJSZWZlcmVuY2VcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCIsIFwidzpjb21tZW50UmFuZ2VTdGFydFwiLCBcInc6Y29tbWVudFJhbmdlRW5kXCIsIFwidzpjb21tZW50UmVmZXJlbmNlXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcInc6cFwiLCBcInc6YnJcIiwgXCJ3OmJvb2ttYXJrU3RhcnRcIiwgXCJ3OmJvb2ttYXJrRW5kXCJdLFxuICAgIGV4cGFuZFRhZ3M6IFt7XG4gICAgICBjb250YWluczogXCJ3OnRjXCIsXG4gICAgICBleHBhbmQ6IFwidzp0clwiXG4gICAgfV0sXG4gICAgb25QYXJhZ3JhcGhMb29wOiBbe1xuICAgICAgY29udGFpbnM6IFwidzpwXCIsXG4gICAgICBleHBhbmQ6IFwidzpwXCIsXG4gICAgICBvbmx5VGV4dEluVGFnOiB0cnVlXG4gICAgfV0sXG4gICAgdGFnUmF3WG1sOiBcInc6cFwiLFxuICAgIGJhc2VNb2R1bGVzOiBbbG9vcE1vZHVsZSwgc3BhY2VQcmVzZXJ2ZU1vZHVsZSwgZXhwYW5kUGFpclRyYWl0LCByYXdYbWxNb2R1bGUsIHJlbmRlcl0sXG4gICAgdGFnU2hvdWxkQ29udGFpbjogW3tcbiAgICAgIHRhZzogXCJ3OnNkdENvbnRlbnRcIixcbiAgICAgIHNob3VsZENvbnRhaW46IFtcInc6cFwiLCBcInc6clwiLCBcInc6Y29tbWVudFJhbmdlU3RhcnRcIiwgXCJ3OnNkdFwiXSxcbiAgICAgIHZhbHVlOiBcIjx3OnA+PC93OnA+XCJcbiAgICB9LCB7XG4gICAgICB0YWc6IFwidzp0Y1wiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzpwXCJdLFxuICAgICAgdmFsdWU6IFwiPHc6cD48L3c6cD5cIlxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRyXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJ3OnRjXCJdLFxuICAgICAgZHJvcDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHRhZzogXCJ3OnRibFwiLFxuICAgICAgc2hvdWxkQ29udGFpbjogW1widzp0clwiXSxcbiAgICAgIGRyb3A6IHRydWVcbiAgICB9XVxuICB9O1xufVxuZnVuY3Rpb24gUHB0WEZpbGVUeXBlQ29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdldFRlbXBsYXRlZEZpbGVzOiBmdW5jdGlvbiBnZXRUZW1wbGF0ZWRGaWxlcygpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIHRleHRQYXRoOiBmdW5jdGlvbiB0ZXh0UGF0aChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MudGV4dFRhcmdldDtcbiAgICB9LFxuICAgIHRhZ3NYbWxUZXh0QXJyYXk6IFtcIkNvbXBhbnlcIiwgXCJIeXBlcmxpbmtCYXNlXCIsIFwiTWFuYWdlclwiLCBcImNwOmNhdGVnb3J5XCIsIFwiY3A6a2V5d29yZHNcIiwgXCJkYzpjcmVhdG9yXCIsIFwiZGM6ZGVzY3JpcHRpb25cIiwgXCJkYzpzdWJqZWN0XCIsIFwiZGM6dGl0bGVcIiwgXCJhOnRcIiwgXCJtOnRcIiwgXCJ2dDpscHN0clwiLCBcInZ0Omxwd3N0clwiXSxcbiAgICB0YWdzWG1sTGV4ZWRBcnJheTogW1wicDpzcFwiLCBcImE6dGNcIiwgXCJhOnRyXCIsIFwiYTp0YmxcIiwgXCJhOmdyYXBoaWNEYXRhXCIsIFwiYTpwXCIsIFwiYTpyXCIsIFwiYTpyUHJcIiwgXCJwOnR4Qm9keVwiLCBcImE6dHhCb2R5XCIsIFwiYTpvZmZcIiwgXCJhOmV4dFwiLCBcInA6Z3JhcGhpY0ZyYW1lXCIsIFwicDp4ZnJtXCIsIFwiYTE2OnJvd0lkXCIsIFwiYTplbmRQYXJhUlByXCJdLFxuICAgIGRyb3BwZWRUYWdzSW5zaWRlUGxhY2Vob2xkZXI6IFtcImE6cFwiLCBcImE6ZW5kUGFyYVJQclwiXSxcbiAgICBleHBhbmRUYWdzOiBbe1xuICAgICAgY29udGFpbnM6IFwiYTp0Y1wiLFxuICAgICAgZXhwYW5kOiBcImE6dHJcIlxuICAgIH1dLFxuICAgIG9uUGFyYWdyYXBoTG9vcDogW3tcbiAgICAgIGNvbnRhaW5zOiBcImE6cFwiLFxuICAgICAgZXhwYW5kOiBcImE6cFwiLFxuICAgICAgb25seVRleHRJblRhZzogdHJ1ZVxuICAgIH1dLFxuICAgIHRhZ1Jhd1htbDogXCJwOnNwXCIsXG4gICAgYmFzZU1vZHVsZXM6IFtsb29wTW9kdWxlLCBleHBhbmRQYWlyVHJhaXQsIHJhd1htbE1vZHVsZSwgcmVuZGVyXSxcbiAgICB0YWdTaG91bGRDb250YWluOiBbe1xuICAgICAgdGFnOiBcImE6dGJsXCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnRyXCJdLFxuICAgICAgZHJvcFBhcmVudDogXCJwOmdyYXBoaWNGcmFtZVwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcInA6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfSwge1xuICAgICAgdGFnOiBcImE6dHhCb2R5XCIsXG4gICAgICBzaG91bGRDb250YWluOiBbXCJhOnBcIl0sXG4gICAgICB2YWx1ZTogXCI8YTpwPjwvYTpwPlwiXG4gICAgfV1cbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkb2N4OiBEb2NYRmlsZVR5cGVDb25maWcsXG4gIHBwdHg6IFBwdFhGaWxlVHlwZUNvbmZpZ1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/file-type-config.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/filetypes.js":
/*!********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/filetypes.js ***!
  \********************************************************/
/***/ ((module) => {

eval("\n\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar commentsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar xlsxContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\";\nvar xlsmContentType = \"application/vnd.ms-excel.sheet.macroEnabled.main+xml\";\nvar xlsxWorksheetContentType = \"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\";\n/*\n * This is used for the main part of the document, ie usually that would be the\n * type of word/document.xml\n */\nvar main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];\nvar filetypes = {\n  main: main,\n  docx: [headerContentType].concat(main, [footerContentType, footnotesContentType, commentsContentType]),\n  pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType],\n  xlsx: [xlsxContentType, xlsmContentType, xlsxWorksheetContentType]\n};\nmodule.exports = filetypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZmlsZXR5cGVzLmpzPzQ3NzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkb2N4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50Lm1haW4reG1sXCI7XG52YXIgZG9jeG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9FbmFibGVkLm1haW4reG1sXCI7XG52YXIgZG90eENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC50ZW1wbGF0ZS5tYWluK3htbFwiO1xudmFyIGRvdG1Db250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9FbmFibGVkVGVtcGxhdGUubWFpbit4bWxcIjtcbnZhciBoZWFkZXJDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuaGVhZGVyK3htbFwiO1xudmFyIGZvb3Rub3Rlc0NvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5mb290bm90ZXMreG1sXCI7XG52YXIgY29tbWVudHNDb250ZW50VHlwZSA9IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuY29tbWVudHMreG1sXCI7XG52YXIgZm9vdGVyQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmZvb3Rlcit4bWxcIjtcbnZhciBwcHR4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZSt4bWxcIjtcbnZhciBwcHR4U2xpZGVNYXN0ZXIgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZU1hc3Rlcit4bWxcIjtcbnZhciBwcHR4U2xpZGVMYXlvdXQgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZUxheW91dCt4bWxcIjtcbnZhciBwcHR4UHJlc2VudGF0aW9uQ29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24ubWFpbit4bWxcIjtcbnZhciB4bHN4Q29udGVudFR5cGUgPSBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0Lm1haW4reG1sXCI7XG52YXIgeGxzbUNvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwuc2hlZXQubWFjcm9FbmFibGVkLm1haW4reG1sXCI7XG52YXIgeGxzeFdvcmtzaGVldENvbnRlbnRUeXBlID0gXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC53b3Jrc2hlZXQreG1sXCI7XG4vKlxuICogVGhpcyBpcyB1c2VkIGZvciB0aGUgbWFpbiBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgaWUgdXN1YWxseSB0aGF0IHdvdWxkIGJlIHRoZVxuICogdHlwZSBvZiB3b3JkL2RvY3VtZW50LnhtbFxuICovXG52YXIgbWFpbiA9IFtkb2N4Q29udGVudFR5cGUsIGRvY3htQ29udGVudFR5cGUsIGRvdHhDb250ZW50VHlwZSwgZG90bUNvbnRlbnRUeXBlXTtcbnZhciBmaWxldHlwZXMgPSB7XG4gIG1haW46IG1haW4sXG4gIGRvY3g6IFtoZWFkZXJDb250ZW50VHlwZV0uY29uY2F0KG1haW4sIFtmb290ZXJDb250ZW50VHlwZSwgZm9vdG5vdGVzQ29udGVudFR5cGUsIGNvbW1lbnRzQ29udGVudFR5cGVdKSxcbiAgcHB0eDogW3BwdHhDb250ZW50VHlwZSwgcHB0eFNsaWRlTWFzdGVyLCBwcHR4U2xpZGVMYXlvdXQsIHBwdHhQcmVzZW50YXRpb25Db250ZW50VHlwZV0sXG4gIHhsc3g6IFt4bHN4Q29udGVudFR5cGUsIHhsc21Db250ZW50VHlwZSwgeGxzeFdvcmtzaGVldENvbnRlbnRUeXBlXVxufTtcbm1vZHVsZS5leHBvcnRzID0gZmlsZXR5cGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/filetypes.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/get-content-types.js":
/*!****************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/get-content-types.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  str2xml = _require.str2xml;\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n  for (var _i2 = 0; _i2 < overrides.length; _i2++) {\n    var override = overrides[_i2];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n  var _loop = function _loop() {\n    var def = defaults[_i4];\n    var contentType = def.getAttribute(\"ContentType\");\n    var extension = def.getAttribute(\"Extension\");\n    zip.file(/./).map(function (_ref) {\n      var name = _ref.name;\n      if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n        partNames[name] = contentType;\n      }\n    });\n  };\n  for (var _i4 = 0; _i4 < defaults.length; _i4++) {\n    _loop();\n  }\n  return partNames;\n}\nfunction getContentTypes(zip) {\n  var contentTypes = zip.files[ctXML];\n  var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n  var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n  var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n  return {\n    overrides: overrides,\n    defaults: defaults,\n    contentTypes: contentTypes,\n    contentTypeXml: contentTypeXml\n  };\n}\nmodule.exports = {\n  collectContentTypes: collectContentTypes,\n  getContentTypes: getContentTypes\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LWNvbnRlbnQtdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LWNvbnRlbnQtdHlwZXMuanM/ZjFmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBzdHIyeG1sID0gX3JlcXVpcmUuc3RyMnhtbDtcbnZhciBjdFhNTCA9IFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiO1xuZnVuY3Rpb24gY29sbGVjdENvbnRlbnRUeXBlcyhvdmVycmlkZXMsIGRlZmF1bHRzLCB6aXApIHtcbiAgdmFyIHBhcnROYW1lcyA9IHt9O1xuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvdmVycmlkZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBvdmVycmlkZSA9IG92ZXJyaWRlc1tfaTJdO1xuICAgIHZhciBjb250ZW50VHlwZSA9IG92ZXJyaWRlLmdldEF0dHJpYnV0ZShcIkNvbnRlbnRUeXBlXCIpO1xuICAgIHZhciBwYXJ0TmFtZSA9IG92ZXJyaWRlLmdldEF0dHJpYnV0ZShcIlBhcnROYW1lXCIpLnN1YnN0cigxKTtcbiAgICBwYXJ0TmFtZXNbcGFydE5hbWVdID0gY29udGVudFR5cGU7XG4gIH1cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW19pNF07XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gZGVmLmdldEF0dHJpYnV0ZShcIkNvbnRlbnRUeXBlXCIpO1xuICAgIHZhciBleHRlbnNpb24gPSBkZWYuZ2V0QXR0cmlidXRlKFwiRXh0ZW5zaW9uXCIpO1xuICAgIHppcC5maWxlKC8uLykubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgIGlmIChuYW1lLnNsaWNlKG5hbWUubGVuZ3RoIC0gZXh0ZW5zaW9uLmxlbmd0aCkgPT09IGV4dGVuc2lvbiAmJiAhcGFydE5hbWVzW25hbWVdICYmIG5hbWUgIT09IGN0WE1MKSB7XG4gICAgICAgIHBhcnROYW1lc1tuYW1lXSA9IGNvbnRlbnRUeXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBkZWZhdWx0cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgX2xvb3AoKTtcbiAgfVxuICByZXR1cm4gcGFydE5hbWVzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVzKHppcCkge1xuICB2YXIgY29udGVudFR5cGVzID0gemlwLmZpbGVzW2N0WE1MXTtcbiAgdmFyIGNvbnRlbnRUeXBlWG1sID0gY29udGVudFR5cGVzID8gc3RyMnhtbChjb250ZW50VHlwZXMuYXNUZXh0KCkpIDogbnVsbDtcbiAgdmFyIG92ZXJyaWRlcyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJPdmVycmlkZVwiKSA6IG51bGw7XG4gIHZhciBkZWZhdWx0cyA9IGNvbnRlbnRUeXBlWG1sID8gY29udGVudFR5cGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJEZWZhdWx0XCIpIDogbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBvdmVycmlkZXM6IG92ZXJyaWRlcyxcbiAgICBkZWZhdWx0czogZGVmYXVsdHMsXG4gICAgY29udGVudFR5cGVzOiBjb250ZW50VHlwZXMsXG4gICAgY29udGVudFR5cGVYbWw6IGNvbnRlbnRUeXBlWG1sXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29sbGVjdENvbnRlbnRUeXBlczogY29sbGVjdENvbnRlbnRUeXBlcyxcbiAgZ2V0Q29udGVudFR5cGVzOiBnZXRDb250ZW50VHlwZXNcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/get-content-types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/get-relation-types.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/get-relation-types.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  str2xml = _require.str2xml;\nvar relsFile = \"_rels/.rels\";\nfunction getRelsTypes(zip) {\n  var rootRels = zip.files[relsFile];\n  var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n  var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n  var relsTypes = {};\n  for (var _i2 = 0; _i2 < rootRelationships.length; _i2++) {\n    var relation = rootRelationships[_i2];\n    relsTypes[relation.getAttribute(\"Target\")] = relation.getAttribute(\"Type\");\n  }\n  return relsTypes;\n}\nmodule.exports = {\n  getRelsTypes: getRelsTypes\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlbGF0aW9uLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyw4RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2dldC1yZWxhdGlvbi10eXBlcy5qcz81OWMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHN0cjJ4bWwgPSBfcmVxdWlyZS5zdHIyeG1sO1xudmFyIHJlbHNGaWxlID0gXCJfcmVscy8ucmVsc1wiO1xuZnVuY3Rpb24gZ2V0UmVsc1R5cGVzKHppcCkge1xuICB2YXIgcm9vdFJlbHMgPSB6aXAuZmlsZXNbcmVsc0ZpbGVdO1xuICB2YXIgcm9vdFJlbHNYbWwgPSByb290UmVscyA/IHN0cjJ4bWwocm9vdFJlbHMuYXNUZXh0KCkpIDogbnVsbDtcbiAgdmFyIHJvb3RSZWxhdGlvbnNoaXBzID0gcm9vdFJlbHNYbWwgPyByb290UmVsc1htbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIlJlbGF0aW9uc2hpcFwiKSA6IFtdO1xuICB2YXIgcmVsc1R5cGVzID0ge307XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHJvb3RSZWxhdGlvbnNoaXBzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgcmVsYXRpb24gPSByb290UmVsYXRpb25zaGlwc1tfaTJdO1xuICAgIHJlbHNUeXBlc1tyZWxhdGlvbi5nZXRBdHRyaWJ1dGUoXCJUYXJnZXRcIildID0gcmVsYXRpb24uZ2V0QXR0cmlidXRlKFwiVHlwZVwiKTtcbiAgfVxuICByZXR1cm4gcmVsc1R5cGVzO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldFJlbHNUeXBlczogZ2V0UmVsc1R5cGVzXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/get-relation-types.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/get-resolved-id.js":
/*!**************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/get-resolved-id.js ***!
  \**************************************************************/
/***/ ((module) => {

eval("\n\nfunction getResolvedId(part, options) {\n  if (part.lIndex == null) {\n    return null;\n  }\n  var path = options.scopeManager.scopePathItem;\n  if (part.parentPart) {\n    path = path.slice(0, path.length - 1);\n  }\n  var res = options.filePath + \"@\" + part.lIndex.toString() + \"-\" + path.join(\"-\");\n  return res;\n}\nmodule.exports = getResolvedId;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlc29sdmVkLWlkLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXJlc29sdmVkLWlkLmpzP2JjYzgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucykge1xuICBpZiAocGFydC5sSW5kZXggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwYXRoID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuc2NvcGVQYXRoSXRlbTtcbiAgaWYgKHBhcnQucGFyZW50UGFydCkge1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHBhdGgubGVuZ3RoIC0gMSk7XG4gIH1cbiAgdmFyIHJlcyA9IG9wdGlvbnMuZmlsZVBhdGggKyBcIkBcIiArIHBhcnQubEluZGV4LnRvU3RyaW5nKCkgKyBcIi1cIiArIHBhdGguam9pbihcIi1cIik7XG4gIHJldHVybiByZXM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGdldFJlc29sdmVkSWQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/get-resolved-id.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/get-tags.js":
/*!*******************************************************!*\
  !*** ../../node_modules/docxtemplater/js/get-tags.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("\n\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction isPlaceholder(part) {\n  return part.type === \"placeholder\";\n}\n\n/* eslint-disable-next-line complexity */\nfunction getTags(postParsed) {\n  var tags = {};\n  var stack = [{\n    items: postParsed.filter(isPlaceholder),\n    parents: [],\n    path: []\n  }];\n  function processFiltered(part, current, filtered) {\n    if (filtered.length) {\n      stack.push({\n        items: filtered,\n        parents: [].concat(_toConsumableArray(current.parents), [part]),\n        path: part.dataBound !== false && !part.attrParsed && part.value && !part.attrParsed ? [].concat(_toConsumableArray(current.path), [part.value]) : _toConsumableArray(current.path)\n      });\n    }\n  }\n  function getLocalTags(tags, path) {\n    var sizeScope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.length;\n    var localTags = tags;\n    for (var i = 0; i < sizeScope; i++) {\n      localTags = localTags[path[i]];\n    }\n    return localTags;\n  }\n  function getScopeSize(part, parents) {\n    var size = parents.length;\n    for (var _i2 = 0; _i2 < parents.length; _i2++) {\n      var parent = parents[_i2];\n      var lIndexLoop = typeof parent.lIndex === \"number\" ? parent.lIndex : parseInt(parent.lIndex.split(\"-\")[0], 10);\n      if (lIndexLoop > part.lIndex) {\n        size--;\n      }\n    }\n    return size;\n  }\n  while (stack.length > 0) {\n    var current = stack.pop();\n    var localTags = getLocalTags(tags, current.path);\n    for (var _i4 = 0, _current$items2 = current.items; _i4 < _current$items2.length; _i4++) {\n      var _localTags4, _part$value2;\n      var part = _current$items2[_i4];\n      if (part.attrParsed) {\n        for (var key in part.attrParsed) {\n          processFiltered(part, current, part.attrParsed[key].filter(isPlaceholder));\n        }\n        continue;\n      }\n      if (part.subparsed) {\n        if (part.dataBound !== false) {\n          var _localTags, _part$value;\n          (_localTags = localTags)[_part$value = part.value] || (_localTags[_part$value] = {});\n        }\n        processFiltered(part, current, part.subparsed.filter(isPlaceholder));\n        continue;\n      }\n      if (part.cellParsed) {\n        for (var _i6 = 0, _part$cellPostParsed2 = part.cellPostParsed; _i6 < _part$cellPostParsed2.length; _i6++) {\n          var cp = _part$cellPostParsed2[_i6];\n          if (cp.type === \"placeholder\") {\n            if (cp.module === \"pro-xml-templating/xls-module-loop\") {\n              continue;\n            } else if (cp.subparsed) {\n              var _localTags2, _cp$value;\n              (_localTags2 = localTags)[_cp$value = cp.value] || (_localTags2[_cp$value] = {});\n              processFiltered(cp, current, cp.subparsed.filter(isPlaceholder));\n            } else {\n              var _localTags3, _cp$value2;\n              var sizeScope = getScopeSize(part, current.parents);\n              localTags = getLocalTags(tags, current.path, sizeScope);\n              (_localTags3 = localTags)[_cp$value2 = cp.value] || (_localTags3[_cp$value2] = {});\n            }\n          }\n        }\n        continue;\n      }\n      if (part.dataBound === false) {\n        continue;\n      }\n      (_localTags4 = localTags)[_part$value2 = part.value] || (_localTags4[_part$value2] = {});\n    }\n  }\n  return tags;\n}\nmodule.exports = {\n  getTags: getTags,\n  isPlaceholder: isPlaceholder\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXRhZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUNBQWlDO0FBQ2pDLGdDQUFnQztBQUNoQyw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxvQ0FBb0M7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvZ2V0LXRhZ3MuanM/NmFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIGlzUGxhY2Vob2xkZXIocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCI7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5ICovXG5mdW5jdGlvbiBnZXRUYWdzKHBvc3RQYXJzZWQpIHtcbiAgdmFyIHRhZ3MgPSB7fTtcbiAgdmFyIHN0YWNrID0gW3tcbiAgICBpdGVtczogcG9zdFBhcnNlZC5maWx0ZXIoaXNQbGFjZWhvbGRlciksXG4gICAgcGFyZW50czogW10sXG4gICAgcGF0aDogW11cbiAgfV07XG4gIGZ1bmN0aW9uIHByb2Nlc3NGaWx0ZXJlZChwYXJ0LCBjdXJyZW50LCBmaWx0ZXJlZCkge1xuICAgIGlmIChmaWx0ZXJlZC5sZW5ndGgpIHtcbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBpdGVtczogZmlsdGVyZWQsXG4gICAgICAgIHBhcmVudHM6IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoY3VycmVudC5wYXJlbnRzKSwgW3BhcnRdKSxcbiAgICAgICAgcGF0aDogcGFydC5kYXRhQm91bmQgIT09IGZhbHNlICYmICFwYXJ0LmF0dHJQYXJzZWQgJiYgcGFydC52YWx1ZSAmJiAhcGFydC5hdHRyUGFyc2VkID8gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjdXJyZW50LnBhdGgpLCBbcGFydC52YWx1ZV0pIDogX3RvQ29uc3VtYWJsZUFycmF5KGN1cnJlbnQucGF0aClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRMb2NhbFRhZ3ModGFncywgcGF0aCkge1xuICAgIHZhciBzaXplU2NvcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHBhdGgubGVuZ3RoO1xuICAgIHZhciBsb2NhbFRhZ3MgPSB0YWdzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVNjb3BlOyBpKyspIHtcbiAgICAgIGxvY2FsVGFncyA9IGxvY2FsVGFnc1twYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsVGFncztcbiAgfVxuICBmdW5jdGlvbiBnZXRTY29wZVNpemUocGFydCwgcGFyZW50cykge1xuICAgIHZhciBzaXplID0gcGFyZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFyZW50cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tfaTJdO1xuICAgICAgdmFyIGxJbmRleExvb3AgPSB0eXBlb2YgcGFyZW50LmxJbmRleCA9PT0gXCJudW1iZXJcIiA/IHBhcmVudC5sSW5kZXggOiBwYXJzZUludChwYXJlbnQubEluZGV4LnNwbGl0KFwiLVwiKVswXSwgMTApO1xuICAgICAgaWYgKGxJbmRleExvb3AgPiBwYXJ0LmxJbmRleCkge1xuICAgICAgICBzaXplLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9XG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbG9jYWxUYWdzID0gZ2V0TG9jYWxUYWdzKHRhZ3MsIGN1cnJlbnQucGF0aCk7XG4gICAgZm9yICh2YXIgX2k0ID0gMCwgX2N1cnJlbnQkaXRlbXMyID0gY3VycmVudC5pdGVtczsgX2k0IDwgX2N1cnJlbnQkaXRlbXMyLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgIHZhciBfbG9jYWxUYWdzNCwgX3BhcnQkdmFsdWUyO1xuICAgICAgdmFyIHBhcnQgPSBfY3VycmVudCRpdGVtczJbX2k0XTtcbiAgICAgIGlmIChwYXJ0LmF0dHJQYXJzZWQpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcnQuYXR0clBhcnNlZCkge1xuICAgICAgICAgIHByb2Nlc3NGaWx0ZXJlZChwYXJ0LCBjdXJyZW50LCBwYXJ0LmF0dHJQYXJzZWRba2V5XS5maWx0ZXIoaXNQbGFjZWhvbGRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQuc3VicGFyc2VkKSB7XG4gICAgICAgIGlmIChwYXJ0LmRhdGFCb3VuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgX2xvY2FsVGFncywgX3BhcnQkdmFsdWU7XG4gICAgICAgICAgKF9sb2NhbFRhZ3MgPSBsb2NhbFRhZ3MpW19wYXJ0JHZhbHVlID0gcGFydC52YWx1ZV0gfHwgKF9sb2NhbFRhZ3NbX3BhcnQkdmFsdWVdID0ge30pO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NGaWx0ZXJlZChwYXJ0LCBjdXJyZW50LCBwYXJ0LnN1YnBhcnNlZC5maWx0ZXIoaXNQbGFjZWhvbGRlcikpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmNlbGxQYXJzZWQpIHtcbiAgICAgICAgZm9yICh2YXIgX2k2ID0gMCwgX3BhcnQkY2VsbFBvc3RQYXJzZWQyID0gcGFydC5jZWxsUG9zdFBhcnNlZDsgX2k2IDwgX3BhcnQkY2VsbFBvc3RQYXJzZWQyLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICB2YXIgY3AgPSBfcGFydCRjZWxsUG9zdFBhcnNlZDJbX2k2XTtcbiAgICAgICAgICBpZiAoY3AudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICAgICAgICBpZiAoY3AubW9kdWxlID09PSBcInByby14bWwtdGVtcGxhdGluZy94bHMtbW9kdWxlLWxvb3BcIikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Auc3VicGFyc2VkKSB7XG4gICAgICAgICAgICAgIHZhciBfbG9jYWxUYWdzMiwgX2NwJHZhbHVlO1xuICAgICAgICAgICAgICAoX2xvY2FsVGFnczIgPSBsb2NhbFRhZ3MpW19jcCR2YWx1ZSA9IGNwLnZhbHVlXSB8fCAoX2xvY2FsVGFnczJbX2NwJHZhbHVlXSA9IHt9KTtcbiAgICAgICAgICAgICAgcHJvY2Vzc0ZpbHRlcmVkKGNwLCBjdXJyZW50LCBjcC5zdWJwYXJzZWQuZmlsdGVyKGlzUGxhY2Vob2xkZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfbG9jYWxUYWdzMywgX2NwJHZhbHVlMjtcbiAgICAgICAgICAgICAgdmFyIHNpemVTY29wZSA9IGdldFNjb3BlU2l6ZShwYXJ0LCBjdXJyZW50LnBhcmVudHMpO1xuICAgICAgICAgICAgICBsb2NhbFRhZ3MgPSBnZXRMb2NhbFRhZ3ModGFncywgY3VycmVudC5wYXRoLCBzaXplU2NvcGUpO1xuICAgICAgICAgICAgICAoX2xvY2FsVGFnczMgPSBsb2NhbFRhZ3MpW19jcCR2YWx1ZTIgPSBjcC52YWx1ZV0gfHwgKF9sb2NhbFRhZ3MzW19jcCR2YWx1ZTJdID0ge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LmRhdGFCb3VuZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAoX2xvY2FsVGFnczQgPSBsb2NhbFRhZ3MpW19wYXJ0JHZhbHVlMiA9IHBhcnQudmFsdWVdIHx8IChfbG9jYWxUYWdzNFtfcGFydCR2YWx1ZTJdID0ge30pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFncztcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRUYWdzOiBnZXRUYWdzLFxuICBpc1BsYWNlaG9sZGVyOiBpc1BsYWNlaG9sZGVyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/get-tags.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/join-uncorrupt.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/join-uncorrupt.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = __webpack_require__(/*! ./filetypes.js */ \"(rsc)/../../node_modules/docxtemplater/js/filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p) || startsWith(p, \"<w:bookmarkEnd\")) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\") &&\n      // Tested by #regression-paragraph-after-table-header-footer\n      !startsWith(p, \"</w:ftr>\") && !startsWith(p, \"</w:hdr>\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /*\n   * Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * ------------------------------------------------\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var j = 0, len2 = contains.length; j < len2; j++) {\n    var _contains$j = contains[j],\n      tag = _contains$j.tag,\n      shouldContain = _contains$j.shouldContain,\n      value = _contains$j.value,\n      drop = _contains$j.drop,\n      dropParent = _contains$j.dropParent;\n    for (var i = 0, len = parts.length; i < len; i++) {\n      var part = parts[i];\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (dropParent) {\n            var start = -1;\n            for (var k = startIndex; k > 0; k--) {\n              if (isStarting(parts[k], dropParent)) {\n                start = k;\n                break;\n              }\n            }\n            for (var _k = start; _k <= parts.length; _k++) {\n              if (isEnding(parts[_k], dropParent)) {\n                parts[_k] = \"\";\n                break;\n              }\n              parts[_k] = \"\";\n            }\n          } else {\n            for (var _k2 = startIndex; _k2 <= i; _k2++) {\n              parts[_k2] = \"\";\n            }\n            if (!drop) {\n              parts[i] = collecting + value + part;\n            }\n          }\n        }\n        collecting += part;\n        for (var _k3 = 0, len3 = shouldContain.length; _k3 < len3; _k3++) {\n          var sc = shouldContain[_k3];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            break;\n          }\n        }\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      /*\n       * To verify that the part doesn't have multiple tags,\n       * such as <w:tc><w:p>\n       */\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvam9pbi11bmNvcnJ1cHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWdCO0FBQ3hDO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVcsUUFBUSxVQUFVO0FBQ3JDLFFBQVEsV0FBVyxRQUFRLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL2pvaW4tdW5jb3JydXB0LmpzP2UxNmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGgsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIGlzU3RhcnRpbmcgPSBfcmVxdWlyZS5pc1N0YXJ0aW5nLFxuICBpc0VuZGluZyA9IF9yZXF1aXJlLmlzRW5kaW5nLFxuICBpc1doaXRlU3BhY2UgPSBfcmVxdWlyZS5pc1doaXRlU3BhY2U7XG52YXIgZmlsZXR5cGVzID0gcmVxdWlyZShcIi4vZmlsZXR5cGVzLmpzXCIpO1xuZnVuY3Rpb24gYWRkRW1wdHlQYXJhZ3JhcGhBZnRlclRhYmxlKHBhcnRzKSB7XG4gIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgIGlmIChpc1doaXRlU3BhY2UocCkgfHwgc3RhcnRzV2l0aChwLCBcIjx3OmJvb2ttYXJrRW5kXCIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGVuZHNXaXRoKGxhc3ROb25FbXB0eSwgXCI8L3c6dGJsPlwiKSkge1xuICAgICAgaWYgKCFzdGFydHNXaXRoKHAsIFwiPHc6cFwiKSAmJiAhc3RhcnRzV2l0aChwLCBcIjx3OnRibFwiKSAmJiAhc3RhcnRzV2l0aChwLCBcIjx3OnNlY3RQclwiKSAmJlxuICAgICAgLy8gVGVzdGVkIGJ5ICNyZWdyZXNzaW9uLXBhcmFncmFwaC1hZnRlci10YWJsZS1oZWFkZXItZm9vdGVyXG4gICAgICAhc3RhcnRzV2l0aChwLCBcIjwvdzpmdHI+XCIpICYmICFzdGFydHNXaXRoKHAsIFwiPC93Omhkcj5cIikpIHtcbiAgICAgICAgcCA9IFwiPHc6cC8+XCIuY29uY2F0KHApO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0Tm9uRW1wdHkgPSBwO1xuICAgIHBhcnRzW2ldID0gcDtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBqb2luVW5jb3JydXB0KHBhcnRzLCBvcHRpb25zKSB7XG4gIHZhciBjb250YWlucyA9IG9wdGlvbnMuZmlsZVR5cGVDb25maWcudGFnU2hvdWxkQ29udGFpbiB8fCBbXTtcbiAgLypcbiAgICogQmVmb3JlIGRvaW5nIHRoaXMgXCJ1bmNvcnJ1cHRpb25cIiBtZXRob2QgaGVyZSwgdGhpcyB3YXMgZG9uZSB3aXRoIHRoZVxuICAgKiBgcGFydC5lbXB0eVZhbHVlYCB0cmljaywgaG93ZXZlciwgdGhlcmUgd2VyZSBzb21lIGNvcnJ1cHRpb25zIHRoYXQgd2VyZVxuICAgKiBub3QgaGFuZGxlZCwgZm9yIGV4YW1wbGUgd2l0aCBhIHRlbXBsYXRlIGxpa2UgdGhpcyA6XG4gICAqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiB8IHstdzpwIGZhbHN5fU15IHBhcmF7L2ZhbHN5fSAgIHwgICAgICAgICAgICAgIHxcbiAgICogfCB7LXc6cCBmYWxzeX1NeSBwYXJhey9mYWxzeX0gICB8ICAgICAgICAgICAgICB8XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cbiAgdmFyIGNvbGxlY3RpbmcgPSBcIlwiO1xuICB2YXIgY3VycmVudGx5Q29sbGVjdGluZyA9IC0xO1xuICBpZiAoZmlsZXR5cGVzLmRvY3guaW5kZXhPZihvcHRpb25zLmNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICBwYXJ0cyA9IGFkZEVtcHR5UGFyYWdyYXBoQWZ0ZXJUYWJsZShwYXJ0cyk7XG4gIH1cbiAgdmFyIHN0YXJ0SW5kZXggPSAtMTtcbiAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBjb250YWlucy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcbiAgICB2YXIgX2NvbnRhaW5zJGogPSBjb250YWluc1tqXSxcbiAgICAgIHRhZyA9IF9jb250YWlucyRqLnRhZyxcbiAgICAgIHNob3VsZENvbnRhaW4gPSBfY29udGFpbnMkai5zaG91bGRDb250YWluLFxuICAgICAgdmFsdWUgPSBfY29udGFpbnMkai52YWx1ZSxcbiAgICAgIGRyb3AgPSBfY29udGFpbnMkai5kcm9wLFxuICAgICAgZHJvcFBhcmVudCA9IF9jb250YWlucyRqLmRyb3BQYXJlbnQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKGN1cnJlbnRseUNvbGxlY3RpbmcgPT09IGopIHtcbiAgICAgICAgaWYgKGlzRW5kaW5nKHBhcnQsIHRhZykpIHtcbiAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gLTE7XG4gICAgICAgICAgaWYgKGRyb3BQYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IHN0YXJ0SW5kZXg7IGsgPiAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgaWYgKGlzU3RhcnRpbmcocGFydHNba10sIGRyb3BQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBfayA9IHN0YXJ0OyBfayA8PSBwYXJ0cy5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgICAgaWYgKGlzRW5kaW5nKHBhcnRzW19rXSwgZHJvcFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tfa10gPSBcIlwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBhcnRzW19rXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9rMiA9IHN0YXJ0SW5kZXg7IF9rMiA8PSBpOyBfazIrKykge1xuICAgICAgICAgICAgICBwYXJ0c1tfazJdID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHJvcCkge1xuICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGNvbGxlY3RpbmcgKyB2YWx1ZSArIHBhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3RpbmcgKz0gcGFydDtcbiAgICAgICAgZm9yICh2YXIgX2szID0gMCwgbGVuMyA9IHNob3VsZENvbnRhaW4ubGVuZ3RoOyBfazMgPCBsZW4zOyBfazMrKykge1xuICAgICAgICAgIHZhciBzYyA9IHNob3VsZENvbnRhaW5bX2szXTtcbiAgICAgICAgICBpZiAoaXNTdGFydGluZyhwYXJ0LCBzYykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRseUNvbGxlY3RpbmcgPSAtMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRseUNvbGxlY3RpbmcgPT09IC0xICYmIGlzU3RhcnRpbmcocGFydCwgdGFnKSAmJlxuICAgICAgLypcbiAgICAgICAqIFRvIHZlcmlmeSB0aGF0IHRoZSBwYXJ0IGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSB0YWdzLFxuICAgICAgICogc3VjaCBhcyA8dzp0Yz48dzpwPlxuICAgICAgICovXG4gICAgICBwYXJ0LnN1YnN0cigxKS5pbmRleE9mKFwiPFwiKSA9PT0gLTEpIHtcbiAgICAgICAgLy8gc2VsZi1jbG9zaW5nIHRhZyBzdWNoIGFzIDx3OnQvPlxuICAgICAgICBpZiAocGFydFtwYXJ0Lmxlbmd0aCAtIDJdID09PSBcIi9cIikge1xuICAgICAgICAgIHBhcnRzW2ldID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICBjdXJyZW50bHlDb2xsZWN0aW5nID0gajtcbiAgICAgICAgICBjb2xsZWN0aW5nID0gcGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGpvaW5VbmNvcnJ1cHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/join-uncorrupt.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/lexer.js":
/*!****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/lexer.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8,\n  pushArray = _require2.pushArray;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var _i2 = 0; _i2 < textMatchArray.length; _i2++) {\n    var m = textMatchArray[_i2];\n    allMatches[m] = true;\n  }\n  for (var _i4 = 0; _i4 < othersMatchArray.length; _i4++) {\n    var _m = othersMatchArray[_i4];\n    allMatches[_m] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText, syntaxOptions) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  var delimiterWithErrors = delimiterMatches.reduce(function (delimiterAcc, currDelimiterMatch) {\n    var position = currDelimiterMatch.position;\n    var delimiterOffset = currDelimiterMatch.offset;\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    var lastDelimiterLength = lastDelimiterMatch.length;\n    xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset);\n    if (inDelimiter && position === \"start\") {\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        if (!syntaxOptions.allowUnclosedTag) {\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterOffset\n          }));\n          lastDelimiterMatch = currDelimiterMatch;\n          delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n            error: true\n          }));\n          return delimiterAcc;\n        }\n      }\n      if (!syntaxOptions.allowUnclosedTag) {\n        errors.push(getUnclosedTagException({\n          xtag: wordToUtf8(xtag),\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      delimiterAcc.pop();\n    }\n    if (!inDelimiter && position === \"end\") {\n      if (syntaxOptions.allowUnopenedTag) {\n        return delimiterAcc;\n      }\n      if (lastDelimiterOffset + lastDelimiterLength === delimiterOffset) {\n        xtag = fullText.substr(lastDelimiterOffset - 4, delimiterOffset - lastDelimiterOffset + lastDelimiterLength + 4);\n        errors.push(getDuplicateCloseTagException({\n          xtag: xtag,\n          offset: lastDelimiterOffset\n        }));\n        lastDelimiterMatch = currDelimiterMatch;\n        delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n          error: true\n        }));\n        return delimiterAcc;\n      }\n      errors.push(getUnopenedTagException({\n        xtag: xtag,\n        offset: delimiterOffset\n      }));\n      lastDelimiterMatch = currDelimiterMatch;\n      delimiterAcc.push(_objectSpread(_objectSpread({}, currDelimiterMatch), {}, {\n        error: true\n      }));\n      return delimiterAcc;\n    }\n    inDelimiter = position === \"start\";\n    lastDelimiterMatch = currDelimiterMatch;\n    delimiterAcc.push(currDelimiterMatch);\n    return delimiterAcc;\n  }, []);\n  if (inDelimiter) {\n    var lastDelimiterOffset = lastDelimiterMatch.offset;\n    xtag = fullText.substr(lastDelimiterOffset, fullText.length - lastDelimiterOffset);\n    if (!syntaxOptions.allowUnclosedTag) {\n      errors.push(getUnclosedTagException({\n        xtag: wordToUtf8(xtag),\n        offset: lastDelimiterOffset\n      }));\n    } else {\n      delimiterWithErrors.pop();\n    }\n  }\n  return {\n    delimiterWithErrors: delimiterWithErrors,\n    errors: errors\n  };\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters, syntaxOptions) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  if (start == null && end == null) {\n    // Special case of delimiter set to null/null, no templating is done\n    return [];\n  }\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    /*\n     * If tag starts with =, such as {=[ ]=}\n     * then the delimiters will change right after that tag.\n     *\n     * For example, with the following template :\n     *\n     * Hello {foo}, {=[ ]=}what's up with [name] ?\n     *\n     * The \"foo\" tag is a normal tag, the \"=[ ]=\" is a tag to change the\n     * delimiters to \"[\" and \"]\", and the last \"name\" is a tag with the new\n     * delimiters\n     */\n    if (syntaxOptions.changeDelimiterPrefix && compareResult === DELIMITER_START && fullText[offset + start.length] === syntaxOptions.changeDelimiterPrefix) {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(syntaxOptions.changeDelimiterPrefix, offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters, syntaxOptions) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters, syntaxOptions);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var _getDelimiterErrors = getDelimiterErrors(delimiterMatches, full, syntaxOptions),\n    delimiterWithErrors = _getDelimiterErrors.delimiterWithErrors,\n    errors = _getDelimiterErrors.errors;\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterWithErrors.length && inRange(range, delimiterWithErrors[delimiterIndex])) {\n      delimitersInOffset.push(delimiterWithErrors[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    for (var _i6 = 0; _i6 < delimitersInOffset.length; _i6++) {\n      var delimiterInOffset = delimitersInOffset[_i6];\n      var _value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (_value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: _value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        continue;\n      }\n      if (_value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: _value\n        });\n        cursor += _value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    }\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed, fileType) {\n  var inTextTag = false;\n  for (var _i8 = 0; _i8 < xmlparsed.length; _i8++) {\n    var part = xmlparsed[_i8];\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (fileType !== \"text\" && isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  }\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmllexed, delimiters, syntax, fileType) {\n    decodeContentParts(xmllexed, fileType);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmllexed), delimiters, syntax),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    for (var _i0 = 0; _i0 < xmllexed.length; _i0++) {\n      var part = xmllexed[_i0];\n      if (isInsideContent(part)) {\n        for (var _i10 = 0, _delimiterParsed$inde2 = delimiterParsed[index]; _i10 < _delimiterParsed$inde2.length; _i10++) {\n          var p = _delimiterParsed$inde2[_i10];\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n        }\n        pushArray(lexed, delimiterParsed[index]);\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    }\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = [];\n    for (var _i12 = 0; _i12 < matches.length; _i12++) {\n      var match = matches[_i12];\n      if (content.length > cursor && match.offset - cursor > 0) {\n        parsed.push({\n          type: \"content\",\n          value: content.substr(cursor, match.offset - cursor)\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n    }\n    if (content.length > cursor) {\n      parsed.push({\n        type: \"content\",\n        value: content.substr(cursor)\n      });\n    }\n    return parsed;\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbGV4ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsZ0NBQWdDO0FBQ2hDLDhCQUE4QjtBQUM5Qiw2Q0FBNkMsU0FBUywwREFBMEQsVUFBVSxnQ0FBZ0M7QUFDMUosbUNBQW1DLCtDQUErQyw4QkFBOEIsT0FBTyxrQkFBa0I7QUFDekksdUNBQXVDLGtHQUFrRyxpQkFBaUIsd0NBQXdDLE1BQU0seUNBQXlDLDZCQUE2QixVQUFVLFlBQVksa0VBQWtFLFdBQVcsWUFBWSxpQkFBaUIsVUFBVSxNQUFNLGlGQUFpRixVQUFVLG9CQUFvQjtBQUM3Z0IsOEJBQThCO0FBQzlCLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxlQUFlLG1CQUFPLENBQUMsd0VBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSwwREFBMEQseUJBQXlCO0FBQ25GO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdEQUF3RCx5QkFBeUI7QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNEQUFzRCx5QkFBeUI7QUFDL0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSSxHQUFHLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0EsNEVBQTRFLHNDQUFzQztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9sZXhlci5qcz9lYTQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7IHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHsgdmFsdWU6IHQsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSkgOiBlW3JdID0gdCwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgZ2V0VW5jbG9zZWRUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRVbmNsb3NlZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24gPSBfcmVxdWlyZS5nZXRVbm9wZW5lZFRhZ0V4Y2VwdGlvbixcbiAgZ2V0RHVwbGljYXRlT3BlblRhZ0V4Y2VwdGlvbiA9IF9yZXF1aXJlLmdldER1cGxpY2F0ZU9wZW5UYWdFeGNlcHRpb24sXG4gIGdldER1cGxpY2F0ZUNsb3NlVGFnRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24sXG4gIHRocm93TWFsZm9ybWVkWG1sID0gX3JlcXVpcmUudGhyb3dNYWxmb3JtZWRYbWwsXG4gIHRocm93WG1sSW52YWxpZCA9IF9yZXF1aXJlLnRocm93WG1sSW52YWxpZCxcbiAgWFRUZW1wbGF0ZUVycm9yID0gX3JlcXVpcmUuWFRUZW1wbGF0ZUVycm9yO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgaXNUZXh0U3RhcnQgPSBfcmVxdWlyZTIuaXNUZXh0U3RhcnQsXG4gIGlzVGV4dEVuZCA9IF9yZXF1aXJlMi5pc1RleHRFbmQsXG4gIHdvcmRUb1V0ZjggPSBfcmVxdWlyZTIud29yZFRvVXRmOCxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUyLnB1c2hBcnJheTtcbnZhciBERUxJTUlURVJfTk9ORSA9IDAsXG4gIERFTElNSVRFUl9FUVVBTCA9IDEsXG4gIERFTElNSVRFUl9TVEFSVCA9IDIsXG4gIERFTElNSVRFUl9FTkQgPSAzO1xuZnVuY3Rpb24gaW5SYW5nZShyYW5nZSwgbWF0Y2gpIHtcbiAgcmV0dXJuIHJhbmdlWzBdIDw9IG1hdGNoLm9mZnNldCAmJiBtYXRjaC5vZmZzZXQgPCByYW5nZVsxXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluVGV4dFRhZyhwYXJ0LCBpblRleHRUYWcpIHtcbiAgaWYgKGlzVGV4dFN0YXJ0KHBhcnQpKSB7XG4gICAgaWYgKGluVGV4dFRhZykge1xuICAgICAgdGhyb3dNYWxmb3JtZWRYbWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzVGV4dEVuZChwYXJ0KSkge1xuICAgIGlmICghaW5UZXh0VGFnKSB7XG4gICAgICB0aHJvd01hbGZvcm1lZFhtbCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGluVGV4dFRhZztcbn1cbmZ1bmN0aW9uIGdldFRhZyh0YWcpIHtcbiAgdmFyIHBvc2l0aW9uID0gXCJcIjtcbiAgdmFyIHN0YXJ0ID0gMTtcbiAgdmFyIGVuZCA9IHRhZy5pbmRleE9mKFwiIFwiKTtcbiAgaWYgKHRhZ1t0YWcubGVuZ3RoIC0gMl0gPT09IFwiL1wiKSB7XG4gICAgcG9zaXRpb24gPSBcInNlbGZjbG9zaW5nXCI7XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIGVuZCA9IHRhZy5sZW5ndGggLSAyO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWdbMV0gPT09IFwiL1wiKSB7XG4gICAgc3RhcnQgPSAyO1xuICAgIHBvc2l0aW9uID0gXCJlbmRcIjtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgZW5kID0gdGFnLmxlbmd0aCAtIDE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBvc2l0aW9uID0gXCJzdGFydFwiO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICBlbmQgPSB0YWcubGVuZ3RoIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0YWc6IHRhZy5zbGljZShzdGFydCwgZW5kKSxcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfTtcbn1cbmZ1bmN0aW9uIHRhZ01hdGNoZXIoY29udGVudCwgdGV4dE1hdGNoQXJyYXksIG90aGVyc01hdGNoQXJyYXkpIHtcbiAgdmFyIGN1cnNvciA9IDA7XG4gIHZhciBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHZhciBhbGxNYXRjaGVzID0ge307XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRleHRNYXRjaEFycmF5Lmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgbSA9IHRleHRNYXRjaEFycmF5W19pMl07XG4gICAgYWxsTWF0Y2hlc1ttXSA9IHRydWU7XG4gIH1cbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgb3RoZXJzTWF0Y2hBcnJheS5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIF9tID0gb3RoZXJzTWF0Y2hBcnJheVtfaTRdO1xuICAgIGFsbE1hdGNoZXNbX21dID0gZmFsc2U7XG4gIH1cbiAgdmFyIHRvdGFsTWF0Y2hlcyA9IFtdO1xuICB3aGlsZSAoY3Vyc29yIDwgY29udGVudExlbmd0aCkge1xuICAgIGN1cnNvciA9IGNvbnRlbnQuaW5kZXhPZihcIjxcIiwgY3Vyc29yKTtcbiAgICBpZiAoY3Vyc29yID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBvZmZzZXQgPSBjdXJzb3I7XG4gICAgdmFyIG5leHRPcGVuaW5nID0gY29udGVudC5pbmRleE9mKFwiPFwiLCBjdXJzb3IgKyAxKTtcbiAgICBjdXJzb3IgPSBjb250ZW50LmluZGV4T2YoXCI+XCIsIGN1cnNvcik7XG4gICAgaWYgKGN1cnNvciA9PT0gLTEgfHwgbmV4dE9wZW5pbmcgIT09IC0xICYmIGN1cnNvciA+IG5leHRPcGVuaW5nKSB7XG4gICAgICB0aHJvd1htbEludmFsaWQoY29udGVudCwgb2Zmc2V0KTtcbiAgICB9XG4gICAgdmFyIHRhZ1RleHQgPSBjb250ZW50LnNsaWNlKG9mZnNldCwgY3Vyc29yICsgMSk7XG4gICAgdmFyIF9nZXRUYWcgPSBnZXRUYWcodGFnVGV4dCksXG4gICAgICB0YWcgPSBfZ2V0VGFnLnRhZyxcbiAgICAgIHBvc2l0aW9uID0gX2dldFRhZy5wb3NpdGlvbjtcbiAgICB2YXIgdGV4dCA9IGFsbE1hdGNoZXNbdGFnXTtcbiAgICBpZiAodGV4dCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdG90YWxNYXRjaGVzLnB1c2goe1xuICAgICAgdHlwZTogXCJ0YWdcIixcbiAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgIHZhbHVlOiB0YWdUZXh0LFxuICAgICAgdGFnOiB0YWdcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdG90YWxNYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGVsaW1pdGVyRXJyb3JzKGRlbGltaXRlck1hdGNoZXMsIGZ1bGxUZXh0LCBzeW50YXhPcHRpb25zKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIGluRGVsaW1pdGVyID0gZmFsc2U7XG4gIHZhciBsYXN0RGVsaW1pdGVyTWF0Y2ggPSB7XG4gICAgb2Zmc2V0OiAwXG4gIH07XG4gIHZhciB4dGFnO1xuICB2YXIgZGVsaW1pdGVyV2l0aEVycm9ycyA9IGRlbGltaXRlck1hdGNoZXMucmVkdWNlKGZ1bmN0aW9uIChkZWxpbWl0ZXJBY2MsIGN1cnJEZWxpbWl0ZXJNYXRjaCkge1xuICAgIHZhciBwb3NpdGlvbiA9IGN1cnJEZWxpbWl0ZXJNYXRjaC5wb3NpdGlvbjtcbiAgICB2YXIgZGVsaW1pdGVyT2Zmc2V0ID0gY3VyckRlbGltaXRlck1hdGNoLm9mZnNldDtcbiAgICB2YXIgbGFzdERlbGltaXRlck9mZnNldCA9IGxhc3REZWxpbWl0ZXJNYXRjaC5vZmZzZXQ7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJMZW5ndGggPSBsYXN0RGVsaW1pdGVyTWF0Y2gubGVuZ3RoO1xuICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCk7XG4gICAgaWYgKGluRGVsaW1pdGVyICYmIHBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcbiAgICAgIGlmIChsYXN0RGVsaW1pdGVyT2Zmc2V0ICsgbGFzdERlbGltaXRlckxlbmd0aCA9PT0gZGVsaW1pdGVyT2Zmc2V0KSB7XG4gICAgICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggKyA0KTtcbiAgICAgICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChnZXREdXBsaWNhdGVPcGVuVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgICAgICBvZmZzZXQ6IGxhc3REZWxpbWl0ZXJPZmZzZXRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICAgIGRlbGltaXRlckFjYy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY3VyckRlbGltaXRlck1hdGNoKSwge30sIHtcbiAgICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc3ludGF4T3B0aW9ucy5hbGxvd1VuY2xvc2VkVGFnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgICB4dGFnOiB3b3JkVG9VdGY4KHh0YWcpLFxuICAgICAgICAgIG9mZnNldDogbGFzdERlbGltaXRlck9mZnNldFxuICAgICAgICB9KSk7XG4gICAgICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICAgIGVycm9yOiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICAgIH1cbiAgICAgIGRlbGltaXRlckFjYy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKCFpbkRlbGltaXRlciAmJiBwb3NpdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKHN5bnRheE9wdGlvbnMuYWxsb3dVbm9wZW5lZFRhZykge1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgaWYgKGxhc3REZWxpbWl0ZXJPZmZzZXQgKyBsYXN0RGVsaW1pdGVyTGVuZ3RoID09PSBkZWxpbWl0ZXJPZmZzZXQpIHtcbiAgICAgICAgeHRhZyA9IGZ1bGxUZXh0LnN1YnN0cihsYXN0RGVsaW1pdGVyT2Zmc2V0IC0gNCwgZGVsaW1pdGVyT2Zmc2V0IC0gbGFzdERlbGltaXRlck9mZnNldCArIGxhc3REZWxpbWl0ZXJMZW5ndGggKyA0KTtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0RHVwbGljYXRlQ2xvc2VUYWdFeGNlcHRpb24oe1xuICAgICAgICAgIHh0YWc6IHh0YWcsXG4gICAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgICBkZWxpbWl0ZXJBY2MucHVzaChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGN1cnJEZWxpbWl0ZXJNYXRjaCksIHt9LCB7XG4gICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZGVsaW1pdGVyQWNjO1xuICAgICAgfVxuICAgICAgZXJyb3JzLnB1c2goZ2V0VW5vcGVuZWRUYWdFeGNlcHRpb24oe1xuICAgICAgICB4dGFnOiB4dGFnLFxuICAgICAgICBvZmZzZXQ6IGRlbGltaXRlck9mZnNldFxuICAgICAgfSkpO1xuICAgICAgbGFzdERlbGltaXRlck1hdGNoID0gY3VyckRlbGltaXRlck1hdGNoO1xuICAgICAgZGVsaW1pdGVyQWNjLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjdXJyRGVsaW1pdGVyTWF0Y2gpLCB7fSwge1xuICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGRlbGltaXRlckFjYztcbiAgICB9XG4gICAgaW5EZWxpbWl0ZXIgPSBwb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgIGxhc3REZWxpbWl0ZXJNYXRjaCA9IGN1cnJEZWxpbWl0ZXJNYXRjaDtcbiAgICBkZWxpbWl0ZXJBY2MucHVzaChjdXJyRGVsaW1pdGVyTWF0Y2gpO1xuICAgIHJldHVybiBkZWxpbWl0ZXJBY2M7XG4gIH0sIFtdKTtcbiAgaWYgKGluRGVsaW1pdGVyKSB7XG4gICAgdmFyIGxhc3REZWxpbWl0ZXJPZmZzZXQgPSBsYXN0RGVsaW1pdGVyTWF0Y2gub2Zmc2V0O1xuICAgIHh0YWcgPSBmdWxsVGV4dC5zdWJzdHIobGFzdERlbGltaXRlck9mZnNldCwgZnVsbFRleHQubGVuZ3RoIC0gbGFzdERlbGltaXRlck9mZnNldCk7XG4gICAgaWYgKCFzeW50YXhPcHRpb25zLmFsbG93VW5jbG9zZWRUYWcpIHtcbiAgICAgIGVycm9ycy5wdXNoKGdldFVuY2xvc2VkVGFnRXhjZXB0aW9uKHtcbiAgICAgICAgeHRhZzogd29yZFRvVXRmOCh4dGFnKSxcbiAgICAgICAgb2Zmc2V0OiBsYXN0RGVsaW1pdGVyT2Zmc2V0XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGltaXRlcldpdGhFcnJvcnMucG9wKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZGVsaW1pdGVyV2l0aEVycm9yczogZGVsaW1pdGVyV2l0aEVycm9ycyxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gY29tcGFyZU9mZnNldHMoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICBpZiAoc3RhcnRPZmZzZXQgPT09IC0xICYmIGVuZE9mZnNldCA9PT0gLTEpIHtcbiAgICByZXR1cm4gREVMSU1JVEVSX05PTkU7XG4gIH1cbiAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMSU1JVEVSX0VRVUFMO1xuICB9XG4gIGlmIChzdGFydE9mZnNldCA9PT0gLTEgfHwgZW5kT2Zmc2V0ID09PSAtMSkge1xuICAgIHJldHVybiBlbmRPZmZzZXQgPCBzdGFydE9mZnNldCA/IERFTElNSVRFUl9TVEFSVCA6IERFTElNSVRFUl9FTkQ7XG4gIH1cbiAgcmV0dXJuIHN0YXJ0T2Zmc2V0IDwgZW5kT2Zmc2V0ID8gREVMSU1JVEVSX1NUQVJUIDogREVMSU1JVEVSX0VORDtcbn1cbmZ1bmN0aW9uIHNwbGl0RGVsaW1pdGVycyhpbnNpZGUpIHtcbiAgdmFyIG5ld0RlbGltaXRlcnMgPSBpbnNpZGUuc3BsaXQoXCIgXCIpO1xuICBpZiAobmV3RGVsaW1pdGVycy5sZW5ndGggIT09IDIpIHtcbiAgICB2YXIgZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5ldyBEZWxpbWl0ZXJzIGNhbm5vdCBiZSBwYXJzZWRcIik7XG4gICAgZXJyLnByb3BlcnRpZXMgPSB7XG4gICAgICBpZDogXCJjaGFuZ2VfZGVsaW1pdGVyc19pbnZhbGlkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJDYW5ub3QgcGFyc2VyIGRlbGltaXRlcnNcIlxuICAgIH07XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIHZhciBfbmV3RGVsaW1pdGVycyA9IF9zbGljZWRUb0FycmF5KG5ld0RlbGltaXRlcnMsIDIpLFxuICAgIHN0YXJ0ID0gX25ld0RlbGltaXRlcnNbMF0sXG4gICAgZW5kID0gX25ld0RlbGltaXRlcnNbMV07XG4gIGlmIChzdGFydC5sZW5ndGggPT09IDAgfHwgZW5kLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBfZXJyID0gbmV3IFhUVGVtcGxhdGVFcnJvcihcIk5ldyBEZWxpbWl0ZXJzIGNhbm5vdCBiZSBwYXJzZWRcIik7XG4gICAgX2Vyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgaWQ6IFwiY2hhbmdlX2RlbGltaXRlcnNfaW52YWxpZFwiLFxuICAgICAgZXhwbGFuYXRpb246IFwiQ2Fubm90IHBhcnNlciBkZWxpbWl0ZXJzXCJcbiAgICB9O1xuICAgIHRocm93IF9lcnI7XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbn1cbmZ1bmN0aW9uIGdldEFsbERlbGltaXRlckluZGV4ZXMoZnVsbFRleHQsIGRlbGltaXRlcnMsIHN5bnRheE9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgdmFyIHN0YXJ0ID0gZGVsaW1pdGVycy5zdGFydCxcbiAgICBlbmQgPSBkZWxpbWl0ZXJzLmVuZDtcbiAgdmFyIG9mZnNldCA9IC0xO1xuICB2YXIgaW5zaWRlVGFnID0gZmFsc2U7XG4gIGlmIChzdGFydCA9PSBudWxsICYmIGVuZCA9PSBudWxsKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlIG9mIGRlbGltaXRlciBzZXQgdG8gbnVsbC9udWxsLCBubyB0ZW1wbGF0aW5nIGlzIGRvbmVcbiAgICByZXR1cm4gW107XG4gIH1cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSBmdWxsVGV4dC5pbmRleE9mKHN0YXJ0LCBvZmZzZXQgKyAxKTtcbiAgICB2YXIgZW5kT2Zmc2V0ID0gZnVsbFRleHQuaW5kZXhPZihlbmQsIG9mZnNldCArIDEpO1xuICAgIHZhciBwb3NpdGlvbiA9IG51bGw7XG4gICAgdmFyIGxlbiA9IHZvaWQgMDtcbiAgICB2YXIgY29tcGFyZVJlc3VsdCA9IGNvbXBhcmVPZmZzZXRzKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgIGlmIChjb21wYXJlUmVzdWx0ID09PSBERUxJTUlURVJfRVFVQUwpIHtcbiAgICAgIGNvbXBhcmVSZXN1bHQgPSBpbnNpZGVUYWcgPyBERUxJTUlURVJfRU5EIDogREVMSU1JVEVSX1NUQVJUO1xuICAgIH1cbiAgICBzd2l0Y2ggKGNvbXBhcmVSZXN1bHQpIHtcbiAgICAgIGNhc2UgREVMSU1JVEVSX05PTkU6XG4gICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgY2FzZSBERUxJTUlURVJfRU5EOlxuICAgICAgICBpbnNpZGVUYWcgPSBmYWxzZTtcbiAgICAgICAgb2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbiA9IFwiZW5kXCI7XG4gICAgICAgIGxlbiA9IGVuZC5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERUxJTUlURVJfU1RBUlQ6XG4gICAgICAgIGluc2lkZVRhZyA9IHRydWU7XG4gICAgICAgIG9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgICBwb3NpdGlvbiA9IFwic3RhcnRcIjtcbiAgICAgICAgbGVuID0gc3RhcnQubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLypcbiAgICAgKiBJZiB0YWcgc3RhcnRzIHdpdGggPSwgc3VjaCBhcyB7PVsgXT19XG4gICAgICogdGhlbiB0aGUgZGVsaW1pdGVycyB3aWxsIGNoYW5nZSByaWdodCBhZnRlciB0aGF0IHRhZy5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB3aXRoIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgOlxuICAgICAqXG4gICAgICogSGVsbG8ge2Zvb30sIHs9WyBdPX13aGF0J3MgdXAgd2l0aCBbbmFtZV0gP1xuICAgICAqXG4gICAgICogVGhlIFwiZm9vXCIgdGFnIGlzIGEgbm9ybWFsIHRhZywgdGhlIFwiPVsgXT1cIiBpcyBhIHRhZyB0byBjaGFuZ2UgdGhlXG4gICAgICogZGVsaW1pdGVycyB0byBcIltcIiBhbmQgXCJdXCIsIGFuZCB0aGUgbGFzdCBcIm5hbWVcIiBpcyBhIHRhZyB3aXRoIHRoZSBuZXdcbiAgICAgKiBkZWxpbWl0ZXJzXG4gICAgICovXG4gICAgaWYgKHN5bnRheE9wdGlvbnMuY2hhbmdlRGVsaW1pdGVyUHJlZml4ICYmIGNvbXBhcmVSZXN1bHQgPT09IERFTElNSVRFUl9TVEFSVCAmJiBmdWxsVGV4dFtvZmZzZXQgKyBzdGFydC5sZW5ndGhdID09PSBzeW50YXhPcHRpb25zLmNoYW5nZURlbGltaXRlclByZWZpeCkge1xuICAgICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgICAgb2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwic3RhcnRcIixcbiAgICAgICAgbGVuZ3RoOiBzdGFydC5sZW5ndGgsXG4gICAgICAgIGNoYW5nZWRlbGltaXRlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgbmV4dEVxdWFsID0gZnVsbFRleHQuaW5kZXhPZihzeW50YXhPcHRpb25zLmNoYW5nZURlbGltaXRlclByZWZpeCwgb2Zmc2V0ICsgc3RhcnQubGVuZ3RoICsgMSk7XG4gICAgICB2YXIgbmV4dEVuZE9mZnNldCA9IGZ1bGxUZXh0LmluZGV4T2YoZW5kLCBuZXh0RXF1YWwgKyAxKTtcbiAgICAgIGluZGV4ZXMucHVzaCh7XG4gICAgICAgIG9mZnNldDogbmV4dEVuZE9mZnNldCxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCIsXG4gICAgICAgIGxlbmd0aDogZW5kLmxlbmd0aCxcbiAgICAgICAgY2hhbmdlZGVsaW1pdGVyOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhciBfaW5zaWRlVGFnID0gZnVsbFRleHQuc3Vic3RyKG9mZnNldCArIHN0YXJ0Lmxlbmd0aCArIDEsIG5leHRFcXVhbCAtIG9mZnNldCAtIHN0YXJ0Lmxlbmd0aCAtIDEpO1xuICAgICAgdmFyIF9zcGxpdERlbGltaXRlcnMgPSBzcGxpdERlbGltaXRlcnMoX2luc2lkZVRhZyk7XG4gICAgICB2YXIgX3NwbGl0RGVsaW1pdGVyczIgPSBfc2xpY2VkVG9BcnJheShfc3BsaXREZWxpbWl0ZXJzLCAyKTtcbiAgICAgIHN0YXJ0ID0gX3NwbGl0RGVsaW1pdGVyczJbMF07XG4gICAgICBlbmQgPSBfc3BsaXREZWxpbWl0ZXJzMlsxXTtcbiAgICAgIG9mZnNldCA9IG5leHRFbmRPZmZzZXQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaW5kZXhlcy5wdXNoKHtcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VEZWxpbWl0ZXJzKGlubmVyQ29udGVudFBhcnRzLCBkZWxpbWl0ZXJzLCBzeW50YXhPcHRpb25zKSB7XG4gIHZhciBmdWxsID0gaW5uZXJDb250ZW50UGFydHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAudmFsdWU7XG4gIH0pLmpvaW4oXCJcIik7XG4gIHZhciBkZWxpbWl0ZXJNYXRjaGVzID0gZ2V0QWxsRGVsaW1pdGVySW5kZXhlcyhmdWxsLCBkZWxpbWl0ZXJzLCBzeW50YXhPcHRpb25zKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIHZhciByYW5nZXMgPSBpbm5lckNvbnRlbnRQYXJ0cy5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICBvZmZzZXQgKz0gcGFydC52YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldDogb2Zmc2V0IC0gcGFydC52YWx1ZS5sZW5ndGgsXG4gICAgICBsSW5kZXg6IHBhcnQubEluZGV4XG4gICAgfTtcbiAgfSk7XG4gIHZhciBfZ2V0RGVsaW1pdGVyRXJyb3JzID0gZ2V0RGVsaW1pdGVyRXJyb3JzKGRlbGltaXRlck1hdGNoZXMsIGZ1bGwsIHN5bnRheE9wdGlvbnMpLFxuICAgIGRlbGltaXRlcldpdGhFcnJvcnMgPSBfZ2V0RGVsaW1pdGVyRXJyb3JzLmRlbGltaXRlcldpdGhFcnJvcnMsXG4gICAgZXJyb3JzID0gX2dldERlbGltaXRlckVycm9ycy5lcnJvcnM7XG4gIHZhciBjdXROZXh0ID0gMDtcbiAgdmFyIGRlbGltaXRlckluZGV4ID0gMDtcbiAgdmFyIHBhcnNlZCA9IHJhbmdlcy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gcC5vZmZzZXQ7XG4gICAgdmFyIHJhbmdlID0gW29mZnNldCwgb2Zmc2V0ICsgaW5uZXJDb250ZW50UGFydHNbaV0udmFsdWUubGVuZ3RoXTtcbiAgICB2YXIgcGFydENvbnRlbnQgPSBpbm5lckNvbnRlbnRQYXJ0c1tpXS52YWx1ZTtcbiAgICB2YXIgZGVsaW1pdGVyc0luT2Zmc2V0ID0gW107XG4gICAgd2hpbGUgKGRlbGltaXRlckluZGV4IDwgZGVsaW1pdGVyV2l0aEVycm9ycy5sZW5ndGggJiYgaW5SYW5nZShyYW5nZSwgZGVsaW1pdGVyV2l0aEVycm9yc1tkZWxpbWl0ZXJJbmRleF0pKSB7XG4gICAgICBkZWxpbWl0ZXJzSW5PZmZzZXQucHVzaChkZWxpbWl0ZXJXaXRoRXJyb3JzW2RlbGltaXRlckluZGV4XSk7XG4gICAgICBkZWxpbWl0ZXJJbmRleCsrO1xuICAgIH1cbiAgICB2YXIgcGFydHMgPSBbXTtcbiAgICB2YXIgY3Vyc29yID0gMDtcbiAgICBpZiAoY3V0TmV4dCA+IDApIHtcbiAgICAgIGN1cnNvciA9IGN1dE5leHQ7XG4gICAgICBjdXROZXh0ID0gMDtcbiAgICB9XG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZGVsaW1pdGVyc0luT2Zmc2V0Lmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBkZWxpbWl0ZXJJbk9mZnNldCA9IGRlbGltaXRlcnNJbk9mZnNldFtfaTZdO1xuICAgICAgdmFyIF92YWx1ZSA9IHBhcnRDb250ZW50LnN1YnN0cihjdXJzb3IsIGRlbGltaXRlckluT2Zmc2V0Lm9mZnNldCAtIG9mZnNldCAtIGN1cnNvcik7XG4gICAgICBpZiAoZGVsaW1pdGVySW5PZmZzZXQuY2hhbmdlZGVsaW1pdGVyKSB7XG4gICAgICAgIGlmIChkZWxpbWl0ZXJJbk9mZnNldC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgaWYgKF92YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgIHZhbHVlOiBfdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJzb3IgPSBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgKyBkZWxpbWl0ZXJJbk9mZnNldC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoX3ZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY3Vyc29yICs9IF92YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICB2YXIgZGVsaW1pdGVyUGFydCA9IHtcbiAgICAgICAgdHlwZTogXCJkZWxpbWl0ZXJcIixcbiAgICAgICAgcG9zaXRpb246IGRlbGltaXRlckluT2Zmc2V0LnBvc2l0aW9uLFxuICAgICAgICBvZmZzZXQ6IGN1cnNvciArIG9mZnNldFxuICAgICAgfTtcbiAgICAgIHBhcnRzLnB1c2goZGVsaW1pdGVyUGFydCk7XG4gICAgICBjdXJzb3IgPSBkZWxpbWl0ZXJJbk9mZnNldC5vZmZzZXQgLSBvZmZzZXQgKyBkZWxpbWl0ZXJJbk9mZnNldC5sZW5ndGg7XG4gICAgfVxuICAgIGN1dE5leHQgPSBjdXJzb3IgLSBwYXJ0Q29udGVudC5sZW5ndGg7XG4gICAgdmFyIHZhbHVlID0gcGFydENvbnRlbnQuc3Vic3RyKGN1cnNvcik7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHtcbiAgICBwYXJzZWQ6IHBhcnNlZCxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxuZnVuY3Rpb24gaXNJbnNpZGVDb250ZW50KHBhcnQpIHtcbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhlIHBhcnQucG9zaXRpb24gPT09IFwiaW5zaWRldGFnXCIgd291bGQgYmUgZW5vdWdoIGJ1dCB3ZSB3YW50IHRvIG1ha2UgdGhlIEFQSSBmdXR1cmUgcHJvb2ZcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIgJiYgcGFydC5wb3NpdGlvbiA9PT0gXCJpbnNpZGV0YWdcIjtcbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxufVxuZnVuY3Rpb24gZ2V0Q29udGVudFBhcnRzKHhtbHBhcnNlZCkge1xuICByZXR1cm4geG1scGFyc2VkLmZpbHRlcihpc0luc2lkZUNvbnRlbnQpO1xufVxuZnVuY3Rpb24gZGVjb2RlQ29udGVudFBhcnRzKHhtbHBhcnNlZCwgZmlsZVR5cGUpIHtcbiAgdmFyIGluVGV4dFRhZyA9IGZhbHNlO1xuICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCB4bWxwYXJzZWQubGVuZ3RoOyBfaTgrKykge1xuICAgIHZhciBwYXJ0ID0geG1scGFyc2VkW19pOF07XG4gICAgaW5UZXh0VGFnID0gdXBkYXRlSW5UZXh0VGFnKHBhcnQsIGluVGV4dFRhZyk7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgIHBhcnQucG9zaXRpb24gPSBpblRleHRUYWcgPyBcImluc2lkZXRhZ1wiIDogXCJvdXRzaWRldGFnXCI7XG4gICAgfVxuICAgIGlmIChmaWxlVHlwZSAhPT0gXCJ0ZXh0XCIgJiYgaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICBwYXJ0LnZhbHVlID0gcGFydC52YWx1ZS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKTtcbiAgICB9XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZURlbGltaXRlcnM6IHBhcnNlRGVsaW1pdGVycyxcbiAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHhtbGxleGVkLCBkZWxpbWl0ZXJzLCBzeW50YXgsIGZpbGVUeXBlKSB7XG4gICAgZGVjb2RlQ29udGVudFBhcnRzKHhtbGxleGVkLCBmaWxlVHlwZSk7XG4gICAgdmFyIF9wYXJzZURlbGltaXRlcnMgPSBwYXJzZURlbGltaXRlcnMoZ2V0Q29udGVudFBhcnRzKHhtbGxleGVkKSwgZGVsaW1pdGVycywgc3ludGF4KSxcbiAgICAgIGRlbGltaXRlclBhcnNlZCA9IF9wYXJzZURlbGltaXRlcnMucGFyc2VkLFxuICAgICAgZXJyb3JzID0gX3BhcnNlRGVsaW1pdGVycy5lcnJvcnM7XG4gICAgdmFyIGxleGVkID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbEluZGV4ID0gMDtcbiAgICBmb3IgKHZhciBfaTAgPSAwOyBfaTAgPCB4bWxsZXhlZC5sZW5ndGg7IF9pMCsrKSB7XG4gICAgICB2YXIgcGFydCA9IHhtbGxleGVkW19pMF07XG4gICAgICBpZiAoaXNJbnNpZGVDb250ZW50KHBhcnQpKSB7XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfZGVsaW1pdGVyUGFyc2VkJGluZGUyID0gZGVsaW1pdGVyUGFyc2VkW2luZGV4XTsgX2kxMCA8IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTIubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgICB2YXIgcCA9IF9kZWxpbWl0ZXJQYXJzZWQkaW5kZTJbX2kxMF07XG4gICAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJjb250ZW50XCIpIHtcbiAgICAgICAgICAgIHAucG9zaXRpb24gPSBcImluc2lkZXRhZ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwLmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHB1c2hBcnJheShsZXhlZCwgZGVsaW1pdGVyUGFyc2VkW2luZGV4XSk7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0LmxJbmRleCA9IGxJbmRleCsrO1xuICAgICAgICBsZXhlZC5wdXNoKHBhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICBsZXhlZDogbGV4ZWRcbiAgICB9O1xuICB9LFxuICB4bWxwYXJzZTogZnVuY3Rpb24geG1scGFyc2UoY29udGVudCwgeG1sdGFncykge1xuICAgIHZhciBtYXRjaGVzID0gdGFnTWF0Y2hlcihjb250ZW50LCB4bWx0YWdzLnRleHQsIHhtbHRhZ3Mub3RoZXIpO1xuICAgIHZhciBjdXJzb3IgPSAwO1xuICAgIHZhciBwYXJzZWQgPSBbXTtcbiAgICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IG1hdGNoZXMubGVuZ3RoOyBfaTEyKyspIHtcbiAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbX2kxMl07XG4gICAgICBpZiAoY29udGVudC5sZW5ndGggPiBjdXJzb3IgJiYgbWF0Y2gub2Zmc2V0IC0gY3Vyc29yID4gMCkge1xuICAgICAgICBwYXJzZWQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJjb250ZW50XCIsXG4gICAgICAgICAgdmFsdWU6IGNvbnRlbnQuc3Vic3RyKGN1cnNvciwgbWF0Y2gub2Zmc2V0IC0gY3Vyc29yKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGN1cnNvciA9IG1hdGNoLm9mZnNldCArIG1hdGNoLnZhbHVlLmxlbmd0aDtcbiAgICAgIGRlbGV0ZSBtYXRjaC5vZmZzZXQ7XG4gICAgICBwYXJzZWQucHVzaChtYXRjaCk7XG4gICAgfVxuICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IGN1cnNvcikge1xuICAgICAgcGFyc2VkLnB1c2goe1xuICAgICAgICB0eXBlOiBcImNvbnRlbnRcIixcbiAgICAgICAgdmFsdWU6IGNvbnRlbnQuc3Vic3RyKGN1cnNvcilcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/lexer.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/merge-sort.js":
/*!*********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/merge-sort.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\nfunction getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\nmodule.exports = function (arrays) {\n  var totalLength = 0;\n  for (var _i2 = 0, _arrays2 = arrays; _i2 < _arrays2.length; _i2++) {\n    var array = _arrays2[_i2];\n    totalLength += array.length;\n  }\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  for (var i = 0; i < totalLength; i++) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n  }\n  return resultArray;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWVyZ2Utc29ydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21lcmdlLXNvcnQuanM/ODY1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKSB7XG4gIHZhciBtaW5JbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoc3RhdGVbaV0gPj0gYXJyYXlzW2ldLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChtaW5JbmRleCA9PT0gLTEgfHwgYXJyYXlzW2ldW3N0YXRlW2ldXS5vZmZzZXQgPCBhcnJheXNbbWluSW5kZXhdW3N0YXRlW21pbkluZGV4XV0ub2Zmc2V0KSB7XG4gICAgICBtaW5JbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5JbmRleDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFycmF5cykge1xuICB2YXIgdG90YWxMZW5ndGggPSAwO1xuICBmb3IgKHZhciBfaTIgPSAwLCBfYXJyYXlzMiA9IGFycmF5czsgX2kyIDwgX2FycmF5czIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBhcnJheSA9IF9hcnJheXMyW19pMl07XG4gICAgdG90YWxMZW5ndGggKz0gYXJyYXkubGVuZ3RoO1xuICB9XG4gIGFycmF5cyA9IGFycmF5cy5maWx0ZXIoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDA7XG4gIH0pO1xuICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgQXJyYXkodG90YWxMZW5ndGgpO1xuICB2YXIgc3RhdGUgPSBhcnJheXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxMZW5ndGg7IGkrKykge1xuICAgIHZhciBhcnJheUluZGV4ID0gZ2V0TWluRnJvbUFycmF5cyhhcnJheXMsIHN0YXRlKTtcbiAgICByZXN1bHRBcnJheVtpXSA9IGFycmF5c1thcnJheUluZGV4XVtzdGF0ZVthcnJheUluZGV4XV07XG4gICAgc3RhdGVbYXJyYXlJbmRleF0rKztcbiAgfVxuICByZXR1cm4gcmVzdWx0QXJyYXk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/merge-sort.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/minizod.js":
/*!******************************************************!*\
  !*** ../../node_modules/docxtemplater/js/minizod.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\n\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar MiniZod = /*#__PURE__*/function () {\n  function MiniZod() {\n    _classCallCheck(this, MiniZod);\n  }\n  return _createClass(MiniZod, null, [{\n    key: \"createSchema\",\n    value: function createSchema(validateFn) {\n      var schema = {\n        validate: validateFn,\n        optional: function optional() {\n          return MiniZod.createSchema(function (value) {\n            return value === undefined ? {\n              success: true,\n              value: value\n            } : validateFn(value);\n          });\n        },\n        nullable: function nullable() {\n          return MiniZod.createSchema(function (value) {\n            return value == null ? {\n              success: true,\n              value: value\n            } : validateFn(value);\n          });\n        }\n      };\n      return schema;\n    }\n  }, {\n    key: \"string\",\n    value: function string() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"string\") {\n          return {\n            success: false,\n            error: \"Expected string, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"date\",\n    value: function date() {\n      return MiniZod.createSchema(function (value) {\n        if (!(value instanceof Date)) {\n          return {\n            success: false,\n            error: \"Expected date, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"boolean\",\n    value: function _boolean() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"boolean\") {\n          return {\n            success: false,\n            error: \"Expected boolean, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"number\",\n    value: function number() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"number\") {\n          return {\n            success: false,\n            error: \"Expected number, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"function\",\n    value: function _function() {\n      return MiniZod.createSchema(function (value) {\n        if (typeof value !== \"function\") {\n          return {\n            success: false,\n            error: \"Expected function, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"array\",\n    value: function array(itemSchema) {\n      return MiniZod.createSchema(function (value) {\n        if (!Array.isArray(value)) {\n          return {\n            success: false,\n            error: \"Expected array, received \".concat(_typeof(value))\n          };\n        }\n        for (var i = 0; i < value.length; i++) {\n          var result = itemSchema.validate(value[i]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at index \").concat(i)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"any\",\n    value: function any() {\n      return MiniZod.createSchema(function (value) {\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"isRegex\",\n    value: function isRegex() {\n      return MiniZod.createSchema(function (value) {\n        if (!(value instanceof RegExp)) {\n          return {\n            success: false,\n            error: \"Expected RegExp, received \".concat(_typeof(value))\n          };\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }, {\n    key: \"union\",\n    value: function union(schemas) {\n      return MiniZod.createSchema(function (value) {\n        for (var _i2 = 0; _i2 < schemas.length; _i2++) {\n          var s = schemas[_i2];\n          var result = s.validate(value);\n          if (result.success) {\n            return result;\n          }\n        }\n        return {\n          success: false,\n          error: \"Value \".concat(value, \" does not match any schema in union\")\n        };\n      });\n    }\n  }, {\n    key: \"object\",\n    value: function object(shape) {\n      var schema = MiniZod.createSchema(function (value) {\n        if (value == null) {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(value)\n          };\n        }\n        if (_typeof(value) !== \"object\") {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(_typeof(value))\n          };\n        }\n        for (var _i4 = 0, _Object$entries2 = Object.entries(shape); _i4 < _Object$entries2.length; _i4++) {\n          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),\n            key = _Object$entries2$_i[0],\n            validator = _Object$entries2$_i[1];\n          var result = validator.validate(value[key]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at \").concat(key)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n      schema.strict = function () {\n        return MiniZod.createSchema(function (value) {\n          var baseResult = schema.validate(value);\n          if (!baseResult.success) {\n            return baseResult;\n          }\n          var extraKeys = Object.keys(value).filter(function (key) {\n            return !(key in shape);\n          });\n          if (extraKeys.length > 0) {\n            return {\n              success: false,\n              error: \"Unexpected properties: \".concat(extraKeys.join(\", \"))\n            };\n          }\n          return baseResult;\n        });\n      };\n      return schema;\n    }\n  }, {\n    key: \"record\",\n    value: function record(valueSchema) {\n      return MiniZod.createSchema(function (value) {\n        if (value === null) {\n          return {\n            success: false,\n            error: \"Expected object, received null\"\n          };\n        }\n        if (_typeof(value) !== \"object\") {\n          return {\n            success: false,\n            error: \"Expected object, received \".concat(_typeof(value))\n          };\n        }\n        for (var _i6 = 0, _Object$keys2 = Object.keys(value); _i6 < _Object$keys2.length; _i6++) {\n          var key = _Object$keys2[_i6];\n          if (typeof key !== \"string\") {\n            return {\n              success: false,\n              error: \"Expected string key, received \".concat(_typeof(key), \" at \").concat(key)\n            };\n          }\n          var result = valueSchema.validate(value[key]);\n          if (!result.success) {\n            return {\n              success: false,\n              error: \"\".concat(result.error, \" at key \").concat(key)\n            };\n          }\n        }\n        return {\n          success: true,\n          value: value\n        };\n      });\n    }\n  }]);\n}();\nmodule.exports = MiniZod;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbWluaXpvZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSwrQkFBK0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0QkFBNEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9taW5pem9kLmpzP2MwZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7IGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikgeyBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHsgdmFyIG8gPSByW3RdOyBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkgeyByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7IHdyaXRhYmxlOiAhMSB9KSwgZTsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkgeyB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTsgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7IHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAodm9pZCAwICE9PSBlKSB7IHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpOyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7IH1cbnZhciBNaW5pWm9kID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWluaVpvZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWluaVpvZCk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNaW5pWm9kLCBudWxsLCBbe1xuICAgIGtleTogXCJjcmVhdGVTY2hlbWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlU2NoZW1hKHZhbGlkYXRlRm4pIHtcbiAgICAgIHZhciBzY2hlbWEgPSB7XG4gICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUZuLFxuICAgICAgICBvcHRpb25hbDogZnVuY3Rpb24gb3B0aW9uYWwoKSB7XG4gICAgICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSA6IHZhbGlkYXRlRm4odmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBudWxsYWJsZTogZnVuY3Rpb24gbnVsbGFibGUoKSB7XG4gICAgICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSA6IHZhbGlkYXRlRm4odmFsdWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIHN0cmluZywgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGRhdGUsIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJib29sZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ib29sZWFuKCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGJvb2xlYW4sIHJlY2VpdmVkIFwiLmNvbmNhdChfdHlwZW9mKHZhbHVlKSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJudW1iZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtYmVyKCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgbnVtYmVyLCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnVuY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Z1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBmdW5jdGlvbiwgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFycmF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFycmF5KGl0ZW1TY2hlbWEpIHtcbiAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIGFycmF5LCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZW1TY2hlbWEudmFsaWRhdGUodmFsdWVbaV0pO1xuICAgICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogXCJcIi5jb25jYXQocmVzdWx0LmVycm9yLCBcIiBhdCBpbmRleCBcIikuY29uY2F0KGkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYW55XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFueSgpIHtcbiAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUmVnZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNSZWdleCgpIHtcbiAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgUmVnRXhwLCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5pb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5pb24oc2NoZW1hcykge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBzY2hlbWFzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgcyA9IHNjaGVtYXNbX2kyXTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gcy52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIlZhbHVlIFwiLmNvbmNhdCh2YWx1ZSwgXCIgZG9lcyBub3QgbWF0Y2ggYW55IHNjaGVtYSBpbiB1bmlvblwiKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvYmplY3Qoc2hhcGUpIHtcbiAgICAgIHZhciBzY2hlbWEgPSBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBvYmplY3QsIHJlY2VpdmVkIFwiLmNvbmNhdCh2YWx1ZSlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZW9mKHZhbHVlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBcIkV4cGVjdGVkIG9iamVjdCwgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2YodmFsdWUpKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX09iamVjdCRlbnRyaWVzMiA9IE9iamVjdC5lbnRyaWVzKHNoYXBlKTsgX2k0IDwgX09iamVjdCRlbnRyaWVzMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIF9PYmplY3QkZW50cmllczIkX2kgPSBfc2xpY2VkVG9BcnJheShfT2JqZWN0JGVudHJpZXMyW19pNF0sIDIpLFxuICAgICAgICAgICAga2V5ID0gX09iamVjdCRlbnRyaWVzMiRfaVswXSxcbiAgICAgICAgICAgIHZhbGlkYXRvciA9IF9PYmplY3QkZW50cmllczIkX2lbMV07XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IFwiXCIuY29uY2F0KHJlc3VsdC5lcnJvciwgXCIgYXQgXCIpLmNvbmNhdChrZXkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHNjaGVtYS5zdHJpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNaW5pWm9kLmNyZWF0ZVNjaGVtYShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgYmFzZVJlc3VsdCA9IHNjaGVtYS52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKCFiYXNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZXh0cmFLZXlzID0gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gIShrZXkgaW4gc2hhcGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBcIlVuZXhwZWN0ZWQgcHJvcGVydGllczogXCIuY29uY2F0KGV4dHJhS2V5cy5qb2luKFwiLCBcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb3JkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlY29yZCh2YWx1ZVNjaGVtYSkge1xuICAgICAgcmV0dXJuIE1pbmlab2QuY3JlYXRlU2NoZW1hKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogXCJFeHBlY3RlZCBvYmplY3QsIHJlY2VpdmVkIG51bGxcIlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgb2JqZWN0LCByZWNlaXZlZCBcIi5jb25jYXQoX3R5cGVvZih2YWx1ZSkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaTYgPSAwLCBfT2JqZWN0JGtleXMyID0gT2JqZWN0LmtleXModmFsdWUpOyBfaTYgPCBfT2JqZWN0JGtleXMyLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzMltfaTZdO1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6IFwiRXhwZWN0ZWQgc3RyaW5nIGtleSwgcmVjZWl2ZWQgXCIuY29uY2F0KF90eXBlb2Yoa2V5KSwgXCIgYXQgXCIpLmNvbmNhdChrZXkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVTY2hlbWEudmFsaWRhdGUodmFsdWVba2V5XSk7XG4gICAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiBcIlwiLmNvbmNhdChyZXN1bHQuZXJyb3IsIFwiIGF0IGtleSBcIikuY29uY2F0KGtleSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBNaW5pWm9kOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/minizod.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/module-wrapper.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n  return i;\n}\nmodule.exports = function (module) {\n  var defaults = {\n    set: emptyFun,\n    matchers: function matchers() {\n      return [];\n    },\n    parse: emptyFun,\n    render: emptyFun,\n    getTraits: emptyFun,\n    getFileType: emptyFun,\n    nullGetter: emptyFun,\n    optionsTransformer: identity,\n    postrender: identity,\n    errorsTransformer: identity,\n    getRenderedMap: identity,\n    preparse: identity,\n    postparse: identity,\n    on: emptyFun,\n    resolve: emptyFun,\n    preResolve: emptyFun\n  };\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n    err.properties = {\n      id: \"module_cannot_be_wrapped\",\n      explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n    };\n    throw err;\n  }\n  for (var key in defaults) {\n    module[key] || (module[key] = defaults[key]);\n  }\n  return module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlLXdyYXBwZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLHdFQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGUtd3JhcHBlci5qcz83ZjRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIFhUSW50ZXJuYWxFcnJvciA9IF9yZXF1aXJlLlhUSW50ZXJuYWxFcnJvcjtcbmZ1bmN0aW9uIGVtcHR5RnVuKCkge31cbmZ1bmN0aW9uIGlkZW50aXR5KGkpIHtcbiAgcmV0dXJuIGk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHNldDogZW1wdHlGdW4sXG4gICAgbWF0Y2hlcnM6IGZ1bmN0aW9uIG1hdGNoZXJzKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgcGFyc2U6IGVtcHR5RnVuLFxuICAgIHJlbmRlcjogZW1wdHlGdW4sXG4gICAgZ2V0VHJhaXRzOiBlbXB0eUZ1bixcbiAgICBnZXRGaWxlVHlwZTogZW1wdHlGdW4sXG4gICAgbnVsbEdldHRlcjogZW1wdHlGdW4sXG4gICAgb3B0aW9uc1RyYW5zZm9ybWVyOiBpZGVudGl0eSxcbiAgICBwb3N0cmVuZGVyOiBpZGVudGl0eSxcbiAgICBlcnJvcnNUcmFuc2Zvcm1lcjogaWRlbnRpdHksXG4gICAgZ2V0UmVuZGVyZWRNYXA6IGlkZW50aXR5LFxuICAgIHByZXBhcnNlOiBpZGVudGl0eSxcbiAgICBwb3N0cGFyc2U6IGlkZW50aXR5LFxuICAgIG9uOiBlbXB0eUZ1bixcbiAgICByZXNvbHZlOiBlbXB0eUZ1bixcbiAgICBwcmVSZXNvbHZlOiBlbXB0eUZ1blxuICB9O1xuICBpZiAoT2JqZWN0LmtleXMoZGVmYXVsdHMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIW1vZHVsZVtrZXldO1xuICB9KSkge1xuICAgIHZhciBlcnIgPSBuZXcgWFRJbnRlcm5hbEVycm9yKFwiVGhpcyBtb2R1bGUgY2Fubm90IGJlIHdyYXBwZWQsIGJlY2F1c2UgaXQgZG9lc24ndCBkZWZpbmUgYW55IG9mIHRoZSBuZWNlc3NhcnkgZnVuY3Rpb25zXCIpO1xuICAgIGVyci5wcm9wZXJ0aWVzID0ge1xuICAgICAgaWQ6IFwibW9kdWxlX2Nhbm5vdF9iZV93cmFwcGVkXCIsXG4gICAgICBleHBsYW5hdGlvbjogXCJUaGlzIG1vZHVsZSBjYW5ub3QgYmUgd3JhcHBlZCwgYmVjYXVzZSBpdCBkb2Vzbid0IGRlZmluZSBhbnkgb2YgdGhlIG5lY2Vzc2FyeSBmdW5jdGlvbnNcIlxuICAgIH07XG4gICAgdGhyb3cgZXJyO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgIG1vZHVsZVtrZXldIHx8IChtb2R1bGVba2V5XSA9IGRlZmF1bHRzW2tleV0pO1xuICB9XG4gIHJldHVybiBtb2R1bGU7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/common.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/common.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/../../node_modules/docxtemplater/js/filetypes.js\");\nvar _require2 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/../../node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require2.settingsContentType,\n  coreContentType = _require2.coreContentType,\n  appContentType = _require2.appContentType,\n  customContentType = _require2.customContentType,\n  diagramDataContentType = _require2.diagramDataContentType,\n  diagramDrawingContentType = _require2.diagramDrawingContentType;\nvar commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType, diagramDataContentType, diagramDrawingContentType];\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n    this.name = \"Common\";\n  }\n  return _createClass(Common, [{\n    key: \"getFileType\",\n    value: function getFileType(_ref) {\n      var doc = _ref.doc;\n      var invertedContentTypes = doc.invertedContentTypes;\n      if (!invertedContentTypes) {\n        return;\n      }\n      for (var _i2 = 0; _i2 < commonContentTypes.length; _i2++) {\n        var ct = commonContentTypes[_i2];\n        if (invertedContentTypes[ct]) {\n          pushArray(doc.targets, invertedContentTypes[ct]);\n        }\n      }\n      var keys = [\"docx\", \"pptx\", \"xlsx\"];\n      var ftCandidate;\n      for (var _i4 = 0; _i4 < keys.length; _i4++) {\n        var key = keys[_i4];\n        var contentTypes = filetypes[key];\n        for (var _i6 = 0; _i6 < contentTypes.length; _i6++) {\n          var _ct = contentTypes[_i6];\n          if (invertedContentTypes[_ct]) {\n            for (var _i8 = 0, _invertedContentTypes2 = invertedContentTypes[_ct]; _i8 < _invertedContentTypes2.length; _i8++) {\n              var target = _invertedContentTypes2[_i8];\n              if (doc.relsTypes[target] && [\"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\", \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"].indexOf(doc.relsTypes[target]) === -1) {\n                continue;\n              }\n              ftCandidate = key;\n              if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                doc.textTarget || (doc.textTarget = target);\n              }\n              if (ftCandidate === \"xlsx\") {\n                continue;\n              }\n              doc.targets.push(target);\n            }\n          }\n        }\n        if (ftCandidate) {\n          return ftCandidate;\n        }\n      }\n      return ftCandidate;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Common());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQywrRUFBaUI7QUFDeEM7QUFDQSxjQUFjLG1CQUFPLENBQUMseUZBQXNCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFpQjtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQSxrRkFBa0YscUNBQXFDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL2NvbW1vbi5qcz8zY2RiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd3JhcHBlciA9IHJlcXVpcmUoXCIuLi9tb2R1bGUtd3JhcHBlci5qc1wiKTtcbnZhciBmaWxldHlwZXMgPSByZXF1aXJlKFwiLi4vZmlsZXR5cGVzLmpzXCIpO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoXCIuLi9jb250ZW50LXR5cGVzLmpzXCIpLFxuICBzZXR0aW5nc0NvbnRlbnRUeXBlID0gX3JlcXVpcmUyLnNldHRpbmdzQ29udGVudFR5cGUsXG4gIGNvcmVDb250ZW50VHlwZSA9IF9yZXF1aXJlMi5jb3JlQ29udGVudFR5cGUsXG4gIGFwcENvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmFwcENvbnRlbnRUeXBlLFxuICBjdXN0b21Db250ZW50VHlwZSA9IF9yZXF1aXJlMi5jdXN0b21Db250ZW50VHlwZSxcbiAgZGlhZ3JhbURhdGFDb250ZW50VHlwZSA9IF9yZXF1aXJlMi5kaWFncmFtRGF0YUNvbnRlbnRUeXBlLFxuICBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlID0gX3JlcXVpcmUyLmRpYWdyYW1EcmF3aW5nQ29udGVudFR5cGU7XG52YXIgY29tbW9uQ29udGVudFR5cGVzID0gW3NldHRpbmdzQ29udGVudFR5cGUsIGNvcmVDb250ZW50VHlwZSwgYXBwQ29udGVudFR5cGUsIGN1c3RvbUNvbnRlbnRUeXBlLCBkaWFncmFtRGF0YUNvbnRlbnRUeXBlLCBkaWFncmFtRHJhd2luZ0NvbnRlbnRUeXBlXTtcbnZhciBDb21tb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21tb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbW1vbik7XG4gICAgdGhpcy5uYW1lID0gXCJDb21tb25cIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENvbW1vbiwgW3tcbiAgICBrZXk6IFwiZ2V0RmlsZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RmlsZVR5cGUoX3JlZikge1xuICAgICAgdmFyIGRvYyA9IF9yZWYuZG9jO1xuICAgICAgdmFyIGludmVydGVkQ29udGVudFR5cGVzID0gZG9jLmludmVydGVkQ29udGVudFR5cGVzO1xuICAgICAgaWYgKCFpbnZlcnRlZENvbnRlbnRUeXBlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBjb21tb25Db250ZW50VHlwZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgY3QgPSBjb21tb25Db250ZW50VHlwZXNbX2kyXTtcbiAgICAgICAgaWYgKGludmVydGVkQ29udGVudFR5cGVzW2N0XSkge1xuICAgICAgICAgIHB1c2hBcnJheShkb2MudGFyZ2V0cywgaW52ZXJ0ZWRDb250ZW50VHlwZXNbY3RdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGtleXMgPSBbXCJkb2N4XCIsIFwicHB0eFwiLCBcInhsc3hcIl07XG4gICAgICB2YXIgZnRDYW5kaWRhdGU7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBrZXlzLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbX2k0XTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlcyA9IGZpbGV0eXBlc1trZXldO1xuICAgICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjb250ZW50VHlwZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgIHZhciBfY3QgPSBjb250ZW50VHlwZXNbX2k2XTtcbiAgICAgICAgICBpZiAoaW52ZXJ0ZWRDb250ZW50VHlwZXNbX2N0XSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX2ludmVydGVkQ29udGVudFR5cGVzMiA9IGludmVydGVkQ29udGVudFR5cGVzW19jdF07IF9pOCA8IF9pbnZlcnRlZENvbnRlbnRUeXBlczIubGVuZ3RoOyBfaTgrKykge1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX2ludmVydGVkQ29udGVudFR5cGVzMltfaThdO1xuICAgICAgICAgICAgICBpZiAoZG9jLnJlbHNUeXBlc1t0YXJnZXRdICYmIFtcImh0dHA6Ly9wdXJsLm9jbGMub3JnL29veG1sL29mZmljZURvY3VtZW50L3JlbGF0aW9uc2hpcHMvb2ZmaWNlRG9jdW1lbnRcIiwgXCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL29mZmljZURvY3VtZW50XCJdLmluZGV4T2YoZG9jLnJlbHNUeXBlc1t0YXJnZXRdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdENhbmRpZGF0ZSA9IGtleTtcbiAgICAgICAgICAgICAgaWYgKGZpbGV0eXBlcy5tYWluLmluZGV4T2YoX2N0KSAhPT0gLTEgfHwgX2N0ID09PSBmaWxldHlwZXMucHB0eFswXSkge1xuICAgICAgICAgICAgICAgIGRvYy50ZXh0VGFyZ2V0IHx8IChkb2MudGV4dFRhcmdldCA9IHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlID09PSBcInhsc3hcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRvYy50YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZ0Q2FuZGlkYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ0Q2FuZGlkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnRDYW5kaWRhdGU7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IENvbW1vbigpKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/common.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/expand-pair-trait.js":
/*!************************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/expand-pair-trait.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traitName = \"expandPair\";\nvar mergeSort = __webpack_require__(/*! ../merge-sort.js */ \"(rsc)/../../node_modules/docxtemplater/js/merge-sort.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  getLeft = _require.getLeft,\n  getRight = _require.getRight,\n  pushArray = _require.pushArray;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require2 = __webpack_require__(/*! ../traits.js */ \"(rsc)/../../node_modules/docxtemplater/js/traits.js\"),\n  getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = __webpack_require__(/*! ../errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n  getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n  getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n    case \"end\":\n      return -1;\n  }\n}\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n  while (i < traits.length) {\n    var part = traits[i].part;\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        offseter++;\n      }\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n    i++;\n  }\n  for (var _i2 = 0; _i2 < traits.length; _i2++) {\n    var _part = traits[_i2].part;\n    errors.push(getUnmatchedLoopException(_part));\n  }\n  return {\n    traits: [],\n    errors: errors\n  };\n}\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var transformedTraits = [];\n  pushArray(transformedTraits, traits);\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    pushArray(errors, result.errors);\n    transformedTraits = result.traits;\n  }\n\n  // Stryker disable all : because this check makes the function return quicker\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n  // Stryker restore all\n  var countOpen = 0;\n  for (var _i4 = 0; _i4 < traits.length; _i4++) {\n    var currentTrait = traits[_i4];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(part);\n    countOpen += change;\n    if (change === 1) {\n      levelTraits[countOpen] = currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n      if (countOpen === 0) {\n        pairs.push([startTrait, currentTrait]);\n      }\n    }\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\nvar ExpandPairTrait = /*#__PURE__*/function () {\n  function ExpandPairTrait() {\n    _classCallCheck(this, ExpandPairTrait);\n    this.name = \"ExpandPairTrait\";\n  }\n  return _createClass(ExpandPairTrait, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      if (docxtemplater.options.paragraphLoop) {\n        pushArray(docxtemplater.fileTypeConfig.expandTags, docxtemplater.fileTypeConfig.onParagraphLoop);\n      }\n      this.expandTags = docxtemplater.fileTypeConfig.expandTags;\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, _ref) {\n      var _this = this;\n      var getTraits = _ref.getTraits,\n        _postparse = _ref.postparse,\n        fileType = _ref.fileType;\n      var traits = getTraits(traitName, postparsed);\n      traits = traits.map(function (trait) {\n        return trait || [];\n      });\n      traits = mergeSort(traits);\n      var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n      var lastRight = 0;\n      var lastPair = null;\n      var expandedPairs = pairs.map(function (pair) {\n        var expandTo = pair[0].part.expandTo;\n        if (expandTo === \"auto\" && fileType !== \"text\") {\n          var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n          if (result.error) {\n            errors.push(result.error);\n          }\n          expandTo = result.value;\n        }\n        if (!expandTo || fileType === \"text\") {\n          var _left = pair[0].offset;\n          var _right = pair[1].offset;\n          if (_left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n            errors.push(getUnbalancedLoopException(pair, lastPair));\n          }\n          lastPair = pair;\n          lastRight = _right;\n          return [_left, _right];\n        }\n        var left, right;\n        try {\n          left = getLeft(postparsed, expandTo, pair[0].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        try {\n          right = getRight(postparsed, expandTo, pair[1].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        if (left < lastRight && !_this.docxtemplater.options.syntax.allowUnbalancedLoops) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n        lastRight = right;\n        lastPair = pair;\n        return [left, right];\n      });\n\n      // Stryker disable all : because this check makes the function return quicker\n      if (errors.length > 0) {\n        return {\n          postparsed: postparsed,\n          errors: errors\n        };\n      }\n      // Stryker restore all\n      var currentPairIndex = 0;\n      var innerParts;\n      var newParsed = postparsed.reduce(function (newParsed, part, i) {\n        var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n        var pair = pairs[currentPairIndex];\n        var expandedPair = expandedPairs[currentPairIndex];\n        if (!inPair) {\n          newParsed.push(part);\n          return newParsed;\n        }\n        // We're inside the pair\n        if (expandedPair[0] === i) {\n          // Start pair\n          innerParts = [];\n        }\n        if (pair[0].offset !== i && pair[1].offset !== i) {\n          // Exclude inner pair indexes\n          innerParts.push(part);\n        }\n        if (expandedPair[1] === i) {\n          // End pair\n          var basePart = postparsed[pair[0].offset];\n          basePart.subparsed = _postparse(innerParts, {\n            basePart: basePart\n          });\n          basePart.endLindex = pair[1].part.lIndex;\n          delete basePart.location;\n          delete basePart.expandTo;\n          newParsed.push(basePart);\n          currentPairIndex++;\n          var _expandedPair = expandedPairs[currentPairIndex];\n          while (_expandedPair && _expandedPair[0] < i) {\n            /*\n             * If we have :\n             * expandedPairs =[[5,72],[51,67],[90,106]]\n             * Then after treating [5,72], we need to treat [90,106]\n             * Fixed since v3.58.4\n             */\n            currentPairIndex++;\n            _expandedPair = expandedPairs[currentPairIndex];\n          }\n        }\n        return newParsed;\n      }, []);\n      return {\n        postparsed: newParsed,\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new ExpandPairTrait());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLCtFQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMseUZBQXNCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHlFQUFjO0FBQ3RDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9leHBhbmQtcGFpci10cmFpdC5qcz8yNjQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgdHJhaXROYW1lID0gXCJleHBhbmRQYWlyXCI7XG52YXIgbWVyZ2VTb3J0ID0gcmVxdWlyZShcIi4uL21lcmdlLXNvcnQuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBnZXRMZWZ0ID0gX3JlcXVpcmUuZ2V0TGVmdCxcbiAgZ2V0UmlnaHQgPSBfcmVxdWlyZS5nZXRSaWdodCxcbiAgcHVzaEFycmF5ID0gX3JlcXVpcmUucHVzaEFycmF5O1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uL3RyYWl0cy5qc1wiKSxcbiAgZ2V0RXhwYW5kVG9EZWZhdWx0ID0gX3JlcXVpcmUyLmdldEV4cGFuZFRvRGVmYXVsdDtcbnZhciBfcmVxdWlyZTMgPSByZXF1aXJlKFwiLi4vZXJyb3JzLmpzXCIpLFxuICBnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uID0gX3JlcXVpcmUzLmdldFVubWF0Y2hlZExvb3BFeGNlcHRpb24sXG4gIGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcgPSBfcmVxdWlyZTMuZ2V0Q2xvc2luZ1RhZ05vdE1hdGNoT3BlbmluZ1RhZyxcbiAgZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24gPSBfcmVxdWlyZTMuZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb247XG5mdW5jdGlvbiBnZXRPcGVuQ291bnRDaGFuZ2UocGFydCkge1xuICBzd2l0Y2ggKHBhcnQubG9jYXRpb24pIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgIHJldHVybiAtMTtcbiAgfVxufVxuZnVuY3Rpb24gbWF0Y2goc3RhcnQsIGVuZCkge1xuICByZXR1cm4gc3RhcnQgIT0gbnVsbCAmJiBlbmQgIT0gbnVsbCAmJiAoc3RhcnQucGFydC5sb2NhdGlvbiA9PT0gXCJzdGFydFwiICYmIGVuZC5wYXJ0LmxvY2F0aW9uID09PSBcImVuZFwiICYmIHN0YXJ0LnBhcnQudmFsdWUgPT09IGVuZC5wYXJ0LnZhbHVlIHx8IGVuZC5wYXJ0LnZhbHVlID09PSBcIlwiKTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybWVyKHRyYWl0cykge1xuICB2YXIgaSA9IDA7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgd2hpbGUgKGkgPCB0cmFpdHMubGVuZ3RoKSB7XG4gICAgdmFyIHBhcnQgPSB0cmFpdHNbaV0ucGFydDtcbiAgICBpZiAocGFydC5sb2NhdGlvbiA9PT0gXCJlbmRcIikge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdHJhaXRzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5tYXRjaGVkTG9vcEV4Y2VwdGlvbihwYXJ0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhaXRzOiB0cmFpdHMsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHZhciBlbmRJbmRleCA9IGk7XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGkgLSAxO1xuICAgICAgdmFyIG9mZnNldGVyID0gMTtcbiAgICAgIGlmIChtYXRjaCh0cmFpdHNbc3RhcnRJbmRleF0sIHRyYWl0c1tlbmRJbmRleF0pKSB7XG4gICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgICB0cmFpdHMuc3BsaWNlKHN0YXJ0SW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICAgIHRyYWl0czogdHJhaXRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB3aGlsZSAob2Zmc2V0ZXIgPCA1MCkge1xuICAgICAgICB2YXIgc3RhcnRDYW5kaWRhdGUgPSB0cmFpdHNbc3RhcnRJbmRleCAtIG9mZnNldGVyXTtcbiAgICAgICAgdmFyIGVuZENhbmRpZGF0ZSA9IHRyYWl0c1tlbmRJbmRleCArIG9mZnNldGVyXTtcbiAgICAgICAgaWYgKG1hdGNoKHN0YXJ0Q2FuZGlkYXRlLCB0cmFpdHNbZW5kSW5kZXhdKSkge1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2Uoc3RhcnRJbmRleCAtIG9mZnNldGVyLCAxKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB0cmFpdHM6IHRyYWl0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKHRyYWl0c1tzdGFydEluZGV4XSwgZW5kQ2FuZGlkYXRlKSkge1xuICAgICAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXggKyBvZmZzZXRlciwgMSk7XG4gICAgICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICB0cmFpdHM6IHRyYWl0c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ZXIrKztcbiAgICAgIH1cbiAgICAgIGVycm9ycy5wdXNoKGdldENsb3NpbmdUYWdOb3RNYXRjaE9wZW5pbmdUYWcoe1xuICAgICAgICB0YWdzOiBbdHJhaXRzW3N0YXJ0SW5kZXhdLnBhcnQsIHRyYWl0c1tlbmRJbmRleF0ucGFydF1cbiAgICAgIH0pKTtcbiAgICAgIHRyYWl0cy5zcGxpY2UoZW5kSW5kZXgsIDEpO1xuICAgICAgdHJhaXRzLnNwbGljZShzdGFydEluZGV4LCAxKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYWl0czogdHJhaXRzLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRyYWl0cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9wYXJ0ID0gdHJhaXRzW19pMl0ucGFydDtcbiAgICBlcnJvcnMucHVzaChnZXRVbm1hdGNoZWRMb29wRXhjZXB0aW9uKF9wYXJ0KSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0cmFpdHM6IFtdLFxuICAgIGVycm9yczogZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWlycyh0cmFpdHMpIHtcbiAgdmFyIGxldmVsVHJhaXRzID0ge307XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHBhaXJzID0gW107XG4gIHZhciB0cmFuc2Zvcm1lZFRyYWl0cyA9IFtdO1xuICBwdXNoQXJyYXkodHJhbnNmb3JtZWRUcmFpdHMsIHRyYWl0cyk7XG4gIHdoaWxlICh0cmFuc2Zvcm1lZFRyYWl0cy5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybWVyKHRyYW5zZm9ybWVkVHJhaXRzKTtcbiAgICBwdXNoQXJyYXkoZXJyb3JzLCByZXN1bHQuZXJyb3JzKTtcbiAgICB0cmFuc2Zvcm1lZFRyYWl0cyA9IHJlc3VsdC50cmFpdHM7XG4gIH1cblxuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGNoZWNrIG1ha2VzIHRoZSBmdW5jdGlvbiByZXR1cm4gcXVpY2tlclxuICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGFpcnM6IHBhaXJzLFxuICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICB9O1xuICB9XG4gIC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgdmFyIGNvdW50T3BlbiA9IDA7XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHRyYWl0cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGN1cnJlbnRUcmFpdCA9IHRyYWl0c1tfaTRdO1xuICAgIHZhciBwYXJ0ID0gY3VycmVudFRyYWl0LnBhcnQ7XG4gICAgdmFyIGNoYW5nZSA9IGdldE9wZW5Db3VudENoYW5nZShwYXJ0KTtcbiAgICBjb3VudE9wZW4gKz0gY2hhbmdlO1xuICAgIGlmIChjaGFuZ2UgPT09IDEpIHtcbiAgICAgIGxldmVsVHJhaXRzW2NvdW50T3Blbl0gPSBjdXJyZW50VHJhaXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydFRyYWl0ID0gbGV2ZWxUcmFpdHNbY291bnRPcGVuICsgMV07XG4gICAgICBpZiAoY291bnRPcGVuID09PSAwKSB7XG4gICAgICAgIHBhaXJzLnB1c2goW3N0YXJ0VHJhaXQsIGN1cnJlbnRUcmFpdF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb3VudE9wZW4gPSBjb3VudE9wZW4gPj0gMCA/IGNvdW50T3BlbiA6IDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwYWlyczogcGFpcnMsXG4gICAgZXJyb3JzOiBlcnJvcnNcbiAgfTtcbn1cbnZhciBFeHBhbmRQYWlyVHJhaXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFeHBhbmRQYWlyVHJhaXQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV4cGFuZFBhaXJUcmFpdCk7XG4gICAgdGhpcy5uYW1lID0gXCJFeHBhbmRQYWlyVHJhaXRcIjtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEV4cGFuZFBhaXJUcmFpdCwgW3tcbiAgICBrZXk6IFwib3B0aW9uc1RyYW5zZm9ybWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wdGlvbnNUcmFuc2Zvcm1lcihvcHRpb25zLCBkb2N4dGVtcGxhdGVyKSB7XG4gICAgICBpZiAoZG9jeHRlbXBsYXRlci5vcHRpb25zLnBhcmFncmFwaExvb3ApIHtcbiAgICAgICAgcHVzaEFycmF5KGRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGVDb25maWcuZXhwYW5kVGFncywgZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5vblBhcmFncmFwaExvb3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5leHBhbmRUYWdzID0gZG9jeHRlbXBsYXRlci5maWxlVHlwZUNvbmZpZy5leHBhbmRUYWdzO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocG9zdHBhcnNlZCwgX3JlZikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBnZXRUcmFpdHMgPSBfcmVmLmdldFRyYWl0cyxcbiAgICAgICAgX3Bvc3RwYXJzZSA9IF9yZWYucG9zdHBhcnNlLFxuICAgICAgICBmaWxlVHlwZSA9IF9yZWYuZmlsZVR5cGU7XG4gICAgICB2YXIgdHJhaXRzID0gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcG9zdHBhcnNlZCk7XG4gICAgICB0cmFpdHMgPSB0cmFpdHMubWFwKGZ1bmN0aW9uICh0cmFpdCkge1xuICAgICAgICByZXR1cm4gdHJhaXQgfHwgW107XG4gICAgICB9KTtcbiAgICAgIHRyYWl0cyA9IG1lcmdlU29ydCh0cmFpdHMpO1xuICAgICAgdmFyIF9nZXRQYWlycyA9IGdldFBhaXJzKHRyYWl0cyksXG4gICAgICAgIHBhaXJzID0gX2dldFBhaXJzLnBhaXJzLFxuICAgICAgICBlcnJvcnMgPSBfZ2V0UGFpcnMuZXJyb3JzO1xuICAgICAgdmFyIGxhc3RSaWdodCA9IDA7XG4gICAgICB2YXIgbGFzdFBhaXIgPSBudWxsO1xuICAgICAgdmFyIGV4cGFuZGVkUGFpcnMgPSBwYWlycy5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgdmFyIGV4cGFuZFRvID0gcGFpclswXS5wYXJ0LmV4cGFuZFRvO1xuICAgICAgICBpZiAoZXhwYW5kVG8gPT09IFwiYXV0b1wiICYmIGZpbGVUeXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBnZXRFeHBhbmRUb0RlZmF1bHQocG9zdHBhcnNlZCwgcGFpciwgX3RoaXMuZXhwYW5kVGFncyk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVzdWx0LmVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwYW5kVG8gPSByZXN1bHQudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleHBhbmRUbyB8fCBmaWxlVHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICB2YXIgX2xlZnQgPSBwYWlyWzBdLm9mZnNldDtcbiAgICAgICAgICB2YXIgX3JpZ2h0ID0gcGFpclsxXS5vZmZzZXQ7XG4gICAgICAgICAgaWYgKF9sZWZ0IDwgbGFzdFJpZ2h0ICYmICFfdGhpcy5kb2N4dGVtcGxhdGVyLm9wdGlvbnMuc3ludGF4LmFsbG93VW5iYWxhbmNlZExvb3BzKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaChnZXRVbmJhbGFuY2VkTG9vcEV4Y2VwdGlvbihwYWlyLCBsYXN0UGFpcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0UGFpciA9IHBhaXI7XG4gICAgICAgICAgbGFzdFJpZ2h0ID0gX3JpZ2h0O1xuICAgICAgICAgIHJldHVybiBbX2xlZnQsIF9yaWdodF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlZnQsIHJpZ2h0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxlZnQgPSBnZXRMZWZ0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBwYWlyWzBdLm9mZnNldCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJpZ2h0ID0gZ2V0UmlnaHQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIHBhaXJbMV0ub2Zmc2V0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0IDwgbGFzdFJpZ2h0ICYmICFfdGhpcy5kb2N4dGVtcGxhdGVyLm9wdGlvbnMuc3ludGF4LmFsbG93VW5iYWxhbmNlZExvb3BzKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2goZ2V0VW5iYWxhbmNlZExvb3BFeGNlcHRpb24ocGFpciwgbGFzdFBhaXIpKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UmlnaHQgPSByaWdodDtcbiAgICAgICAgbGFzdFBhaXIgPSBwYWlyO1xuICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGNoZWNrIG1ha2VzIHRoZSBmdW5jdGlvbiByZXR1cm4gcXVpY2tlclxuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICAgICAgdmFyIGN1cnJlbnRQYWlySW5kZXggPSAwO1xuICAgICAgdmFyIGlubmVyUGFydHM7XG4gICAgICB2YXIgbmV3UGFyc2VkID0gcG9zdHBhcnNlZC5yZWR1Y2UoZnVuY3Rpb24gKG5ld1BhcnNlZCwgcGFydCwgaSkge1xuICAgICAgICB2YXIgaW5QYWlyID0gY3VycmVudFBhaXJJbmRleCA8IHBhaXJzLmxlbmd0aCAmJiBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdWzBdIDw9IGkgJiYgaSA8PSBleHBhbmRlZFBhaXJzW2N1cnJlbnRQYWlySW5kZXhdWzFdO1xuICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2N1cnJlbnRQYWlySW5kZXhdO1xuICAgICAgICB2YXIgZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgaWYgKCFpblBhaXIpIHtcbiAgICAgICAgICBuZXdQYXJzZWQucHVzaChwYXJ0KTtcbiAgICAgICAgICByZXR1cm4gbmV3UGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlJ3JlIGluc2lkZSB0aGUgcGFpclxuICAgICAgICBpZiAoZXhwYW5kZWRQYWlyWzBdID09PSBpKSB7XG4gICAgICAgICAgLy8gU3RhcnQgcGFpclxuICAgICAgICAgIGlubmVyUGFydHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFpclswXS5vZmZzZXQgIT09IGkgJiYgcGFpclsxXS5vZmZzZXQgIT09IGkpIHtcbiAgICAgICAgICAvLyBFeGNsdWRlIGlubmVyIHBhaXIgaW5kZXhlc1xuICAgICAgICAgIGlubmVyUGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwYW5kZWRQYWlyWzFdID09PSBpKSB7XG4gICAgICAgICAgLy8gRW5kIHBhaXJcbiAgICAgICAgICB2YXIgYmFzZVBhcnQgPSBwb3N0cGFyc2VkW3BhaXJbMF0ub2Zmc2V0XTtcbiAgICAgICAgICBiYXNlUGFydC5zdWJwYXJzZWQgPSBfcG9zdHBhcnNlKGlubmVyUGFydHMsIHtcbiAgICAgICAgICAgIGJhc2VQYXJ0OiBiYXNlUGFydFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJhc2VQYXJ0LmVuZExpbmRleCA9IHBhaXJbMV0ucGFydC5sSW5kZXg7XG4gICAgICAgICAgZGVsZXRlIGJhc2VQYXJ0LmxvY2F0aW9uO1xuICAgICAgICAgIGRlbGV0ZSBiYXNlUGFydC5leHBhbmRUbztcbiAgICAgICAgICBuZXdQYXJzZWQucHVzaChiYXNlUGFydCk7XG4gICAgICAgICAgY3VycmVudFBhaXJJbmRleCsrO1xuICAgICAgICAgIHZhciBfZXhwYW5kZWRQYWlyID0gZXhwYW5kZWRQYWlyc1tjdXJyZW50UGFpckluZGV4XTtcbiAgICAgICAgICB3aGlsZSAoX2V4cGFuZGVkUGFpciAmJiBfZXhwYW5kZWRQYWlyWzBdIDwgaSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgOlxuICAgICAgICAgICAgICogZXhwYW5kZWRQYWlycyA9W1s1LDcyXSxbNTEsNjddLFs5MCwxMDZdXVxuICAgICAgICAgICAgICogVGhlbiBhZnRlciB0cmVhdGluZyBbNSw3Ml0sIHdlIG5lZWQgdG8gdHJlYXQgWzkwLDEwNl1cbiAgICAgICAgICAgICAqIEZpeGVkIHNpbmNlIHYzLjU4LjRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY3VycmVudFBhaXJJbmRleCsrO1xuICAgICAgICAgICAgX2V4cGFuZGVkUGFpciA9IGV4cGFuZGVkUGFpcnNbY3VycmVudFBhaXJJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdQYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0cGFyc2VkOiBuZXdQYXJzZWQsXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBFeHBhbmRQYWlyVHJhaXQoKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/expand-pair-trait.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/loop.js":
/*!***********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/loop.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  chunkBy = _require.chunkBy,\n  last = _require.last,\n  isParagraphStart = _require.isParagraphStart,\n  isModule = _require.isModule,\n  pushArray = _require.pushArray,\n  isParagraphEnd = _require.isParagraphEnd,\n  isContent = _require.isContent,\n  startsWith = _require.startsWith,\n  isTagEnd = _require.isTagEnd,\n  isTagStart = _require.isTagStart,\n  getSingleAttribute = _require.getSingleAttribute,\n  setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = __webpack_require__(/*! ../filetypes.js */ \"(rsc)/../../node_modules/docxtemplater/js/filetypes.js\");\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n  return parts.some(function (part) {\n    return isContent(part);\n  });\n}\nfunction getFirstMeaningFulPart(parsed) {\n  for (var _i2 = 0; _i2 < parsed.length; _i2++) {\n    var part = parsed[_i2];\n    if (part.type !== \"content\") {\n      return part;\n    }\n  }\n  return null;\n}\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n  return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n  return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n  var j = subRendered.parts.length - 1;\n  if (subRendered.parts[j] === \"</w:p>\") {\n    subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n  } else {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n  });\n}\nfunction isNextPage(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n  });\n}\nfunction addSectionBefore(parts, sect) {\n  return pushArray([\"<w:p><w:pPr>\".concat(sect.map(function (_ref) {\n    var value = _ref.value;\n    return value;\n  }).join(\"\"), \"</w:pPr></w:p>\")], parts);\n}\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  var result = [];\n  for (var _i4 = 0; _i4 < parts.length; _i4++) {\n    var part = parts[_i4];\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\n        result.push('<w:type w:val=\"continuous\"/>');\n      }\n    }\n    result.push(part);\n  }\n  return result;\n}\nfunction dropHeaderFooterRefs(parts) {\n  return parts.filter(function (text) {\n    return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n  });\n}\nfunction hasPageBreak(chunk) {\n  return chunk.some(function (part) {\n    return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n  });\n}\nfunction hasImage(chunk) {\n  return chunk.some(function (_ref2) {\n    var tag = _ref2.tag;\n    return tag === \"w:drawing\";\n  });\n}\nfunction getSectPr(chunks) {\n  var collectSectPr = false;\n  var sectPrs = [];\n  for (var _i6 = 0; _i6 < chunks.length; _i6++) {\n    var part = chunks[_i6];\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPrs.push([]);\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      sectPrs[sectPrs.length - 1].push(part);\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  for (var _i8 = 0; _i8 < chunks.length; _i8++) {\n    var part = chunks[_i8];\n    if (isTagStart(\"w:sectPr\", part)) {\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  }\n  return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n  var sectPr = [];\n  var inSectPr = false;\n  for (var i = parsed.length - 1; i >= 0; i--) {\n    var part = parsed[i];\n    if (isTagEnd(\"w:sectPr\", part)) {\n      inSectPr = true;\n    }\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPr.unshift(part.value);\n      inSectPr = false;\n    }\n    if (inSectPr) {\n      sectPr.unshift(part.value);\n    }\n    if (isParagraphStart(part)) {\n      if (sectPr.length > 0) {\n        return sectPr.join(\"\");\n      }\n      break;\n    }\n  }\n  return \"\";\n}\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n    this.name = \"LoopModule\";\n    this.inXfrm = false;\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)/,\n      inverted: \"^\"\n    };\n  }\n  return _createClass(LoopModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(opts, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      return opts;\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse(parsed, _ref3) {\n      var contentType = _ref3.contentType;\n      if (filetypes.main.indexOf(contentType) !== -1) {\n        this.sects = getSectPr(parsed);\n      }\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      var module = moduleName;\n      return [[this.prefix.start, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: false\n      }], [this.prefix.inverted, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: true\n      }], [this.prefix.end, module, {\n        location: \"end\"\n      }], [this.prefix.dash, module, function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 3),\n          expandTo = _ref5[1],\n          value = _ref5[2];\n        return {\n          location: \"start\",\n          inverted: false,\n          expandTo: expandTo,\n          value: value\n        };\n      }]];\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      // Stryker disable all : because getTraits should disappear in v4\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n      // Stryker restore all\n\n      var tags = [];\n      for (var offset = 0, len = parsed.length; offset < len; offset++) {\n        var part = parsed[offset];\n        if (isModule(part, moduleName) && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n      }\n      return tags;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref6) {\n      var basePart = _ref6.basePart;\n      if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        this.totalSectPr += basePart.sectPrCount;\n        var sects = this.sects;\n        sects.some(function (sect, index) {\n          if (basePart.lIndex < sect[0].lIndex) {\n            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n              basePart.addContinuousType = true;\n            }\n            return true;\n          }\n          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n            if (isNextPage(sects[index])) {\n              basePart.addNextPage = {\n                index: index\n              };\n            }\n            return true;\n          }\n        });\n        basePart.lastParagrapSectPr = getLastSectPr(parsed);\n      }\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n      basePart.paragraphLoop = true;\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n        if (isParagraphEnd(p)) {\n          level--;\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n        return null;\n      });\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      if (hasImage(firstChunk)) {\n        firstOffset = 0;\n      }\n      if (hasImage(lastChunk)) {\n        lastOffset = 0;\n      }\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        promises.push(options.resolve(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        })));\n      }\n      var errorList = [];\n      return promisedValue.then(function (values) {\n        values !== null && values !== void 0 ? values : values = options.nullGetter(part);\n        return new Promise(function (resolve) {\n          if (values instanceof Promise) {\n            return values.then(function (values) {\n              if (values instanceof Array) {\n                Promise.all(values).then(resolve);\n              } else {\n                resolve(values);\n              }\n            });\n          }\n          if (values instanceof Array) {\n            Promise.all(values).then(resolve);\n          } else {\n            resolve(values);\n          }\n        }).then(function (values) {\n          sm.loopOverValue(values, loopOver, part.inverted);\n          return Promise.all(promises).then(function (r) {\n            return r.map(function (_ref7) {\n              var resolved = _ref7.resolved,\n                errors = _ref7.errors;\n              pushArray(errorList, errors);\n              return resolved;\n            });\n          }).then(function (value) {\n            if (errorList.length > 0) {\n              throw errorList;\n            }\n            return value;\n          });\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.tag === \"p:xfrm\") {\n        this.inXfrm = part.position === \"start\";\n      }\n      if (part.tag === \"a:ext\" && this.inXfrm) {\n        this.lastExt = part;\n        return part;\n      }\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var totalValue = [];\n      var errors = [];\n      var heightOffset = 0;\n      var self = this;\n      var firstTag = part.subparsed[0];\n      var tagHeight = 0;\n      if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n        tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n      }\n      heightOffset -= tagHeight;\n      var a16RowIdOffset = 0;\n      var insideParagraphLoop = isInsideParagraphLoop(part);\n      function loopOver(scope, i, length) {\n        heightOffset += tagHeight;\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        for (var _i0 = 0, _part$subparsed2 = part.subparsed; _i0 < _part$subparsed2.length; _i0++) {\n          var pp = _part$subparsed2[_i0];\n          if (isTagStart(\"a16:rowId\", pp)) {\n            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n            a16RowIdOffset = 1;\n            pp.value = setSingleAttribute(pp.value, \"val\", val);\n          }\n        }\n        var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n        if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n          addPageBreakAtEnd(subRendered);\n        }\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n          if (part.addContinuousType) {\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        } else if (part.addNextPage) {\n          subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n        }\n        if (part.addNextPage) {\n          addPageBreakAtEnd(subRendered);\n        }\n        if (part.hasPageBreakBeginning && insideParagraphLoop) {\n          addPageBreakAtBeginning(subRendered);\n        }\n        for (var _i10 = 0, _subRendered$parts2 = subRendered.parts; _i10 < _subRendered$parts2.length; _i10++) {\n          var _val = _subRendered$parts2[_i10];\n          totalValue.push(_val);\n        }\n        pushArray(errors, subRendered.errors);\n      }\n      var value = options.scopeManager.getValue(part.value, {\n        part: part\n      });\n      value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      var result = options.scopeManager.loopOverValue(value, loopOver, part.inverted);\n      // if the loop is showing empty content\n      if (result === false) {\n        if (part.lastParagrapSectPr) {\n          if (part.paragraphLoop) {\n            return {\n              value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n            };\n          }\n          return {\n            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n          };\n        }\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n      if (heightOffset !== 0) {\n        var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n        /*\n         * We do edit the value of a previous result here\n         * #edit-value-backwards\n         */\n        this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n      }\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9sb29wLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQywrRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQWlCO0FBQ3pDLGNBQWMsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELCtCQUErQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxjQUFjO0FBQ3JGO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxtQ0FBbUM7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsY0FBYztBQUM3RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9sb29wLmpzPzc1NTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBjaHVua0J5ID0gX3JlcXVpcmUuY2h1bmtCeSxcbiAgbGFzdCA9IF9yZXF1aXJlLmxhc3QsXG4gIGlzUGFyYWdyYXBoU3RhcnQgPSBfcmVxdWlyZS5pc1BhcmFncmFwaFN0YXJ0LFxuICBpc01vZHVsZSA9IF9yZXF1aXJlLmlzTW9kdWxlLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXksXG4gIGlzUGFyYWdyYXBoRW5kID0gX3JlcXVpcmUuaXNQYXJhZ3JhcGhFbmQsXG4gIGlzQ29udGVudCA9IF9yZXF1aXJlLmlzQ29udGVudCxcbiAgc3RhcnRzV2l0aCA9IF9yZXF1aXJlLnN0YXJ0c1dpdGgsXG4gIGlzVGFnRW5kID0gX3JlcXVpcmUuaXNUYWdFbmQsXG4gIGlzVGFnU3RhcnQgPSBfcmVxdWlyZS5pc1RhZ1N0YXJ0LFxuICBnZXRTaW5nbGVBdHRyaWJ1dGUgPSBfcmVxdWlyZS5nZXRTaW5nbGVBdHRyaWJ1dGUsXG4gIHNldFNpbmdsZUF0dHJpYnV0ZSA9IF9yZXF1aXJlLnNldFNpbmdsZUF0dHJpYnV0ZTtcbnZhciBmaWxldHlwZXMgPSByZXF1aXJlKFwiLi4vZmlsZXR5cGVzLmpzXCIpO1xudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgbW9kdWxlTmFtZSA9IFwibG9vcFwiO1xuZnVuY3Rpb24gaGFzQ29udGVudChwYXJ0cykge1xuICByZXR1cm4gcGFydHMuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBpc0NvbnRlbnQocGFydCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RNZWFuaW5nRnVsUGFydChwYXJzZWQpIHtcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgcGFyc2VkLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgcGFydCA9IHBhcnNlZFtfaTJdO1xuICAgIGlmIChwYXJ0LnR5cGUgIT09IFwiY29udGVudFwiKSB7XG4gICAgICByZXR1cm4gcGFydDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0luc2lkZVBhcmFncmFwaExvb3AocGFydCkge1xuICB2YXIgZmlyc3RNZWFuaW5nZnVsUGFydCA9IGdldEZpcnN0TWVhbmluZ0Z1bFBhcnQocGFydC5zdWJwYXJzZWQpO1xuICByZXR1cm4gZmlyc3RNZWFuaW5nZnVsUGFydCAhPSBudWxsICYmIGZpcnN0TWVhbmluZ2Z1bFBhcnQudGFnICE9PSBcInc6dFwiO1xufVxuZnVuY3Rpb24gZ2V0UGFnZUJyZWFrSWZBcHBsaWVzKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQuaGFzUGFnZUJyZWFrICYmIGlzSW5zaWRlUGFyYWdyYXBoTG9vcChwYXJ0KSA/ICc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj48L3c6cD4nIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGlzRW5jbG9zZWRCeVBhcmFncmFwaHMocGFyc2VkKSB7XG4gIHJldHVybiBwYXJzZWQubGVuZ3RoICYmIGlzUGFyYWdyYXBoU3RhcnQocGFyc2VkWzBdKSAmJiBpc1BhcmFncmFwaEVuZChsYXN0KHBhcnNlZCkpO1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGNodW5rKSB7XG4gIHJldHVybiBoYXNDb250ZW50KGNodW5rKSA/IDAgOiBjaHVuay5sZW5ndGg7XG59XG5mdW5jdGlvbiBhZGRQYWdlQnJlYWtBdEVuZChzdWJSZW5kZXJlZCkge1xuICB2YXIgaiA9IHN1YlJlbmRlcmVkLnBhcnRzLmxlbmd0aCAtIDE7XG4gIGlmIChzdWJSZW5kZXJlZC5wYXJ0c1tqXSA9PT0gXCI8L3c6cD5cIikge1xuICAgIHN1YlJlbmRlcmVkLnBhcnRzLnNwbGljZShqLCAwLCAnPHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPicpO1xuICB9IGVsc2Uge1xuICAgIHN1YlJlbmRlcmVkLnBhcnRzLnB1c2goJzx3OnA+PHc6cj48dzpiciB3OnR5cGU9XCJwYWdlXCIvPjwvdzpyPjwvdzpwPicpO1xuICB9XG59XG5mdW5jdGlvbiBhZGRQYWdlQnJlYWtBdEJlZ2lubmluZyhzdWJSZW5kZXJlZCkge1xuICBzdWJSZW5kZXJlZC5wYXJ0cy51bnNoaWZ0KCc8dzpwPjx3OnI+PHc6YnIgdzp0eXBlPVwicGFnZVwiLz48L3c6cj48L3c6cD4nKTtcbn1cbmZ1bmN0aW9uIGlzQ29udGludW91cyhwYXJ0cykge1xuICByZXR1cm4gcGFydHMuc29tZShmdW5jdGlvbiAocGFydCkge1xuICAgIHJldHVybiBpc1RhZ1N0YXJ0KFwidzp0eXBlXCIsIHBhcnQpICYmIHBhcnQudmFsdWUuaW5kZXhPZihcImNvbnRpbnVvdXNcIikgIT09IC0xO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTmV4dFBhZ2UocGFydHMpIHtcbiAgcmV0dXJuIHBhcnRzLnNvbWUoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICByZXR1cm4gaXNUYWdTdGFydChcInc6dHlwZVwiLCBwYXJ0KSAmJiBwYXJ0LnZhbHVlLmluZGV4T2YoJ3c6dmFsPVwibmV4dFBhZ2VcIicpICE9PSAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRTZWN0aW9uQmVmb3JlKHBhcnRzLCBzZWN0KSB7XG4gIHJldHVybiBwdXNoQXJyYXkoW1wiPHc6cD48dzpwUHI+XCIuY29uY2F0KHNlY3QubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIHZhbHVlID0gX3JlZi52YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0pLmpvaW4oXCJcIiksIFwiPC93OnBQcj48L3c6cD5cIildLCBwYXJ0cyk7XG59XG5mdW5jdGlvbiBhZGRDb250aW51b3VzVHlwZShwYXJ0cykge1xuICB2YXIgc3RvcCA9IGZhbHNlO1xuICB2YXIgaW5TZWN0UHIgPSBmYWxzZTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBwYXJ0cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJ0c1tfaTRdO1xuICAgIGlmIChzdG9wID09PSBmYWxzZSAmJiBzdGFydHNXaXRoKHBhcnQsIFwiPHc6c2VjdFByXCIpKSB7XG4gICAgICBpblNlY3RQciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpblNlY3RQcikge1xuICAgICAgaWYgKHN0YXJ0c1dpdGgocGFydCwgXCI8dzp0eXBlXCIpKSB7XG4gICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3AgPT09IGZhbHNlICYmIHN0YXJ0c1dpdGgocGFydCwgXCI8L3c6c2VjdFByXCIpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCc8dzp0eXBlIHc6dmFsPVwiY29udGludW91c1wiLz4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocGFydCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRyb3BIZWFkZXJGb290ZXJSZWZzKHBhcnRzKSB7XG4gIHJldHVybiBwYXJ0cy5maWx0ZXIoZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpoZWFkZXJSZWZlcmVuY2VcIikgJiYgIXN0YXJ0c1dpdGgodGV4dCwgXCI8dzpmb290ZXJSZWZlcmVuY2VcIik7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzUGFnZUJyZWFrKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay5zb21lKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIHBhcnQudGFnID09PSBcInc6YnJcIiAmJiBwYXJ0LnZhbHVlLmluZGV4T2YoJ3c6dHlwZT1cInBhZ2VcIicpICE9PSAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoYXNJbWFnZShjaHVuaykge1xuICByZXR1cm4gY2h1bmsuc29tZShmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgdGFnID0gX3JlZjIudGFnO1xuICAgIHJldHVybiB0YWcgPT09IFwidzpkcmF3aW5nXCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFByKGNodW5rcykge1xuICB2YXIgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICB2YXIgc2VjdFBycyA9IFtdO1xuICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBjaHVua3MubGVuZ3RoOyBfaTYrKykge1xuICAgIHZhciBwYXJ0ID0gY2h1bmtzW19pNl07XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFBycy5wdXNoKFtdKTtcbiAgICAgIGNvbGxlY3RTZWN0UHIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29sbGVjdFNlY3RQcikge1xuICAgICAgc2VjdFByc1tzZWN0UHJzLmxlbmd0aCAtIDFdLnB1c2gocGFydCk7XG4gICAgfVxuICAgIGlmIChpc1RhZ0VuZChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZWN0UHJzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdFBySGVhZGVyRm9vdGVyQ2hhbmdlQ291bnQoY2h1bmtzKSB7XG4gIHZhciBjb2xsZWN0U2VjdFByID0gZmFsc2U7XG4gIHZhciBzZWN0UHJDb3VudCA9IDA7XG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGNodW5rcy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIHBhcnQgPSBjaHVua3NbX2k4XTtcbiAgICBpZiAoaXNUYWdTdGFydChcInc6c2VjdFByXCIsIHBhcnQpKSB7XG4gICAgICBjb2xsZWN0U2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNvbGxlY3RTZWN0UHIpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJ3OmhlYWRlclJlZmVyZW5jZVwiIHx8IHBhcnQudGFnID09PSBcInc6Zm9vdGVyUmVmZXJlbmNlXCIpIHtcbiAgICAgICAgc2VjdFByQ291bnQrKztcbiAgICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUYWdFbmQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgY29sbGVjdFNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VjdFByQ291bnQ7XG59XG5mdW5jdGlvbiBnZXRMYXN0U2VjdFByKHBhcnNlZCkge1xuICB2YXIgc2VjdFByID0gW107XG4gIHZhciBpblNlY3RQciA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gcGFyc2VkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBwYXJzZWRbaV07XG4gICAgaWYgKGlzVGFnRW5kKFwidzpzZWN0UHJcIiwgcGFydCkpIHtcbiAgICAgIGluU2VjdFByID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzVGFnU3RhcnQoXCJ3OnNlY3RQclwiLCBwYXJ0KSkge1xuICAgICAgc2VjdFByLnVuc2hpZnQocGFydC52YWx1ZSk7XG4gICAgICBpblNlY3RQciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaW5TZWN0UHIpIHtcbiAgICAgIHNlY3RQci51bnNoaWZ0KHBhcnQudmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNQYXJhZ3JhcGhTdGFydChwYXJ0KSkge1xuICAgICAgaWYgKHNlY3RQci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzZWN0UHIuam9pbihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBMb29wTW9kdWxlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9vcE1vZHVsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTG9vcE1vZHVsZSk7XG4gICAgdGhpcy5uYW1lID0gXCJMb29wTW9kdWxlXCI7XG4gICAgdGhpcy5pblhmcm0gPSBmYWxzZTtcbiAgICB0aGlzLnRvdGFsU2VjdFByID0gMDtcbiAgICB0aGlzLnByZWZpeCA9IHtcbiAgICAgIHN0YXJ0OiBcIiNcIixcbiAgICAgIGVuZDogXCIvXCIsXG4gICAgICBkYXNoOiAvXi0oW15cXHNdKylcXHMoLispLyxcbiAgICAgIGludmVydGVkOiBcIl5cIlxuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMb29wTW9kdWxlLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdHMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZG9jeHRlbXBsYXRlciA9IGRvY3h0ZW1wbGF0ZXI7XG4gICAgICByZXR1cm4gb3B0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBfcmVmMykge1xuICAgICAgdmFyIGNvbnRlbnRUeXBlID0gX3JlZjMuY29udGVudFR5cGU7XG4gICAgICBpZiAoZmlsZXR5cGVzLm1haW4uaW5kZXhPZihjb250ZW50VHlwZSkgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuc2VjdHMgPSBnZXRTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlcnMoKSB7XG4gICAgICB2YXIgbW9kdWxlID0gbW9kdWxlTmFtZTtcbiAgICAgIHJldHVybiBbW3RoaXMucHJlZml4LnN0YXJ0LCBtb2R1bGUsIHtcbiAgICAgICAgZXhwYW5kVG86IFwiYXV0b1wiLFxuICAgICAgICBsb2NhdGlvbjogXCJzdGFydFwiLFxuICAgICAgICBpbnZlcnRlZDogZmFsc2VcbiAgICAgIH1dLCBbdGhpcy5wcmVmaXguaW52ZXJ0ZWQsIG1vZHVsZSwge1xuICAgICAgICBleHBhbmRUbzogXCJhdXRvXCIsXG4gICAgICAgIGxvY2F0aW9uOiBcInN0YXJ0XCIsXG4gICAgICAgIGludmVydGVkOiB0cnVlXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmVuZCwgbW9kdWxlLCB7XG4gICAgICAgIGxvY2F0aW9uOiBcImVuZFwiXG4gICAgICB9XSwgW3RoaXMucHJlZml4LmRhc2gsIG1vZHVsZSwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICAgIHZhciBfcmVmNSA9IF9zbGljZWRUb0FycmF5KF9yZWY0LCAzKSxcbiAgICAgICAgICBleHBhbmRUbyA9IF9yZWY1WzFdLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjVbMl07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbG9jYXRpb246IFwic3RhcnRcIixcbiAgICAgICAgICBpbnZlcnRlZDogZmFsc2UsXG4gICAgICAgICAgZXhwYW5kVG86IGV4cGFuZFRvLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfV1dO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFpdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcGFyc2VkKSB7XG4gICAgICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSBnZXRUcmFpdHMgc2hvdWxkIGRpc2FwcGVhciBpbiB2NFxuICAgICAgaWYgKHRyYWl0TmFtZSAhPT0gXCJleHBhbmRQYWlyXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuXG4gICAgICB2YXIgdGFncyA9IFtdO1xuICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMCwgbGVuID0gcGFyc2VkLmxlbmd0aDsgb2Zmc2V0IDwgbGVuOyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgcGFydCA9IHBhcnNlZFtvZmZzZXRdO1xuICAgICAgICBpZiAoaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkgJiYgcGFydC5zdWJwYXJzZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHRhZ3MucHVzaCh7XG4gICAgICAgICAgICBwYXJ0OiBwYXJ0LFxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UocGFyc2VkLCBfcmVmNikge1xuICAgICAgdmFyIGJhc2VQYXJ0ID0gX3JlZjYuYmFzZVBhcnQ7XG4gICAgICBpZiAoYmFzZVBhcnQgJiYgdGhpcy5kb2N4dGVtcGxhdGVyLmZpbGVUeXBlID09PSBcImRvY3hcIiAmJiBwYXJzZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBiYXNlUGFydC5zZWN0UHJDb3VudCA9IGdldFNlY3RQckhlYWRlckZvb3RlckNoYW5nZUNvdW50KHBhcnNlZCk7XG4gICAgICAgIHRoaXMudG90YWxTZWN0UHIgKz0gYmFzZVBhcnQuc2VjdFByQ291bnQ7XG4gICAgICAgIHZhciBzZWN0cyA9IHRoaXMuc2VjdHM7XG4gICAgICAgIHNlY3RzLnNvbWUoZnVuY3Rpb24gKHNlY3QsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGJhc2VQYXJ0LmxJbmRleCA8IHNlY3RbMF0ubEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxIDwgc2VjdHMubGVuZ3RoICYmIGlzQ29udGludW91cyhzZWN0c1tpbmRleCArIDFdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGRDb250aW51b3VzVHlwZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcnNlZFswXS5sSW5kZXggPCBzZWN0WzBdLmxJbmRleCAmJiBzZWN0WzBdLmxJbmRleCA8IGJhc2VQYXJ0LmxJbmRleCkge1xuICAgICAgICAgICAgaWYgKGlzTmV4dFBhZ2Uoc2VjdHNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBiYXNlUGFydC5hZGROZXh0UGFnZSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2VQYXJ0Lmxhc3RQYXJhZ3JhcFNlY3RQciA9IGdldExhc3RTZWN0UHIocGFyc2VkKTtcbiAgICAgIH1cbiAgICAgIGlmICghYmFzZVBhcnQgfHwgYmFzZVBhcnQuZXhwYW5kVG8gIT09IFwiYXV0b1wiIHx8IGJhc2VQYXJ0Lm1vZHVsZSAhPT0gbW9kdWxlTmFtZSB8fCAhaXNFbmNsb3NlZEJ5UGFyYWdyYXBocyhwYXJzZWQpKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBiYXNlUGFydC5wYXJhZ3JhcGhMb29wID0gdHJ1ZTtcbiAgICAgIHZhciBsZXZlbCA9IDA7XG4gICAgICB2YXIgY2h1bmtzID0gY2h1bmtCeShwYXJzZWQsIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGlmIChpc1BhcmFncmFwaFN0YXJ0KHApKSB7XG4gICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICBpZiAobGV2ZWwgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcInN0YXJ0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhcmFncmFwaEVuZChwKSkge1xuICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIHZhciBmaXJzdENodW5rID0gY2h1bmtzWzBdO1xuICAgICAgdmFyIGxhc3RDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICAgIHZhciBmaXJzdE9mZnNldCA9IGdldE9mZnNldChmaXJzdENodW5rKTtcbiAgICAgIHZhciBsYXN0T2Zmc2V0ID0gZ2V0T2Zmc2V0KGxhc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWtCZWdpbm5pbmcgPSBoYXNQYWdlQnJlYWsoZmlyc3RDaHVuayk7XG4gICAgICBiYXNlUGFydC5oYXNQYWdlQnJlYWsgPSBoYXNQYWdlQnJlYWsobGFzdENodW5rKTtcbiAgICAgIGlmIChoYXNJbWFnZShmaXJzdENodW5rKSkge1xuICAgICAgICBmaXJzdE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoaGFzSW1hZ2UobGFzdENodW5rKSkge1xuICAgICAgICBsYXN0T2Zmc2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQuc2xpY2UoZmlyc3RPZmZzZXQsIHBhcnNlZC5sZW5ndGggLSBsYXN0T2Zmc2V0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghaXNNb2R1bGUocGFydCwgbW9kdWxlTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgc20gPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgICAgIHZhciBwcm9taXNlZFZhbHVlID0gc20uZ2V0VmFsdWVBc3luYyhwYXJ0LnZhbHVlLCB7XG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICBmdW5jdGlvbiBsb29wT3ZlcihzY29wZSwgaSwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY29wZU1hbmFnZXIgPSBzbS5jcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHBhcnQudmFsdWUsIGksIHBhcnQsIGxlbmd0aCk7XG4gICAgICAgIHByb21pc2VzLnB1c2gob3B0aW9ucy5yZXNvbHZlKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKSk7XG4gICAgICB9XG4gICAgICB2YXIgZXJyb3JMaXN0ID0gW107XG4gICAgICByZXR1cm4gcHJvbWlzZWRWYWx1ZS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzICE9PSBudWxsICYmIHZhbHVlcyAhPT0gdm9pZCAwID8gdmFsdWVzIDogdmFsdWVzID0gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpZiAodmFsdWVzIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFsdWVzKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwodmFsdWVzKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgICBzbS5sb29wT3ZlclZhbHVlKHZhbHVlcywgbG9vcE92ZXIsIHBhcnQuaW52ZXJ0ZWQpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHIubWFwKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBfcmVmNy5yZXNvbHZlZCxcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBfcmVmNy5lcnJvcnM7XG4gICAgICAgICAgICAgIHB1c2hBcnJheShlcnJvckxpc3QsIGVycm9ycyk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3JMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdGhyb3cgZXJyb3JMaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJwOnhmcm1cIikge1xuICAgICAgICB0aGlzLmluWGZybSA9IHBhcnQucG9zaXRpb24gPT09IFwic3RhcnRcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gXCJhOmV4dFwiICYmIHRoaXMuaW5YZnJtKSB7XG4gICAgICAgIHRoaXMubGFzdEV4dCA9IHBhcnQ7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfVxuICAgICAgaWYgKCFpc01vZHVsZShwYXJ0LCBtb2R1bGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB0b3RhbFZhbHVlID0gW107XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgaGVpZ2h0T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBmaXJzdFRhZyA9IHBhcnQuc3VicGFyc2VkWzBdO1xuICAgICAgdmFyIHRhZ0hlaWdodCA9IDA7XG4gICAgICBpZiAoKGZpcnN0VGFnID09PSBudWxsIHx8IGZpcnN0VGFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFRhZy50YWcpID09PSBcImE6dHJcIikge1xuICAgICAgICB0YWdIZWlnaHQgPSArZ2V0U2luZ2xlQXR0cmlidXRlKGZpcnN0VGFnLnZhbHVlLCBcImhcIik7XG4gICAgICB9XG4gICAgICBoZWlnaHRPZmZzZXQgLT0gdGFnSGVpZ2h0O1xuICAgICAgdmFyIGExNlJvd0lkT2Zmc2V0ID0gMDtcbiAgICAgIHZhciBpbnNpZGVQYXJhZ3JhcGhMb29wID0gaXNJbnNpZGVQYXJhZ3JhcGhMb29wKHBhcnQpO1xuICAgICAgZnVuY3Rpb24gbG9vcE92ZXIoc2NvcGUsIGksIGxlbmd0aCkge1xuICAgICAgICBoZWlnaHRPZmZzZXQgKz0gdGFnSGVpZ2h0O1xuICAgICAgICB2YXIgc2NvcGVNYW5hZ2VyID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuY3JlYXRlU3ViU2NvcGVNYW5hZ2VyKHNjb3BlLCBwYXJ0LnZhbHVlLCBpLCBwYXJ0LCBsZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBfaTAgPSAwLCBfcGFydCRzdWJwYXJzZWQyID0gcGFydC5zdWJwYXJzZWQ7IF9pMCA8IF9wYXJ0JHN1YnBhcnNlZDIubGVuZ3RoOyBfaTArKykge1xuICAgICAgICAgIHZhciBwcCA9IF9wYXJ0JHN1YnBhcnNlZDJbX2kwXTtcbiAgICAgICAgICBpZiAoaXNUYWdTdGFydChcImExNjpyb3dJZFwiLCBwcCkpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSArZ2V0U2luZ2xlQXR0cmlidXRlKHBwLnZhbHVlLCBcInZhbFwiKSArIGExNlJvd0lkT2Zmc2V0O1xuICAgICAgICAgICAgYTE2Um93SWRPZmZzZXQgPSAxO1xuICAgICAgICAgICAgcHAudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUocHAudmFsdWUsIFwidmFsXCIsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJSZW5kZXJlZCA9IG9wdGlvbnMucmVuZGVyKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tcGlsZWQ6IHBhcnQuc3VicGFyc2VkLFxuICAgICAgICAgIHRhZ3M6IHt9LFxuICAgICAgICAgIHNjb3BlTWFuYWdlcjogc2NvcGVNYW5hZ2VyXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBhcnQuaGFzUGFnZUJyZWFrICYmIGkgPT09IGxlbmd0aCAtIDEgJiYgaW5zaWRlUGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgIGFkZFBhZ2VCcmVha0F0RW5kKHN1YlJlbmRlcmVkKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNOb3RGaXJzdCA9IHNjb3BlTWFuYWdlci5zY29wZVBhdGhJdGVtLnNvbWUoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICByZXR1cm4gaSAhPT0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc05vdEZpcnN0KSB7XG4gICAgICAgICAgaWYgKHBhcnQuc2VjdFByQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHN1YlJlbmRlcmVkLnBhcnRzID0gZHJvcEhlYWRlckZvb3RlclJlZnMoc3ViUmVuZGVyZWQucGFydHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5hZGRDb250aW51b3VzVHlwZSkge1xuICAgICAgICAgICAgc3ViUmVuZGVyZWQucGFydHMgPSBhZGRDb250aW51b3VzVHlwZShzdWJSZW5kZXJlZC5wYXJ0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhcnQuYWRkTmV4dFBhZ2UpIHtcbiAgICAgICAgICBzdWJSZW5kZXJlZC5wYXJ0cyA9IGFkZFNlY3Rpb25CZWZvcmUoc3ViUmVuZGVyZWQucGFydHMsIHNlbGYuc2VjdHNbcGFydC5hZGROZXh0UGFnZS5pbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LmFkZE5leHRQYWdlKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRFbmQoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0Lmhhc1BhZ2VCcmVha0JlZ2lubmluZyAmJiBpbnNpZGVQYXJhZ3JhcGhMb29wKSB7XG4gICAgICAgICAgYWRkUGFnZUJyZWFrQXRCZWdpbm5pbmcoc3ViUmVuZGVyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSAwLCBfc3ViUmVuZGVyZWQkcGFydHMyID0gc3ViUmVuZGVyZWQucGFydHM7IF9pMTAgPCBfc3ViUmVuZGVyZWQkcGFydHMyLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgICAgdmFyIF92YWwgPSBfc3ViUmVuZGVyZWQkcGFydHMyW19pMTBdO1xuICAgICAgICAgIHRvdGFsVmFsdWUucHVzaChfdmFsKTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBzdWJSZW5kZXJlZC5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuZ2V0VmFsdWUocGFydC52YWx1ZSwge1xuICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICB9KTtcbiAgICAgIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHZhbHVlID0gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpO1xuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyLmxvb3BPdmVyVmFsdWUodmFsdWUsIGxvb3BPdmVyLCBwYXJ0LmludmVydGVkKTtcbiAgICAgIC8vIGlmIHRoZSBsb29wIGlzIHNob3dpbmcgZW1wdHkgY29udGVudFxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhcnQubGFzdFBhcmFncmFwU2VjdFByKSB7XG4gICAgICAgICAgaWYgKHBhcnQucGFyYWdyYXBoTG9vcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFwiPHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PC93OnA+XCIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IFwiPC93OnQ+PC93OnI+PC93OnA+PHc6cD48dzpwUHI+XCIuY29uY2F0KHBhcnQubGFzdFBhcmFncmFwU2VjdFByLCBcIjwvdzpwUHI+PHc6cj48dzp0PlwiKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZ2V0UGFnZUJyZWFrSWZBcHBsaWVzKHBhcnQpIHx8IFwiXCIsXG4gICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHRPZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFyIGN5ID0gK2dldFNpbmdsZUF0dHJpYnV0ZSh0aGlzLmxhc3RFeHQudmFsdWUsIFwiY3lcIik7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGRvIGVkaXQgdGhlIHZhbHVlIG9mIGEgcHJldmlvdXMgcmVzdWx0IGhlcmVcbiAgICAgICAgICogI2VkaXQtdmFsdWUtYmFja3dhcmRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RFeHQudmFsdWUgPSBzZXRTaW5nbGVBdHRyaWJ1dGUodGhpcy5sYXN0RXh0LnZhbHVlLCBcImN5XCIsIGN5ICsgaGVpZ2h0T2Zmc2V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvcHRpb25zLmpvaW5VbmNvcnJ1cHQodG90YWxWYWx1ZSwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICBiYXNlUGFydDogcGFydFxuICAgICAgICB9KSksXG4gICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xufSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3cmFwcGVyKG5ldyBMb29wTW9kdWxlKCkpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/loop.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/rawxml.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/rawxml.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar traits = __webpack_require__(/*! ../traits.js */ \"(rsc)/../../node_modules/docxtemplater/js/traits.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  isContent = _require.isContent;\nvar _require2 = __webpack_require__(/*! ../errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph,\n  getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar moduleName = \"rawxml\";\nfunction getInner(_ref) {\n  var part = _ref.part,\n    left = _ref.left,\n    right = _ref.right,\n    postparsed = _ref.postparsed,\n    index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  for (var i = 0, len = paragraphParts.length; i < len; i++) {\n    if (i === index - left - 1) {\n      continue;\n    }\n    var p = paragraphParts[i];\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  }\n  return part;\n}\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n  return _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      return [[this.prefix, moduleName]];\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n      var value;\n      var errors = [];\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n        value !== null && value !== void 0 ? value : value = options.nullGetter(part);\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n      value = value ? value : \"\";\n      if (typeof value === \"string\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        errors: [getInvalidRawXMLValueException({\n          tag: part.value,\n          value: value,\n          offset: part.offset\n        })]\n      };\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yYXd4bWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGFBQWEsbUJBQU8sQ0FBQyx5RUFBYztBQUNuQyxlQUFlLG1CQUFPLENBQUMsK0VBQWlCO0FBQ3hDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMseUVBQWM7QUFDdEM7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9tb2R1bGVzL3Jhd3htbC5qcz81MTk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgdHJhaXRzID0gcmVxdWlyZShcIi4uL3RyYWl0cy5qc1wiKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuLi9kb2MtdXRpbHMuanNcIiksXG4gIGlzQ29udGVudCA9IF9yZXF1aXJlLmlzQ29udGVudDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi4vZXJyb3JzLmpzXCIpLFxuICB0aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCA9IF9yZXF1aXJlMi50aHJvd1Jhd1RhZ1Nob3VsZEJlT25seVRleHRJblBhcmFncmFwaCxcbiAgZ2V0SW52YWxpZFJhd1hNTFZhbHVlRXhjZXB0aW9uID0gX3JlcXVpcmUyLmdldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbjtcbnZhciB3cmFwcGVyID0gcmVxdWlyZShcIi4uL21vZHVsZS13cmFwcGVyLmpzXCIpO1xudmFyIG1vZHVsZU5hbWUgPSBcInJhd3htbFwiO1xuZnVuY3Rpb24gZ2V0SW5uZXIoX3JlZikge1xuICB2YXIgcGFydCA9IF9yZWYucGFydCxcbiAgICBsZWZ0ID0gX3JlZi5sZWZ0LFxuICAgIHJpZ2h0ID0gX3JlZi5yaWdodCxcbiAgICBwb3N0cGFyc2VkID0gX3JlZi5wb3N0cGFyc2VkLFxuICAgIGluZGV4ID0gX3JlZi5pbmRleDtcbiAgdmFyIHBhcmFncmFwaFBhcnRzID0gcG9zdHBhcnNlZC5zbGljZShsZWZ0ICsgMSwgcmlnaHQpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYWdyYXBoUGFydHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gaW5kZXggLSBsZWZ0IC0gMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwID0gcGFyYWdyYXBoUGFydHNbaV07XG4gICAgaWYgKGlzQ29udGVudChwKSkge1xuICAgICAgdGhyb3dSYXdUYWdTaG91bGRCZU9ubHlUZXh0SW5QYXJhZ3JhcGgoe1xuICAgICAgICBwYXJhZ3JhcGhQYXJ0czogcGFyYWdyYXBoUGFydHMsXG4gICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydDtcbn1cbnZhciBSYXdYbWxNb2R1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSYXdYbWxNb2R1bGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhd1htbE1vZHVsZSk7XG4gICAgdGhpcy5uYW1lID0gXCJSYXdYbWxNb2R1bGVcIjtcbiAgICB0aGlzLnByZWZpeCA9IFwiQFwiO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmF3WG1sTW9kdWxlLCBbe1xuICAgIGtleTogXCJvcHRpb25zVHJhbnNmb3JtZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3B0aW9uc1RyYW5zZm9ybWVyKG9wdGlvbnMsIGRvY3h0ZW1wbGF0ZXIpIHtcbiAgICAgIHRoaXMuZmlsZVR5cGVDb25maWcgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlQ29uZmlnO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1hdGNoZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1hdGNoZXJzKCkge1xuICAgICAgcmV0dXJuIFtbdGhpcy5wcmVmaXgsIG1vZHVsZU5hbWVdXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9zdHBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkKSB7XG4gICAgICByZXR1cm4gdHJhaXRzLmV4cGFuZFRvT25lKHBvc3RwYXJzZWQsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogbW9kdWxlTmFtZSxcbiAgICAgICAgZ2V0SW5uZXI6IGdldElubmVyLFxuICAgICAgICBleHBhbmRUbzogdGhpcy5maWxlVHlwZUNvbmZpZy50YWdSYXdYbWwsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgbWVzc2FnZTogXCJSYXcgdGFnIG5vdCBpbiBwYXJhZ3JhcGhcIixcbiAgICAgICAgICBpZDogXCJyYXdfdGFnX291dGVyeG1sX2ludmFsaWRcIixcbiAgICAgICAgICBleHBsYW5hdGlvbjogZnVuY3Rpb24gZXhwbGFuYXRpb24ocGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVGhlIHRhZyBcXFwiXCIuY29uY2F0KHBhcnQudmFsdWUsIFwiXFxcIiBpcyBub3QgaW5zaWRlIGEgcGFyYWdyYXBoLCBwdXR0aW5nIHJhdyB0YWdzIGluc2lkZSBhbiBpbmxpbmUgbG9vcCBpcyBkaXNhbGxvd2VkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXJ0Lm1vZHVsZSAhPT0gbW9kdWxlTmFtZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5zY29wZU1hbmFnZXIuZ2V0VmFsdWUocGFydC52YWx1ZSwge1xuICAgICAgICAgIHBhcnQ6IHBhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgPyB2YWx1ZSA6IHZhbHVlID0gb3B0aW9ucy5udWxsR2V0dGVyKHBhcnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA/IHZhbHVlIDogXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yczogW2dldEludmFsaWRSYXdYTUxWYWx1ZUV4Y2VwdGlvbih7XG4gICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBvZmZzZXQ6IHBhcnQub2Zmc2V0XG4gICAgICAgIH0pXVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd3JhcHBlcihuZXcgUmF3WG1sTW9kdWxlKCkpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/rawxml.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/render.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/render.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  getScopeCompilationError = _require.getScopeCompilationError,\n  getCorruptCharactersException = _require.getCorruptCharactersException;\nvar _require2 = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  utf8ToWord = _require2.utf8ToWord,\n  hasCorruptCharacters = _require2.hasCorruptCharacters,\n  removeCorruptCharacters = _require2.removeCorruptCharacters;\nvar _require3 = __webpack_require__(/*! ../content-types.js */ \"(rsc)/../../node_modules/docxtemplater/js/content-types.js\"),\n  settingsContentType = _require3.settingsContentType,\n  coreContentType = _require3.coreContentType,\n  appContentType = _require3.appContentType,\n  customContentType = _require3.customContentType;\nvar NON_LINE_BREAKS_CONTENT_TYPE = [settingsContentType, coreContentType, appContentType, customContentType];\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n  return _createClass(Render, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      this.brTag = docxtemplater.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      this.prefix = ftprefix[docxtemplater.fileType];\n      this.runStartTag = \"\".concat(this.prefix, \":r\");\n      this.runPropsStartTag = \"\".concat(this.prefix, \":rPr\");\n      return options;\n    }\n  }, {\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      for (var from in this.compiled) {\n        mapper[from] = {\n          from: from,\n          data: this.data\n        };\n      }\n      return mapper;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var errors = [];\n      for (var _i2 = 0; _i2 < postparsed.length; _i2++) {\n        var p = postparsed[_i2];\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n          try {\n            options.cachedParsers[p.lIndex] = this.docxtemplater.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      }\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var contentType = _ref.contentType,\n        scopeManager = _ref.scopeManager,\n        linebreaks = _ref.linebreaks,\n        nullGetter = _ref.nullGetter,\n        fileType = _ref.fileType,\n        stripInvalidXMLChars = _ref.stripInvalidXMLChars;\n      if (NON_LINE_BREAKS_CONTENT_TYPE.indexOf(contentType) !== -1) {\n        // Fixes issue tested in #docprops-linebreak\n        linebreaks = false;\n      }\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n      var value;\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n      value !== null && value !== void 0 ? value : value = nullGetter(part);\n      if (typeof value === \"string\") {\n        if (stripInvalidXMLChars) {\n          value = removeCorruptCharacters(value);\n        } else if ([\"docx\", \"pptx\", \"xlsx\"].indexOf(fileType) !== -1 && hasCorruptCharacters(value)) {\n          return {\n            errors: [getCorruptCharactersException({\n              tag: part.value,\n              value: value,\n              offset: part.offset\n            })]\n          };\n        }\n      }\n      if (fileType === \"text\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === this.runStartTag) {\n        this.recordedRun = \"\";\n      } else if (part.tag === this.runPropsStartTag) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun += part.value;\n        }\n        if (part.position === \"end\" || part.position === \"selfclosing\") {\n          this.recordedRun += part.value;\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun += part.value;\n      }\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var result = [];\n      var lines = value.split(\"\\n\");\n      for (var i = 0, len = lines.length; i < len; i++) {\n        result.push(utf8ToWord(lines[i]));\n        if (i < lines.length - 1) {\n          result.push(\"</\".concat(this.prefix, \":t></\").concat(this.prefix, \":r>\").concat(this.brTag, \"<\").concat(this.prefix, \":r>\").concat(this.recordedRun, \"<\").concat(this.prefix, \":t\").concat(this.docxtemplater.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n        }\n      }\n      return result;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new Render());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1MsaUNBQWlDO0FBQ2pDLG1DQUFtQyxnQkFBZ0IsY0FBYyxPQUFPLGNBQWM7QUFDdEYsaUNBQWlDLHFIQUFxSCxjQUFjO0FBQ3BLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGNBQWMsbUJBQU8sQ0FBQyx5RkFBc0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3JDO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsdUZBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9yZW5kZXIuanM/YmNkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZXJyb3JzLmpzXCIpLFxuICBnZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IgPSBfcmVxdWlyZS5nZXRTY29wZUNvbXBpbGF0aW9uRXJyb3IsXG4gIGdldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uID0gX3JlcXVpcmUuZ2V0Q29ycnVwdENoYXJhY3RlcnNFeGNlcHRpb247XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4uL2RvYy11dGlscy5qc1wiKSxcbiAgdXRmOFRvV29yZCA9IF9yZXF1aXJlMi51dGY4VG9Xb3JkLFxuICBoYXNDb3JydXB0Q2hhcmFjdGVycyA9IF9yZXF1aXJlMi5oYXNDb3JydXB0Q2hhcmFjdGVycyxcbiAgcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnMgPSBfcmVxdWlyZTIucmVtb3ZlQ29ycnVwdENoYXJhY3RlcnM7XG52YXIgX3JlcXVpcmUzID0gcmVxdWlyZShcIi4uL2NvbnRlbnQtdHlwZXMuanNcIiksXG4gIHNldHRpbmdzQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuc2V0dGluZ3NDb250ZW50VHlwZSxcbiAgY29yZUNvbnRlbnRUeXBlID0gX3JlcXVpcmUzLmNvcmVDb250ZW50VHlwZSxcbiAgYXBwQ29udGVudFR5cGUgPSBfcmVxdWlyZTMuYXBwQ29udGVudFR5cGUsXG4gIGN1c3RvbUNvbnRlbnRUeXBlID0gX3JlcXVpcmUzLmN1c3RvbUNvbnRlbnRUeXBlO1xudmFyIE5PTl9MSU5FX0JSRUFLU19DT05URU5UX1RZUEUgPSBbc2V0dGluZ3NDb250ZW50VHlwZSwgY29yZUNvbnRlbnRUeXBlLCBhcHBDb250ZW50VHlwZSwgY3VzdG9tQ29udGVudFR5cGVdO1xudmFyIGZ0cHJlZml4ID0ge1xuICBkb2N4OiBcIndcIixcbiAgcHB0eDogXCJhXCJcbn07XG52YXIgUmVuZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVuZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXIpO1xuICAgIHRoaXMubmFtZSA9IFwiUmVuZGVyXCI7XG4gICAgdGhpcy5yZWNvcmRSdW4gPSBmYWxzZTtcbiAgICB0aGlzLnJlY29yZGVkUnVuID0gW107XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhSZW5kZXIsIFt7XG4gICAga2V5OiBcIm9wdGlvbnNUcmFuc2Zvcm1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcHRpb25zVHJhbnNmb3JtZXIob3B0aW9ucywgZG9jeHRlbXBsYXRlcikge1xuICAgICAgdGhpcy5kb2N4dGVtcGxhdGVyID0gZG9jeHRlbXBsYXRlcjtcbiAgICAgIHRoaXMuYnJUYWcgPSBkb2N4dGVtcGxhdGVyLmZpbGVUeXBlID09PSBcImRvY3hcIiA/IFwiPHc6cj48dzpici8+PC93OnI+XCIgOiBcIjxhOmJyLz5cIjtcbiAgICAgIHRoaXMucHJlZml4ID0gZnRwcmVmaXhbZG9jeHRlbXBsYXRlci5maWxlVHlwZV07XG4gICAgICB0aGlzLnJ1blN0YXJ0VGFnID0gXCJcIi5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnJcIik7XG4gICAgICB0aGlzLnJ1blByb3BzU3RhcnRUYWcgPSBcIlwiLmNvbmNhdCh0aGlzLnByZWZpeCwgXCI6clByXCIpO1xuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob2JqKSB7XG4gICAgICBpZiAob2JqLmNvbXBpbGVkKSB7XG4gICAgICAgIHRoaXMuY29tcGlsZWQgPSBvYmouY29tcGlsZWQ7XG4gICAgICB9XG4gICAgICBpZiAob2JqLmRhdGEgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBvYmouZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyZWRNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyZWRNYXAobWFwcGVyKSB7XG4gICAgICBmb3IgKHZhciBmcm9tIGluIHRoaXMuY29tcGlsZWQpIHtcbiAgICAgICAgbWFwcGVyW2Zyb21dID0ge1xuICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBvc3RwYXJzZWQubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgcCA9IHBvc3RwYXJzZWRbX2kyXTtcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiKSB7XG4gICAgICAgICAgdmFyIHRhZyA9IHAudmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2FjaGVkUGFyc2Vyc1twLmxJbmRleF0gPSB0aGlzLmRvY3h0ZW1wbGF0ZXIucGFyc2VyKHRhZywge1xuICAgICAgICAgICAgICB0YWc6IHBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKHJvb3RFcnJvcikge1xuICAgICAgICAgICAgZXJyb3JzLnB1c2goZ2V0U2NvcGVDb21waWxhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgdGFnOiB0YWcsXG4gICAgICAgICAgICAgIHJvb3RFcnJvcjogcm9vdEVycm9yLFxuICAgICAgICAgICAgICBvZmZzZXQ6IHAub2Zmc2V0XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3N0cGFyc2VkOiBwb3N0cGFyc2VkLFxuICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJ0LCBfcmVmKSB7XG4gICAgICB2YXIgY29udGVudFR5cGUgPSBfcmVmLmNvbnRlbnRUeXBlLFxuICAgICAgICBzY29wZU1hbmFnZXIgPSBfcmVmLnNjb3BlTWFuYWdlcixcbiAgICAgICAgbGluZWJyZWFrcyA9IF9yZWYubGluZWJyZWFrcyxcbiAgICAgICAgbnVsbEdldHRlciA9IF9yZWYubnVsbEdldHRlcixcbiAgICAgICAgZmlsZVR5cGUgPSBfcmVmLmZpbGVUeXBlLFxuICAgICAgICBzdHJpcEludmFsaWRYTUxDaGFycyA9IF9yZWYuc3RyaXBJbnZhbGlkWE1MQ2hhcnM7XG4gICAgICBpZiAoTk9OX0xJTkVfQlJFQUtTX0NPTlRFTlRfVFlQRS5pbmRleE9mKGNvbnRlbnRUeXBlKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gRml4ZXMgaXNzdWUgdGVzdGVkIGluICNkb2Nwcm9wcy1saW5lYnJlYWtcbiAgICAgICAgbGluZWJyZWFrcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVicmVha3MpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRSdW5zKHBhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJwbGFjZWhvbGRlclwiIHx8IHBhcnQubW9kdWxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gc2NvcGVNYW5hZ2VyLmdldFZhbHVlKHBhcnQudmFsdWUsIHtcbiAgICAgICAgICBwYXJ0OiBwYXJ0XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVycm9yczogW2VdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiB2YWx1ZSA9IG51bGxHZXR0ZXIocGFydCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChzdHJpcEludmFsaWRYTUxDaGFycykge1xuICAgICAgICAgIHZhbHVlID0gcmVtb3ZlQ29ycnVwdENoYXJhY3RlcnModmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKFtcImRvY3hcIiwgXCJwcHR4XCIsIFwieGxzeFwiXS5pbmRleE9mKGZpbGVUeXBlKSAhPT0gLTEgJiYgaGFzQ29ycnVwdENoYXJhY3RlcnModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVycm9yczogW2dldENvcnJ1cHRDaGFyYWN0ZXJzRXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgdGFnOiBwYXJ0LnZhbHVlLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIG9mZnNldDogcGFydC5vZmZzZXRcbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWxlVHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBsaW5lYnJlYWtzICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHRoaXMucmVuZGVyTGluZUJyZWFrcyh2YWx1ZSkgOiB1dGY4VG9Xb3JkKHZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb3JkUnVuc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWNvcmRSdW5zKHBhcnQpIHtcbiAgICAgIGlmIChwYXJ0LnRhZyA9PT0gdGhpcy5ydW5TdGFydFRhZykge1xuICAgICAgICB0aGlzLnJlY29yZGVkUnVuID0gXCJcIjtcbiAgICAgIH0gZWxzZSBpZiAocGFydC50YWcgPT09IHRoaXMucnVuUHJvcHNTdGFydFRhZykge1xuICAgICAgICBpZiAocGFydC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWNvcmRSdW4gPSB0cnVlO1xuICAgICAgICAgIHRoaXMucmVjb3JkZWRSdW4gKz0gcGFydC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5wb3NpdGlvbiA9PT0gXCJlbmRcIiB8fCBwYXJ0LnBvc2l0aW9uID09PSBcInNlbGZjbG9zaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY29yZGVkUnVuICs9IHBhcnQudmFsdWU7XG4gICAgICAgICAgdGhpcy5yZWNvcmRSdW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLnJlY29yZFJ1bikge1xuICAgICAgICB0aGlzLnJlY29yZGVkUnVuICs9IHBhcnQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckxpbmVCcmVha3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGluZUJyZWFrcyh2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGxpbmVzID0gdmFsdWUuc3BsaXQoXCJcXG5cIik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LnB1c2godXRmOFRvV29yZChsaW5lc1tpXSkpO1xuICAgICAgICBpZiAoaSA8IGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChcIjwvXCIuY29uY2F0KHRoaXMucHJlZml4LCBcIjp0PjwvXCIpLmNvbmNhdCh0aGlzLnByZWZpeCwgXCI6cj5cIikuY29uY2F0KHRoaXMuYnJUYWcsIFwiPFwiKS5jb25jYXQodGhpcy5wcmVmaXgsIFwiOnI+XCIpLmNvbmNhdCh0aGlzLnJlY29yZGVkUnVuLCBcIjxcIikuY29uY2F0KHRoaXMucHJlZml4LCBcIjp0XCIpLmNvbmNhdCh0aGlzLmRvY3h0ZW1wbGF0ZXIuZmlsZVR5cGUgPT09IFwiZG9jeFwiID8gJyB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiJyA6IFwiXCIsIFwiPlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFJlbmRlcigpKTtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/render.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/modules/space-preserve.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/modules/space-preserve.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar wrapper = __webpack_require__(/*! ../module-wrapper.js */ \"(rsc)/../../node_modules/docxtemplater/js/module-wrapper.js\");\nvar _require = __webpack_require__(/*! ../doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  isTextStart = _require.isTextStart,\n  isTextEnd = _require.isTextEnd,\n  endsWith = _require.endsWith,\n  startsWith = _require.startsWith,\n  pushArray = _require.pushArray;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\n\n// This module is used only for `docx` files\nvar SpacePreserve = /*#__PURE__*/function () {\n  function SpacePreserve() {\n    _classCallCheck(this, SpacePreserve);\n    this.name = \"SpacePreserveModule\";\n  }\n  return _createClass(SpacePreserve, [{\n    key: \"postparse\",\n    value: function postparse(postparsed, meta) {\n      var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n      function isStartingPlaceHolder(part, chunk) {\n        return part.type === \"placeholder\" && chunk.length > 1;\n      }\n      var result = postparsed.reduce(function (postparsed, part) {\n        if (isWtStart(part)) {\n          inTextTag = true;\n          lastTextTag = chunk.length;\n        }\n        if (!inTextTag) {\n          postparsed.push(part);\n          return postparsed;\n        }\n        chunk.push(part);\n        if (isInsideLoop(meta, chunk)) {\n          endLindex = meta.basePart.endLindex;\n          chunk[0].value = addXMLPreserve(chunk, 0);\n        }\n        if (isStartingPlaceHolder(part, chunk)) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          endLindex = part.endLindex;\n        }\n        if (isTextEnd(part) && part.lIndex > endLindex) {\n          if (endLindex !== 0) {\n            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          }\n          pushArray(postparsed, chunk);\n          chunk = [];\n          inTextTag = false;\n          endLindex = 0;\n          lastTextTag = 0;\n        }\n        return postparsed;\n      }, []);\n      pushArray(result, chunk);\n      return result;\n    }\n  }, {\n    key: \"postrender\",\n    value: function postrender(parts) {\n      var lastNonEmpty = \"\";\n      var lastNonEmptyIndex = 0;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        var p = parts[i];\n        if (p === \"\") {\n          continue;\n        }\n        if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n          parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n          p = p.substr(wtEndlen);\n        }\n        lastNonEmpty = p;\n        lastNonEmptyIndex = i;\n        parts[i] = p;\n      }\n      return parts;\n    }\n  }]);\n}();\nmodule.exports = function () {\n  return wrapper(new SpacePreserve());\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvbW9kdWxlcy9zcGFjZS1wcmVzZXJ2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsY0FBYyxtQkFBTyxDQUFDLHlGQUFzQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsK0VBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL21vZHVsZXMvc3BhY2UtcHJlc2VydmUuanM/YzU3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIHdyYXBwZXIgPSByZXF1aXJlKFwiLi4vbW9kdWxlLXdyYXBwZXIuanNcIik7XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi4vZG9jLXV0aWxzLmpzXCIpLFxuICBpc1RleHRTdGFydCA9IF9yZXF1aXJlLmlzVGV4dFN0YXJ0LFxuICBpc1RleHRFbmQgPSBfcmVxdWlyZS5pc1RleHRFbmQsXG4gIGVuZHNXaXRoID0gX3JlcXVpcmUuZW5kc1dpdGgsXG4gIHN0YXJ0c1dpdGggPSBfcmVxdWlyZS5zdGFydHNXaXRoLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgd1RwcmVzZXJ2ZSA9ICc8dzp0IHhtbDpzcGFjZT1cInByZXNlcnZlXCI+JztcbnZhciB3VHByZXNlcnZlbGVuID0gd1RwcmVzZXJ2ZS5sZW5ndGg7XG52YXIgd3RFbmQgPSBcIjwvdzp0PlwiO1xudmFyIHd0RW5kbGVuID0gd3RFbmQubGVuZ3RoO1xuZnVuY3Rpb24gaXNXdFN0YXJ0KHBhcnQpIHtcbiAgcmV0dXJuIGlzVGV4dFN0YXJ0KHBhcnQpICYmIHBhcnQudGFnID09PSBcInc6dFwiO1xufVxuZnVuY3Rpb24gYWRkWE1MUHJlc2VydmUoY2h1bmssIGluZGV4KSB7XG4gIHZhciB0YWcgPSBjaHVua1tpbmRleF0udmFsdWU7XG4gIGlmIChjaHVua1tpbmRleCArIDFdLnZhbHVlID09PSBcIjwvdzp0PlwiKSB7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuICBpZiAodGFnLmluZGV4T2YoJ3htbDpzcGFjZT1cInByZXNlcnZlXCInKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG4gIHJldHVybiB0YWcuc3Vic3RyKDAsIHRhZy5sZW5ndGggLSAxKSArICcgeG1sOnNwYWNlPVwicHJlc2VydmVcIj4nO1xufVxuZnVuY3Rpb24gaXNJbnNpZGVMb29wKG1ldGEsIGNodW5rKSB7XG4gIHJldHVybiBtZXRhICYmIG1ldGEuYmFzZVBhcnQgJiYgY2h1bmsubGVuZ3RoID4gMTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgaXMgdXNlZCBvbmx5IGZvciBgZG9jeGAgZmlsZXNcbnZhciBTcGFjZVByZXNlcnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3BhY2VQcmVzZXJ2ZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3BhY2VQcmVzZXJ2ZSk7XG4gICAgdGhpcy5uYW1lID0gXCJTcGFjZVByZXNlcnZlTW9kdWxlXCI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTcGFjZVByZXNlcnZlLCBbe1xuICAgIGtleTogXCJwb3N0cGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBvc3RwYXJzZWQsIG1ldGEpIHtcbiAgICAgIHZhciBjaHVuayA9IFtdLFxuICAgICAgICBpblRleHRUYWcgPSBmYWxzZSxcbiAgICAgICAgZW5kTGluZGV4ID0gMCxcbiAgICAgICAgbGFzdFRleHRUYWcgPSAwO1xuICAgICAgZnVuY3Rpb24gaXNTdGFydGluZ1BsYWNlSG9sZGVyKHBhcnQsIGNodW5rKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicGxhY2Vob2xkZXJcIiAmJiBjaHVuay5sZW5ndGggPiAxO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHBvc3RwYXJzZWQucmVkdWNlKGZ1bmN0aW9uIChwb3N0cGFyc2VkLCBwYXJ0KSB7XG4gICAgICAgIGlmIChpc1d0U3RhcnQocGFydCkpIHtcbiAgICAgICAgICBpblRleHRUYWcgPSB0cnVlO1xuICAgICAgICAgIGxhc3RUZXh0VGFnID0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5UZXh0VGFnKSB7XG4gICAgICAgICAgcG9zdHBhcnNlZC5wdXNoKHBhcnQpO1xuICAgICAgICAgIHJldHVybiBwb3N0cGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGNodW5rLnB1c2gocGFydCk7XG4gICAgICAgIGlmIChpc0luc2lkZUxvb3AobWV0YSwgY2h1bmspKSB7XG4gICAgICAgICAgZW5kTGluZGV4ID0gbWV0YS5iYXNlUGFydC5lbmRMaW5kZXg7XG4gICAgICAgICAgY2h1bmtbMF0udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RhcnRpbmdQbGFjZUhvbGRlcihwYXJ0LCBjaHVuaykpIHtcbiAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIGVuZExpbmRleCA9IHBhcnQuZW5kTGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RleHRFbmQocGFydCkgJiYgcGFydC5sSW5kZXggPiBlbmRMaW5kZXgpIHtcbiAgICAgICAgICBpZiAoZW5kTGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICBjaHVua1tsYXN0VGV4dFRhZ10udmFsdWUgPSBhZGRYTUxQcmVzZXJ2ZShjaHVuaywgbGFzdFRleHRUYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwdXNoQXJyYXkocG9zdHBhcnNlZCwgY2h1bmspO1xuICAgICAgICAgIGNodW5rID0gW107XG4gICAgICAgICAgaW5UZXh0VGFnID0gZmFsc2U7XG4gICAgICAgICAgZW5kTGluZGV4ID0gMDtcbiAgICAgICAgICBsYXN0VGV4dFRhZyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc3RwYXJzZWQ7XG4gICAgICB9LCBbXSk7XG4gICAgICBwdXNoQXJyYXkocmVzdWx0LCBjaHVuayk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3N0cmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RyZW5kZXIocGFydHMpIHtcbiAgICAgIHZhciBsYXN0Tm9uRW1wdHkgPSBcIlwiO1xuICAgICAgdmFyIGxhc3ROb25FbXB0eUluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAocCA9PT0gXCJcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRzV2l0aChsYXN0Tm9uRW1wdHksIHdUcHJlc2VydmUpICYmIHN0YXJ0c1dpdGgocCwgd3RFbmQpKSB7XG4gICAgICAgICAgcGFydHNbbGFzdE5vbkVtcHR5SW5kZXhdID0gbGFzdE5vbkVtcHR5LnN1YnN0cigwLCBsYXN0Tm9uRW1wdHkubGVuZ3RoIC0gd1RwcmVzZXJ2ZWxlbikgKyBcIjx3OnQvPlwiO1xuICAgICAgICAgIHAgPSBwLnN1YnN0cih3dEVuZGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdE5vbkVtcHR5ID0gcDtcbiAgICAgICAgbGFzdE5vbkVtcHR5SW5kZXggPSBpO1xuICAgICAgICBwYXJ0c1tpXSA9IHA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdyYXBwZXIobmV3IFNwYWNlUHJlc2VydmUoKSk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/modules/space-preserve.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/parser.js":
/*!*****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/parser.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8,\n  pushArray = _require.pushArray;\nvar _require2 = __webpack_require__(/*! ./prefix-matcher.js */ \"(rsc)/../../node_modules/docxtemplater/js/prefix-matcher.js\"),\n  match = _require2.match,\n  getValue = _require2.getValue,\n  getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n  var allMatchers = [];\n  for (var _i2 = 0; _i2 < modules.length; _i2++) {\n    var _module = modules[_i2];\n    if (_module.matchers) {\n      var matchers = _module.matchers(options);\n      if (!(matchers instanceof Array)) {\n        throw new Error(\"module matcher returns a non array\");\n      }\n      pushArray(allMatchers, matchers);\n    }\n  }\n  return allMatchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n  var matches = [];\n  for (var _i4 = 0; _i4 < matchers.length; _i4++) {\n    var matcher = matchers[_i4];\n    var _matcher = _slicedToArray(matcher, 2),\n      prefix = _matcher[0],\n      _module2 = _matcher[1];\n    var properties = matcher[2] || {};\n    if (options.match(prefix, placeHolderContent)) {\n      var values = options.getValues(prefix, placeHolderContent);\n      if (typeof properties === \"function\") {\n        properties = properties(values);\n      }\n      if (!properties.value) {\n        var _values = _slicedToArray(values, 2);\n        properties.value = _values[1];\n      }\n      matches.push(_objectSpread({\n        type: \"placeholder\",\n        prefix: prefix,\n        module: _module2,\n        onMatch: properties.onMatch,\n        priority: properties.priority\n      }, properties));\n    }\n  }\n  return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules,\n    startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n  var matchers = getMatchers(modules, options);\n  var matches = getMatches(matchers, placeHolderContent, options);\n  if (matches.length > 0) {\n    var bestMatch = null;\n    for (var _i6 = 0; _i6 < matches.length; _i6++) {\n      var _match = matches[_i6];\n      _match.priority || (_match.priority = -_match.value.length);\n      if (!bestMatch || _match.priority > bestMatch.priority) {\n        bestMatch = _match;\n      }\n    }\n    bestMatch.offset = startOffset;\n    delete bestMatch.priority;\n    bestMatch.endLindex = endLindex;\n    bestMatch.lIndex = endLindex;\n    bestMatch.raw = placeHolderContent;\n    if (bestMatch.onMatch) {\n      bestMatch.onMatch(bestMatch);\n    }\n    delete bestMatch.onMatch;\n    delete bestMatch.prefix;\n    return bestMatch;\n  }\n  for (var _i8 = 0; _i8 < modules.length; _i8++) {\n    var _module3 = modules[_i8];\n    moduleParsed = _module3.parse(placeHolderContent, options);\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      for (var _i0 = 0; _i0 < modules.length; _i0++) {\n        var _module4 = modules[_i0];\n        parsed = _module4.preparse(parsed, options) || parsed;\n      }\n      return parsed;\n    }\n    return preparse(parsed, options);\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n    return lexed.reduce(function (parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n        if (token.position === \"end\") {\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n          parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n          pushArray(parsed, tailParts);\n          tailParts = [];\n        }\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n        placeHolderContent = \"\";\n        return parsed;\n      }\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        if (droppedTags.indexOf(token.tag) !== -1) {\n          return parsed;\n        }\n        tailParts.push(token);\n        return parsed;\n      }\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed) {\n      return modules.map(function (module) {\n        return module.getTraits(traitName, postparsed);\n      });\n    }\n    var errors = [];\n    function _postparse(postparsed, options) {\n      var newPostparsed = postparsed;\n      for (var _i10 = 0; _i10 < modules.length; _i10++) {\n        var _module5 = modules[_i10];\n        var postparseResult = _module5.postparse(newPostparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n        if (postparseResult == null) {\n          continue;\n        }\n        if (postparseResult.errors) {\n          pushArray(errors, postparseResult.errors);\n          newPostparsed = postparseResult.postparsed;\n          continue;\n        }\n        newPostparsed = postparseResult;\n      }\n      return newPostparsed;\n    }\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  }\n};\nmodule.exports = parser;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLHlCQUF5Qix3QkFBd0Isb0NBQW9DLHlDQUF5QyxrQ0FBa0MsMERBQTBELDBCQUEwQjtBQUNwUCw0QkFBNEIsZ0JBQWdCLHNCQUFzQixPQUFPLGtEQUFrRCxzREFBc0QsOEJBQThCLG1KQUFtSixxRUFBcUUsS0FBSztBQUM1YSxvQ0FBb0Msb0VBQW9FLDBEQUEwRDtBQUNsSyw2QkFBNkIsbUNBQW1DO0FBQ2hFLDhCQUE4Qiw0Q0FBNEMsK0JBQStCLG9CQUFvQixtQ0FBbUMsc0NBQXNDLHVFQUF1RTtBQUM3USxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0ZBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRixzQkFBc0I7QUFDckg7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0EsOEZBQThGLGNBQWM7QUFDNUc7QUFDQSxvRUFBb0U7QUFDcEUsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wYXJzZXIuanM/ZTQ5ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7IHZhciB0ID0gT2JqZWN0LmtleXMoZSk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9OyByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkgeyByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7IHZhbHVlOiB0LCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pIDogZVtyXSA9IHQsIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7IGlmIChyKSB7IGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7IHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7IHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwOyB9IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHsgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpOyBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTsgcmV0dXJuIG47IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7IHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IHQpIHsgdmFyIGUsIG4sIGksIHUsIGEgPSBbXSwgZiA9ICEwLCBvID0gITE7IHRyeSB7IGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIHsgaWYgKE9iamVjdCh0KSAhPT0gdCkgcmV0dXJuOyBmID0gITE7IH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTsgfSBjYXRjaCAocikgeyBvID0gITAsIG4gPSByOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIWYgJiYgbnVsbCAhPSB0W1wicmV0dXJuXCJdICYmICh1ID0gdFtcInJldHVyblwiXSgpLCBPYmplY3QodSkgIT09IHUpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChvKSB0aHJvdyBuOyB9IH0gcmV0dXJuIGE7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHsgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHdvcmRUb1V0ZjggPSBfcmVxdWlyZS53b3JkVG9VdGY4LFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgX3JlcXVpcmUyID0gcmVxdWlyZShcIi4vcHJlZml4LW1hdGNoZXIuanNcIiksXG4gIG1hdGNoID0gX3JlcXVpcmUyLm1hdGNoLFxuICBnZXRWYWx1ZSA9IF9yZXF1aXJlMi5nZXRWYWx1ZSxcbiAgZ2V0VmFsdWVzID0gX3JlcXVpcmUyLmdldFZhbHVlcztcbmZ1bmN0aW9uIGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgdmFyIGFsbE1hdGNoZXJzID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gbW9kdWxlc1tfaTJdO1xuICAgIGlmIChfbW9kdWxlLm1hdGNoZXJzKSB7XG4gICAgICB2YXIgbWF0Y2hlcnMgPSBfbW9kdWxlLm1hdGNoZXJzKG9wdGlvbnMpO1xuICAgICAgaWYgKCEobWF0Y2hlcnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibW9kdWxlIG1hdGNoZXIgcmV0dXJucyBhIG5vbiBhcnJheVwiKTtcbiAgICAgIH1cbiAgICAgIHB1c2hBcnJheShhbGxNYXRjaGVycywgbWF0Y2hlcnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzKG1hdGNoZXJzLCBwbGFjZUhvbGRlckNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbWF0Y2hlcnMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciBtYXRjaGVyID0gbWF0Y2hlcnNbX2k0XTtcbiAgICB2YXIgX21hdGNoZXIgPSBfc2xpY2VkVG9BcnJheShtYXRjaGVyLCAyKSxcbiAgICAgIHByZWZpeCA9IF9tYXRjaGVyWzBdLFxuICAgICAgX21vZHVsZTIgPSBfbWF0Y2hlclsxXTtcbiAgICB2YXIgcHJvcGVydGllcyA9IG1hdGNoZXJbMl0gfHwge307XG4gICAgaWYgKG9wdGlvbnMubWF0Y2gocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpKSB7XG4gICAgICB2YXIgdmFsdWVzID0gb3B0aW9ucy5nZXRWYWx1ZXMocHJlZml4LCBwbGFjZUhvbGRlckNvbnRlbnQpO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXModmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcGVydGllcy52YWx1ZSkge1xuICAgICAgICB2YXIgX3ZhbHVlcyA9IF9zbGljZWRUb0FycmF5KHZhbHVlcywgMik7XG4gICAgICAgIHByb3BlcnRpZXMudmFsdWUgPSBfdmFsdWVzWzFdO1xuICAgICAgfVxuICAgICAgbWF0Y2hlcy5wdXNoKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBtb2R1bGU6IF9tb2R1bGUyLFxuICAgICAgICBvbk1hdGNoOiBwcm9wZXJ0aWVzLm9uTWF0Y2gsXG4gICAgICAgIHByaW9yaXR5OiBwcm9wZXJ0aWVzLnByaW9yaXR5XG4gICAgICB9LCBwcm9wZXJ0aWVzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gbW9kdWxlUGFyc2UocGxhY2VIb2xkZXJDb250ZW50LCBvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVzID0gb3B0aW9ucy5tb2R1bGVzLFxuICAgIHN0YXJ0T2Zmc2V0ID0gb3B0aW9ucy5zdGFydE9mZnNldDtcbiAgdmFyIGVuZExpbmRleCA9IG9wdGlvbnMubEluZGV4O1xuICB2YXIgbW9kdWxlUGFyc2VkO1xuICBvcHRpb25zLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICBvcHRpb25zLm1hdGNoID0gbWF0Y2g7XG4gIG9wdGlvbnMuZ2V0VmFsdWUgPSBnZXRWYWx1ZTtcbiAgb3B0aW9ucy5nZXRWYWx1ZXMgPSBnZXRWYWx1ZXM7XG4gIHZhciBtYXRjaGVycyA9IGdldE1hdGNoZXJzKG1vZHVsZXMsIG9wdGlvbnMpO1xuICB2YXIgbWF0Y2hlcyA9IGdldE1hdGNoZXMobWF0Y2hlcnMsIHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucyk7XG4gIGlmIChtYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgYmVzdE1hdGNoID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBtYXRjaGVzLmxlbmd0aDsgX2k2KyspIHtcbiAgICAgIHZhciBfbWF0Y2ggPSBtYXRjaGVzW19pNl07XG4gICAgICBfbWF0Y2gucHJpb3JpdHkgfHwgKF9tYXRjaC5wcmlvcml0eSA9IC1fbWF0Y2gudmFsdWUubGVuZ3RoKTtcbiAgICAgIGlmICghYmVzdE1hdGNoIHx8IF9tYXRjaC5wcmlvcml0eSA+IGJlc3RNYXRjaC5wcmlvcml0eSkge1xuICAgICAgICBiZXN0TWF0Y2ggPSBfbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuICAgIGJlc3RNYXRjaC5vZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICBkZWxldGUgYmVzdE1hdGNoLnByaW9yaXR5O1xuICAgIGJlc3RNYXRjaC5lbmRMaW5kZXggPSBlbmRMaW5kZXg7XG4gICAgYmVzdE1hdGNoLmxJbmRleCA9IGVuZExpbmRleDtcbiAgICBiZXN0TWF0Y2gucmF3ID0gcGxhY2VIb2xkZXJDb250ZW50O1xuICAgIGlmIChiZXN0TWF0Y2gub25NYXRjaCkge1xuICAgICAgYmVzdE1hdGNoLm9uTWF0Y2goYmVzdE1hdGNoKTtcbiAgICB9XG4gICAgZGVsZXRlIGJlc3RNYXRjaC5vbk1hdGNoO1xuICAgIGRlbGV0ZSBiZXN0TWF0Y2gucHJlZml4O1xuICAgIHJldHVybiBiZXN0TWF0Y2g7XG4gIH1cbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbW9kdWxlcy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgdmFyIF9tb2R1bGUzID0gbW9kdWxlc1tfaThdO1xuICAgIG1vZHVsZVBhcnNlZCA9IF9tb2R1bGUzLnBhcnNlKHBsYWNlSG9sZGVyQ29udGVudCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVBhcnNlZCkge1xuICAgICAgbW9kdWxlUGFyc2VkLm9mZnNldCA9IHN0YXJ0T2Zmc2V0O1xuICAgICAgbW9kdWxlUGFyc2VkLmVuZExpbmRleCA9IGVuZExpbmRleDtcbiAgICAgIG1vZHVsZVBhcnNlZC5sSW5kZXggPSBlbmRMaW5kZXg7XG4gICAgICBtb2R1bGVQYXJzZWQucmF3ID0gcGxhY2VIb2xkZXJDb250ZW50O1xuICAgICAgcmV0dXJuIG1vZHVsZVBhcnNlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBsYWNlaG9sZGVyXCIsXG4gICAgdmFsdWU6IHBsYWNlSG9sZGVyQ29udGVudCxcbiAgICBvZmZzZXQ6IHN0YXJ0T2Zmc2V0LFxuICAgIGVuZExpbmRleDogZW5kTGluZGV4LFxuICAgIGxJbmRleDogZW5kTGluZGV4XG4gIH07XG59XG52YXIgcGFyc2VyID0ge1xuICBwcmVwYXJzZTogZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gcHJlcGFyc2UocGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICBmb3IgKHZhciBfaTAgPSAwOyBfaTAgPCBtb2R1bGVzLmxlbmd0aDsgX2kwKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU0ID0gbW9kdWxlc1tfaTBdO1xuICAgICAgICBwYXJzZWQgPSBfbW9kdWxlNC5wcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpIHx8IHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJzZShwYXJzZWQsIG9wdGlvbnMpO1xuICB9LFxuICBwYXJzZTogZnVuY3Rpb24gcGFyc2UobGV4ZWQsIG1vZHVsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5QbGFjZUhvbGRlciA9IGZhbHNlO1xuICAgIHZhciBwbGFjZUhvbGRlckNvbnRlbnQgPSBcIlwiO1xuICAgIHZhciBzdGFydE9mZnNldDtcbiAgICB2YXIgdGFpbFBhcnRzID0gW107XG4gICAgdmFyIGRyb3BwZWRUYWdzID0gb3B0aW9ucy5maWxlVHlwZUNvbmZpZy5kcm9wcGVkVGFnc0luc2lkZVBsYWNlaG9sZGVyIHx8IFtdO1xuICAgIHJldHVybiBsZXhlZC5yZWR1Y2UoZnVuY3Rpb24gKHBhcnNlZCwgdG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBcImRlbGltaXRlclwiKSB7XG4gICAgICAgIGluUGxhY2VIb2xkZXIgPSB0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiO1xuICAgICAgICBpZiAodG9rZW4ucG9zaXRpb24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICBvcHRpb25zLnBhcnNlID0gZnVuY3Rpb24gKHBsYWNlSG9sZGVyQ29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVBhcnNlKHBsYWNlSG9sZGVyQ29udGVudCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB0b2tlbiksIHt9LCB7XG4gICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBzdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgbW9kdWxlczogbW9kdWxlc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcGFyc2VkLnB1c2gob3B0aW9ucy5wYXJzZSh3b3JkVG9VdGY4KHBsYWNlSG9sZGVyQ29udGVudCkpKTtcbiAgICAgICAgICBwdXNoQXJyYXkocGFyc2VkLCB0YWlsUGFydHMpO1xuICAgICAgICAgIHRhaWxQYXJ0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbi5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgdGFpbFBhcnRzID0gW107XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSB0b2tlbi5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcGxhY2VIb2xkZXJDb250ZW50ID0gXCJcIjtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIGlmICghaW5QbGFjZUhvbGRlcikge1xuICAgICAgICBwYXJzZWQucHVzaCh0b2tlbik7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gXCJjb250ZW50XCIgfHwgdG9rZW4ucG9zaXRpb24gIT09IFwiaW5zaWRldGFnXCIpIHtcbiAgICAgICAgaWYgKGRyb3BwZWRUYWdzLmluZGV4T2YodG9rZW4udGFnKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxQYXJ0cy5wdXNoKHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH1cbiAgICAgIHBsYWNlSG9sZGVyQ29udGVudCArPSB0b2tlbi52YWx1ZTtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSwgW10pO1xuICB9LFxuICBwb3N0cGFyc2U6IGZ1bmN0aW9uIHBvc3RwYXJzZShwb3N0cGFyc2VkLCBtb2R1bGVzLCBvcHRpb25zKSB7XG4gICAgZnVuY3Rpb24gZ2V0VHJhaXRzKHRyYWl0TmFtZSwgcG9zdHBhcnNlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5nZXRUcmFpdHModHJhaXROYW1lLCBwb3N0cGFyc2VkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzID0gW107XG4gICAgZnVuY3Rpb24gX3Bvc3RwYXJzZShwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbmV3UG9zdHBhcnNlZCA9IHBvc3RwYXJzZWQ7XG4gICAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG1vZHVsZXMubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGU1ID0gbW9kdWxlc1tfaTEwXTtcbiAgICAgICAgdmFyIHBvc3RwYXJzZVJlc3VsdCA9IF9tb2R1bGU1LnBvc3RwYXJzZShuZXdQb3N0cGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIHBvc3RwYXJzZTogZnVuY3Rpb24gcG9zdHBhcnNlKHBhcnNlZCwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIF9wb3N0cGFyc2UocGFyc2VkLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMpLCBvcHRzKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRUcmFpdHM6IGdldFRyYWl0c1xuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChwb3N0cGFyc2VSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3N0cGFyc2VSZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgcHVzaEFycmF5KGVycm9ycywgcG9zdHBhcnNlUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgbmV3UG9zdHBhcnNlZCA9IHBvc3RwYXJzZVJlc3VsdC5wb3N0cGFyc2VkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld1Bvc3RwYXJzZWQgPSBwb3N0cGFyc2VSZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3UG9zdHBhcnNlZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3RwYXJzZWQ6IF9wb3N0cGFyc2UocG9zdHBhcnNlZCwgb3B0aW9ucyksXG4gICAgICBlcnJvcnM6IGVycm9yc1xuICAgIH07XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlcjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/parser.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/postrender.js":
/*!*********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/postrender.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("\n\n/*\n * Convert string to array (typed, when possible)\n * Stryker disable all : because this is a utility function that was copied\n * from\n * https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n */\nfunction string2buf(str) {\n  var c,\n    c2,\n    mPos,\n    i,\n    bufLen = 0;\n  var strLen = str.length;\n\n  // count binary size\n  for (mPos = 0; mPos < strLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  var buf = new Uint8Array(bufLen);\n\n  // convert\n  for (i = 0, mPos = 0; i < bufLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n}\n// Stryker restore all\n\nfunction postrender(parts, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    parts = _module.postrender(parts, options);\n  }\n  var fullLength = 0;\n  var newParts = options.joinUncorrupt(parts, options);\n  var longStr = \"\";\n  var lenStr = 0;\n  var maxCompact = 65536;\n  var uintArrays = [];\n  for (var i = 0, len = newParts.length; i < len; i++) {\n    var part = newParts[i];\n\n    /*\n     * This condition should be hit in the integration test at :\n     * it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n     * Stryker disable all : because this is an optimisation that won't make any tests fail\n     */\n    if (part.length + lenStr > maxCompact) {\n      var _arr = string2buf(longStr);\n      fullLength += _arr.length;\n      uintArrays.push(_arr);\n      longStr = \"\";\n    }\n    // Stryker restore all\n\n    longStr += part;\n    lenStr += part.length;\n    delete newParts[i];\n  }\n  var arr = string2buf(longStr);\n  fullLength += arr.length;\n  uintArrays.push(arr);\n  var array = new Uint8Array(fullLength);\n  var j = 0;\n\n  // Stryker disable all : because this is an optimisation that won't make any tests fail\n  for (var _i4 = 0; _i4 < uintArrays.length; _i4++) {\n    var buf = uintArrays[_i4];\n    for (var _i5 = 0; _i5 < buf.length; ++_i5) {\n      array[_i5 + j] = buf[_i5];\n    }\n    j += buf.length;\n  } // Stryker restore all\n  return array;\n}\nmodule.exports = postrender;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcG9zdHJlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Bvc3RyZW5kZXIuanM/ODkyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAqIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbiAqIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHRoaXMgaXMgYSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgd2FzIGNvcGllZFxuICogZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL29wZW4teG1sLXRlbXBsYXRpbmcvcGl6emlwL2Jsb2IvMzRhODQwNTUzYzYwNDk4MDg1OWRjNmQwZGNkMWY4OWI2ZTU1MjdiMy9lczYvdXRmOC5qcyNMMzNcbiAqL1xuZnVuY3Rpb24gc3RyaW5nMmJ1ZihzdHIpIHtcbiAgdmFyIGMsXG4gICAgYzIsXG4gICAgbVBvcyxcbiAgICBpLFxuICAgIGJ1ZkxlbiA9IDA7XG4gIHZhciBzdHJMZW4gPSBzdHIubGVuZ3RoO1xuXG4gIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gIGZvciAobVBvcyA9IDA7IG1Qb3MgPCBzdHJMZW47IG1Qb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtUG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgbVBvcyArIDEgPCBzdHJMZW4pIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobVBvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArIChjIC0gMHhkODAwIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1Qb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmTGVuICs9IGMgPCAweDgwID8gMSA6IGMgPCAweDgwMCA/IDIgOiBjIDwgMHgxMDAwMCA/IDMgOiA0O1xuICB9XG5cbiAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShidWZMZW4pO1xuXG4gIC8vIGNvbnZlcnRcbiAgZm9yIChpID0gMCwgbVBvcyA9IDA7IGkgPCBidWZMZW47IG1Qb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtUG9zKTtcbiAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgbVBvcyArIDEgPCBzdHJMZW4pIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobVBvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArIChjIC0gMHhkODAwIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1Qb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgYnVmW2krK10gPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAvKiB0d28gYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhjMCB8IGMgPj4+IDY7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjICYgMHgzZjtcbiAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgYnVmW2krK10gPSAweGUwIHwgYyA+Pj4gMTI7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCBjID4+PiA2ICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgJiAweDNmO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiBmb3VyIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4ZjAgfCBjID4+PiAxODtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDEyICYgMHgzZjtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IGMgPj4+IDYgJiAweDNmO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgYyAmIDB4M2Y7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWY7XG59XG4vLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbmZ1bmN0aW9uIHBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgX2kyID0gMCwgX29wdGlvbnMkbW9kdWxlczIgPSBvcHRpb25zLm1vZHVsZXM7IF9pMiA8IF9vcHRpb25zJG1vZHVsZXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX21vZHVsZSA9IF9vcHRpb25zJG1vZHVsZXMyW19pMl07XG4gICAgcGFydHMgPSBfbW9kdWxlLnBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpO1xuICB9XG4gIHZhciBmdWxsTGVuZ3RoID0gMDtcbiAgdmFyIG5ld1BhcnRzID0gb3B0aW9ucy5qb2luVW5jb3JydXB0KHBhcnRzLCBvcHRpb25zKTtcbiAgdmFyIGxvbmdTdHIgPSBcIlwiO1xuICB2YXIgbGVuU3RyID0gMDtcbiAgdmFyIG1heENvbXBhY3QgPSA2NTUzNjtcbiAgdmFyIHVpbnRBcnJheXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5ld1BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBuZXdQYXJ0c1tpXTtcblxuICAgIC8qXG4gICAgICogVGhpcyBjb25kaXRpb24gc2hvdWxkIGJlIGhpdCBpbiB0aGUgaW50ZWdyYXRpb24gdGVzdCBhdCA6XG4gICAgICogaXQoXCJzaG91bGQgbm90IHJlZ3Jlc3Mgd2l0aCBsb25nIGZpbGUgKGhpdCBtYXhDb21wYWN0IHZhbHVlIG9mIDY1NTM2KVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICogU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBpcyBhbiBvcHRpbWlzYXRpb24gdGhhdCB3b24ndCBtYWtlIGFueSB0ZXN0cyBmYWlsXG4gICAgICovXG4gICAgaWYgKHBhcnQubGVuZ3RoICsgbGVuU3RyID4gbWF4Q29tcGFjdCkge1xuICAgICAgdmFyIF9hcnIgPSBzdHJpbmcyYnVmKGxvbmdTdHIpO1xuICAgICAgZnVsbExlbmd0aCArPSBfYXJyLmxlbmd0aDtcbiAgICAgIHVpbnRBcnJheXMucHVzaChfYXJyKTtcbiAgICAgIGxvbmdTdHIgPSBcIlwiO1xuICAgIH1cbiAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG5cbiAgICBsb25nU3RyICs9IHBhcnQ7XG4gICAgbGVuU3RyICs9IHBhcnQubGVuZ3RoO1xuICAgIGRlbGV0ZSBuZXdQYXJ0c1tpXTtcbiAgfVxuICB2YXIgYXJyID0gc3RyaW5nMmJ1Zihsb25nU3RyKTtcbiAgZnVsbExlbmd0aCArPSBhcnIubGVuZ3RoO1xuICB1aW50QXJyYXlzLnB1c2goYXJyKTtcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZnVsbExlbmd0aCk7XG4gIHZhciBqID0gMDtcblxuICAvLyBTdHJ5a2VyIGRpc2FibGUgYWxsIDogYmVjYXVzZSB0aGlzIGlzIGFuIG9wdGltaXNhdGlvbiB0aGF0IHdvbid0IG1ha2UgYW55IHRlc3RzIGZhaWxcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdWludEFycmF5cy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgdmFyIGJ1ZiA9IHVpbnRBcnJheXNbX2k0XTtcbiAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBidWYubGVuZ3RoOyArK19pNSkge1xuICAgICAgYXJyYXlbX2k1ICsgal0gPSBidWZbX2k1XTtcbiAgICB9XG4gICAgaiArPSBidWYubGVuZ3RoO1xuICB9IC8vIFN0cnlrZXIgcmVzdG9yZSBhbGxcbiAgcmV0dXJuIGFycmF5O1xufVxubW9kdWxlLmV4cG9ydHMgPSBwb3N0cmVuZGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/postrender.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/prefix-matcher.js":
/*!*************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/prefix-matcher.js ***!
  \*************************************************************/
/***/ ((module) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n  return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n  }\n  if (condition instanceof RegExp) {\n    return condition.test(replaceNbsps(placeHolderContent));\n  }\n  if (type === \"function\") {\n    return !!condition(placeHolderContent);\n  }\n}\nfunction getValue(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return replaceNbsps(placeHolderContent).substr(condition.length);\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition)[1];\n  }\n  if (type === \"function\") {\n    return condition(placeHolderContent);\n  }\n}\nfunction getValues(condition, placeHolderContent) {\n  var type = _typeof(condition);\n  if (type === \"string\") {\n    return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition);\n  }\n  if (type === \"function\") {\n    return [placeHolderContent, condition(placeHolderContent)];\n  }\n}\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcHJlZml4LW1hdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsc0JBQXNCLDJCQUEyQixvR0FBb0csbUJBQW1CLGlCQUFpQixzSEFBc0g7QUFDL1M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9wcmVmaXgtbWF0Y2hlci5qcz81OTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG52YXIgbmJzcFJlZ2V4ID0gbmV3IFJlZ0V4cChTdHJpbmcuZnJvbUNoYXJDb2RlKDE2MCksIFwiZ1wiKTtcbmZ1bmN0aW9uIHJlcGxhY2VOYnNwcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ic3BSZWdleCwgXCIgXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2goY29uZGl0aW9uLCBwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGNvbmRpdGlvbik7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQuc3Vic3RyKDAsIGNvbmRpdGlvbi5sZW5ndGgpKSA9PT0gY29uZGl0aW9uO1xuICB9XG4gIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gY29uZGl0aW9uLnRlc3QocmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkpO1xuICB9XG4gIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gISFjb25kaXRpb24ocGxhY2VIb2xkZXJDb250ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWUoY29uZGl0aW9uLCBwbGFjZUhvbGRlckNvbnRlbnQpIHtcbiAgdmFyIHR5cGUgPSBfdHlwZW9mKGNvbmRpdGlvbik7XG4gIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLnN1YnN0cihjb25kaXRpb24ubGVuZ3RoKTtcbiAgfVxuICBpZiAoY29uZGl0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VOYnNwcyhwbGFjZUhvbGRlckNvbnRlbnQpLm1hdGNoKGNvbmRpdGlvbilbMV07XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjb25kaXRpb24ocGxhY2VIb2xkZXJDb250ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0VmFsdWVzKGNvbmRpdGlvbiwgcGxhY2VIb2xkZXJDb250ZW50KSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZihjb25kaXRpb24pO1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbcGxhY2VIb2xkZXJDb250ZW50LCByZXBsYWNlTmJzcHMocGxhY2VIb2xkZXJDb250ZW50KS5zdWJzdHIoY29uZGl0aW9uLmxlbmd0aCldO1xuICB9XG4gIGlmIChjb25kaXRpb24gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVwbGFjZU5ic3BzKHBsYWNlSG9sZGVyQ29udGVudCkubWF0Y2goY29uZGl0aW9uKTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIFtwbGFjZUhvbGRlckNvbnRlbnQsIGNvbmRpdGlvbihwbGFjZUhvbGRlckNvbnRlbnQpXTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hdGNoOiBtYXRjaCxcbiAgZ2V0VmFsdWU6IGdldFZhbHVlLFxuICBnZXRWYWx1ZXM6IGdldFZhbHVlc1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/prefix-matcher.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/render.js":
/*!*****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/render.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  throwUnimplementedTagType = _require.throwUnimplementedTagType,\n  XTScopeParserError = _require.XTScopeParserError;\nvar _require2 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require2.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/../../node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleRender(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleRendered = _module.render(part, options);\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n  return false;\n}\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  var errors = [];\n  var parts = [];\n  for (var i = 0, len = compiled.length; i < len; i++) {\n    var part = compiled[i];\n    options.index = i;\n    options.resolvedId = getResolvedId(part, options);\n    var moduleRendered = void 0;\n    try {\n      moduleRendered = moduleRender(part, options);\n    } catch (e) {\n      if (e instanceof XTScopeParserError) {\n        errors.push(e);\n        parts.push(part);\n        continue;\n      }\n      throw e;\n    }\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        pushArray(errors, moduleRendered.errors);\n      }\n      parts.push(moduleRendered);\n      continue;\n    }\n    if (part.type === \"content\" || part.type === \"tag\") {\n      parts.push(part);\n      continue;\n    }\n    throwUnimplementedTagType(part, i);\n  }\n\n  // This is done in two steps because for some files, it is possible to #edit-value-backwards\n  var totalParts = [];\n  for (var _i4 = 0; _i4 < parts.length; _i4++) {\n    var value = parts[_i4].value;\n    if (value instanceof Array) {\n      pushArray(totalParts, value);\n    } else if (value) {\n      totalParts.push(value);\n    }\n  }\n  return {\n    errors: errors,\n    parts: totalParts\n  };\n}\nmodule.exports = render;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx3RUFBYTtBQUNwQztBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsOEVBQWdCO0FBQ3hDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsMEZBQXNCO0FBQ2xEO0FBQ0EseURBQXlELGdDQUFnQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVuZGVyLmpzP2Q3ZjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoXCIuL2Vycm9ycy5qc1wiKSxcbiAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZSA9IF9yZXF1aXJlLnRocm93VW5pbXBsZW1lbnRlZFRhZ1R5cGUsXG4gIFhUU2NvcGVQYXJzZXJFcnJvciA9IF9yZXF1aXJlLlhUU2NvcGVQYXJzZXJFcnJvcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlMi5wdXNoQXJyYXk7XG52YXIgZ2V0UmVzb2x2ZWRJZCA9IHJlcXVpcmUoXCIuL2dldC1yZXNvbHZlZC1pZC5qc1wiKTtcbmZ1bmN0aW9uIG1vZHVsZVJlbmRlcihwYXJ0LCBvcHRpb25zKSB7XG4gIGZvciAodmFyIF9pMiA9IDAsIF9vcHRpb25zJG1vZHVsZXMyID0gb3B0aW9ucy5tb2R1bGVzOyBfaTIgPCBfb3B0aW9ucyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIF9tb2R1bGUgPSBfb3B0aW9ucyRtb2R1bGVzMltfaTJdO1xuICAgIHZhciBtb2R1bGVSZW5kZXJlZCA9IF9tb2R1bGUucmVuZGVyKHBhcnQsIG9wdGlvbnMpO1xuICAgIGlmIChtb2R1bGVSZW5kZXJlZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZVJlbmRlcmVkO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW5kZXIob3B0aW9ucykge1xuICB2YXIgYmFzZU51bGxHZXR0ZXIgPSBvcHRpb25zLmJhc2VOdWxsR2V0dGVyO1xuICB2YXIgY29tcGlsZWQgPSBvcHRpb25zLmNvbXBpbGVkLFxuICAgIHNjb3BlTWFuYWdlciA9IG9wdGlvbnMuc2NvcGVNYW5hZ2VyO1xuICBvcHRpb25zLm51bGxHZXR0ZXIgPSBmdW5jdGlvbiAocGFydCwgc20pIHtcbiAgICByZXR1cm4gYmFzZU51bGxHZXR0ZXIocGFydCwgc20gfHwgc2NvcGVNYW5hZ2VyKTtcbiAgfTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBpbGVkLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHBhcnQgPSBjb21waWxlZFtpXTtcbiAgICBvcHRpb25zLmluZGV4ID0gaTtcbiAgICBvcHRpb25zLnJlc29sdmVkSWQgPSBnZXRSZXNvbHZlZElkKHBhcnQsIG9wdGlvbnMpO1xuICAgIHZhciBtb2R1bGVSZW5kZXJlZCA9IHZvaWQgMDtcbiAgICB0cnkge1xuICAgICAgbW9kdWxlUmVuZGVyZWQgPSBtb2R1bGVSZW5kZXIocGFydCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYVFNjb3BlUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZVJlbmRlcmVkKSB7XG4gICAgICBpZiAobW9kdWxlUmVuZGVyZWQuZXJyb3JzKSB7XG4gICAgICAgIHB1c2hBcnJheShlcnJvcnMsIG1vZHVsZVJlbmRlcmVkLmVycm9ycyk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG1vZHVsZVJlbmRlcmVkKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSBcImNvbnRlbnRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidGFnXCIpIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhyb3dVbmltcGxlbWVudGVkVGFnVHlwZShwYXJ0LCBpKTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgZG9uZSBpbiB0d28gc3RlcHMgYmVjYXVzZSBmb3Igc29tZSBmaWxlcywgaXQgaXMgcG9zc2libGUgdG8gI2VkaXQtdmFsdWUtYmFja3dhcmRzXG4gIHZhciB0b3RhbFBhcnRzID0gW107XG4gIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHBhcnRzLmxlbmd0aDsgX2k0KyspIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJ0c1tfaTRdLnZhbHVlO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwdXNoQXJyYXkodG90YWxQYXJ0cywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHRvdGFsUGFydHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgcGFydHM6IHRvdGFsUGFydHNcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/render.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/resolve.js":
/*!******************************************************!*\
  !*** ../../node_modules/docxtemplater/js/resolve.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray;\nvar getResolvedId = __webpack_require__(/*! ./get-resolved-id.js */ \"(rsc)/../../node_modules/docxtemplater/js/get-resolved-id.js\");\nfunction moduleResolve(part, options) {\n  for (var _i2 = 0, _options$modules2 = options.modules; _i2 < _options$modules2.length; _i2++) {\n    var _module = _options$modules2[_i2];\n    var moduleResolved = _module.resolve(part, options);\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n  return false;\n}\nfunction resolve(options) {\n  var resolved = [];\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  options.resolved = resolved;\n  var errors = [];\n  return Promise.all(compiled.filter(function (part) {\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\n  }).reduce(function (promises, part) {\n    var moduleResolved = moduleResolve(part, _objectSpread(_objectSpread({}, options), {}, {\n      resolvedId: getResolvedId(part, options)\n    }));\n    var result;\n    if (moduleResolved) {\n      result = moduleResolved.then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n      });\n    } else if (part.type === \"placeholder\") {\n      result = scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        return value == null ? options.nullGetter(part) : value;\n      }).then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n        return value;\n      });\n    } else {\n      return;\n    }\n    promises.push(result[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        pushArray(errors, e);\n      } else {\n        errors.push(e);\n      }\n    }));\n    return promises;\n  }, [])).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\nmodule.exports = resolve;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvcmVzb2x2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyx5QkFBeUIsd0JBQXdCLG9DQUFvQyx5Q0FBeUMsa0NBQWtDLDBEQUEwRCwwQkFBMEI7QUFDcFAsNEJBQTRCLGdCQUFnQixzQkFBc0IsT0FBTyxrREFBa0Qsc0RBQXNELDhCQUE4QixtSkFBbUoscUVBQXFFLEtBQUs7QUFDNWEsb0NBQW9DLG9FQUFvRSwwREFBMEQ7QUFDbEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFzQjtBQUNsRDtBQUNBLHlEQUF5RCxnQ0FBZ0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCwyRUFBMkUsY0FBYztBQUN6RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy9yZXNvbHZlLmpzP2RlMGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwdXNoQXJyYXkgPSBfcmVxdWlyZS5wdXNoQXJyYXk7XG52YXIgZ2V0UmVzb2x2ZWRJZCA9IHJlcXVpcmUoXCIuL2dldC1yZXNvbHZlZC1pZC5qc1wiKTtcbmZ1bmN0aW9uIG1vZHVsZVJlc29sdmUocGFydCwgb3B0aW9ucykge1xuICBmb3IgKHZhciBfaTIgPSAwLCBfb3B0aW9ucyRtb2R1bGVzMiA9IG9wdGlvbnMubW9kdWxlczsgX2kyIDwgX29wdGlvbnMkbW9kdWxlczIubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfbW9kdWxlID0gX29wdGlvbnMkbW9kdWxlczJbX2kyXTtcbiAgICB2YXIgbW9kdWxlUmVzb2x2ZWQgPSBfbW9kdWxlLnJlc29sdmUocGFydCwgb3B0aW9ucyk7XG4gICAgaWYgKG1vZHVsZVJlc29sdmVkKSB7XG4gICAgICByZXR1cm4gbW9kdWxlUmVzb2x2ZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUob3B0aW9ucykge1xuICB2YXIgcmVzb2x2ZWQgPSBbXTtcbiAgdmFyIGJhc2VOdWxsR2V0dGVyID0gb3B0aW9ucy5iYXNlTnVsbEdldHRlcjtcbiAgdmFyIGNvbXBpbGVkID0gb3B0aW9ucy5jb21waWxlZCxcbiAgICBzY29wZU1hbmFnZXIgPSBvcHRpb25zLnNjb3BlTWFuYWdlcjtcbiAgb3B0aW9ucy5udWxsR2V0dGVyID0gZnVuY3Rpb24gKHBhcnQsIHNtKSB7XG4gICAgcmV0dXJuIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtIHx8IHNjb3BlTWFuYWdlcik7XG4gIH07XG4gIG9wdGlvbnMucmVzb2x2ZWQgPSByZXNvbHZlZDtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICByZXR1cm4gUHJvbWlzZS5hbGwoY29tcGlsZWQuZmlsdGVyKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgcmV0dXJuIFtcImNvbnRlbnRcIiwgXCJ0YWdcIl0uaW5kZXhPZihwYXJ0LnR5cGUpID09PSAtMTtcbiAgfSkucmVkdWNlKGZ1bmN0aW9uIChwcm9taXNlcywgcGFydCkge1xuICAgIHZhciBtb2R1bGVSZXNvbHZlZCA9IG1vZHVsZVJlc29sdmUocGFydCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgIHJlc29sdmVkSWQ6IGdldFJlc29sdmVkSWQocGFydCwgb3B0aW9ucylcbiAgICB9KSk7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZiAobW9kdWxlUmVzb2x2ZWQpIHtcbiAgICAgIHJlc3VsdCA9IG1vZHVsZVJlc29sdmVkLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmVkLnB1c2goe1xuICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICBsSW5kZXg6IHBhcnQubEluZGV4LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIHJlc3VsdCA9IHNjb3BlTWFuYWdlci5nZXRWYWx1ZUFzeW5jKHBhcnQudmFsdWUsIHtcbiAgICAgICAgcGFydDogcGFydFxuICAgICAgfSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBvcHRpb25zLm51bGxHZXR0ZXIocGFydCkgOiB2YWx1ZTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmVkLnB1c2goe1xuICAgICAgICAgIHRhZzogcGFydC52YWx1ZSxcbiAgICAgICAgICBsSW5kZXg6IHBhcnQubEluZGV4LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJvbWlzZXMucHVzaChyZXN1bHRbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBwdXNoQXJyYXkoZXJyb3JzLCBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gcHJvbWlzZXM7XG4gIH0sIFtdKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgcmVzb2x2ZWQ6IHJlc29sdmVkXG4gICAgfTtcbiAgfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/resolve.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/scope-manager.js":
/*!************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/scope-manager.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = __webpack_require__(/*! ./utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/utils.js\"),\n  last = _require2.last;\nvar _require3 = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n  var scope = this.scopeList[num];\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    var _loop = function _loop() {\n      var lIndex = _this.scopeLindex[i];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[i]];\n    };\n    for (var i = this.resolveOffset, len = this.scopePath.length; i < len; i++) {\n      _loop();\n    }\n    return find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value;\n  }\n  // search in the scopes (in reverse order) and keep the first defined value\n  var result;\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n  return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n  var scope = this.scopeList[num];\n  // search in the scopes (in reverse order) and keep the first defined value\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      tag: meta.part,\n      scopePath: this.scopePath\n    });\n  }\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n    return result;\n  });\n}\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n    this.root = options.root || this;\n    this.resolveOffset = options.resolveOffset || 0;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeType = \"\";\n    this.scopeTypes = options.scopeTypes;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n  return _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n      var type = Object.prototype.toString.call(value);\n      if (this.isValueFalsy(value, type)) {\n        this.scopeType = false;\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n      if (type === \"[object Array]\") {\n        this.scopeType = \"array\";\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n        return true;\n      }\n      if (type === \"[object Object]\") {\n        this.scopeType = \"object\";\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n      if (typeof result === \"function\") {\n        return result(this.scopeList[this.scopeList.length - 1], this);\n      }\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      var _this3 = this;\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function (result) {\n        if (typeof result === \"function\") {\n          return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n        }\n        return result;\n      });\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopeTypes: this.scopeTypes,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolveOffset: this.resolveOffset,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeTypes: concatArrays([this.scopeTypes, [this.scopeType]]),\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n}();\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeTypes = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvc2NvcGUtbWFuYWdlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLHdFQUFhO0FBQ3BDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVk7QUFDcEM7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esa0VBQWtFLFNBQVM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3Njb3BlLW1hbmFnZXIuanM/MjczMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHsgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7IGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykgeyB2YXIgbyA9IHJbdF07IG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pOyB9IH1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7IHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHsgd3JpdGFibGU6ICExIH0pLCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpLFxuICBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yID0gX3JlcXVpcmUuZ2V0U2NvcGVQYXJzZXJFeGVjdXRpb25FcnJvcjtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKSxcbiAgbGFzdCA9IF9yZXF1aXJlMi5sYXN0O1xudmFyIF9yZXF1aXJlMyA9IHJlcXVpcmUoXCIuL2RvYy11dGlscy5qc1wiKSxcbiAgY29uY2F0QXJyYXlzID0gX3JlcXVpcmUzLmNvbmNhdEFycmF5cztcbmZ1bmN0aW9uIGZpbmQobGlzdCwgZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoID4+PiAwO1xuICB2YXIgdmFsdWU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgaWYgKGZuLmNhbGwodGhpcywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBfZ2V0VmFsdWUodGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHNjb3BlID0gdGhpcy5zY29wZUxpc3RbbnVtXTtcbiAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgIHZhciB3ID0gdGhpcy5yZXNvbHZlZDtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBsSW5kZXggPSBfdGhpcy5zY29wZUxpbmRleFtpXTtcbiAgICAgIHcgPSBmaW5kKHcsIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHJldHVybiByLmxJbmRleCA9PT0gbEluZGV4O1xuICAgICAgfSk7XG4gICAgICB3ID0gdy52YWx1ZVtfdGhpcy5zY29wZVBhdGhJdGVtW2ldXTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSB0aGlzLnJlc29sdmVPZmZzZXQsIGxlbiA9IHRoaXMuc2NvcGVQYXRoLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBfbG9vcCgpO1xuICAgIH1cbiAgICByZXR1cm4gZmluZCh3LCBmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIG1ldGEucGFydC5sSW5kZXggPT09IHIubEluZGV4O1xuICAgIH0pLnZhbHVlO1xuICB9XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcmVzdWx0O1xuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICB0cnkge1xuICAgIHJlc3VsdCA9IHBhcnNlci5nZXQoc2NvcGUsIHRoaXMuZ2V0Q29udGV4dChtZXRhLCBudW0pKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRTY29wZVBhcnNlckV4ZWN1dGlvbkVycm9yKHtcbiAgICAgIHRhZzogdGFnLFxuICAgICAgc2NvcGU6IHNjb3BlLFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgb2Zmc2V0OiBtZXRhLnBhcnQub2Zmc2V0XG4gICAgfSk7XG4gIH1cbiAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICByZXR1cm4gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2dldFZhbHVlQXN5bmModGFnLCBtZXRhLCBudW0pIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG4gIHZhciBzY29wZSA9IHRoaXMuc2NvcGVMaXN0W251bV07XG4gIC8vIHNlYXJjaCBpbiB0aGUgc2NvcGVzIChpbiByZXZlcnNlIG9yZGVyKSBhbmQga2VlcCB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZVxuICB2YXIgcGFyc2VyO1xuICBpZiAoIXRoaXMuY2FjaGVkUGFyc2VycyB8fCAhbWV0YS5wYXJ0KSB7XG4gICAgcGFyc2VyID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF0pIHtcbiAgICBwYXJzZXIgPSB0aGlzLmNhY2hlZFBhcnNlcnNbbWV0YS5wYXJ0LmxJbmRleF07XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyID0gdGhpcy5jYWNoZWRQYXJzZXJzW21ldGEucGFydC5sSW5kZXhdID0gdGhpcy5wYXJzZXIodGFnLCB7XG4gICAgICB0YWc6IG1ldGEucGFydCxcbiAgICAgIHNjb3BlUGF0aDogdGhpcy5zY29wZVBhdGhcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhcnNlci5nZXQoc2NvcGUsIF90aGlzMi5nZXRDb250ZXh0KG1ldGEsIG51bSkpO1xuICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHRocm93IGdldFNjb3BlUGFyc2VyRXhlY3V0aW9uRXJyb3Ioe1xuICAgICAgdGFnOiB0YWcsXG4gICAgICBzY29wZTogc2NvcGUsXG4gICAgICBlcnJvcjogZXJyb3IsXG4gICAgICBvZmZzZXQ6IG1ldGEucGFydC5vZmZzZXRcbiAgICB9KTtcbiAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHJlc3VsdCA9PSBudWxsICYmIG51bSA+IDApIHtcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKF90aGlzMiwgdGFnLCBtZXRhLCBudW0gLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG52YXIgU2NvcGVNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NvcGVNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2NvcGVNYW5hZ2VyKTtcbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgdGhpcztcbiAgICB0aGlzLnJlc29sdmVPZmZzZXQgPSBvcHRpb25zLnJlc29sdmVPZmZzZXQgfHwgMDtcbiAgICB0aGlzLnNjb3BlUGF0aCA9IG9wdGlvbnMuc2NvcGVQYXRoO1xuICAgIHRoaXMuc2NvcGVQYXRoSXRlbSA9IG9wdGlvbnMuc2NvcGVQYXRoSXRlbTtcbiAgICB0aGlzLnNjb3BlUGF0aExlbmd0aCA9IG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoO1xuICAgIHRoaXMuc2NvcGVMaXN0ID0gb3B0aW9ucy5zY29wZUxpc3Q7XG4gICAgdGhpcy5zY29wZVR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc2NvcGVUeXBlcyA9IG9wdGlvbnMuc2NvcGVUeXBlcztcbiAgICB0aGlzLnNjb3BlTGluZGV4ID0gb3B0aW9ucy5zY29wZUxpbmRleDtcbiAgICB0aGlzLnBhcnNlciA9IG9wdGlvbnMucGFyc2VyO1xuICAgIHRoaXMucmVzb2x2ZWQgPSBvcHRpb25zLnJlc29sdmVkO1xuICAgIHRoaXMuY2FjaGVkUGFyc2VycyA9IG9wdGlvbnMuY2FjaGVkUGFyc2VycztcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNjb3BlTWFuYWdlciwgW3tcbiAgICBrZXk6IFwibG9vcE92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9vcE92ZXIodGFnLCBmdW5jdG9yLCBpbnZlcnRlZCwgbWV0YSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9vcE92ZXJWYWx1ZSh0aGlzLmdldFZhbHVlKHRhZywgbWV0YSksIGZ1bmN0b3IsIGludmVydGVkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZnVuY3RvcklmSW52ZXJ0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnVuY3RvcklmSW52ZXJ0ZWQoaW52ZXJ0ZWQsIGZ1bmN0b3IsIHZhbHVlLCBpLCBsZW5ndGgpIHtcbiAgICAgIGlmIChpbnZlcnRlZCkge1xuICAgICAgICBmdW5jdG9yKHZhbHVlLCBpLCBsZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludmVydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZhbHVlRmFsc3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCAhdmFsdWUgfHwgdHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9vcE92ZXJWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsb29wT3ZlclZhbHVlKHZhbHVlLCBmdW5jdG9yLCBpbnZlcnRlZCkge1xuICAgICAgaWYgKHRoaXMucm9vdC5maW5pc2hlZFJlc29sdmluZykge1xuICAgICAgICBpbnZlcnRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHRoaXMuaXNWYWx1ZUZhbHN5KHZhbHVlLCB0eXBlKSkge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZChpbnZlcnRlZCwgZnVuY3RvciwgbGFzdCh0aGlzLnNjb3BlTGlzdCksIDAsIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICB0aGlzLnNjb3BlVHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZVtpXSwgaSwgdmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiKSB7XG4gICAgICAgIHRoaXMuc2NvcGVUeXBlID0gXCJvYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3RvcklmSW52ZXJ0ZWQoIWludmVydGVkLCBmdW5jdG9yLCB2YWx1ZSwgMCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5mdW5jdG9ySWZJbnZlcnRlZCghaW52ZXJ0ZWQsIGZ1bmN0b3IsIGxhc3QodGhpcy5zY29wZUxpc3QpLCAwLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUodGFnLCBtZXRhKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gX2dldFZhbHVlLmNhbGwodGhpcywgdGFnLCBtZXRhLCB0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLnNjb3BlTGlzdFt0aGlzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWYWx1ZUFzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlQXN5bmModGFnLCBtZXRhKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHJldHVybiBfZ2V0VmFsdWVBc3luYy5jYWxsKHRoaXMsIHRhZywgbWV0YSwgdGhpcy5zY29wZUxpc3QubGVuZ3RoIC0gMSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0KF90aGlzMy5zY29wZUxpc3RbX3RoaXMzLnNjb3BlTGlzdC5sZW5ndGggLSAxXSwgX3RoaXMzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dChtZXRhLCBudW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG51bTogbnVtLFxuICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICBzY29wZUxpc3Q6IHRoaXMuc2NvcGVMaXN0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgc2NvcGVQYXRoOiB0aGlzLnNjb3BlUGF0aCxcbiAgICAgICAgc2NvcGVUeXBlczogdGhpcy5zY29wZVR5cGVzLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiB0aGlzLnNjb3BlUGF0aEl0ZW0sXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogdGhpcy5zY29wZVBhdGhMZW5ndGhcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVN1YlNjb3BlTWFuYWdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdWJTY29wZU1hbmFnZXIoc2NvcGUsIHRhZywgaSwgcGFydCwgbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbmV3IFNjb3BlTWFuYWdlcih7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgcmVzb2x2ZU9mZnNldDogdGhpcy5yZXNvbHZlT2Zmc2V0LFxuICAgICAgICByZXNvbHZlZDogdGhpcy5yZXNvbHZlZCxcbiAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgY2FjaGVkUGFyc2VyczogdGhpcy5jYWNoZWRQYXJzZXJzLFxuICAgICAgICBzY29wZVR5cGVzOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVUeXBlcywgW3RoaXMuc2NvcGVUeXBlXV0pLFxuICAgICAgICBzY29wZUxpc3Q6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpc3QsIFtzY29wZV1dKSxcbiAgICAgICAgc2NvcGVQYXRoOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoLCBbdGFnXV0pLFxuICAgICAgICBzY29wZVBhdGhJdGVtOiBjb25jYXRBcnJheXMoW3RoaXMuc2NvcGVQYXRoSXRlbSwgW2ldXSksXG4gICAgICAgIHNjb3BlUGF0aExlbmd0aDogY29uY2F0QXJyYXlzKFt0aGlzLnNjb3BlUGF0aExlbmd0aCwgW2xlbmd0aF1dKSxcbiAgICAgICAgc2NvcGVMaW5kZXg6IGNvbmNhdEFycmF5cyhbdGhpcy5zY29wZUxpbmRleCwgW3BhcnQubEluZGV4XV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5zY29wZVBhdGggPSBbXTtcbiAgb3B0aW9ucy5zY29wZVBhdGhJdGVtID0gW107XG4gIG9wdGlvbnMuc2NvcGVQYXRoTGVuZ3RoID0gW107XG4gIG9wdGlvbnMuc2NvcGVUeXBlcyA9IFtdO1xuICBvcHRpb25zLnNjb3BlTGluZGV4ID0gW107XG4gIG9wdGlvbnMuc2NvcGVMaXN0ID0gW29wdGlvbnMudGFnc107XG4gIHJldHVybiBuZXcgU2NvcGVNYW5hZ2VyKG9wdGlvbnMpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/scope-manager.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/traits.js":
/*!*****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/traits.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = __webpack_require__(/*! ./errors.js */ \"(rsc)/../../node_modules/docxtemplater/js/errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n   * Gets the list of closing and opening tags between two texts. It doesn't take\n   * into account tags that are opened then closed. Those that are closed then\n   * opened are kept\n   *\n   * Example input :\n   *\n   * [\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"table1\",\n   * \t\t...\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data1\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"position\": \"end\",\n   * \t\t\"text\": true,\n   * \t\t\"value\": \"</w:t>\",\n   * \t\t\"tag\": \"w:t\",\n   * \t\t\"lIndex\": 112\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:p>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"</w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:tc>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"content\",\n   * \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n   * \t},\n   * \t...\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:r>\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"tag\",\n   * \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n   * \t},\n   * \t{\n   * \t\t\"type\": \"placeholder\",\n   * \t\t\"value\": \"t1data4\",\n   * \t}\n   * ]\n   *\n   * Returns\n   *\n   * \t[\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:t>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"</w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:tc>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:p>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:r>\",\n   * \t\t},\n   * \t\t{\n   * \t\t\t\"tag\": \"<w:t>\",\n   * \t\t},\n   * \t]\n   */\n\n  var result = [];\n  for (var _i2 = 0; _i2 < parts.length; _i2++) {\n    var _parts$_i = parts[_i2],\n      position = _parts$_i.position,\n      value = _parts$_i.value,\n      tag = _parts$_i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var _i4 = 0; _i4 < xmlElements.length; _i4++) {\n    var xmlElement = xmlElements[_i4];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n      var _expandTags$_i = expandTags[_i6],\n        contains = _expandTags$_i.contains,\n        expand = _expandTags$_i.expand,\n        onlyTextInTag = _expandTags$_i.onlyTextInTag;\n      if (has(contains, xmlElements)) {\n        if (onlyTextInTag) {\n          var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n          var right = getRightOrNull(postparsed, contains, pair[1].offset);\n          if (left === null || right === null) {\n            return 0; // continue\n          }\n          var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n            return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n          });\n          var firstChunk = first(chunks);\n          var lastChunk = last(chunks);\n          var firstContent = firstChunk.filter(isContent);\n          var lastContent = lastChunk.filter(isContent);\n          if (firstContent.length !== 1 || lastContent.length !== 1) {\n            return 0; // continue\n          }\n        }\n        return {\n          v: {\n            value: expand\n          }\n        };\n      }\n    },\n    _ret;\n  for (var _i6 = 0; _i6 < expandTags.length; _i6++) {\n    _ret = _loop();\n    if (_ret === 0) continue;\n    if (_ret) return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    var errProps = _objectSpread({\n      part: part,\n      rootError: rootError,\n      postparsed: postparsed,\n      expandTo: expandTo,\n      index: index\n    }, options.error);\n    if (options.onError) {\n      var errorResult = options.onError(errProps);\n      if (errorResult === \"ignore\") {\n        return;\n      }\n    }\n    throwExpandNotFound(errProps);\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\n\n/* eslint-disable-next-line complexity */\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    /*\n     * The part.subparsed check is used to fix this github issue :\n     * https://github.com/open-xml-templating/docxtemplater/issues/671\n     */\n    !part.subparsed && !part.expanded) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        // The Error can only be a\n        errors.push(error);\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  for (var _i7 = 0, _len = limits.length; _i7 < _len; _i7++) {\n    var _postparsed;\n    var _limit2 = limits[_i7];\n    maxRight = Math.max(maxRight, _i7 > 0 ? limits[_i7 - 1].right : 0);\n    if (_limit2.left < maxRight) {\n      continue;\n    }\n    var result = void 0;\n    try {\n      result = expandOne([_limit2.left + offset, _limit2.right + offset], _limit2.part, postparsed, options);\n    } catch (error) {\n      if (options.onError) {\n        var errorResult = options.onError(_objectSpread({\n          part: _limit2.part,\n          rootError: error,\n          postparsed: postparsed,\n          expandOne: expandOne\n        }, options.errors));\n        if (errorResult === \"ignore\") {\n          continue;\n        }\n      }\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      continue;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  }\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdHJhaXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLHNCQUFzQiwyQkFBMkIsb0dBQW9HLG1CQUFtQixpQkFBaUIsc0hBQXNIO0FBQy9TLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLDZDQUE2QyxTQUFTLDBEQUEwRCxVQUFVLGdDQUFnQztBQUMxSixtQ0FBbUMsK0NBQStDLDhCQUE4QixPQUFPLGtCQUFrQjtBQUN6SSx1Q0FBdUMsa0dBQWtHLGlCQUFpQix3Q0FBd0MsTUFBTSx5Q0FBeUMsNkJBQTZCLFVBQVUsWUFBWSxrRUFBa0UsV0FBVyxZQUFZLGlCQUFpQixVQUFVLE1BQU0saUZBQWlGLFVBQVUsb0JBQW9CO0FBQzdnQiw4QkFBOEI7QUFDOUIseUJBQXlCLHdCQUF3QixvQ0FBb0MseUNBQXlDLGtDQUFrQywwREFBMEQsMEJBQTBCO0FBQ3BQLDRCQUE0QixnQkFBZ0Isc0JBQXNCLE9BQU8sa0RBQWtELHNEQUFzRCw4QkFBOEIsbUpBQW1KLHFFQUFxRSxLQUFLO0FBQzVhLG9DQUFvQyxvRUFBb0UsMERBQTBEO0FBQ2xLLDZCQUE2QixtQ0FBbUM7QUFDaEUsOEJBQThCLDRDQUE0QywrQkFBK0Isb0JBQW9CLG1DQUFtQyxzQ0FBc0MsdUVBQXVFO0FBQzdRLGVBQWUsbUJBQU8sQ0FBQyw4RUFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvZG9jeHRlbXBsYXRlci9qcy90cmFpdHMuanM/NzljOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZihvKTsgfVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7IGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7IGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHsgaWYgKHIpIHsgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTsgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTsgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7IH0gfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgeyAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7IGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdOyByZXR1cm4gbjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKG8pIHRocm93IG47IH0gfSByZXR1cm4gYTsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikgeyBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7IH1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikgeyB2YXIgdCA9IE9iamVjdC5rZXlzKGUpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHsgcmV0dXJuIChyID0gX3RvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgeyB2YWx1ZTogdCwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSA6IGVbcl0gPSB0LCBlOyB9XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7IHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpOyByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiOyB9XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikgeyBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDsgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07IGlmICh2b2lkIDAgIT09IGUpIHsgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpOyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7IH0gcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTsgfVxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBnZXRSaWdodE9yTnVsbCA9IF9yZXF1aXJlLmdldFJpZ2h0T3JOdWxsLFxuICBnZXRSaWdodCA9IF9yZXF1aXJlLmdldFJpZ2h0LFxuICBnZXRMZWZ0ID0gX3JlcXVpcmUuZ2V0TGVmdCxcbiAgZ2V0TGVmdE9yTnVsbCA9IF9yZXF1aXJlLmdldExlZnRPck51bGwsXG4gIGNodW5rQnkgPSBfcmVxdWlyZS5jaHVua0J5LFxuICBpc1RhZ1N0YXJ0ID0gX3JlcXVpcmUuaXNUYWdTdGFydCxcbiAgaXNUYWdFbmQgPSBfcmVxdWlyZS5pc1RhZ0VuZCxcbiAgaXNDb250ZW50ID0gX3JlcXVpcmUuaXNDb250ZW50LFxuICBsYXN0ID0gX3JlcXVpcmUubGFzdCxcbiAgZmlyc3QgPSBfcmVxdWlyZS5maXJzdDtcbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKFwiLi9lcnJvcnMuanNcIiksXG4gIFhUVGVtcGxhdGVFcnJvciA9IF9yZXF1aXJlMi5YVFRlbXBsYXRlRXJyb3IsXG4gIHRocm93RXhwYW5kTm90Rm91bmQgPSBfcmVxdWlyZTIudGhyb3dFeHBhbmROb3RGb3VuZCxcbiAgZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3IgPSBfcmVxdWlyZTIuZ2V0TG9vcFBvc2l0aW9uUHJvZHVjZXNJbnZhbGlkWE1MRXJyb3I7XG5mdW5jdGlvbiBsYXN0VGFnSXNPcGVuVGFnKHRhZ3MsIHRhZykge1xuICBpZiAodGFncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGlubmVyTGFzdFRhZyA9IGxhc3QodGFncykuc3Vic3RyKDEpO1xuICByZXR1cm4gaW5uZXJMYXN0VGFnLmluZGV4T2YodGFnKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIGdldExpc3RYbWxFbGVtZW50cyhwYXJ0cykge1xuICAvKlxuICAgKiBHZXRzIHRoZSBsaXN0IG9mIGNsb3NpbmcgYW5kIG9wZW5pbmcgdGFncyBiZXR3ZWVuIHR3byB0ZXh0cy4gSXQgZG9lc24ndCB0YWtlXG4gICAqIGludG8gYWNjb3VudCB0YWdzIHRoYXQgYXJlIG9wZW5lZCB0aGVuIGNsb3NlZC4gVGhvc2UgdGhhdCBhcmUgY2xvc2VkIHRoZW5cbiAgICogb3BlbmVkIGFyZSBrZXB0XG4gICAqXG4gICAqIEV4YW1wbGUgaW5wdXQgOlxuICAgKlxuICAgKiBbXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0YWJsZTFcIixcbiAgICogXHRcdC4uLlxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0MWRhdGExXCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwicG9zaXRpb25cIjogXCJlbmRcIixcbiAgICogXHRcdFwidGV4dFwiOiB0cnVlLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0PlwiLFxuICAgKiBcdFx0XCJ0YWdcIjogXCJ3OnRcIixcbiAgICogXHRcdFwibEluZGV4XCI6IDExMlxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPC93OnI+XCIsXG4gICAqIFx0fSxcbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8L3c6cD5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjwvdzp0Yz5cIixcbiAgICogXHR9LFxuICAgKiBcdHtcbiAgICogXHRcdFwidHlwZVwiOiBcInRhZ1wiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwiY29udGVudFwiLFxuICAgKiBcdFx0XCJ2YWx1ZVwiOiBcIjx3OnRjUHI+PHc6dGNXIHc6dz1cIjI0NDRcIiB3OnR5cGU9XCJkeGFcIi8+PHc6dGNCb3JkZXJzPjx3OnRvcCB3OnZhbD1cIm5pbFwiLz48dzpsZWZ0IHc6dmFsPVwibmlsXCIvPjx3OmJvdHRvbSB3OnZhbD1cIm5pbFwiLz48dzpyaWdodCB3OnZhbD1cIm5pbFwiLz48L3c6dGNCb3JkZXJzPjx3OnNoZCB3OnZhbD1cImNsZWFyXCIgdzpjb2xvcj1cImF1dG9cIiB3OmZpbGw9XCJGRkZGRkZcIi8+PC93OnRjUHI+XCIsXG4gICAqIFx0fSxcbiAgICogXHQuLi5cbiAgICogXHR7XG4gICAqIFx0XHRcInR5cGVcIjogXCJ0YWdcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCI8dzpyPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwidGFnXCIsXG4gICAqIFx0XHRcInZhbHVlXCI6IFwiPHc6dCB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlwiLFxuICAgKiBcdH0sXG4gICAqIFx0e1xuICAgKiBcdFx0XCJ0eXBlXCI6IFwicGxhY2Vob2xkZXJcIixcbiAgICogXHRcdFwidmFsdWVcIjogXCJ0MWRhdGE0XCIsXG4gICAqIFx0fVxuICAgKiBdXG4gICAqXG4gICAqIFJldHVybnNcbiAgICpcbiAgICogXHRbXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnQ+XCIsXG4gICAqIFx0XHR9LFxuICAgKiBcdFx0e1xuICAgKiBcdFx0XHRcInRhZ1wiOiBcIjwvdzpyPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8L3c6cD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPC93OnRjPlwiLFxuICAgKiBcdFx0fSxcbiAgICogXHRcdHtcbiAgICogXHRcdFx0XCJ0YWdcIjogXCI8dzp0Yz5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6cD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6cj5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XHR7XG4gICAqIFx0XHRcdFwidGFnXCI6IFwiPHc6dD5cIixcbiAgICogXHRcdH0sXG4gICAqIFx0XVxuICAgKi9cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHBhcnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3BhcnRzJF9pID0gcGFydHNbX2kyXSxcbiAgICAgIHBvc2l0aW9uID0gX3BhcnRzJF9pLnBvc2l0aW9uLFxuICAgICAgdmFsdWUgPSBfcGFydHMkX2kudmFsdWUsXG4gICAgICB0YWcgPSBfcGFydHMkX2kudGFnO1xuICAgIC8vIFN0cnlrZXIgZGlzYWJsZSBhbGwgOiBiZWNhdXNlIHJlbW92aW5nIHRoaXMgY29uZGl0aW9uIHdvdWxkIGFsc28gd29yayBidXQgd2Ugd2FudCB0byBtYWtlIHRoZSBBUEkgZnV0dXJlIHByb29mXG4gICAgaWYgKCF0YWcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBTdHJ5a2VyIHJlc3RvcmUgYWxsXG4gICAgaWYgKHBvc2l0aW9uID09PSBcImVuZFwiKSB7XG4gICAgICBpZiAobGFzdFRhZ0lzT3BlblRhZyhyZXN1bHQsIHRhZykpIHtcbiAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwic3RhcnRcIikge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvLyBpZ25vcmUgcG9zaXRpb24gPT09IFwic2VsZmNsb3NpbmdcIlxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBoYXMobmFtZSwgeG1sRWxlbWVudHMpIHtcbiAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgeG1sRWxlbWVudHMubGVuZ3RoOyBfaTQrKykge1xuICAgIHZhciB4bWxFbGVtZW50ID0geG1sRWxlbWVudHNbX2k0XTtcbiAgICBpZiAoeG1sRWxlbWVudC5pbmRleE9mKFwiPFwiLmNvbmNhdChuYW1lKSkgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRFeHBhbmRUb0RlZmF1bHQocG9zdHBhcnNlZCwgcGFpciwgZXhwYW5kVGFncykge1xuICB2YXIgcGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKHBhaXJbMF0ub2Zmc2V0LCBwYWlyWzFdLm9mZnNldCk7XG4gIHZhciB4bWxFbGVtZW50cyA9IGdldExpc3RYbWxFbGVtZW50cyhwYXJ0cyk7XG4gIHZhciBjbG9zaW5nVGFnQ291bnQgPSB4bWxFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHRhZykge1xuICAgIHJldHVybiB0YWdbMV0gPT09IFwiL1wiO1xuICB9KS5sZW5ndGg7XG4gIHZhciBzdGFydGluZ1RhZ0NvdW50ID0geG1sRWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gdGFnWzFdICE9PSBcIi9cIiAmJiB0YWdbdGFnLmxlbmd0aCAtIDJdICE9PSBcIi9cIjtcbiAgfSkubGVuZ3RoO1xuICBpZiAoY2xvc2luZ1RhZ0NvdW50ICE9PSBzdGFydGluZ1RhZ0NvdW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBnZXRMb29wUG9zaXRpb25Qcm9kdWNlc0ludmFsaWRYTUxFcnJvcih7XG4gICAgICAgIHRhZzogZmlyc3QocGFpcikucGFydC52YWx1ZSxcbiAgICAgICAgb2Zmc2V0OiBbZmlyc3QocGFpcikucGFydC5vZmZzZXQsIGxhc3QocGFpcikucGFydC5vZmZzZXRdXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgX2V4cGFuZFRhZ3MkX2kgPSBleHBhbmRUYWdzW19pNl0sXG4gICAgICAgIGNvbnRhaW5zID0gX2V4cGFuZFRhZ3MkX2kuY29udGFpbnMsXG4gICAgICAgIGV4cGFuZCA9IF9leHBhbmRUYWdzJF9pLmV4cGFuZCxcbiAgICAgICAgb25seVRleHRJblRhZyA9IF9leHBhbmRUYWdzJF9pLm9ubHlUZXh0SW5UYWc7XG4gICAgICBpZiAoaGFzKGNvbnRhaW5zLCB4bWxFbGVtZW50cykpIHtcbiAgICAgICAgaWYgKG9ubHlUZXh0SW5UYWcpIHtcbiAgICAgICAgICB2YXIgbGVmdCA9IGdldExlZnRPck51bGwocG9zdHBhcnNlZCwgY29udGFpbnMsIHBhaXJbMF0ub2Zmc2V0KTtcbiAgICAgICAgICB2YXIgcmlnaHQgPSBnZXRSaWdodE9yTnVsbChwb3N0cGFyc2VkLCBjb250YWlucywgcGFpclsxXS5vZmZzZXQpO1xuICAgICAgICAgIGlmIChsZWZ0ID09PSBudWxsIHx8IHJpZ2h0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNodW5rcyA9IGNodW5rQnkocG9zdHBhcnNlZC5zbGljZShsZWZ0LCByaWdodCksIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNUYWdTdGFydChjb250YWlucywgcCkgPyBcInN0YXJ0XCIgOiBpc1RhZ0VuZChjb250YWlucywgcCkgPyBcImVuZFwiIDogbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgZmlyc3RDaHVuayA9IGZpcnN0KGNodW5rcyk7XG4gICAgICAgICAgdmFyIGxhc3RDaHVuayA9IGxhc3QoY2h1bmtzKTtcbiAgICAgICAgICB2YXIgZmlyc3RDb250ZW50ID0gZmlyc3RDaHVuay5maWx0ZXIoaXNDb250ZW50KTtcbiAgICAgICAgICB2YXIgbGFzdENvbnRlbnQgPSBsYXN0Q2h1bmsuZmlsdGVyKGlzQ29udGVudCk7XG4gICAgICAgICAgaWYgKGZpcnN0Q29udGVudC5sZW5ndGggIT09IDEgfHwgbGFzdENvbnRlbnQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2OiB7XG4gICAgICAgICAgICB2YWx1ZTogZXhwYW5kXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX3JldDtcbiAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgZXhwYW5kVGFncy5sZW5ndGg7IF9pNisrKSB7XG4gICAgX3JldCA9IF9sb29wKCk7XG4gICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgIGlmIChfcmV0KSByZXR1cm4gX3JldC52O1xuICB9XG4gIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZExpbWl0KHBhcnQsIGluZGV4LCBwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gIHZhciBleHBhbmRUbyA9IHBhcnQuZXhwYW5kVG8gfHwgb3B0aW9ucy5leHBhbmRUbztcbiAgLy8gU3RyeWtlciBkaXNhYmxlIGFsbCA6IGJlY2F1c2UgdGhpcyBjb25kaXRpb24gY2FuIGJlIHJlbW92ZWQgaW4gdjQgKHRoZSBvbmx5IHVzYWdlIHdhcyB0aGUgaW1hZ2UgbW9kdWxlIGJlZm9yZSB2ZXJzaW9uIDMuMTIuMyBvZiB0aGUgaW1hZ2UgbW9kdWxlXG4gIGlmICghZXhwYW5kVG8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU3RyeWtlciByZXN0b3JlIGFsbFxuICB2YXIgcmlnaHQsIGxlZnQ7XG4gIHRyeSB7XG4gICAgbGVmdCA9IGdldExlZnQocG9zdHBhcnNlZCwgZXhwYW5kVG8sIGluZGV4KTtcbiAgICByaWdodCA9IGdldFJpZ2h0KHBvc3RwYXJzZWQsIGV4cGFuZFRvLCBpbmRleCk7XG4gIH0gY2F0Y2ggKHJvb3RFcnJvcikge1xuICAgIHZhciBlcnJQcm9wcyA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgcGFydDogcGFydCxcbiAgICAgIHJvb3RFcnJvcjogcm9vdEVycm9yLFxuICAgICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICAgIGV4cGFuZFRvOiBleHBhbmRUbyxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH0sIG9wdGlvbnMuZXJyb3IpO1xuICAgIGlmIChvcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgIHZhciBlcnJvclJlc3VsdCA9IG9wdGlvbnMub25FcnJvcihlcnJQcm9wcyk7XG4gICAgICBpZiAoZXJyb3JSZXN1bHQgPT09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvd0V4cGFuZE5vdEZvdW5kKGVyclByb3BzKTtcbiAgfVxuICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbn1cbmZ1bmN0aW9uIGV4cGFuZE9uZShfcmVmLCBwYXJ0LCBwb3N0cGFyc2VkLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGxlZnQgPSBfcmVmMlswXSxcbiAgICByaWdodCA9IF9yZWYyWzFdO1xuICB2YXIgaW5kZXggPSBwb3N0cGFyc2VkLmluZGV4T2YocGFydCk7XG4gIHZhciBsZWZ0UGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKGxlZnQsIGluZGV4KTtcbiAgdmFyIHJpZ2h0UGFydHMgPSBwb3N0cGFyc2VkLnNsaWNlKGluZGV4ICsgMSwgcmlnaHQgKyAxKTtcbiAgdmFyIGlubmVyID0gb3B0aW9ucy5nZXRJbm5lcih7XG4gICAgcG9zdHBhcnNlOiBvcHRpb25zLnBvc3RwYXJzZSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgcGFydDogcGFydCxcbiAgICBsZWZ0UGFydHM6IGxlZnRQYXJ0cyxcbiAgICByaWdodFBhcnRzOiByaWdodFBhcnRzLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWRcbiAgfSk7XG4gIGlmICghaW5uZXIubGVuZ3RoKSB7XG4gICAgaW5uZXIuZXhwYW5kZWQgPSBbbGVmdFBhcnRzLCByaWdodFBhcnRzXTtcbiAgICBpbm5lciA9IFtpbm5lcl07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICBpbm5lcjogaW5uZXJcbiAgfTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkgKi9cbmZ1bmN0aW9uIGV4cGFuZFRvT25lKHBvc3RwYXJzZWQsIG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAocG9zdHBhcnNlZC5lcnJvcnMpIHtcbiAgICBlcnJvcnMgPSBwb3N0cGFyc2VkLmVycm9ycztcbiAgICBwb3N0cGFyc2VkID0gcG9zdHBhcnNlZC5wb3N0cGFyc2VkO1xuICB9XG4gIHZhciBsaW1pdHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvc3RwYXJzZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcGFydCA9IHBvc3RwYXJzZWRbaV07XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJwbGFjZWhvbGRlclwiICYmIHBhcnQubW9kdWxlID09PSBvcHRpb25zLm1vZHVsZU5hbWUgJiZcbiAgICAvKlxuICAgICAqIFRoZSBwYXJ0LnN1YnBhcnNlZCBjaGVjayBpcyB1c2VkIHRvIGZpeCB0aGlzIGdpdGh1YiBpc3N1ZSA6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL29wZW4teG1sLXRlbXBsYXRpbmcvZG9jeHRlbXBsYXRlci9pc3N1ZXMvNjcxXG4gICAgICovXG4gICAgIXBhcnQuc3VicGFyc2VkICYmICFwYXJ0LmV4cGFuZGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbGltaXQgPSBnZXRFeHBhbmRMaW1pdChwYXJ0LCBpLCBwb3N0cGFyc2VkLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfbGltaXQgPSBfc2xpY2VkVG9BcnJheShsaW1pdCwgMiksXG4gICAgICAgICAgbGVmdCA9IF9saW1pdFswXSxcbiAgICAgICAgICByaWdodCA9IF9saW1pdFsxXTtcbiAgICAgICAgbGltaXRzLnB1c2goe1xuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHBhcnQ6IHBhcnQsXG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICBsZWZ0UGFydDogcG9zdHBhcnNlZFtsZWZ0XSxcbiAgICAgICAgICByaWdodFBhcnQ6IHBvc3RwYXJzZWRbcmlnaHRdXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gVGhlIEVycm9yIGNhbiBvbmx5IGJlIGFcbiAgICAgICAgZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsaW1pdHMuc29ydChmdW5jdGlvbiAobDEsIGwyKSB7XG4gICAgaWYgKGwxLmxlZnQgPT09IGwyLmxlZnQpIHtcbiAgICAgIHJldHVybiBsMi5wYXJ0LmxJbmRleCA8IGwxLnBhcnQubEluZGV4ID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gbDIubGVmdCA8IGwxLmxlZnQgPyAxIDogLTE7XG4gIH0pO1xuICB2YXIgbWF4UmlnaHQgPSAtMTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGZvciAodmFyIF9pNyA9IDAsIF9sZW4gPSBsaW1pdHMubGVuZ3RoOyBfaTcgPCBfbGVuOyBfaTcrKykge1xuICAgIHZhciBfcG9zdHBhcnNlZDtcbiAgICB2YXIgX2xpbWl0MiA9IGxpbWl0c1tfaTddO1xuICAgIG1heFJpZ2h0ID0gTWF0aC5tYXgobWF4UmlnaHQsIF9pNyA+IDAgPyBsaW1pdHNbX2k3IC0gMV0ucmlnaHQgOiAwKTtcbiAgICBpZiAoX2xpbWl0Mi5sZWZ0IDwgbWF4UmlnaHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBleHBhbmRPbmUoW19saW1pdDIubGVmdCArIG9mZnNldCwgX2xpbWl0Mi5yaWdodCArIG9mZnNldF0sIF9saW1pdDIucGFydCwgcG9zdHBhcnNlZCwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChvcHRpb25zLm9uRXJyb3IpIHtcbiAgICAgICAgdmFyIGVycm9yUmVzdWx0ID0gb3B0aW9ucy5vbkVycm9yKF9vYmplY3RTcHJlYWQoe1xuICAgICAgICAgIHBhcnQ6IF9saW1pdDIucGFydCxcbiAgICAgICAgICByb290RXJyb3I6IGVycm9yLFxuICAgICAgICAgIHBvc3RwYXJzZWQ6IHBvc3RwYXJzZWQsXG4gICAgICAgICAgZXhwYW5kT25lOiBleHBhbmRPbmVcbiAgICAgICAgfSwgb3B0aW9ucy5lcnJvcnMpKTtcbiAgICAgICAgaWYgKGVycm9yUmVzdWx0ID09PSBcImlnbm9yZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFhUVGVtcGxhdGVFcnJvcikge1xuICAgICAgICBlcnJvcnMucHVzaChlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gcmVzdWx0LmlubmVyLmxlbmd0aCAtIChyZXN1bHQucmlnaHQgKyAxIC0gcmVzdWx0LmxlZnQpO1xuICAgIChfcG9zdHBhcnNlZCA9IHBvc3RwYXJzZWQpLnNwbGljZS5hcHBseShfcG9zdHBhcnNlZCwgW3Jlc3VsdC5sZWZ0LCByZXN1bHQucmlnaHQgKyAxIC0gcmVzdWx0LmxlZnRdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkocmVzdWx0LmlubmVyKSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcG9zdHBhcnNlZDogcG9zdHBhcnNlZCxcbiAgICBlcnJvcnM6IGVycm9yc1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGV4cGFuZFRvT25lOiBleHBhbmRUb09uZSxcbiAgZ2V0RXhwYW5kVG9EZWZhdWx0OiBnZXRFeHBhbmRUb0RlZmF1bHRcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/traits.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/utils.js":
/*!****************************************************!*\
  !*** ../../node_modules/docxtemplater/js/utils.js ***!
  \****************************************************/
/***/ ((module) => {

eval("\n\nfunction last(a) {\n  return a[a.length - 1];\n}\nfunction first(a) {\n  return a[0];\n}\nmodule.exports = {\n  last: last,\n  first: first\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9kb2N4dGVtcGxhdGVyL2pzL3V0aWxzLmpzP2I1YjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGxhc3QoYSkge1xuICByZXR1cm4gYVthLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZmlyc3QoYSkge1xuICByZXR1cm4gYVswXTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsYXN0OiBsYXN0LFxuICBmaXJzdDogZmlyc3Rcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/utils.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/xml-matcher.js":
/*!**********************************************************!*\
  !*** ../../node_modules/docxtemplater/js/xml-matcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {\n    content: content\n  };\n  var taj = tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return res;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLW1hdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLW1hdGNoZXIuanM/YTVkYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZShcIi4vZG9jLXV0aWxzLmpzXCIpLFxuICBwcmVnTWF0Y2hBbGwgPSBfcmVxdWlyZS5wcmVnTWF0Y2hBbGw7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhtbE1hdGNoZXIoY29udGVudCwgdGFnc1htbEFycmF5KSB7XG4gIHZhciByZXMgPSB7XG4gICAgY29udGVudDogY29udGVudFxuICB9O1xuICB2YXIgdGFqID0gdGFnc1htbEFycmF5LmpvaW4oXCJ8XCIpO1xuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cChcIig/Oig8KD86XCIuY29uY2F0KHRhaiwgXCIpW14+XSo+KShbXjw+XSopPC8oPzpcIikuY29uY2F0KHRhaiwgXCIpPil8KDwoPzpcIikuY29uY2F0KHRhaiwgXCIpW14+XSovPilcIiksIFwiZ1wiKTtcbiAgcmVzLm1hdGNoZXMgPSBwcmVnTWF0Y2hBbGwocmVnZXhwLCByZXMuY29udGVudCk7XG4gIHJldHVybiByZXM7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/xml-matcher.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/docxtemplater/js/xml-templater.js":
/*!************************************************************!*\
  !*** ../../node_modules/docxtemplater/js/xml-templater.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar _require = __webpack_require__(/*! ./doc-utils.js */ \"(rsc)/../../node_modules/docxtemplater/js/doc-utils.js\"),\n  pushArray = _require.pushArray,\n  wordToUtf8 = _require.wordToUtf8,\n  convertSpaces = _require.convertSpaces;\nvar xmlMatcher = __webpack_require__(/*! ./xml-matcher.js */ \"(rsc)/../../node_modules/docxtemplater/js/xml-matcher.js\");\nvar Lexer = __webpack_require__(/*! ./lexer.js */ \"(rsc)/../../node_modules/docxtemplater/js/lexer.js\");\nvar Parser = __webpack_require__(/*! ./parser.js */ \"(rsc)/../../node_modules/docxtemplater/js/parser.js\");\nvar _render = __webpack_require__(/*! ./render.js */ \"(rsc)/../../node_modules/docxtemplater/js/render.js\");\nvar postrender = __webpack_require__(/*! ./postrender.js */ \"(rsc)/../../node_modules/docxtemplater/js/postrender.js\");\nvar resolve = __webpack_require__(/*! ./resolve.js */ \"(rsc)/../../node_modules/docxtemplater/js/resolve.js\");\nvar joinUncorrupt = __webpack_require__(/*! ./join-uncorrupt.js */ \"(rsc)/../../node_modules/docxtemplater/js/join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    _classCallCheck(this, XmlTemplater);\n    this.cachedParsers = {};\n    this.content = content;\n    for (var key in options) {\n      this[key] = options[key];\n    }\n    this.setModules({\n      inspect: {\n        filePath: options.filePath\n      }\n    });\n  }\n  return _createClass(XmlTemplater, [{\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this = this;\n      this.tags = tags;\n      var options = this.getOptions();\n      var filePath = this.filePath;\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      var errors = [];\n      return Promise.all(this.modules.map(function (module) {\n        return Promise.resolve(module.preResolve(options))[\"catch\"](function (e) {\n          errors.push(e);\n        });\n      })).then(function () {\n        if (errors.length !== 0) {\n          throw errors;\n        }\n        return resolve(options).then(function (_ref) {\n          var resolved = _ref.resolved,\n            errors = _ref.errors;\n          errors = errors.map(function (error) {\n            var _error;\n            // If a string is thrown, convert it to a real Error\n            if (!(error instanceof Error)) {\n              error = new Error(error);\n            }\n            /*\n             * error properties might not be defined if some foreign error\n             * (unhandled error not thrown by docxtemplater willingly) is\n             * thrown.\n             */\n            (_error = error).properties || (_error.properties = {});\n            error.properties.file = filePath;\n            return error;\n          });\n          if (errors.length !== 0) {\n            throw errors;\n          }\n          return Promise.all(resolved).then(function (resolved) {\n            options.scopeManager.root.finishedResolving = true;\n            options.scopeManager.resolved = resolved;\n            _this.setModules({\n              inspect: {\n                resolved: resolved,\n                filePath: filePath\n              }\n            });\n            return resolved;\n          });\n        })[\"catch\"](function (error) {\n          _this.errorChecker(error);\n          throw error;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      for (var _i2 = 0, _this$modules2 = this.modules; _i2 < _this$modules2.length; _i2++) {\n        var _module = _this$modules2[_i2];\n        _module.set(obj);\n      }\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          xmllexed: this.xmllexed\n        }\n      });\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters, this.syntax, this.fileType),\n        lexed = _Lexer$parse.lexed,\n        lexerErrors = _Lexer$parse.errors;\n      pushArray(this.allErrors, lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      this.lexed = Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        noPostParse = _ref2.noPostParse;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          parsed: this.parsed\n        }\n      });\n      if (noPostParse) {\n        return this;\n      }\n      // In v4, we could remove this \"this.postparse()\" so that users have to call this manually.\n      return this.postparse();\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse() {\n      var options = this.getOptions();\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n        postparsed = _Parser$postparse.postparsed,\n        postparsedErrors = _Parser$postparse.errors;\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          postparsed: this.postparsed\n        }\n      });\n      pushArray(this.allErrors, postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      for (var _i4 = 0, _errors2 = errors; _i4 < _errors2.length; _i4++) {\n        var error = _errors2[_i4];\n        /*\n         * error properties might not be defined if some foreign\n         * (unhandled error not thrown by docxtemplater willingly) is\n         * thrown.\n         */\n        error.properties || (error.properties = {});\n        error.properties.file = this.filePath;\n      }\n      for (var _i6 = 0, _this$modules4 = this.modules; _i6 < _this$modules4.length; _i6++) {\n        var _module2 = _this$modules4[_i6];\n        errors = _module2.errorsTransformer(errors);\n      }\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var value = null;\n      for (var _i8 = 0, _this$modules6 = this.modules; _i8 < _this$modules6.length; _i8++) {\n        var _module3 = _this$modules6[_i8];\n        if (value != null) {\n          continue;\n        }\n        value = _module3.nullGetter(part, sm, this);\n      }\n      if (value != null) {\n        return value;\n      }\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        relsType: this.relsType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        fileType: this.fileType,\n        linebreaks: this.linebreaks,\n        stripInvalidXMLChars: this.stripInvalidXMLChars\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n      var _render2 = _render(options),\n        errors = _render2.errors,\n        parts = _render2.parts;\n      if (errors.length > 0) {\n        this.allErrors = errors;\n        this.errorChecker(errors);\n        return this;\n      }\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          filePath: this.filePath,\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixzQkFBc0IsMkJBQTJCLG9HQUFvRyxtQkFBbUIsaUJBQWlCLHNIQUFzSDtBQUMvUyxpQ0FBaUM7QUFDakMsbUNBQW1DLGdCQUFnQixjQUFjLE9BQU8sY0FBYztBQUN0RixpQ0FBaUMscUhBQXFILGNBQWM7QUFDcEssNkJBQTZCLG1DQUFtQztBQUNoRSw4QkFBOEIsNENBQTRDLCtCQUErQixvQkFBb0IsbUNBQW1DLHNDQUFzQyx1RUFBdUU7QUFDN1EsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLHNFQUFZO0FBQ2hDLGFBQWEsbUJBQU8sQ0FBQyx3RUFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsd0VBQWE7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQWlCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQywwRUFBYztBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVEQUF1RCw2QkFBNkI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsdURBQXVELDZCQUE2QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNkJBQTZCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL2RvY3h0ZW1wbGF0ZXIvanMveG1sLXRlbXBsYXRlci5qcz80MmE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mKG8pOyB9XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikgeyBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHsgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7IHZhciBvID0gclt0XTsgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7IH0gfVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHsgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogITEgfSksIGU7IH1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHsgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7IHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7IH1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7IGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0OyB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTsgaWYgKHZvaWQgMCAhPT0gZSkgeyB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTsgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTsgfSByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKFwiLi9kb2MtdXRpbHMuanNcIiksXG4gIHB1c2hBcnJheSA9IF9yZXF1aXJlLnB1c2hBcnJheSxcbiAgd29yZFRvVXRmOCA9IF9yZXF1aXJlLndvcmRUb1V0ZjgsXG4gIGNvbnZlcnRTcGFjZXMgPSBfcmVxdWlyZS5jb252ZXJ0U3BhY2VzO1xudmFyIHhtbE1hdGNoZXIgPSByZXF1aXJlKFwiLi94bWwtbWF0Y2hlci5qc1wiKTtcbnZhciBMZXhlciA9IHJlcXVpcmUoXCIuL2xleGVyLmpzXCIpO1xudmFyIFBhcnNlciA9IHJlcXVpcmUoXCIuL3BhcnNlci5qc1wiKTtcbnZhciBfcmVuZGVyID0gcmVxdWlyZShcIi4vcmVuZGVyLmpzXCIpO1xudmFyIHBvc3RyZW5kZXIgPSByZXF1aXJlKFwiLi9wb3N0cmVuZGVyLmpzXCIpO1xudmFyIHJlc29sdmUgPSByZXF1aXJlKFwiLi9yZXNvbHZlLmpzXCIpO1xudmFyIGpvaW5VbmNvcnJ1cHQgPSByZXF1aXJlKFwiLi9qb2luLXVuY29ycnVwdC5qc1wiKTtcbmZ1bmN0aW9uIF9nZXRGdWxsVGV4dChjb250ZW50LCB0YWdzWG1sQXJyYXkpIHtcbiAgdmFyIG1hdGNoZXIgPSB4bWxNYXRjaGVyKGNvbnRlbnQsIHRhZ3NYbWxBcnJheSk7XG4gIHZhciByZXN1bHQgPSBtYXRjaGVyLm1hdGNoZXMubWFwKGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBtYXRjaC5hcnJheVsyXTtcbiAgfSk7XG4gIHJldHVybiB3b3JkVG9VdGY4KGNvbnZlcnRTcGFjZXMocmVzdWx0LmpvaW4oXCJcIikpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWG1sVGVtcGxhdGVyKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWG1sVGVtcGxhdGVyKTtcbiAgICB0aGlzLmNhY2hlZFBhcnNlcnMgPSB7fTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgfVxuICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICBpbnNwZWN0OiB7XG4gICAgICAgIGZpbGVQYXRoOiBvcHRpb25zLmZpbGVQYXRoXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhYbWxUZW1wbGF0ZXIsIFt7XG4gICAga2V5OiBcInJlc29sdmVUYWdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVUYWdzKHRhZ3MpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLnRhZ3MgPSB0YWdzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHZhciBmaWxlUGF0aCA9IHRoaXMuZmlsZVBhdGg7XG4gICAgICBvcHRpb25zLnNjb3BlTWFuYWdlciA9IHRoaXMuc2NvcGVNYW5hZ2VyO1xuICAgICAgb3B0aW9ucy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLm1vZHVsZXMubWFwKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtb2R1bGUucHJlUmVzb2x2ZShvcHRpb25zKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUob3B0aW9ucykudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciByZXNvbHZlZCA9IF9yZWYucmVzb2x2ZWQsXG4gICAgICAgICAgICBlcnJvcnMgPSBfcmVmLmVycm9ycztcbiAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgdmFyIF9lcnJvcjtcbiAgICAgICAgICAgIC8vIElmIGEgc3RyaW5nIGlzIHRocm93biwgY29udmVydCBpdCB0byBhIHJlYWwgRXJyb3JcbiAgICAgICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBlcnJvciBwcm9wZXJ0aWVzIG1pZ2h0IG5vdCBiZSBkZWZpbmVkIGlmIHNvbWUgZm9yZWlnbiBlcnJvclxuICAgICAgICAgICAgICogKHVuaGFuZGxlZCBlcnJvciBub3QgdGhyb3duIGJ5IGRvY3h0ZW1wbGF0ZXIgd2lsbGluZ2x5KSBpc1xuICAgICAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAoX2Vycm9yID0gZXJyb3IpLnByb3BlcnRpZXMgfHwgKF9lcnJvci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gZmlsZVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IGVycm9ycztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc29sdmVkKS50aGVuKGZ1bmN0aW9uIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zY29wZU1hbmFnZXIucm9vdC5maW5pc2hlZFJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLnNjb3BlTWFuYWdlci5yZXNvbHZlZCA9IHJlc29sdmVkO1xuICAgICAgICAgICAgX3RoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZDogcmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIF90aGlzLmVycm9yQ2hlY2tlcihlcnJvcik7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZ1bGxUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxUZXh0KCkge1xuICAgICAgcmV0dXJuIF9nZXRGdWxsVGV4dCh0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZVR5cGVDb25maWcudGFnc1htbFRleHRBcnJheSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldE1vZHVsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TW9kdWxlcyhvYmopIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF90aGlzJG1vZHVsZXMyID0gdGhpcy5tb2R1bGVzOyBfaTIgPCBfdGhpcyRtb2R1bGVzMi5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlID0gX3RoaXMkbW9kdWxlczJbX2kyXTtcbiAgICAgICAgX21vZHVsZS5zZXQob2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJlcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyc2UoKSB7XG4gICAgICB0aGlzLmFsbEVycm9ycyA9IFtdO1xuICAgICAgdGhpcy54bWxsZXhlZCA9IExleGVyLnhtbHBhcnNlKHRoaXMuY29udGVudCwge1xuICAgICAgICB0ZXh0OiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxUZXh0QXJyYXksXG4gICAgICAgIG90aGVyOiB0aGlzLmZpbGVUeXBlQ29uZmlnLnRhZ3NYbWxMZXhlZEFycmF5XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0TW9kdWxlcyh7XG4gICAgICAgIGluc3BlY3Q6IHtcbiAgICAgICAgICBmaWxlUGF0aDogdGhpcy5maWxlUGF0aCxcbiAgICAgICAgICB4bWxsZXhlZDogdGhpcy54bWxsZXhlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBfTGV4ZXIkcGFyc2UgPSBMZXhlci5wYXJzZSh0aGlzLnhtbGxleGVkLCB0aGlzLmRlbGltaXRlcnMsIHRoaXMuc3ludGF4LCB0aGlzLmZpbGVUeXBlKSxcbiAgICAgICAgbGV4ZWQgPSBfTGV4ZXIkcGFyc2UubGV4ZWQsXG4gICAgICAgIGxleGVyRXJyb3JzID0gX0xleGVyJHBhcnNlLmVycm9ycztcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgbGV4ZXJFcnJvcnMpO1xuICAgICAgdGhpcy5sZXhlZCA9IGxleGVkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIGxleGVkOiB0aGlzLmxleGVkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMubGV4ZWQgPSBQYXJzZXIucHJlcGFyc2UodGhpcy5sZXhlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICBub1Bvc3RQYXJzZSA9IF9yZWYyLm5vUG9zdFBhcnNlO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIHRoaXMucGFyc2VkID0gUGFyc2VyLnBhcnNlKHRoaXMubGV4ZWQsIHRoaXMubW9kdWxlcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNldE1vZHVsZXMoe1xuICAgICAgICBpbnNwZWN0OiB7XG4gICAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgICAgcGFyc2VkOiB0aGlzLnBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChub1Bvc3RQYXJzZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIC8vIEluIHY0LCB3ZSBjb3VsZCByZW1vdmUgdGhpcyBcInRoaXMucG9zdHBhcnNlKClcIiBzbyB0aGF0IHVzZXJzIGhhdmUgdG8gY2FsbCB0aGlzIG1hbnVhbGx5LlxuICAgICAgcmV0dXJuIHRoaXMucG9zdHBhcnNlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvc3RwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0cGFyc2UoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xuICAgICAgdmFyIF9QYXJzZXIkcG9zdHBhcnNlID0gUGFyc2VyLnBvc3RwYXJzZSh0aGlzLnBhcnNlZCwgdGhpcy5tb2R1bGVzLCBvcHRpb25zKSxcbiAgICAgICAgcG9zdHBhcnNlZCA9IF9QYXJzZXIkcG9zdHBhcnNlLnBvc3RwYXJzZWQsXG4gICAgICAgIHBvc3RwYXJzZWRFcnJvcnMgPSBfUGFyc2VyJHBvc3RwYXJzZS5lcnJvcnM7XG4gICAgICB0aGlzLnBvc3RwYXJzZWQgPSBwb3N0cGFyc2VkO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIHBvc3RwYXJzZWQ6IHRoaXMucG9zdHBhcnNlZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHB1c2hBcnJheSh0aGlzLmFsbEVycm9ycywgcG9zdHBhcnNlZEVycm9ycyk7XG4gICAgICB0aGlzLmVycm9yQ2hlY2tlcih0aGlzLmFsbEVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JDaGVja2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yQ2hlY2tlcihlcnJvcnMpIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9lcnJvcnMyID0gZXJyb3JzOyBfaTQgPCBfZXJyb3JzMi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IF9lcnJvcnMyW19pNF07XG4gICAgICAgIC8qXG4gICAgICAgICAqIGVycm9yIHByb3BlcnRpZXMgbWlnaHQgbm90IGJlIGRlZmluZWQgaWYgc29tZSBmb3JlaWduXG4gICAgICAgICAqICh1bmhhbmRsZWQgZXJyb3Igbm90IHRocm93biBieSBkb2N4dGVtcGxhdGVyIHdpbGxpbmdseSkgaXNcbiAgICAgICAgICogdGhyb3duLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IucHJvcGVydGllcyB8fCAoZXJyb3IucHJvcGVydGllcyA9IHt9KTtcbiAgICAgICAgZXJyb3IucHJvcGVydGllcy5maWxlID0gdGhpcy5maWxlUGF0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pNiA9IDAsIF90aGlzJG1vZHVsZXM0ID0gdGhpcy5tb2R1bGVzOyBfaTYgPCBfdGhpcyRtb2R1bGVzNC5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgIHZhciBfbW9kdWxlMiA9IF90aGlzJG1vZHVsZXM0W19pNl07XG4gICAgICAgIGVycm9ycyA9IF9tb2R1bGUyLmVycm9yc1RyYW5zZm9ybWVyKGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJhc2VOdWxsR2V0dGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJhc2VOdWxsR2V0dGVyKHBhcnQsIHNtKSB7XG4gICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgZm9yICh2YXIgX2k4ID0gMCwgX3RoaXMkbW9kdWxlczYgPSB0aGlzLm1vZHVsZXM7IF9pOCA8IF90aGlzJG1vZHVsZXM2Lmxlbmd0aDsgX2k4KyspIHtcbiAgICAgICAgdmFyIF9tb2R1bGUzID0gX3RoaXMkbW9kdWxlczZbX2k4XTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IF9tb2R1bGUzLm51bGxHZXR0ZXIocGFydCwgc20sIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubnVsbEdldHRlcihwYXJ0LCBzbSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBpbGVkOiB0aGlzLnBvc3RwYXJzZWQsXG4gICAgICAgIGNhY2hlZFBhcnNlcnM6IHRoaXMuY2FjaGVkUGFyc2VycyxcbiAgICAgICAgdGFnczogdGhpcy50YWdzLFxuICAgICAgICBtb2R1bGVzOiB0aGlzLm1vZHVsZXMsXG4gICAgICAgIHBhcnNlcjogdGhpcy5wYXJzZXIsXG4gICAgICAgIGNvbnRlbnRUeXBlOiB0aGlzLmNvbnRlbnRUeXBlLFxuICAgICAgICByZWxzVHlwZTogdGhpcy5yZWxzVHlwZSxcbiAgICAgICAgYmFzZU51bGxHZXR0ZXI6IHRoaXMuYmFzZU51bGxHZXR0ZXIuYmluZCh0aGlzKSxcbiAgICAgICAgZmlsZVBhdGg6IHRoaXMuZmlsZVBhdGgsXG4gICAgICAgIGZpbGVUeXBlQ29uZmlnOiB0aGlzLmZpbGVUeXBlQ29uZmlnLFxuICAgICAgICBmaWxlVHlwZTogdGhpcy5maWxlVHlwZSxcbiAgICAgICAgbGluZWJyZWFrczogdGhpcy5saW5lYnJlYWtzLFxuICAgICAgICBzdHJpcEludmFsaWRYTUxDaGFyczogdGhpcy5zdHJpcEludmFsaWRYTUxDaGFyc1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih0bykge1xuICAgICAgdGhpcy5maWxlUGF0aCA9IHRvO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICAgIG9wdGlvbnMucmVzb2x2ZWQgPSB0aGlzLnNjb3BlTWFuYWdlci5yZXNvbHZlZDtcbiAgICAgIG9wdGlvbnMuc2NvcGVNYW5hZ2VyID0gdGhpcy5zY29wZU1hbmFnZXI7XG4gICAgICBvcHRpb25zLnJlbmRlciA9IF9yZW5kZXI7XG4gICAgICBvcHRpb25zLmpvaW5VbmNvcnJ1cHQgPSBqb2luVW5jb3JydXB0O1xuICAgICAgdmFyIF9yZW5kZXIyID0gX3JlbmRlcihvcHRpb25zKSxcbiAgICAgICAgZXJyb3JzID0gX3JlbmRlcjIuZXJyb3JzLFxuICAgICAgICBwYXJ0cyA9IF9yZW5kZXIyLnBhcnRzO1xuICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYWxsRXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLmVycm9yQ2hlY2tlcihlcnJvcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGVudCA9IHBvc3RyZW5kZXIocGFydHMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5zZXRNb2R1bGVzKHtcbiAgICAgICAgaW5zcGVjdDoge1xuICAgICAgICAgIGZpbGVQYXRoOiB0aGlzLmZpbGVQYXRoLFxuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuY29udGVudFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfV0pO1xufSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/docxtemplater/js/xml-templater.js\n");

/***/ })

};
;