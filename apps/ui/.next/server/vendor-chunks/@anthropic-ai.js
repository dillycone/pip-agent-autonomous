"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@anthropic-ai";
exports.ids = ["vendor-chunks/@anthropic-ai"];
exports.modules = {

/***/ "(rsc)/../../node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSdkMcpServer: () => (/* binding */ createSdkMcpServer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   tool: () => (/* binding */ tool)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var readline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! readline */ \"readline\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! crypto */ \"crypto\");\n//#!/usr/bin/env node\n// (c) Anthropic PBC. All rights reserved. Use is subject to the Legal Agreements outlined here: https://docs.claude.com/en/docs/claude-code/legal-and-compliance.\n\n// Version: 0.1.14\n\n// Want to see the unminified source? We're hiring!\n// https://job-boards.greenhouse.io/anthropic/jobs/4816199008\nvar __create = Object.create;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __toESM = (mod, isNodeMode, target) => {\n  target = mod != null ? __create(__getProtoOf(mod)) : {};\n  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target;\n  for (let key of __getOwnPropNames(mod))\n    if (!__hasOwnProp.call(to, key))\n      __defProp(to, key, {\n        get: () => mod[key],\n        enumerable: true\n      });\n  return to;\n};\nvar __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true,\n      configurable: true,\n      set: (newValue) => all[name] = () => newValue\n    });\n};\n\n// ../node_modules/uri-js/dist/es5/uri.all.js\nvar require_uri_all = __commonJS((exports, module) => {\n  (function(global2, factory) {\n    typeof exports === \"object\" && typeof module !== \"undefined\" ? factory(exports) : typeof define === \"function\" && define.amd ? define([\"exports\"], factory) : factory(global2.URI = global2.URI || {});\n  })(exports, function(exports2) {\n    function merge() {\n      for (var _len = arguments.length, sets = Array(_len), _key = 0;_key < _len; _key++) {\n        sets[_key] = arguments[_key];\n      }\n      if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1;x < xl; ++x) {\n          sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join(\"\");\n      } else {\n        return sets[0];\n      }\n    }\n    function subexp(str) {\n      return \"(?:\" + str + \")\";\n    }\n    function typeOf(o) {\n      return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n    }\n    function toUpperCase(str) {\n      return str.toUpperCase();\n    }\n    function toArray(obj) {\n      return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n    }\n    function assign(target, source) {\n      var obj = target;\n      if (source) {\n        for (var key in source) {\n          obj[key] = source[key];\n        }\n      }\n      return obj;\n    }\n    function buildExps(isIRI2) {\n      var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$2 = merge(DIGIT$$, \"[A-Fa-f]\"), LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$2 = subexp(subexp(\"%[EFef]\" + HEXDIG$$2 + \"%\" + HEXDIG$$2 + HEXDIG$$2 + \"%\" + HEXDIG$$2 + HEXDIG$$2) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$2 + \"%\" + HEXDIG$$2 + HEXDIG$$2) + \"|\" + subexp(\"%\" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", IPRIVATE$$ = isIRI2 ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + \"|\" + merge(UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$), IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + \"|\" + PCT_ENCODED$2) + \"+\"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$2 + \"{2})\") + ZONEID$), IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$2 + \"+\\\\.\" + merge(UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + \"|\" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$2 + \"|\" + merge(UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + \"|\" + merge(UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n      return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$2, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$2, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$2, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$2, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$2, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$2, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$2, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$2, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$2, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$2 + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\")\n      };\n    }\n    var URI_PROTOCOL = buildExps(false);\n    var IRI_PROTOCOL = buildExps(true);\n    var slicedToArray = function() {\n      function sliceIterator(arr, i) {\n        var _arr = [];\n        var _n = true;\n        var _d = false;\n        var _e = undefined;\n        try {\n          for (var _i = arr[Symbol.iterator](), _s;!(_n = (_s = _i.next()).done); _n = true) {\n            _arr.push(_s.value);\n            if (i && _arr.length === i)\n              break;\n          }\n        } catch (err) {\n          _d = true;\n          _e = err;\n        } finally {\n          try {\n            if (!_n && _i[\"return\"])\n              _i[\"return\"]();\n          } finally {\n            if (_d)\n              throw _e;\n          }\n        }\n        return _arr;\n      }\n      return function(arr, i) {\n        if (Array.isArray(arr)) {\n          return arr;\n        } else if (Symbol.iterator in Object(arr)) {\n          return sliceIterator(arr, i);\n        } else {\n          throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n        }\n      };\n    }();\n    var toConsumableArray = function(arr) {\n      if (Array.isArray(arr)) {\n        for (var i = 0, arr2 = Array(arr.length);i < arr.length; i++)\n          arr2[i] = arr[i];\n        return arr2;\n      } else {\n        return Array.from(arr);\n      }\n    };\n    var maxInt = 2147483647;\n    var base = 36;\n    var tMin = 1;\n    var tMax = 26;\n    var skew = 38;\n    var damp = 700;\n    var initialBias = 72;\n    var initialN = 128;\n    var delimiter = \"-\";\n    var regexPunycode = /^xn--/;\n    var regexNonASCII = /[^\\0-\\x7E]/;\n    var regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\n    var errors2 = {\n      overflow: \"Overflow: input needs wider integers to process\",\n      \"not-basic\": \"Illegal input >= 0x80 (not a basic code point)\",\n      \"invalid-input\": \"Invalid input\"\n    };\n    var baseMinusTMin = base - tMin;\n    var floor = Math.floor;\n    var stringFromCharCode = String.fromCharCode;\n    function error$1(type) {\n      throw new RangeError(errors2[type]);\n    }\n    function map(array, fn) {\n      var result = [];\n      var length = array.length;\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n      return result;\n    }\n    function mapDomain(string, fn) {\n      var parts = string.split(\"@\");\n      var result = \"\";\n      if (parts.length > 1) {\n        result = parts[0] + \"@\";\n        string = parts[1];\n      }\n      string = string.replace(regexSeparators, \".\");\n      var labels = string.split(\".\");\n      var encoded = map(labels, fn).join(\".\");\n      return result + encoded;\n    }\n    function ucs2decode(string) {\n      var output = [];\n      var counter = 0;\n      var length = string.length;\n      while (counter < length) {\n        var value = string.charCodeAt(counter++);\n        if (value >= 55296 && value <= 56319 && counter < length) {\n          var extra = string.charCodeAt(counter++);\n          if ((extra & 64512) == 56320) {\n            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);\n          } else {\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n      return output;\n    }\n    var ucs2encode = function ucs2encode(array) {\n      return String.fromCodePoint.apply(String, toConsumableArray(array));\n    };\n    var basicToDigit = function basicToDigit(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n      return base;\n    };\n    var digitToBasic = function digitToBasic(digit, flag) {\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    };\n    var adapt = function adapt(delta, numPoints, firstTime) {\n      var k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n      for (;delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    };\n    var decode = function decode(input) {\n      var output = [];\n      var inputLength = input.length;\n      var i = 0;\n      var n = initialN;\n      var bias = initialBias;\n      var basic = input.lastIndexOf(delimiter);\n      if (basic < 0) {\n        basic = 0;\n      }\n      for (var j = 0;j < basic; ++j) {\n        if (input.charCodeAt(j) >= 128) {\n          error$1(\"not-basic\");\n        }\n        output.push(input.charCodeAt(j));\n      }\n      for (var index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {\n        var oldi = i;\n        for (var w = 1, k = base;; k += base) {\n          if (index >= inputLength) {\n            error$1(\"invalid-input\");\n          }\n          var digit = basicToDigit(input.charCodeAt(index++));\n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error$1(\"overflow\");\n          }\n          i += digit * w;\n          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n          if (digit < t) {\n            break;\n          }\n          var baseMinusT = base - t;\n          if (w > floor(maxInt / baseMinusT)) {\n            error$1(\"overflow\");\n          }\n          w *= baseMinusT;\n        }\n        var out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0);\n        if (floor(i / out) > maxInt - n) {\n          error$1(\"overflow\");\n        }\n        n += floor(i / out);\n        i %= out;\n        output.splice(i++, 0, n);\n      }\n      return String.fromCodePoint.apply(String, output);\n    };\n    var encode = function encode(input) {\n      var output = [];\n      input = ucs2decode(input);\n      var inputLength = input.length;\n      var n = initialN;\n      var delta = 0;\n      var bias = initialBias;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n      try {\n        for (var _iterator = input[Symbol.iterator](), _step;!(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _currentValue2 = _step.value;\n          if (_currentValue2 < 128) {\n            output.push(stringFromCharCode(_currentValue2));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n      var basicLength = output.length;\n      var handledCPCount = basicLength;\n      if (basicLength) {\n        output.push(delimiter);\n      }\n      while (handledCPCount < inputLength) {\n        var m = maxInt;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n        try {\n          for (var _iterator2 = input[Symbol.iterator](), _step2;!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var currentValue = _step2.value;\n            if (currentValue >= n && currentValue < m) {\n              m = currentValue;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n        var handledCPCountPlusOne = handledCPCount + 1;\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error$1(\"overflow\");\n        }\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n        try {\n          for (var _iterator3 = input[Symbol.iterator](), _step3;!(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var _currentValue = _step3.value;\n            if (_currentValue < n && ++delta > maxInt) {\n              error$1(\"overflow\");\n            }\n            if (_currentValue == n) {\n              var q = delta;\n              for (var k = base;; k += base) {\n                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n                if (q < t) {\n                  break;\n                }\n                var qMinusT = q - t;\n                var baseMinusT = base - t;\n                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                q = floor(qMinusT / baseMinusT);\n              }\n              output.push(stringFromCharCode(digitToBasic(q, 0)));\n              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n              delta = 0;\n              ++handledCPCount;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n        ++delta;\n        ++n;\n      }\n      return output.join(\"\");\n    };\n    var toUnicode = function toUnicode(input) {\n      return mapDomain(input, function(string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n      });\n    };\n    var toASCII = function toASCII(input) {\n      return mapDomain(input, function(string) {\n        return regexNonASCII.test(string) ? \"xn--\" + encode(string) : string;\n      });\n    };\n    var punycode = {\n      version: \"2.1.0\",\n      ucs2: {\n        decode: ucs2decode,\n        encode: ucs2encode\n      },\n      decode,\n      encode,\n      toASCII,\n      toUnicode\n    };\n    var SCHEMES = {};\n    function pctEncChar(chr) {\n      var c = chr.charCodeAt(0);\n      var e = undefined;\n      if (c < 16)\n        e = \"%0\" + c.toString(16).toUpperCase();\n      else if (c < 128)\n        e = \"%\" + c.toString(16).toUpperCase();\n      else if (c < 2048)\n        e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n      else\n        e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n      return e;\n    }\n    function pctDecChars(str) {\n      var newStr = \"\";\n      var i = 0;\n      var il = str.length;\n      while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n          newStr += String.fromCharCode(c);\n          i += 3;\n        } else if (c >= 194 && c < 224) {\n          if (il - i >= 6) {\n            var c2 = parseInt(str.substr(i + 4, 2), 16);\n            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n          } else {\n            newStr += str.substr(i, 6);\n          }\n          i += 6;\n        } else if (c >= 224) {\n          if (il - i >= 9) {\n            var _c = parseInt(str.substr(i + 4, 2), 16);\n            var c3 = parseInt(str.substr(i + 7, 2), 16);\n            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n          } else {\n            newStr += str.substr(i, 9);\n          }\n          i += 9;\n        } else {\n          newStr += str.substr(i, 3);\n          i += 3;\n        }\n      }\n      return newStr;\n    }\n    function _normalizeComponentEncoding(components, protocol) {\n      function decodeUnreserved2(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n      }\n      if (components.scheme)\n        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n      if (components.userinfo !== undefined)\n        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n      if (components.host !== undefined)\n        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n      if (components.path !== undefined)\n        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n      if (components.query !== undefined)\n        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n      if (components.fragment !== undefined)\n        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n      return components;\n    }\n    function _stripLeadingZeros(str) {\n      return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n    }\n    function _normalizeIPv4(host, protocol) {\n      var matches = host.match(protocol.IPV4ADDRESS) || [];\n      var _matches = slicedToArray(matches, 2), address = _matches[1];\n      if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n      } else {\n        return host;\n      }\n    }\n    function _normalizeIPv6(host, protocol) {\n      var matches = host.match(protocol.IPV6ADDRESS) || [];\n      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];\n      if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split(\"::\").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0;x < fieldCount; ++x) {\n          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || \"\";\n        }\n        if (isLastFieldIPv4Address) {\n          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function(acc, field, index) {\n          if (!field || field === \"0\") {\n            var lastLongest = acc[acc.length - 1];\n            if (lastLongest && lastLongest.index + lastLongest.length === index) {\n              lastLongest.length++;\n            } else {\n              acc.push({ index, length: 1 });\n            }\n          }\n          return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function(a, b) {\n          return b.length - a.length;\n        })[0];\n        var newHost = undefined;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n          var newFirst = fields.slice(0, longestZeroFields.index);\n          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n          newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n          newHost = fields.join(\":\");\n        }\n        if (zone) {\n          newHost += \"%\" + zone;\n        }\n        return newHost;\n      } else {\n        return host;\n      }\n    }\n    var URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\n    var NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\n    function parse(uriString) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var components = {};\n      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n      if (options.reference === \"suffix\")\n        uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n      var matches = uriString.match(URI_PARSE);\n      if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n          components.scheme = matches[1];\n          components.userinfo = matches[3];\n          components.host = matches[4];\n          components.port = parseInt(matches[5], 10);\n          components.path = matches[6] || \"\";\n          components.query = matches[7];\n          components.fragment = matches[8];\n          if (isNaN(components.port)) {\n            components.port = matches[5];\n          }\n        } else {\n          components.scheme = matches[1] || undefined;\n          components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n          components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n          components.port = parseInt(matches[5], 10);\n          components.path = matches[6] || \"\";\n          components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n          components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n          if (isNaN(components.port)) {\n            components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n          }\n        }\n        if (components.host) {\n          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n          components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n          components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n          components.reference = \"absolute\";\n        } else {\n          components.reference = \"uri\";\n        }\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n          components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n            try {\n              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n            } catch (e) {\n              components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n            }\n          }\n          _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n          _normalizeComponentEncoding(components, protocol);\n        }\n        if (schemeHandler && schemeHandler.parse) {\n          schemeHandler.parse(components, options);\n        }\n      } else {\n        components.error = components.error || \"URI can not be parsed.\";\n      }\n      return components;\n    }\n    function _recomposeAuthority(components, options) {\n      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n      var uriTokens = [];\n      if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n      }\n      if (components.host !== undefined) {\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {\n          return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n      }\n      if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n      }\n      return uriTokens.length ? uriTokens.join(\"\") : undefined;\n    }\n    var RDS1 = /^\\.\\.?\\//;\n    var RDS2 = /^\\/\\.(\\/|$)/;\n    var RDS3 = /^\\/\\.\\.(\\/|$)/;\n    var RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\n    function removeDotSegments(input) {\n      var output = [];\n      while (input.length) {\n        if (input.match(RDS1)) {\n          input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n          input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n          input = input.replace(RDS3, \"/\");\n          output.pop();\n        } else if (input === \".\" || input === \"..\") {\n          input = \"\";\n        } else {\n          var im = input.match(RDS5);\n          if (im) {\n            var s = im[0];\n            input = input.slice(s.length);\n            output.push(s);\n          } else {\n            throw new Error(\"Unexpected dot segment condition\");\n          }\n        }\n      }\n      return output.join(\"\");\n    }\n    function serialize(components) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n      var uriTokens = [];\n      var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n      if (schemeHandler && schemeHandler.serialize)\n        schemeHandler.serialize(components, options);\n      if (components.host) {\n        if (protocol.IPV6ADDRESS.test(components.host)) {} else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n          try {\n            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n          } catch (e) {\n            components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n          }\n        }\n      }\n      _normalizeComponentEncoding(components, protocol);\n      if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n      }\n      var authority = _recomposeAuthority(components, options);\n      if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n          uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n          uriTokens.push(\"/\");\n        }\n      }\n      if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n          s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n          s = s.replace(/^\\/\\//, \"/%2F\");\n        }\n        uriTokens.push(s);\n      }\n      if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n      }\n      if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n      }\n      return uriTokens.join(\"\");\n    }\n    function resolveComponents(base2, relative) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var skipNormalization = arguments[3];\n      var target = {};\n      if (!skipNormalization) {\n        base2 = parse(serialize(base2, options), options);\n        relative = parse(serialize(relative, options), options);\n      }\n      options = options || {};\n      if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n      } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n          target.userinfo = relative.userinfo;\n          target.host = relative.host;\n          target.port = relative.port;\n          target.path = removeDotSegments(relative.path || \"\");\n          target.query = relative.query;\n        } else {\n          if (!relative.path) {\n            target.path = base2.path;\n            if (relative.query !== undefined) {\n              target.query = relative.query;\n            } else {\n              target.query = base2.query;\n            }\n          } else {\n            if (relative.path.charAt(0) === \"/\") {\n              target.path = removeDotSegments(relative.path);\n            } else {\n              if ((base2.userinfo !== undefined || base2.host !== undefined || base2.port !== undefined) && !base2.path) {\n                target.path = \"/\" + relative.path;\n              } else if (!base2.path) {\n                target.path = relative.path;\n              } else {\n                target.path = base2.path.slice(0, base2.path.lastIndexOf(\"/\") + 1) + relative.path;\n              }\n              target.path = removeDotSegments(target.path);\n            }\n            target.query = relative.query;\n          }\n          target.userinfo = base2.userinfo;\n          target.host = base2.host;\n          target.port = base2.port;\n        }\n        target.scheme = base2.scheme;\n      }\n      target.fragment = relative.fragment;\n      return target;\n    }\n    function resolve(baseURI, relativeURI, options) {\n      var schemelessOptions = assign({ scheme: \"null\" }, options);\n      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n    }\n    function normalize(uri, options) {\n      if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n      } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n      }\n      return uri;\n    }\n    function equal(uriA, uriB, options) {\n      if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n      } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n      }\n      if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n      } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n      }\n      return uriA === uriB;\n    }\n    function escapeComponent(str, options) {\n      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n    }\n    function unescapeComponent(str, options) {\n      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n    }\n    var handler = {\n      scheme: \"http\",\n      domainHost: true,\n      parse: function parse(components, options) {\n        if (!components.host) {\n          components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n      },\n      serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n          components.port = undefined;\n        }\n        if (!components.path) {\n          components.path = \"/\";\n        }\n        return components;\n      }\n    };\n    var handler$1 = {\n      scheme: \"https\",\n      domainHost: handler.domainHost,\n      parse: handler.parse,\n      serialize: handler.serialize\n    };\n    function isSecure(wsComponents) {\n      return typeof wsComponents.secure === \"boolean\" ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n    }\n    var handler$2 = {\n      scheme: \"ws\",\n      domainHost: true,\n      parse: function parse(components, options) {\n        var wsComponents = components;\n        wsComponents.secure = isSecure(wsComponents);\n        wsComponents.resourceName = (wsComponents.path || \"/\") + (wsComponents.query ? \"?\" + wsComponents.query : \"\");\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n      },\n      serialize: function serialize(wsComponents, options) {\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n          wsComponents.port = undefined;\n        }\n        if (typeof wsComponents.secure === \"boolean\") {\n          wsComponents.scheme = wsComponents.secure ? \"wss\" : \"ws\";\n          wsComponents.secure = undefined;\n        }\n        if (wsComponents.resourceName) {\n          var _wsComponents$resourc = wsComponents.resourceName.split(\"?\"), _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2), path = _wsComponents$resourc2[0], query = _wsComponents$resourc2[1];\n          wsComponents.path = path && path !== \"/\" ? path : undefined;\n          wsComponents.query = query;\n          wsComponents.resourceName = undefined;\n        }\n        wsComponents.fragment = undefined;\n        return wsComponents;\n      }\n    };\n    var handler$3 = {\n      scheme: \"wss\",\n      domainHost: handler$2.domainHost,\n      parse: handler$2.parse,\n      serialize: handler$2.serialize\n    };\n    var O = {};\n    var isIRI = true;\n    var UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\n    var HEXDIG$$ = \"[0-9A-Fa-f]\";\n    var PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$));\n    var ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n    var QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\n    var VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\n    var SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\n    var UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\n    var PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\n    var NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\\\\"]\", VCHAR$$), \"g\");\n    var NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\n    var NOT_HFVALUE = NOT_HFNAME;\n    function decodeUnreserved(str) {\n      var decStr = pctDecChars(str);\n      return !decStr.match(UNRESERVED) ? str : decStr;\n    }\n    var handler$4 = {\n      scheme: \"mailto\",\n      parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n          var unknownHeaders = false;\n          var headers = {};\n          var hfields = mailtoComponents.query.split(\"&\");\n          for (var x = 0, xl = hfields.length;x < xl; ++x) {\n            var hfield = hfields[x].split(\"=\");\n            switch (hfield[0]) {\n              case \"to\":\n                var toAddrs = hfield[1].split(\",\");\n                for (var _x = 0, _xl = toAddrs.length;_x < _xl; ++_x) {\n                  to.push(toAddrs[_x]);\n                }\n                break;\n              case \"subject\":\n                mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                break;\n              case \"body\":\n                mailtoComponents.body = unescapeComponent(hfield[1], options);\n                break;\n              default:\n                unknownHeaders = true;\n                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                break;\n            }\n          }\n          if (unknownHeaders)\n            mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length;_x2 < _xl2; ++_x2) {\n          var addr = to[_x2].split(\"@\");\n          addr[0] = unescapeComponent(addr[0]);\n          if (!options.unicodeSupport) {\n            try {\n              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n            } catch (e) {\n              mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n            }\n          } else {\n            addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n          }\n          to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n      },\n      serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n          for (var x = 0, xl = to.length;x < xl; ++x) {\n            var toAddr = String(to[x]);\n            var atIdx = toAddr.lastIndexOf(\"@\");\n            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n            var domain = toAddr.slice(atIdx + 1);\n            try {\n              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n            } catch (e) {\n              components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n            }\n            to[x] = localPart + \"@\" + domain;\n          }\n          components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject)\n          headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body)\n          headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n          if (headers[name] !== O[name]) {\n            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n          }\n        }\n        if (fields.length) {\n          components.query = fields.join(\"&\");\n        }\n        return components;\n      }\n    };\n    var URN_PARSE = /^([^\\:]+)\\:(.*)/;\n    var handler$5 = {\n      scheme: \"urn\",\n      parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n          var scheme = options.scheme || urnComponents.scheme || \"urn\";\n          var nid = matches[1].toLowerCase();\n          var nss = matches[2];\n          var urnScheme = scheme + \":\" + (options.nid || nid);\n          var schemeHandler = SCHEMES[urnScheme];\n          urnComponents.nid = nid;\n          urnComponents.nss = nss;\n          urnComponents.path = undefined;\n          if (schemeHandler) {\n            urnComponents = schemeHandler.parse(urnComponents, options);\n          }\n        } else {\n          urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n      },\n      serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n          urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n      }\n    };\n    var UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n    var handler$6 = {\n      scheme: \"urn:uuid\",\n      parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n          uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n      },\n      serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n      }\n    };\n    SCHEMES[handler.scheme] = handler;\n    SCHEMES[handler$1.scheme] = handler$1;\n    SCHEMES[handler$2.scheme] = handler$2;\n    SCHEMES[handler$3.scheme] = handler$3;\n    SCHEMES[handler$4.scheme] = handler$4;\n    SCHEMES[handler$5.scheme] = handler$5;\n    SCHEMES[handler$6.scheme] = handler$6;\n    exports2.SCHEMES = SCHEMES;\n    exports2.pctEncChar = pctEncChar;\n    exports2.pctDecChars = pctDecChars;\n    exports2.parse = parse;\n    exports2.removeDotSegments = removeDotSegments;\n    exports2.serialize = serialize;\n    exports2.resolveComponents = resolveComponents;\n    exports2.resolve = resolve;\n    exports2.normalize = normalize;\n    exports2.equal = equal;\n    exports2.escapeComponent = escapeComponent;\n    exports2.unescapeComponent = unescapeComponent;\n    Object.defineProperty(exports2, \"__esModule\", { value: true });\n  });\n});\n\n// ../node_modules/fast-deep-equal/index.js\nvar require_fast_deep_equal = __commonJS((exports, module) => {\n  module.exports = function equal(a, b) {\n    if (a === b)\n      return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor)\n        return false;\n      var length, i, keys;\n      if (Array.isArray(a)) {\n        length = a.length;\n        if (length != b.length)\n          return false;\n        for (i = length;i-- !== 0; )\n          if (!equal(a[i], b[i]))\n            return false;\n        return true;\n      }\n      if (a.constructor === RegExp)\n        return a.source === b.source && a.flags === b.flags;\n      if (a.valueOf !== Object.prototype.valueOf)\n        return a.valueOf() === b.valueOf();\n      if (a.toString !== Object.prototype.toString)\n        return a.toString() === b.toString();\n      keys = Object.keys(a);\n      length = keys.length;\n      if (length !== Object.keys(b).length)\n        return false;\n      for (i = length;i-- !== 0; )\n        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))\n          return false;\n      for (i = length;i-- !== 0; ) {\n        var key = keys[i];\n        if (!equal(a[key], b[key]))\n          return false;\n      }\n      return true;\n    }\n    return a !== a && b !== b;\n  };\n});\n\n// ../node_modules/ajv/lib/compile/ucs2length.js\nvar require_ucs2length = __commonJS((exports, module) => {\n  module.exports = function ucs2length(str) {\n    var length = 0, len = str.length, pos = 0, value;\n    while (pos < len) {\n      length++;\n      value = str.charCodeAt(pos++);\n      if (value >= 55296 && value <= 56319 && pos < len) {\n        value = str.charCodeAt(pos);\n        if ((value & 64512) == 56320)\n          pos++;\n      }\n    }\n    return length;\n  };\n});\n\n// ../node_modules/ajv/lib/compile/util.js\nvar require_util = __commonJS((exports, module) => {\n  module.exports = {\n    copy,\n    checkDataType,\n    checkDataTypes,\n    coerceToTypes,\n    toHash,\n    getProperty,\n    escapeQuotes,\n    equal: require_fast_deep_equal(),\n    ucs2length: require_ucs2length(),\n    varOccurences,\n    varReplace,\n    schemaHasRules,\n    schemaHasRulesExcept,\n    schemaUnknownRules,\n    toQuotedString,\n    getPathExpr,\n    getPath,\n    getData,\n    unescapeFragment,\n    unescapeJsonPointer,\n    escapeFragment,\n    escapeJsonPointer\n  };\n  function copy(o, to) {\n    to = to || {};\n    for (var key in o)\n      to[key] = o[key];\n    return to;\n  }\n  function checkDataType(dataType, data, strictNumbers, negate) {\n    var EQUAL = negate ? \" !== \" : \" === \", AND = negate ? \" || \" : \" && \", OK2 = negate ? \"!\" : \"\", NOT = negate ? \"\" : \"!\";\n    switch (dataType) {\n      case \"null\":\n        return data + EQUAL + \"null\";\n      case \"array\":\n        return OK2 + \"Array.isArray(\" + data + \")\";\n      case \"object\":\n        return \"(\" + OK2 + data + AND + \"typeof \" + data + EQUAL + '\"object\"' + AND + NOT + \"Array.isArray(\" + data + \"))\";\n      case \"integer\":\n        return \"(typeof \" + data + EQUAL + '\"number\"' + AND + NOT + \"(\" + data + \" % 1)\" + AND + data + EQUAL + data + (strictNumbers ? AND + OK2 + \"isFinite(\" + data + \")\" : \"\") + \")\";\n      case \"number\":\n        return \"(typeof \" + data + EQUAL + '\"' + dataType + '\"' + (strictNumbers ? AND + OK2 + \"isFinite(\" + data + \")\" : \"\") + \")\";\n      default:\n        return \"typeof \" + data + EQUAL + '\"' + dataType + '\"';\n    }\n  }\n  function checkDataTypes(dataTypes, data, strictNumbers) {\n    switch (dataTypes.length) {\n      case 1:\n        return checkDataType(dataTypes[0], data, strictNumbers, true);\n      default:\n        var code = \"\";\n        var types2 = toHash(dataTypes);\n        if (types2.array && types2.object) {\n          code = types2.null ? \"(\" : \"(!\" + data + \" || \";\n          code += \"typeof \" + data + ' !== \"object\")';\n          delete types2.null;\n          delete types2.array;\n          delete types2.object;\n        }\n        if (types2.number)\n          delete types2.integer;\n        for (var t in types2)\n          code += (code ? \" && \" : \"\") + checkDataType(t, data, strictNumbers, true);\n        return code;\n    }\n  }\n  var COERCE_TO_TYPES = toHash([\"string\", \"number\", \"integer\", \"boolean\", \"null\"]);\n  function coerceToTypes(optionCoerceTypes, dataTypes) {\n    if (Array.isArray(dataTypes)) {\n      var types2 = [];\n      for (var i = 0;i < dataTypes.length; i++) {\n        var t = dataTypes[i];\n        if (COERCE_TO_TYPES[t])\n          types2[types2.length] = t;\n        else if (optionCoerceTypes === \"array\" && t === \"array\")\n          types2[types2.length] = t;\n      }\n      if (types2.length)\n        return types2;\n    } else if (COERCE_TO_TYPES[dataTypes]) {\n      return [dataTypes];\n    } else if (optionCoerceTypes === \"array\" && dataTypes === \"array\") {\n      return [\"array\"];\n    }\n  }\n  function toHash(arr) {\n    var hash = {};\n    for (var i = 0;i < arr.length; i++)\n      hash[arr[i]] = true;\n    return hash;\n  }\n  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\n  var SINGLE_QUOTE = /'|\\\\/g;\n  function getProperty(key) {\n    return typeof key == \"number\" ? \"[\" + key + \"]\" : IDENTIFIER.test(key) ? \".\" + key : \"['\" + escapeQuotes(key) + \"']\";\n  }\n  function escapeQuotes(str) {\n    return str.replace(SINGLE_QUOTE, \"\\\\$&\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\f/g, \"\\\\f\").replace(/\\t/g, \"\\\\t\");\n  }\n  function varOccurences(str, dataVar) {\n    dataVar += \"[^0-9]\";\n    var matches = str.match(new RegExp(dataVar, \"g\"));\n    return matches ? matches.length : 0;\n  }\n  function varReplace(str, dataVar, expr) {\n    dataVar += \"([^0-9])\";\n    expr = expr.replace(/\\$/g, \"$$$$\");\n    return str.replace(new RegExp(dataVar, \"g\"), expr + \"$1\");\n  }\n  function schemaHasRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n      return !schema;\n    for (var key in schema)\n      if (rules[key])\n        return true;\n  }\n  function schemaHasRulesExcept(schema, rules, exceptKeyword) {\n    if (typeof schema == \"boolean\")\n      return !schema && exceptKeyword != \"not\";\n    for (var key in schema)\n      if (key != exceptKeyword && rules[key])\n        return true;\n  }\n  function schemaUnknownRules(schema, rules) {\n    if (typeof schema == \"boolean\")\n      return;\n    for (var key in schema)\n      if (!rules[key])\n        return key;\n  }\n  function toQuotedString(str) {\n    return \"'\" + escapeQuotes(str) + \"'\";\n  }\n  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {\n    var path = jsonPointers ? \"'/' + \" + expr + (isNumber ? \"\" : \".replace(/~/g, '~0').replace(/\\\\//g, '~1')\") : isNumber ? \"'[' + \" + expr + \" + ']'\" : \"'[\\\\'' + \" + expr + \" + '\\\\']'\";\n    return joinPaths(currentPath, path);\n  }\n  function getPath(currentPath, prop, jsonPointers) {\n    var path = jsonPointers ? toQuotedString(\"/\" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));\n    return joinPaths(currentPath, path);\n  }\n  var JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\n  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n  function getData($data, lvl, paths) {\n    var up, jsonPointer, data, matches;\n    if ($data === \"\")\n      return \"rootData\";\n    if ($data[0] == \"/\") {\n      if (!JSON_POINTER.test($data))\n        throw new Error(\"Invalid JSON-pointer: \" + $data);\n      jsonPointer = $data;\n      data = \"rootData\";\n    } else {\n      matches = $data.match(RELATIVE_JSON_POINTER);\n      if (!matches)\n        throw new Error(\"Invalid JSON-pointer: \" + $data);\n      up = +matches[1];\n      jsonPointer = matches[2];\n      if (jsonPointer == \"#\") {\n        if (up >= lvl)\n          throw new Error(\"Cannot access property/index \" + up + \" levels up, current level is \" + lvl);\n        return paths[lvl - up];\n      }\n      if (up > lvl)\n        throw new Error(\"Cannot access data \" + up + \" levels up, current level is \" + lvl);\n      data = \"data\" + (lvl - up || \"\");\n      if (!jsonPointer)\n        return data;\n    }\n    var expr = data;\n    var segments = jsonPointer.split(\"/\");\n    for (var i = 0;i < segments.length; i++) {\n      var segment = segments[i];\n      if (segment) {\n        data += getProperty(unescapeJsonPointer(segment));\n        expr += \" && \" + data;\n      }\n    }\n    return expr;\n  }\n  function joinPaths(a, b) {\n    if (a == '\"\"')\n      return b;\n    return (a + \" + \" + b).replace(/([^\\\\])' \\+ '/g, \"$1\");\n  }\n  function unescapeFragment(str) {\n    return unescapeJsonPointer(decodeURIComponent(str));\n  }\n  function escapeFragment(str) {\n    return encodeURIComponent(escapeJsonPointer(str));\n  }\n  function escapeJsonPointer(str) {\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }\n  function unescapeJsonPointer(str) {\n    return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }\n});\n\n// ../node_modules/ajv/lib/compile/schema_obj.js\nvar require_schema_obj = __commonJS((exports, module) => {\n  var util3 = require_util();\n  module.exports = SchemaObject;\n  function SchemaObject(obj) {\n    util3.copy(obj, this);\n  }\n});\n\n// ../node_modules/json-schema-traverse/index.js\nvar require_json_schema_traverse = __commonJS((exports, module) => {\n  var traverse = module.exports = function(schema, opts, cb) {\n    if (typeof opts == \"function\") {\n      cb = opts;\n      opts = {};\n    }\n    cb = opts.cb || cb;\n    var pre = typeof cb == \"function\" ? cb : cb.pre || function() {};\n    var post = cb.post || function() {};\n    _traverse(opts, pre, post, schema, \"\", schema);\n  };\n  traverse.keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  traverse.arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  traverse.propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependencies: true\n  };\n  traverse.skipKeywords = {\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true\n  };\n  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (schema && typeof schema == \"object\" && !Array.isArray(schema)) {\n      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n      for (var key in schema) {\n        var sch = schema[key];\n        if (Array.isArray(sch)) {\n          if (key in traverse.arrayKeywords) {\n            for (var i = 0;i < sch.length; i++)\n              _traverse(opts, pre, post, sch[i], jsonPtr + \"/\" + key + \"/\" + i, rootSchema, jsonPtr, key, schema, i);\n          }\n        } else if (key in traverse.propsKeywords) {\n          if (sch && typeof sch == \"object\") {\n            for (var prop in sch)\n              _traverse(opts, pre, post, sch[prop], jsonPtr + \"/\" + key + \"/\" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n          }\n        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {\n          _traverse(opts, pre, post, sch, jsonPtr + \"/\" + key, rootSchema, jsonPtr, key, schema);\n        }\n      }\n      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    }\n  }\n  function escapeJsonPtr(str) {\n    return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }\n});\n\n// ../node_modules/ajv/lib/compile/resolve.js\nvar require_resolve = __commonJS((exports, module) => {\n  var URI = require_uri_all();\n  var equal = require_fast_deep_equal();\n  var util3 = require_util();\n  var SchemaObject = require_schema_obj();\n  var traverse = require_json_schema_traverse();\n  module.exports = resolve;\n  resolve.normalizeId = normalizeId;\n  resolve.fullPath = getFullPath;\n  resolve.url = resolveUrl;\n  resolve.ids = resolveIds;\n  resolve.inlineRef = inlineRef;\n  resolve.schema = resolveSchema;\n  function resolve(compile, root2, ref) {\n    var refVal = this._refs[ref];\n    if (typeof refVal == \"string\") {\n      if (this._refs[refVal])\n        refVal = this._refs[refVal];\n      else\n        return resolve.call(this, compile, root2, refVal);\n    }\n    refVal = refVal || this._schemas[ref];\n    if (refVal instanceof SchemaObject) {\n      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);\n    }\n    var res = resolveSchema.call(this, root2, ref);\n    var schema, v, baseId;\n    if (res) {\n      schema = res.schema;\n      root2 = res.root;\n      baseId = res.baseId;\n    }\n    if (schema instanceof SchemaObject) {\n      v = schema.validate || compile.call(this, schema.schema, root2, undefined, baseId);\n    } else if (schema !== undefined) {\n      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root2, undefined, baseId);\n    }\n    return v;\n  }\n  function resolveSchema(root2, ref) {\n    var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root2.schema));\n    if (Object.keys(root2.schema).length === 0 || refPath !== baseId) {\n      var id = normalizeId(refPath);\n      var refVal = this._refs[id];\n      if (typeof refVal == \"string\") {\n        return resolveRecursive.call(this, root2, refVal, p);\n      } else if (refVal instanceof SchemaObject) {\n        if (!refVal.validate)\n          this._compile(refVal);\n        root2 = refVal;\n      } else {\n        refVal = this._schemas[id];\n        if (refVal instanceof SchemaObject) {\n          if (!refVal.validate)\n            this._compile(refVal);\n          if (id == normalizeId(ref))\n            return { schema: refVal, root: root2, baseId };\n          root2 = refVal;\n        } else {\n          return;\n        }\n      }\n      if (!root2.schema)\n        return;\n      baseId = getFullPath(this._getId(root2.schema));\n    }\n    return getJsonPointer.call(this, p, baseId, root2.schema, root2);\n  }\n  function resolveRecursive(root2, ref, parsedRef) {\n    var res = resolveSchema.call(this, root2, ref);\n    if (res) {\n      var schema = res.schema;\n      var baseId = res.baseId;\n      root2 = res.root;\n      var id = this._getId(schema);\n      if (id)\n        baseId = resolveUrl(baseId, id);\n      return getJsonPointer.call(this, parsedRef, baseId, schema, root2);\n    }\n  }\n  var PREVENT_SCOPE_CHANGE = util3.toHash([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n  function getJsonPointer(parsedRef, baseId, schema, root2) {\n    parsedRef.fragment = parsedRef.fragment || \"\";\n    if (parsedRef.fragment.slice(0, 1) != \"/\")\n      return;\n    var parts = parsedRef.fragment.split(\"/\");\n    for (var i = 1;i < parts.length; i++) {\n      var part = parts[i];\n      if (part) {\n        part = util3.unescapeFragment(part);\n        schema = schema[part];\n        if (schema === undefined)\n          break;\n        var id;\n        if (!PREVENT_SCOPE_CHANGE[part]) {\n          id = this._getId(schema);\n          if (id)\n            baseId = resolveUrl(baseId, id);\n          if (schema.$ref) {\n            var $ref = resolveUrl(baseId, schema.$ref);\n            var res = resolveSchema.call(this, root2, $ref);\n            if (res) {\n              schema = res.schema;\n              root2 = res.root;\n              baseId = res.baseId;\n            }\n          }\n        }\n      }\n    }\n    if (schema !== undefined && schema !== root2.schema)\n      return { schema, root: root2, baseId };\n  }\n  var SIMPLE_INLINED = util3.toHash([\n    \"type\",\n    \"format\",\n    \"pattern\",\n    \"maxLength\",\n    \"minLength\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"maxItems\",\n    \"minItems\",\n    \"maximum\",\n    \"minimum\",\n    \"uniqueItems\",\n    \"multipleOf\",\n    \"required\",\n    \"enum\"\n  ]);\n  function inlineRef(schema, limit) {\n    if (limit === false)\n      return false;\n    if (limit === undefined || limit === true)\n      return checkNoRef(schema);\n    else if (limit)\n      return countKeys(schema) <= limit;\n  }\n  function checkNoRef(schema) {\n    var item;\n    if (Array.isArray(schema)) {\n      for (var i = 0;i < schema.length; i++) {\n        item = schema[i];\n        if (typeof item == \"object\" && !checkNoRef(item))\n          return false;\n      }\n    } else {\n      for (var key in schema) {\n        if (key == \"$ref\")\n          return false;\n        item = schema[key];\n        if (typeof item == \"object\" && !checkNoRef(item))\n          return false;\n      }\n    }\n    return true;\n  }\n  function countKeys(schema) {\n    var count = 0, item;\n    if (Array.isArray(schema)) {\n      for (var i = 0;i < schema.length; i++) {\n        item = schema[i];\n        if (typeof item == \"object\")\n          count += countKeys(item);\n        if (count == Infinity)\n          return Infinity;\n      }\n    } else {\n      for (var key in schema) {\n        if (key == \"$ref\")\n          return Infinity;\n        if (SIMPLE_INLINED[key]) {\n          count++;\n        } else {\n          item = schema[key];\n          if (typeof item == \"object\")\n            count += countKeys(item) + 1;\n          if (count == Infinity)\n            return Infinity;\n        }\n      }\n    }\n    return count;\n  }\n  function getFullPath(id, normalize) {\n    if (normalize !== false)\n      id = normalizeId(id);\n    var p = URI.parse(id);\n    return _getFullPath(p);\n  }\n  function _getFullPath(p) {\n    return URI.serialize(p).split(\"#\")[0] + \"#\";\n  }\n  var TRAILING_SLASH_HASH = /#\\/?$/;\n  function normalizeId(id) {\n    return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\";\n  }\n  function resolveUrl(baseId, id) {\n    id = normalizeId(id);\n    return URI.resolve(baseId, id);\n  }\n  function resolveIds(schema) {\n    var schemaId = normalizeId(this._getId(schema));\n    var baseIds = { \"\": schemaId };\n    var fullPaths = { \"\": getFullPath(schemaId, false) };\n    var localRefs = {};\n    var self2 = this;\n    traverse(schema, { allKeys: true }, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n      if (jsonPtr === \"\")\n        return;\n      var id = self2._getId(sch);\n      var baseId = baseIds[parentJsonPtr];\n      var fullPath = fullPaths[parentJsonPtr] + \"/\" + parentKeyword;\n      if (keyIndex !== undefined)\n        fullPath += \"/\" + (typeof keyIndex == \"number\" ? keyIndex : util3.escapeFragment(keyIndex));\n      if (typeof id == \"string\") {\n        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);\n        var refVal = self2._refs[id];\n        if (typeof refVal == \"string\")\n          refVal = self2._refs[refVal];\n        if (refVal && refVal.schema) {\n          if (!equal(sch, refVal.schema))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n        } else if (id != normalizeId(fullPath)) {\n          if (id[0] == \"#\") {\n            if (localRefs[id] && !equal(sch, localRefs[id]))\n              throw new Error('id \"' + id + '\" resolves to more than one schema');\n            localRefs[id] = sch;\n          } else {\n            self2._refs[id] = fullPath;\n          }\n        }\n      }\n      baseIds[jsonPtr] = baseId;\n      fullPaths[jsonPtr] = fullPath;\n    });\n    return localRefs;\n  }\n});\n\n// ../node_modules/ajv/lib/compile/error_classes.js\nvar require_error_classes = __commonJS((exports, module) => {\n  var resolve = require_resolve();\n  module.exports = {\n    Validation: errorSubclass(ValidationError),\n    MissingRef: errorSubclass(MissingRefError)\n  };\n  function ValidationError(errors2) {\n    this.message = \"validation failed\";\n    this.errors = errors2;\n    this.ajv = this.validation = true;\n  }\n  MissingRefError.message = function(baseId, ref) {\n    return \"can't resolve reference \" + ref + \" from id \" + baseId;\n  };\n  function MissingRefError(baseId, ref, message) {\n    this.message = message || MissingRefError.message(baseId, ref);\n    this.missingRef = resolve.url(baseId, ref);\n    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));\n  }\n  function errorSubclass(Subclass) {\n    Subclass.prototype = Object.create(Error.prototype);\n    Subclass.prototype.constructor = Subclass;\n    return Subclass;\n  }\n});\n\n// ../node_modules/fast-json-stable-stringify/index.js\nvar require_fast_json_stable_stringify = __commonJS((exports, module) => {\n  module.exports = function(data, opts) {\n    if (!opts)\n      opts = {};\n    if (typeof opts === \"function\")\n      opts = { cmp: opts };\n    var cycles = typeof opts.cycles === \"boolean\" ? opts.cycles : false;\n    var cmp = opts.cmp && function(f) {\n      return function(node) {\n        return function(a, b) {\n          var aobj = { key: a, value: node[a] };\n          var bobj = { key: b, value: node[b] };\n          return f(aobj, bobj);\n        };\n      };\n    }(opts.cmp);\n    var seen = [];\n    return function stringify(node) {\n      if (node && node.toJSON && typeof node.toJSON === \"function\") {\n        node = node.toJSON();\n      }\n      if (node === undefined)\n        return;\n      if (typeof node == \"number\")\n        return isFinite(node) ? \"\" + node : \"null\";\n      if (typeof node !== \"object\")\n        return JSON.stringify(node);\n      var i, out;\n      if (Array.isArray(node)) {\n        out = \"[\";\n        for (i = 0;i < node.length; i++) {\n          if (i)\n            out += \",\";\n          out += stringify(node[i]) || \"null\";\n        }\n        return out + \"]\";\n      }\n      if (node === null)\n        return \"null\";\n      if (seen.indexOf(node) !== -1) {\n        if (cycles)\n          return JSON.stringify(\"__cycle__\");\n        throw new TypeError(\"Converting circular structure to JSON\");\n      }\n      var seenIndex = seen.push(node) - 1;\n      var keys = Object.keys(node).sort(cmp && cmp(node));\n      out = \"\";\n      for (i = 0;i < keys.length; i++) {\n        var key = keys[i];\n        var value = stringify(node[key]);\n        if (!value)\n          continue;\n        if (out)\n          out += \",\";\n        out += JSON.stringify(key) + \":\" + value;\n      }\n      seen.splice(seenIndex, 1);\n      return \"{\" + out + \"}\";\n    }(data);\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/validate.js\nvar require_validate = __commonJS((exports, module) => {\n  module.exports = function generate_validate(it, $keyword, $ruleType) {\n    var out = \"\";\n    var $async = it.schema.$async === true, $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, \"$ref\"), $id = it.self._getId(it.schema);\n    if (it.opts.strictKeywords) {\n      var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n      if ($unknownKwd) {\n        var $keywordsMsg = \"unknown keyword: \" + $unknownKwd;\n        if (it.opts.strictKeywords === \"log\")\n          it.logger.warn($keywordsMsg);\n        else\n          throw new Error($keywordsMsg);\n      }\n    }\n    if (it.isTop) {\n      out += \" var validate = \";\n      if ($async) {\n        it.async = true;\n        out += \"async \";\n      }\n      out += \"function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; \";\n      if ($id && (it.opts.sourceCode || it.opts.processCode)) {\n        out += \" \" + (\"/*# sourceURL=\" + $id + \" */\") + \" \";\n      }\n    }\n    if (typeof it.schema == \"boolean\" || !($refKeywords || it.schema.$ref)) {\n      var $keyword = \"false schema\";\n      var $lvl = it.level;\n      var $dataLvl = it.dataLevel;\n      var $schema = it.schema[$keyword];\n      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n      var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n      var $breakOnError = !it.opts.allErrors;\n      var $errorKeyword;\n      var $data = \"data\" + ($dataLvl || \"\");\n      var $valid = \"valid\" + $lvl;\n      if (it.schema === false) {\n        if (it.isTop) {\n          $breakOnError = true;\n        } else {\n          out += \" var \" + $valid + \" = false; \";\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = \"\";\n        if (it.createErrors !== false) {\n          out += \" { keyword: '\" + ($errorKeyword || \"false schema\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n          if (it.opts.messages !== false) {\n            out += \" , message: 'boolean schema is false' \";\n          }\n          if (it.opts.verbose) {\n            out += \" , schema: false , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n          }\n          out += \" } \";\n        } else {\n          out += \" {} \";\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          if (it.async) {\n            out += \" throw new ValidationError([\" + __err + \"]); \";\n          } else {\n            out += \" validate.errors = [\" + __err + \"]; return false; \";\n          }\n        } else {\n          out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n        }\n      } else {\n        if (it.isTop) {\n          if ($async) {\n            out += \" return data; \";\n          } else {\n            out += \" validate.errors = null; return true; \";\n          }\n        } else {\n          out += \" var \" + $valid + \" = true; \";\n        }\n      }\n      if (it.isTop) {\n        out += \" }; return validate; \";\n      }\n      return out;\n    }\n    if (it.isTop) {\n      var $top = it.isTop, $lvl = it.level = 0, $dataLvl = it.dataLevel = 0, $data = \"data\";\n      it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n      it.baseId = it.baseId || it.rootId;\n      delete it.isTop;\n      it.dataPathArr = [\"\"];\n      if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n        var $defaultMsg = \"default is ignored in the schema root\";\n        if (it.opts.strictDefaults === \"log\")\n          it.logger.warn($defaultMsg);\n        else\n          throw new Error($defaultMsg);\n      }\n      out += \" var vErrors = null; \";\n      out += \" var errors = 0;     \";\n      out += \" if (rootData === undefined) rootData = data; \";\n    } else {\n      var { level: $lvl, dataLevel: $dataLvl } = it, $data = \"data\" + ($dataLvl || \"\");\n      if ($id)\n        it.baseId = it.resolve.url(it.baseId, $id);\n      if ($async && !it.async)\n        throw new Error(\"async schema in sync schema\");\n      out += \" var errs_\" + $lvl + \" = errors;\";\n    }\n    var $valid = \"valid\" + $lvl, $breakOnError = !it.opts.allErrors, $closingBraces1 = \"\", $closingBraces2 = \"\";\n    var $errorKeyword;\n    var $typeSchema = it.schema.type, $typeIsArray = Array.isArray($typeSchema);\n    if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n      if ($typeIsArray) {\n        if ($typeSchema.indexOf(\"null\") == -1)\n          $typeSchema = $typeSchema.concat(\"null\");\n      } else if ($typeSchema != \"null\") {\n        $typeSchema = [$typeSchema, \"null\"];\n        $typeIsArray = true;\n      }\n    }\n    if ($typeIsArray && $typeSchema.length == 1) {\n      $typeSchema = $typeSchema[0];\n      $typeIsArray = false;\n    }\n    if (it.schema.$ref && $refKeywords) {\n      if (it.opts.extendRefs == \"fail\") {\n        throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)');\n      } else if (it.opts.extendRefs !== true) {\n        $refKeywords = false;\n        it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n      }\n    }\n    if (it.schema.$comment && it.opts.$comment) {\n      out += \" \" + it.RULES.all.$comment.code(it, \"$comment\");\n    }\n    if ($typeSchema) {\n      if (it.opts.coerceTypes) {\n        var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);\n      }\n      var $rulesGroup = it.RULES.types[$typeSchema];\n      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {\n        var $schemaPath = it.schemaPath + \".type\", $errSchemaPath = it.errSchemaPath + \"/type\";\n        var $schemaPath = it.schemaPath + \".type\", $errSchemaPath = it.errSchemaPath + \"/type\", $method = $typeIsArray ? \"checkDataTypes\" : \"checkDataType\";\n        out += \" if (\" + it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true) + \") { \";\n        if ($coerceToTypes) {\n          var $dataType = \"dataType\" + $lvl, $coerced = \"coerced\" + $lvl;\n          out += \" var \" + $dataType + \" = typeof \" + $data + \"; var \" + $coerced + \" = undefined; \";\n          if (it.opts.coerceTypes == \"array\") {\n            out += \" if (\" + $dataType + \" == 'object' && Array.isArray(\" + $data + \") && \" + $data + \".length == 1) { \" + $data + \" = \" + $data + \"[0]; \" + $dataType + \" = typeof \" + $data + \"; if (\" + it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers) + \") \" + $coerced + \" = \" + $data + \"; } \";\n          }\n          out += \" if (\" + $coerced + \" !== undefined) ; \";\n          var arr1 = $coerceToTypes;\n          if (arr1) {\n            var $type, $i = -1, l1 = arr1.length - 1;\n            while ($i < l1) {\n              $type = arr1[$i += 1];\n              if ($type == \"string\") {\n                out += \" else if (\" + $dataType + \" == 'number' || \" + $dataType + \" == 'boolean') \" + $coerced + \" = '' + \" + $data + \"; else if (\" + $data + \" === null) \" + $coerced + \" = ''; \";\n              } else if ($type == \"number\" || $type == \"integer\") {\n                out += \" else if (\" + $dataType + \" == 'boolean' || \" + $data + \" === null || (\" + $dataType + \" == 'string' && \" + $data + \" && \" + $data + \" == +\" + $data + \" \";\n                if ($type == \"integer\") {\n                  out += \" && !(\" + $data + \" % 1)\";\n                }\n                out += \")) \" + $coerced + \" = +\" + $data + \"; \";\n              } else if ($type == \"boolean\") {\n                out += \" else if (\" + $data + \" === 'false' || \" + $data + \" === 0 || \" + $data + \" === null) \" + $coerced + \" = false; else if (\" + $data + \" === 'true' || \" + $data + \" === 1) \" + $coerced + \" = true; \";\n              } else if ($type == \"null\") {\n                out += \" else if (\" + $data + \" === '' || \" + $data + \" === 0 || \" + $data + \" === false) \" + $coerced + \" = null; \";\n              } else if (it.opts.coerceTypes == \"array\" && $type == \"array\") {\n                out += \" else if (\" + $dataType + \" == 'string' || \" + $dataType + \" == 'number' || \" + $dataType + \" == 'boolean' || \" + $data + \" == null) \" + $coerced + \" = [\" + $data + \"]; \";\n              }\n            }\n          }\n          out += \" else {   \";\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + ($errorKeyword || \"type\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { type: '\";\n            if ($typeIsArray) {\n              out += \"\" + $typeSchema.join(\",\");\n            } else {\n              out += \"\" + $typeSchema;\n            }\n            out += \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: 'should be \";\n              if ($typeIsArray) {\n                out += \"\" + $typeSchema.join(\",\");\n              } else {\n                out += \"\" + $typeSchema;\n              }\n              out += \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n          out += \" } if (\" + $coerced + \" !== undefined) {  \";\n          var $parentData = $dataLvl ? \"data\" + ($dataLvl - 1 || \"\") : \"parentData\", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : \"parentDataProperty\";\n          out += \" \" + $data + \" = \" + $coerced + \"; \";\n          if (!$dataLvl) {\n            out += \"if (\" + $parentData + \" !== undefined)\";\n          }\n          out += \" \" + $parentData + \"[\" + $parentDataProperty + \"] = \" + $coerced + \"; } \";\n        } else {\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + ($errorKeyword || \"type\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { type: '\";\n            if ($typeIsArray) {\n              out += \"\" + $typeSchema.join(\",\");\n            } else {\n              out += \"\" + $typeSchema;\n            }\n            out += \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: 'should be \";\n              if ($typeIsArray) {\n                out += \"\" + $typeSchema.join(\",\");\n              } else {\n                out += \"\" + $typeSchema;\n              }\n              out += \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n        }\n        out += \" } \";\n      }\n    }\n    if (it.schema.$ref && !$refKeywords) {\n      out += \" \" + it.RULES.all.$ref.code(it, \"$ref\") + \" \";\n      if ($breakOnError) {\n        out += \" } if (errors === \";\n        if ($top) {\n          out += \"0\";\n        } else {\n          out += \"errs_\" + $lvl;\n        }\n        out += \") { \";\n        $closingBraces2 += \"}\";\n      }\n    } else {\n      var arr2 = it.RULES;\n      if (arr2) {\n        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;\n        while (i2 < l2) {\n          $rulesGroup = arr2[i2 += 1];\n          if ($shouldUseGroup($rulesGroup)) {\n            if ($rulesGroup.type) {\n              out += \" if (\" + it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers) + \") { \";\n            }\n            if (it.opts.useDefaults) {\n              if ($rulesGroup.type == \"object\" && it.schema.properties) {\n                var $schema = it.schema.properties, $schemaKeys = Object.keys($schema);\n                var arr3 = $schemaKeys;\n                if (arr3) {\n                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;\n                  while (i3 < l3) {\n                    $propertyKey = arr3[i3 += 1];\n                    var $sch = $schema[$propertyKey];\n                    if ($sch.default !== undefined) {\n                      var $passData = $data + it.util.getProperty($propertyKey);\n                      if (it.compositeRule) {\n                        if (it.opts.strictDefaults) {\n                          var $defaultMsg = \"default is ignored for: \" + $passData;\n                          if (it.opts.strictDefaults === \"log\")\n                            it.logger.warn($defaultMsg);\n                          else\n                            throw new Error($defaultMsg);\n                        }\n                      } else {\n                        out += \" if (\" + $passData + \" === undefined \";\n                        if (it.opts.useDefaults == \"empty\") {\n                          out += \" || \" + $passData + \" === null || \" + $passData + \" === '' \";\n                        }\n                        out += \" ) \" + $passData + \" = \";\n                        if (it.opts.useDefaults == \"shared\") {\n                          out += \" \" + it.useDefault($sch.default) + \" \";\n                        } else {\n                          out += \" \" + JSON.stringify($sch.default) + \" \";\n                        }\n                        out += \"; \";\n                      }\n                    }\n                  }\n                }\n              } else if ($rulesGroup.type == \"array\" && Array.isArray(it.schema.items)) {\n                var arr4 = it.schema.items;\n                if (arr4) {\n                  var $sch, $i = -1, l4 = arr4.length - 1;\n                  while ($i < l4) {\n                    $sch = arr4[$i += 1];\n                    if ($sch.default !== undefined) {\n                      var $passData = $data + \"[\" + $i + \"]\";\n                      if (it.compositeRule) {\n                        if (it.opts.strictDefaults) {\n                          var $defaultMsg = \"default is ignored for: \" + $passData;\n                          if (it.opts.strictDefaults === \"log\")\n                            it.logger.warn($defaultMsg);\n                          else\n                            throw new Error($defaultMsg);\n                        }\n                      } else {\n                        out += \" if (\" + $passData + \" === undefined \";\n                        if (it.opts.useDefaults == \"empty\") {\n                          out += \" || \" + $passData + \" === null || \" + $passData + \" === '' \";\n                        }\n                        out += \" ) \" + $passData + \" = \";\n                        if (it.opts.useDefaults == \"shared\") {\n                          out += \" \" + it.useDefault($sch.default) + \" \";\n                        } else {\n                          out += \" \" + JSON.stringify($sch.default) + \" \";\n                        }\n                        out += \"; \";\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            var arr5 = $rulesGroup.rules;\n            if (arr5) {\n              var $rule, i5 = -1, l5 = arr5.length - 1;\n              while (i5 < l5) {\n                $rule = arr5[i5 += 1];\n                if ($shouldUseRule($rule)) {\n                  var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);\n                  if ($code) {\n                    out += \" \" + $code + \" \";\n                    if ($breakOnError) {\n                      $closingBraces1 += \"}\";\n                    }\n                  }\n                }\n              }\n            }\n            if ($breakOnError) {\n              out += \" \" + $closingBraces1 + \" \";\n              $closingBraces1 = \"\";\n            }\n            if ($rulesGroup.type) {\n              out += \" } \";\n              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {\n                out += \" else { \";\n                var $schemaPath = it.schemaPath + \".type\", $errSchemaPath = it.errSchemaPath + \"/type\";\n                var $$outStack = $$outStack || [];\n                $$outStack.push(out);\n                out = \"\";\n                if (it.createErrors !== false) {\n                  out += \" { keyword: '\" + ($errorKeyword || \"type\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { type: '\";\n                  if ($typeIsArray) {\n                    out += \"\" + $typeSchema.join(\",\");\n                  } else {\n                    out += \"\" + $typeSchema;\n                  }\n                  out += \"' } \";\n                  if (it.opts.messages !== false) {\n                    out += \" , message: 'should be \";\n                    if ($typeIsArray) {\n                      out += \"\" + $typeSchema.join(\",\");\n                    } else {\n                      out += \"\" + $typeSchema;\n                    }\n                    out += \"' \";\n                  }\n                  if (it.opts.verbose) {\n                    out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n                  }\n                  out += \" } \";\n                } else {\n                  out += \" {} \";\n                }\n                var __err = out;\n                out = $$outStack.pop();\n                if (!it.compositeRule && $breakOnError) {\n                  if (it.async) {\n                    out += \" throw new ValidationError([\" + __err + \"]); \";\n                  } else {\n                    out += \" validate.errors = [\" + __err + \"]; return false; \";\n                  }\n                } else {\n                  out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n                }\n                out += \" } \";\n              }\n            }\n            if ($breakOnError) {\n              out += \" if (errors === \";\n              if ($top) {\n                out += \"0\";\n              } else {\n                out += \"errs_\" + $lvl;\n              }\n              out += \") { \";\n              $closingBraces2 += \"}\";\n            }\n          }\n        }\n      }\n    }\n    if ($breakOnError) {\n      out += \" \" + $closingBraces2 + \" \";\n    }\n    if ($top) {\n      if ($async) {\n        out += \" if (errors === 0) return data;           \";\n        out += \" else throw new ValidationError(vErrors); \";\n      } else {\n        out += \" validate.errors = vErrors; \";\n        out += \" return errors === 0;       \";\n      }\n      out += \" }; return validate;\";\n    } else {\n      out += \" var \" + $valid + \" = errors === errs_\" + $lvl + \";\";\n    }\n    function $shouldUseGroup($rulesGroup2) {\n      var rules = $rulesGroup2.rules;\n      for (var i = 0;i < rules.length; i++)\n        if ($shouldUseRule(rules[i]))\n          return true;\n    }\n    function $shouldUseRule($rule2) {\n      return it.schema[$rule2.keyword] !== undefined || $rule2.implements && $ruleImplementsSomeKeyword($rule2);\n    }\n    function $ruleImplementsSomeKeyword($rule2) {\n      var impl = $rule2.implements;\n      for (var i = 0;i < impl.length; i++)\n        if (it.schema[impl[i]] !== undefined)\n          return true;\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/compile/index.js\nvar require_compile = __commonJS((exports, module) => {\n  var resolve = require_resolve();\n  var util3 = require_util();\n  var errorClasses = require_error_classes();\n  var stableStringify = require_fast_json_stable_stringify();\n  var validateGenerator = require_validate();\n  var ucs2length = util3.ucs2length;\n  var equal = require_fast_deep_equal();\n  var ValidationError = errorClasses.Validation;\n  module.exports = compile;\n  function compile(schema, root2, localRefs, baseId) {\n    var self2 = this, opts = this._opts, refVal = [undefined], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];\n    root2 = root2 || { schema, refVal, refs };\n    var c = checkCompiling.call(this, schema, root2, baseId);\n    var compilation = this._compilations[c.index];\n    if (c.compiling)\n      return compilation.callValidate = callValidate;\n    var formats = this._formats;\n    var RULES = this.RULES;\n    try {\n      var v = localCompile(schema, root2, localRefs, baseId);\n      compilation.validate = v;\n      var cv = compilation.callValidate;\n      if (cv) {\n        cv.schema = v.schema;\n        cv.errors = null;\n        cv.refs = v.refs;\n        cv.refVal = v.refVal;\n        cv.root = v.root;\n        cv.$async = v.$async;\n        if (opts.sourceCode)\n          cv.source = v.source;\n      }\n      return v;\n    } finally {\n      endCompiling.call(this, schema, root2, baseId);\n    }\n    function callValidate() {\n      var validate = compilation.validate;\n      var result = validate.apply(this, arguments);\n      callValidate.errors = validate.errors;\n      return result;\n    }\n    function localCompile(_schema, _root, localRefs2, baseId2) {\n      var isRoot = !_root || _root && _root.schema == _schema;\n      if (_root.schema != root2.schema)\n        return compile.call(self2, _schema, _root, localRefs2, baseId2);\n      var $async = _schema.$async === true;\n      var sourceCode = validateGenerator({\n        isTop: true,\n        schema: _schema,\n        isRoot,\n        baseId: baseId2,\n        root: _root,\n        schemaPath: \"\",\n        errSchemaPath: \"#\",\n        errorPath: '\"\"',\n        MissingRefError: errorClasses.MissingRef,\n        RULES,\n        validate: validateGenerator,\n        util: util3,\n        resolve,\n        resolveRef,\n        usePattern,\n        useDefault,\n        useCustomRule,\n        opts,\n        formats,\n        logger: self2.logger,\n        self: self2\n      });\n      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;\n      if (opts.processCode)\n        sourceCode = opts.processCode(sourceCode, _schema);\n      var validate;\n      try {\n        var makeValidate = new Function(\"self\", \"RULES\", \"formats\", \"root\", \"refVal\", \"defaults\", \"customRules\", \"equal\", \"ucs2length\", \"ValidationError\", sourceCode);\n        validate = makeValidate(self2, RULES, formats, root2, refVal, defaults, customRules, equal, ucs2length, ValidationError);\n        refVal[0] = validate;\n      } catch (e) {\n        self2.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        throw e;\n      }\n      validate.schema = _schema;\n      validate.errors = null;\n      validate.refs = refs;\n      validate.refVal = refVal;\n      validate.root = isRoot ? validate : _root;\n      if ($async)\n        validate.$async = true;\n      if (opts.sourceCode === true) {\n        validate.source = {\n          code: sourceCode,\n          patterns,\n          defaults\n        };\n      }\n      return validate;\n    }\n    function resolveRef(baseId2, ref, isRoot) {\n      ref = resolve.url(baseId2, ref);\n      var refIndex = refs[ref];\n      var _refVal, refCode;\n      if (refIndex !== undefined) {\n        _refVal = refVal[refIndex];\n        refCode = \"refVal[\" + refIndex + \"]\";\n        return resolvedRef(_refVal, refCode);\n      }\n      if (!isRoot && root2.refs) {\n        var rootRefId = root2.refs[ref];\n        if (rootRefId !== undefined) {\n          _refVal = root2.refVal[rootRefId];\n          refCode = addLocalRef(ref, _refVal);\n          return resolvedRef(_refVal, refCode);\n        }\n      }\n      refCode = addLocalRef(ref);\n      var v2 = resolve.call(self2, localCompile, root2, ref);\n      if (v2 === undefined) {\n        var localSchema = localRefs && localRefs[ref];\n        if (localSchema) {\n          v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root2, localRefs, baseId2);\n        }\n      }\n      if (v2 === undefined) {\n        removeLocalRef(ref);\n      } else {\n        replaceLocalRef(ref, v2);\n        return resolvedRef(v2, refCode);\n      }\n    }\n    function addLocalRef(ref, v2) {\n      var refId = refVal.length;\n      refVal[refId] = v2;\n      refs[ref] = refId;\n      return \"refVal\" + refId;\n    }\n    function removeLocalRef(ref) {\n      delete refs[ref];\n    }\n    function replaceLocalRef(ref, v2) {\n      var refId = refs[ref];\n      refVal[refId] = v2;\n    }\n    function resolvedRef(refVal2, code) {\n      return typeof refVal2 == \"object\" || typeof refVal2 == \"boolean\" ? { code, schema: refVal2, inline: true } : { code, $async: refVal2 && !!refVal2.$async };\n    }\n    function usePattern(regexStr) {\n      var index = patternsHash[regexStr];\n      if (index === undefined) {\n        index = patternsHash[regexStr] = patterns.length;\n        patterns[index] = regexStr;\n      }\n      return \"pattern\" + index;\n    }\n    function useDefault(value) {\n      switch (typeof value) {\n        case \"boolean\":\n        case \"number\":\n          return \"\" + value;\n        case \"string\":\n          return util3.toQuotedString(value);\n        case \"object\":\n          if (value === null)\n            return \"null\";\n          var valueStr = stableStringify(value);\n          var index = defaultsHash[valueStr];\n          if (index === undefined) {\n            index = defaultsHash[valueStr] = defaults.length;\n            defaults[index] = value;\n          }\n          return \"default\" + index;\n      }\n    }\n    function useCustomRule(rule, schema2, parentSchema, it) {\n      if (self2._opts.validateSchema !== false) {\n        var deps = rule.definition.dependencies;\n        if (deps && !deps.every(function(keyword) {\n          return Object.prototype.hasOwnProperty.call(parentSchema, keyword);\n        }))\n          throw new Error(\"parent schema must have all required keywords: \" + deps.join(\",\"));\n        var validateSchema = rule.definition.validateSchema;\n        if (validateSchema) {\n          var valid = validateSchema(schema2);\n          if (!valid) {\n            var message = \"keyword schema is invalid: \" + self2.errorsText(validateSchema.errors);\n            if (self2._opts.validateSchema == \"log\")\n              self2.logger.error(message);\n            else\n              throw new Error(message);\n          }\n        }\n      }\n      var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;\n      var validate;\n      if (compile2) {\n        validate = compile2.call(self2, schema2, parentSchema, it);\n      } else if (macro) {\n        validate = macro.call(self2, schema2, parentSchema, it);\n        if (opts.validateSchema !== false)\n          self2.validateSchema(validate, true);\n      } else if (inline) {\n        validate = inline.call(self2, it, rule.keyword, schema2, parentSchema);\n      } else {\n        validate = rule.definition.validate;\n        if (!validate)\n          return;\n      }\n      if (validate === undefined)\n        throw new Error('custom keyword \"' + rule.keyword + '\"failed to compile');\n      var index = customRules.length;\n      customRules[index] = validate;\n      return {\n        code: \"customRule\" + index,\n        validate\n      };\n    }\n  }\n  function checkCompiling(schema, root2, baseId) {\n    var index = compIndex.call(this, schema, root2, baseId);\n    if (index >= 0)\n      return { index, compiling: true };\n    index = this._compilations.length;\n    this._compilations[index] = {\n      schema,\n      root: root2,\n      baseId\n    };\n    return { index, compiling: false };\n  }\n  function endCompiling(schema, root2, baseId) {\n    var i = compIndex.call(this, schema, root2, baseId);\n    if (i >= 0)\n      this._compilations.splice(i, 1);\n  }\n  function compIndex(schema, root2, baseId) {\n    for (var i = 0;i < this._compilations.length; i++) {\n      var c = this._compilations[i];\n      if (c.schema == schema && c.root == root2 && c.baseId == baseId)\n        return i;\n    }\n    return -1;\n  }\n  function patternCode(i, patterns) {\n    return \"var pattern\" + i + \" = new RegExp(\" + util3.toQuotedString(patterns[i]) + \");\";\n  }\n  function defaultCode(i) {\n    return \"var default\" + i + \" = defaults[\" + i + \"];\";\n  }\n  function refValCode(i, refVal) {\n    return refVal[i] === undefined ? \"\" : \"var refVal\" + i + \" = refVal[\" + i + \"];\";\n  }\n  function customRuleCode(i) {\n    return \"var customRule\" + i + \" = customRules[\" + i + \"];\";\n  }\n  function vars(arr, statement) {\n    if (!arr.length)\n      return \"\";\n    var code = \"\";\n    for (var i = 0;i < arr.length; i++)\n      code += statement(i, arr);\n    return code;\n  }\n});\n\n// ../node_modules/ajv/lib/cache.js\nvar require_cache = __commonJS((exports, module) => {\n  var Cache = module.exports = function Cache() {\n    this._cache = {};\n  };\n  Cache.prototype.put = function Cache_put(key, value) {\n    this._cache[key] = value;\n  };\n  Cache.prototype.get = function Cache_get(key) {\n    return this._cache[key];\n  };\n  Cache.prototype.del = function Cache_del(key) {\n    delete this._cache[key];\n  };\n  Cache.prototype.clear = function Cache_clear() {\n    this._cache = {};\n  };\n});\n\n// ../node_modules/ajv/lib/compile/formats.js\nvar require_formats = __commonJS((exports, module) => {\n  var util3 = require_util();\n  var DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\n  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  var TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\n  var HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\n  var URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n  var URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n  var URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n  var URL2 = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-)*(?:[0-9a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[a-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;\n  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\n  var JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\n  var JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\n  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n  module.exports = formats;\n  function formats(mode) {\n    mode = mode == \"full\" ? \"full\" : \"fast\";\n    return util3.copy(formats[mode]);\n  }\n  formats.fast = {\n    date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n    time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n    \"date-time\": /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n    uri: /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n    \"uri-reference\": /^(?:(?:[a-z][a-z0-9+\\-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n    \"uri-template\": URITEMPLATE,\n    url: URL2,\n    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n    hostname: HOSTNAME,\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n    regex,\n    uuid: UUID,\n    \"json-pointer\": JSON_POINTER,\n    \"json-pointer-uri-fragment\": JSON_POINTER_URI_FRAGMENT,\n    \"relative-json-pointer\": RELATIVE_JSON_POINTER\n  };\n  formats.full = {\n    date,\n    time,\n    \"date-time\": date_time,\n    uri,\n    \"uri-reference\": URIREF,\n    \"uri-template\": URITEMPLATE,\n    url: URL2,\n    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n    hostname: HOSTNAME,\n    ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n    ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n    regex,\n    uuid: UUID,\n    \"json-pointer\": JSON_POINTER,\n    \"json-pointer-uri-fragment\": JSON_POINTER_URI_FRAGMENT,\n    \"relative-json-pointer\": RELATIVE_JSON_POINTER\n  };\n  function isLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n  }\n  function date(str) {\n    var matches = str.match(DATE);\n    if (!matches)\n      return false;\n    var year = +matches[1];\n    var month = +matches[2];\n    var day = +matches[3];\n    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n  }\n  function time(str, full) {\n    var matches = str.match(TIME);\n    if (!matches)\n      return false;\n    var hour = matches[1];\n    var minute = matches[2];\n    var second = matches[3];\n    var timeZone = matches[5];\n    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);\n  }\n  var DATE_TIME_SEPARATOR = /t|\\s/i;\n  function date_time(str) {\n    var dateTime = str.split(DATE_TIME_SEPARATOR);\n    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);\n  }\n  var NOT_URI_FRAGMENT = /\\/|:/;\n  function uri(str) {\n    return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n  }\n  var Z_ANCHOR = /[^\\\\]\\\\Z/;\n  function regex(str) {\n    if (Z_ANCHOR.test(str))\n      return false;\n    try {\n      new RegExp(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n});\n\n// ../node_modules/ajv/lib/dotjs/ref.js\nvar require_ref = __commonJS((exports, module) => {\n  module.exports = function generate_ref(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $async, $refCode;\n    if ($schema == \"#\" || $schema == \"#/\") {\n      if (it.isRoot) {\n        $async = it.async;\n        $refCode = \"validate\";\n      } else {\n        $async = it.root.schema.$async === true;\n        $refCode = \"root.refVal[0]\";\n      }\n    } else {\n      var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n      if ($refVal === undefined) {\n        var $message = it.MissingRefError.message(it.baseId, $schema);\n        if (it.opts.missingRefs == \"fail\") {\n          it.logger.error($message);\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + \"$ref\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { ref: '\" + it.util.escapeQuotes($schema) + \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: 'can\\\\'t resolve reference \" + it.util.escapeQuotes($schema) + \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: \" + it.util.toQuotedString($schema) + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n          if ($breakOnError) {\n            out += \" if (false) { \";\n          }\n        } else if (it.opts.missingRefs == \"ignore\") {\n          it.logger.warn($message);\n          if ($breakOnError) {\n            out += \" if (true) { \";\n          }\n        } else {\n          throw new it.MissingRefError(it.baseId, $schema, $message);\n        }\n      } else if ($refVal.inline) {\n        var $it = it.util.copy(it);\n        $it.level++;\n        var $nextValid = \"valid\" + $it.level;\n        $it.schema = $refVal.schema;\n        $it.schemaPath = \"\";\n        $it.errSchemaPath = $schema;\n        var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);\n        out += \" \" + $code + \" \";\n        if ($breakOnError) {\n          out += \" if (\" + $nextValid + \") { \";\n        }\n      } else {\n        $async = $refVal.$async === true || it.async && $refVal.$async !== false;\n        $refCode = $refVal.code;\n      }\n    }\n    if ($refCode) {\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      if (it.opts.passContext) {\n        out += \" \" + $refCode + \".call(this, \";\n      } else {\n        out += \" \" + $refCode + \"( \";\n      }\n      out += \" \" + $data + \", (dataPath || '')\";\n      if (it.errorPath != '\"\"') {\n        out += \" + \" + it.errorPath;\n      }\n      var $parentData = $dataLvl ? \"data\" + ($dataLvl - 1 || \"\") : \"parentData\", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : \"parentDataProperty\";\n      out += \" , \" + $parentData + \" , \" + $parentDataProperty + \", rootData)  \";\n      var __callValidate = out;\n      out = $$outStack.pop();\n      if ($async) {\n        if (!it.async)\n          throw new Error(\"async schema referenced by sync schema\");\n        if ($breakOnError) {\n          out += \" var \" + $valid + \"; \";\n        }\n        out += \" try { await \" + __callValidate + \"; \";\n        if ($breakOnError) {\n          out += \" \" + $valid + \" = true; \";\n        }\n        out += \" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; \";\n        if ($breakOnError) {\n          out += \" \" + $valid + \" = false; \";\n        }\n        out += \" } \";\n        if ($breakOnError) {\n          out += \" if (\" + $valid + \") { \";\n        }\n      } else {\n        out += \" if (!\" + __callValidate + \") { if (vErrors === null) vErrors = \" + $refCode + \".errors; else vErrors = vErrors.concat(\" + $refCode + \".errors); errors = vErrors.length; } \";\n        if ($breakOnError) {\n          out += \" else { \";\n        }\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/allOf.js\nvar require_allOf = __commonJS((exports, module) => {\n  module.exports = function generate_allOf(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1, l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n          $allSchemasEmpty = false;\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + \"[\" + $i + \"]\";\n          $it.errSchemaPath = $errSchemaPath + \"/\" + $i;\n          out += \"  \" + it.validate($it) + \" \";\n          $it.baseId = $currentBaseId;\n          if ($breakOnError) {\n            out += \" if (\" + $nextValid + \") { \";\n            $closingBraces += \"}\";\n          }\n        }\n      }\n    }\n    if ($breakOnError) {\n      if ($allSchemasEmpty) {\n        out += \" if (true) { \";\n      } else {\n        out += \" \" + $closingBraces.slice(0, -1) + \" \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/anyOf.js\nvar require_anyOf = __commonJS((exports, module) => {\n  module.exports = function generate_anyOf(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $noEmptySchema = $schema.every(function($sch2) {\n      return it.opts.strictKeywords ? typeof $sch2 == \"object\" && Object.keys($sch2).length > 0 || $sch2 === false : it.util.schemaHasRules($sch2, it.RULES.all);\n    });\n    if ($noEmptySchema) {\n      var $currentBaseId = $it.baseId;\n      out += \" var \" + $errs + \" = errors; var \" + $valid + \" = false;  \";\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      var arr1 = $schema;\n      if (arr1) {\n        var $sch, $i = -1, l1 = arr1.length - 1;\n        while ($i < l1) {\n          $sch = arr1[$i += 1];\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + \"[\" + $i + \"]\";\n          $it.errSchemaPath = $errSchemaPath + \"/\" + $i;\n          out += \"  \" + it.validate($it) + \" \";\n          $it.baseId = $currentBaseId;\n          out += \" \" + $valid + \" = \" + $valid + \" || \" + $nextValid + \"; if (!\" + $valid + \") { \";\n          $closingBraces += \"}\";\n        }\n      }\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      out += \" \" + $closingBraces + \" if (!\" + $valid + \") {   var err =   \";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"anyOf\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n        if (it.opts.messages !== false) {\n          out += \" , message: 'should match some schema in anyOf' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError(vErrors); \";\n        } else {\n          out += \" validate.errors = vErrors; return false; \";\n        }\n      }\n      out += \" } else {  errors = \" + $errs + \"; if (vErrors !== null) { if (\" + $errs + \") vErrors.length = \" + $errs + \"; else vErrors = null; } \";\n      if (it.opts.allErrors) {\n        out += \" } \";\n      }\n    } else {\n      if ($breakOnError) {\n        out += \" if (true) { \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/comment.js\nvar require_comment = __commonJS((exports, module) => {\n  module.exports = function generate_comment(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $schema = it.schema[$keyword];\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $comment = it.util.toQuotedString($schema);\n    if (it.opts.$comment === true) {\n      out += \" console.log(\" + $comment + \");\";\n    } else if (typeof it.opts.$comment == \"function\") {\n      out += \" self._opts.$comment(\" + $comment + \", \" + it.util.toQuotedString($errSchemaPath) + \", validate.root.schema);\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/const.js\nvar require_const = __commonJS((exports, module) => {\n  module.exports = function generate_const(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (!$isData) {\n      out += \" var schema\" + $lvl + \" = validate.schema\" + $schemaPath + \";\";\n    }\n    out += \"var \" + $valid + \" = equal(\" + $data + \", schema\" + $lvl + \"); if (!\" + $valid + \") {   \";\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"const\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { allowedValue: schema\" + $lvl + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should be equal to constant' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \" }\";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/contains.js\nvar require_contains = __commonJS((exports, module) => {\n  module.exports = function generate_contains(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $idx = \"i\" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = \"data\" + $dataNxt, $currentBaseId = it.baseId, $nonEmptySchema = it.opts.strictKeywords ? typeof $schema == \"object\" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all);\n    out += \"var \" + $errs + \" = errors;var \" + $valid + \";\";\n    if ($nonEmptySchema) {\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      $it.schema = $schema;\n      $it.schemaPath = $schemaPath;\n      $it.errSchemaPath = $errSchemaPath;\n      out += \" var \" + $nextValid + \" = false; for (var \" + $idx + \" = 0; \" + $idx + \" < \" + $data + \".length; \" + $idx + \"++) { \";\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + \"[\" + $idx + \"]\";\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n      } else {\n        out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n      }\n      out += \" if (\" + $nextValid + \") break; }  \";\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      out += \" \" + $closingBraces + \" if (!\" + $nextValid + \") {\";\n    } else {\n      out += \" if (\" + $data + \".length == 0) {\";\n    }\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"contains\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should contain a valid item' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \" } else { \";\n    if ($nonEmptySchema) {\n      out += \"  errors = \" + $errs + \"; if (vErrors !== null) { if (\" + $errs + \") vErrors.length = \" + $errs + \"; else vErrors = null; } \";\n    }\n    if (it.opts.allErrors) {\n      out += \" } \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/dependencies.js\nvar require_dependencies = __commonJS((exports, module) => {\n  module.exports = function generate_dependencies(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it.opts.ownProperties;\n    for ($property in $schema) {\n      if ($property == \"__proto__\")\n        continue;\n      var $sch = $schema[$property];\n      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n      $deps[$property] = $sch;\n    }\n    out += \"var \" + $errs + \" = errors;\";\n    var $currentErrorPath = it.errorPath;\n    out += \"var missing\" + $lvl + \";\";\n    for (var $property in $propertyDeps) {\n      $deps = $propertyDeps[$property];\n      if ($deps.length) {\n        out += \" if ( \" + $data + it.util.getProperty($property) + \" !== undefined \";\n        if ($ownProperties) {\n          out += \" && Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($property) + \"') \";\n        }\n        if ($breakOnError) {\n          out += \" && ( \";\n          var arr1 = $deps;\n          if (arr1) {\n            var $propertyKey, $i = -1, l1 = arr1.length - 1;\n            while ($i < l1) {\n              $propertyKey = arr1[$i += 1];\n              if ($i) {\n                out += \" || \";\n              }\n              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;\n              out += \" ( ( \" + $useData + \" === undefined \";\n              if ($ownProperties) {\n                out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n              }\n              out += \") && (missing\" + $lvl + \" = \" + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + \") ) \";\n            }\n          }\n          out += \")) {  \";\n          var $propertyPath = \"missing\" + $lvl, $missingProperty = \"' + \" + $propertyPath + \" + '\";\n          if (it.opts._errorDataPathProperty) {\n            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + \" + \" + $propertyPath;\n          }\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + \"dependencies\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { property: '\" + it.util.escapeQuotes($property) + \"', missingProperty: '\" + $missingProperty + \"', depsCount: \" + $deps.length + \", deps: '\" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \")) + \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: 'should have \";\n              if ($deps.length == 1) {\n                out += \"property \" + it.util.escapeQuotes($deps[0]);\n              } else {\n                out += \"properties \" + it.util.escapeQuotes($deps.join(\", \"));\n              }\n              out += \" when property \" + it.util.escapeQuotes($property) + \" is present' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n        } else {\n          out += \" ) { \";\n          var arr2 = $deps;\n          if (arr2) {\n            var $propertyKey, i2 = -1, l2 = arr2.length - 1;\n            while (i2 < l2) {\n              $propertyKey = arr2[i2 += 1];\n              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              out += \" if ( \" + $useData + \" === undefined \";\n              if ($ownProperties) {\n                out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n              }\n              out += \") {  var err =   \";\n              if (it.createErrors !== false) {\n                out += \" { keyword: '\" + \"dependencies\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { property: '\" + it.util.escapeQuotes($property) + \"', missingProperty: '\" + $missingProperty + \"', depsCount: \" + $deps.length + \", deps: '\" + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \")) + \"' } \";\n                if (it.opts.messages !== false) {\n                  out += \" , message: 'should have \";\n                  if ($deps.length == 1) {\n                    out += \"property \" + it.util.escapeQuotes($deps[0]);\n                  } else {\n                    out += \"properties \" + it.util.escapeQuotes($deps.join(\", \"));\n                  }\n                  out += \" when property \" + it.util.escapeQuotes($property) + \" is present' \";\n                }\n                if (it.opts.verbose) {\n                  out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n                }\n                out += \" } \";\n              } else {\n                out += \" {} \";\n              }\n              out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } \";\n            }\n          }\n        }\n        out += \" }   \";\n        if ($breakOnError) {\n          $closingBraces += \"}\";\n          out += \" else { \";\n        }\n      }\n    }\n    it.errorPath = $currentErrorPath;\n    var $currentBaseId = $it.baseId;\n    for (var $property in $schemaDeps) {\n      var $sch = $schemaDeps[$property];\n      if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n        out += \" \" + $nextValid + \" = true; if ( \" + $data + it.util.getProperty($property) + \" !== undefined \";\n        if ($ownProperties) {\n          out += \" && Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($property) + \"') \";\n        }\n        out += \") { \";\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + it.util.getProperty($property);\n        $it.errSchemaPath = $errSchemaPath + \"/\" + it.util.escapeFragment($property);\n        out += \"  \" + it.validate($it) + \" \";\n        $it.baseId = $currentBaseId;\n        out += \" }  \";\n        if ($breakOnError) {\n          out += \" if (\" + $nextValid + \") { \";\n          $closingBraces += \"}\";\n        }\n      }\n    }\n    if ($breakOnError) {\n      out += \"   \" + $closingBraces + \" if (\" + $errs + \" == errors) {\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/enum.js\nvar require_enum = __commonJS((exports, module) => {\n  module.exports = function generate_enum(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $i = \"i\" + $lvl, $vSchema = \"schema\" + $lvl;\n    if (!$isData) {\n      out += \" var \" + $vSchema + \" = validate.schema\" + $schemaPath + \";\";\n    }\n    out += \"var \" + $valid + \";\";\n    if ($isData) {\n      out += \" if (schema\" + $lvl + \" === undefined) \" + $valid + \" = true; else if (!Array.isArray(schema\" + $lvl + \")) \" + $valid + \" = false; else {\";\n    }\n    out += \"\" + $valid + \" = false;for (var \" + $i + \"=0; \" + $i + \"<\" + $vSchema + \".length; \" + $i + \"++) if (equal(\" + $data + \", \" + $vSchema + \"[\" + $i + \"])) { \" + $valid + \" = true; break; }\";\n    if ($isData) {\n      out += \"  }  \";\n    }\n    out += \" if (!\" + $valid + \") {   \";\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"enum\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { allowedValues: schema\" + $lvl + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should be equal to one of the allowed values' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \" }\";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/format.js\nvar require_format = __commonJS((exports, module) => {\n  module.exports = function generate_format(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    if (it.opts.format === false) {\n      if ($breakOnError) {\n        out += \" if (true) { \";\n      }\n      return out;\n    }\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $unknownFormats = it.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);\n    if ($isData) {\n      var $format = \"format\" + $lvl, $isObject = \"isObject\" + $lvl, $formatType = \"formatType\" + $lvl;\n      out += \" var \" + $format + \" = formats[\" + $schemaValue + \"]; var \" + $isObject + \" = typeof \" + $format + \" == 'object' && !(\" + $format + \" instanceof RegExp) && \" + $format + \".validate; var \" + $formatType + \" = \" + $isObject + \" && \" + $format + \".type || 'string'; if (\" + $isObject + \") { \";\n      if (it.async) {\n        out += \" var async\" + $lvl + \" = \" + $format + \".async; \";\n      }\n      out += \" \" + $format + \" = \" + $format + \".validate; } if (  \";\n      if ($isData) {\n        out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'string') || \";\n      }\n      out += \" (\";\n      if ($unknownFormats != \"ignore\") {\n        out += \" (\" + $schemaValue + \" && !\" + $format + \" \";\n        if ($allowUnknown) {\n          out += \" && self._opts.unknownFormats.indexOf(\" + $schemaValue + \") == -1 \";\n        }\n        out += \") || \";\n      }\n      out += \" (\" + $format + \" && \" + $formatType + \" == '\" + $ruleType + \"' && !(typeof \" + $format + \" == 'function' ? \";\n      if (it.async) {\n        out += \" (async\" + $lvl + \" ? await \" + $format + \"(\" + $data + \") : \" + $format + \"(\" + $data + \")) \";\n      } else {\n        out += \" \" + $format + \"(\" + $data + \") \";\n      }\n      out += \" : \" + $format + \".test(\" + $data + \"))))) {\";\n    } else {\n      var $format = it.formats[$schema];\n      if (!$format) {\n        if ($unknownFormats == \"ignore\") {\n          it.logger.warn('unknown format \"' + $schema + '\" ignored in schema at path \"' + it.errSchemaPath + '\"');\n          if ($breakOnError) {\n            out += \" if (true) { \";\n          }\n          return out;\n        } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {\n          if ($breakOnError) {\n            out += \" if (true) { \";\n          }\n          return out;\n        } else {\n          throw new Error('unknown format \"' + $schema + '\" is used in schema at path \"' + it.errSchemaPath + '\"');\n        }\n      }\n      var $isObject = typeof $format == \"object\" && !($format instanceof RegExp) && $format.validate;\n      var $formatType = $isObject && $format.type || \"string\";\n      if ($isObject) {\n        var $async = $format.async === true;\n        $format = $format.validate;\n      }\n      if ($formatType != $ruleType) {\n        if ($breakOnError) {\n          out += \" if (true) { \";\n        }\n        return out;\n      }\n      if ($async) {\n        if (!it.async)\n          throw new Error(\"async format in sync schema\");\n        var $formatRef = \"formats\" + it.util.getProperty($schema) + \".validate\";\n        out += \" if (!(await \" + $formatRef + \"(\" + $data + \"))) { \";\n      } else {\n        out += \" if (! \";\n        var $formatRef = \"formats\" + it.util.getProperty($schema);\n        if ($isObject)\n          $formatRef += \".validate\";\n        if (typeof $format == \"function\") {\n          out += \" \" + $formatRef + \"(\" + $data + \") \";\n        } else {\n          out += \" \" + $formatRef + \".test(\" + $data + \") \";\n        }\n        out += \") { \";\n      }\n    }\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"format\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { format:  \";\n      if ($isData) {\n        out += \"\" + $schemaValue;\n      } else {\n        out += \"\" + it.util.toQuotedString($schema);\n      }\n      out += \"  } \";\n      if (it.opts.messages !== false) {\n        out += ` , message: 'should match format \"`;\n        if ($isData) {\n          out += \"' + \" + $schemaValue + \" + '\";\n        } else {\n          out += \"\" + it.util.escapeQuotes($schema);\n        }\n        out += `\"' `;\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + it.util.toQuotedString($schema);\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \" } \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/if.js\nvar require_if = __commonJS((exports, module) => {\n  module.exports = function generate_if(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $thenSch = it.schema[\"then\"], $elseSch = it.schema[\"else\"], $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == \"object\" && Object.keys($thenSch).length > 0 || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)), $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == \"object\" && Object.keys($elseSch).length > 0 || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)), $currentBaseId = $it.baseId;\n    if ($thenPresent || $elsePresent) {\n      var $ifClause;\n      $it.createErrors = false;\n      $it.schema = $schema;\n      $it.schemaPath = $schemaPath;\n      $it.errSchemaPath = $errSchemaPath;\n      out += \" var \" + $errs + \" = errors; var \" + $valid + \" = true;  \";\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      out += \"  \" + it.validate($it) + \" \";\n      $it.baseId = $currentBaseId;\n      $it.createErrors = true;\n      out += \"  errors = \" + $errs + \"; if (vErrors !== null) { if (\" + $errs + \") vErrors.length = \" + $errs + \"; else vErrors = null; }  \";\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      if ($thenPresent) {\n        out += \" if (\" + $nextValid + \") {  \";\n        $it.schema = it.schema[\"then\"];\n        $it.schemaPath = it.schemaPath + \".then\";\n        $it.errSchemaPath = it.errSchemaPath + \"/then\";\n        out += \"  \" + it.validate($it) + \" \";\n        $it.baseId = $currentBaseId;\n        out += \" \" + $valid + \" = \" + $nextValid + \"; \";\n        if ($thenPresent && $elsePresent) {\n          $ifClause = \"ifClause\" + $lvl;\n          out += \" var \" + $ifClause + \" = 'then'; \";\n        } else {\n          $ifClause = \"'then'\";\n        }\n        out += \" } \";\n        if ($elsePresent) {\n          out += \" else { \";\n        }\n      } else {\n        out += \" if (!\" + $nextValid + \") { \";\n      }\n      if ($elsePresent) {\n        $it.schema = it.schema[\"else\"];\n        $it.schemaPath = it.schemaPath + \".else\";\n        $it.errSchemaPath = it.errSchemaPath + \"/else\";\n        out += \"  \" + it.validate($it) + \" \";\n        $it.baseId = $currentBaseId;\n        out += \" \" + $valid + \" = \" + $nextValid + \"; \";\n        if ($thenPresent && $elsePresent) {\n          $ifClause = \"ifClause\" + $lvl;\n          out += \" var \" + $ifClause + \" = 'else'; \";\n        } else {\n          $ifClause = \"'else'\";\n        }\n        out += \" } \";\n      }\n      out += \" if (!\" + $valid + \") {   var err =   \";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"if\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { failingKeyword: \" + $ifClause + \" } \";\n        if (it.opts.messages !== false) {\n          out += ` , message: 'should match \"' + ` + $ifClause + ` + '\" schema' `;\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError(vErrors); \";\n        } else {\n          out += \" validate.errors = vErrors; return false; \";\n        }\n      }\n      out += \" }   \";\n      if ($breakOnError) {\n        out += \" else { \";\n      }\n    } else {\n      if ($breakOnError) {\n        out += \" if (true) { \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/items.js\nvar require_items = __commonJS((exports, module) => {\n  module.exports = function generate_items(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $idx = \"i\" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = \"data\" + $dataNxt, $currentBaseId = it.baseId;\n    out += \"var \" + $errs + \" = errors;var \" + $valid + \";\";\n    if (Array.isArray($schema)) {\n      var $additionalItems = it.schema.additionalItems;\n      if ($additionalItems === false) {\n        out += \" \" + $valid + \" = \" + $data + \".length <= \" + $schema.length + \"; \";\n        var $currErrSchemaPath = $errSchemaPath;\n        $errSchemaPath = it.errSchemaPath + \"/additionalItems\";\n        out += \"  if (!\" + $valid + \") {   \";\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = \"\";\n        if (it.createErrors !== false) {\n          out += \" { keyword: '\" + \"additionalItems\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { limit: \" + $schema.length + \" } \";\n          if (it.opts.messages !== false) {\n            out += \" , message: 'should NOT have more than \" + $schema.length + \" items' \";\n          }\n          if (it.opts.verbose) {\n            out += \" , schema: false , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n          }\n          out += \" } \";\n        } else {\n          out += \" {} \";\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          if (it.async) {\n            out += \" throw new ValidationError([\" + __err + \"]); \";\n          } else {\n            out += \" validate.errors = [\" + __err + \"]; return false; \";\n          }\n        } else {\n          out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n        }\n        out += \" } \";\n        $errSchemaPath = $currErrSchemaPath;\n        if ($breakOnError) {\n          $closingBraces += \"}\";\n          out += \" else { \";\n        }\n      }\n      var arr1 = $schema;\n      if (arr1) {\n        var $sch, $i = -1, l1 = arr1.length - 1;\n        while ($i < l1) {\n          $sch = arr1[$i += 1];\n          if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n            out += \" \" + $nextValid + \" = true; if (\" + $data + \".length > \" + $i + \") { \";\n            var $passData = $data + \"[\" + $i + \"]\";\n            $it.schema = $sch;\n            $it.schemaPath = $schemaPath + \"[\" + $i + \"]\";\n            $it.errSchemaPath = $errSchemaPath + \"/\" + $i;\n            $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n            $it.dataPathArr[$dataNxt] = $i;\n            var $code = it.validate($it);\n            $it.baseId = $currentBaseId;\n            if (it.util.varOccurences($code, $nextData) < 2) {\n              out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n            } else {\n              out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n            }\n            out += \" }  \";\n            if ($breakOnError) {\n              out += \" if (\" + $nextValid + \") { \";\n              $closingBraces += \"}\";\n            }\n          }\n        }\n      }\n      if (typeof $additionalItems == \"object\" && (it.opts.strictKeywords ? typeof $additionalItems == \"object\" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {\n        $it.schema = $additionalItems;\n        $it.schemaPath = it.schemaPath + \".additionalItems\";\n        $it.errSchemaPath = it.errSchemaPath + \"/additionalItems\";\n        out += \" \" + $nextValid + \" = true; if (\" + $data + \".length > \" + $schema.length + \") {  for (var \" + $idx + \" = \" + $schema.length + \"; \" + $idx + \" < \" + $data + \".length; \" + $idx + \"++) { \";\n        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n        var $passData = $data + \"[\" + $idx + \"]\";\n        $it.dataPathArr[$dataNxt] = $idx;\n        var $code = it.validate($it);\n        $it.baseId = $currentBaseId;\n        if (it.util.varOccurences($code, $nextData) < 2) {\n          out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n        } else {\n          out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n        }\n        if ($breakOnError) {\n          out += \" if (!\" + $nextValid + \") break; \";\n        }\n        out += \" } }  \";\n        if ($breakOnError) {\n          out += \" if (\" + $nextValid + \") { \";\n          $closingBraces += \"}\";\n        }\n      }\n    } else if (it.opts.strictKeywords ? typeof $schema == \"object\" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {\n      $it.schema = $schema;\n      $it.schemaPath = $schemaPath;\n      $it.errSchemaPath = $errSchemaPath;\n      out += \"  for (var \" + $idx + \" = \" + 0 + \"; \" + $idx + \" < \" + $data + \".length; \" + $idx + \"++) { \";\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + \"[\" + $idx + \"]\";\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n      } else {\n        out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n      }\n      if ($breakOnError) {\n        out += \" if (!\" + $nextValid + \") break; \";\n      }\n      out += \" }\";\n    }\n    if ($breakOnError) {\n      out += \" \" + $closingBraces + \" if (\" + $errs + \" == errors) {\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/_limit.js\nvar require__limit = __commonJS((exports, module) => {\n  module.exports = function generate__limit(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $isMax = $keyword == \"maximum\", $exclusiveKeyword = $isMax ? \"exclusiveMaximum\" : \"exclusiveMinimum\", $schemaExcl = it.schema[$exclusiveKeyword], $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? \"<\" : \">\", $notOp = $isMax ? \">\" : \"<\", $errorKeyword = undefined;\n    if (!($isData || typeof $schema == \"number\" || $schema === undefined)) {\n      throw new Error($keyword + \" must be number\");\n    }\n    if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == \"number\" || typeof $schemaExcl == \"boolean\")) {\n      throw new Error($exclusiveKeyword + \" must be number or boolean\");\n    }\n    if ($isDataExcl) {\n      var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr), $exclusive = \"exclusive\" + $lvl, $exclType = \"exclType\" + $lvl, $exclIsNumber = \"exclIsNumber\" + $lvl, $opExpr = \"op\" + $lvl, $opStr = \"' + \" + $opExpr + \" + '\";\n      out += \" var schemaExcl\" + $lvl + \" = \" + $schemaValueExcl + \"; \";\n      $schemaValueExcl = \"schemaExcl\" + $lvl;\n      out += \" var \" + $exclusive + \"; var \" + $exclType + \" = typeof \" + $schemaValueExcl + \"; if (\" + $exclType + \" != 'boolean' && \" + $exclType + \" != 'undefined' && \" + $exclType + \" != 'number') { \";\n      var $errorKeyword = $exclusiveKeyword;\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + ($errorKeyword || \"_exclusiveLimit\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n        if (it.opts.messages !== false) {\n          out += \" , message: '\" + $exclusiveKeyword + \" should be boolean' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError([\" + __err + \"]); \";\n        } else {\n          out += \" validate.errors = [\" + __err + \"]; return false; \";\n        }\n      } else {\n        out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      }\n      out += \" } else if ( \";\n      if ($isData) {\n        out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n      }\n      out += \" \" + $exclType + \" == 'number' ? ( (\" + $exclusive + \" = \" + $schemaValue + \" === undefined || \" + $schemaValueExcl + \" \" + $op + \"= \" + $schemaValue + \") ? \" + $data + \" \" + $notOp + \"= \" + $schemaValueExcl + \" : \" + $data + \" \" + $notOp + \" \" + $schemaValue + \" ) : ( (\" + $exclusive + \" = \" + $schemaValueExcl + \" === true) ? \" + $data + \" \" + $notOp + \"= \" + $schemaValue + \" : \" + $data + \" \" + $notOp + \" \" + $schemaValue + \" ) || \" + $data + \" !== \" + $data + \") { var op\" + $lvl + \" = \" + $exclusive + \" ? '\" + $op + \"' : '\" + $op + \"='; \";\n      if ($schema === undefined) {\n        $errorKeyword = $exclusiveKeyword;\n        $errSchemaPath = it.errSchemaPath + \"/\" + $exclusiveKeyword;\n        $schemaValue = $schemaValueExcl;\n        $isData = $isDataExcl;\n      }\n    } else {\n      var $exclIsNumber = typeof $schemaExcl == \"number\", $opStr = $op;\n      if ($exclIsNumber && $isData) {\n        var $opExpr = \"'\" + $opStr + \"'\";\n        out += \" if ( \";\n        if ($isData) {\n          out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n        }\n        out += \" ( \" + $schemaValue + \" === undefined || \" + $schemaExcl + \" \" + $op + \"= \" + $schemaValue + \" ? \" + $data + \" \" + $notOp + \"= \" + $schemaExcl + \" : \" + $data + \" \" + $notOp + \" \" + $schemaValue + \" ) || \" + $data + \" !== \" + $data + \") { \";\n      } else {\n        if ($exclIsNumber && $schema === undefined) {\n          $exclusive = true;\n          $errorKeyword = $exclusiveKeyword;\n          $errSchemaPath = it.errSchemaPath + \"/\" + $exclusiveKeyword;\n          $schemaValue = $schemaExcl;\n          $notOp += \"=\";\n        } else {\n          if ($exclIsNumber)\n            $schemaValue = Math[$isMax ? \"min\" : \"max\"]($schemaExcl, $schema);\n          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {\n            $exclusive = true;\n            $errorKeyword = $exclusiveKeyword;\n            $errSchemaPath = it.errSchemaPath + \"/\" + $exclusiveKeyword;\n            $notOp += \"=\";\n          } else {\n            $exclusive = false;\n            $opStr += \"=\";\n          }\n        }\n        var $opExpr = \"'\" + $opStr + \"'\";\n        out += \" if ( \";\n        if ($isData) {\n          out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n        }\n        out += \" \" + $data + \" \" + $notOp + \" \" + $schemaValue + \" || \" + $data + \" !== \" + $data + \") { \";\n      }\n    }\n    $errorKeyword = $errorKeyword || $keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + ($errorKeyword || \"_limit\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { comparison: \" + $opExpr + \", limit: \" + $schemaValue + \", exclusive: \" + $exclusive + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should be \" + $opStr + \" \";\n        if ($isData) {\n          out += \"' + \" + $schemaValue;\n        } else {\n          out += \"\" + $schemaValue + \"'\";\n        }\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \" } \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/_limitItems.js\nvar require__limitItems = __commonJS((exports, module) => {\n  module.exports = function generate__limitItems(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (!($isData || typeof $schema == \"number\")) {\n      throw new Error($keyword + \" must be number\");\n    }\n    var $op = $keyword == \"maxItems\" ? \">\" : \"<\";\n    out += \"if ( \";\n    if ($isData) {\n      out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n    }\n    out += \" \" + $data + \".length \" + $op + \" \" + $schemaValue + \") { \";\n    var $errorKeyword = $keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + ($errorKeyword || \"_limitItems\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { limit: \" + $schemaValue + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should NOT have \";\n        if ($keyword == \"maxItems\") {\n          out += \"more\";\n        } else {\n          out += \"fewer\";\n        }\n        out += \" than \";\n        if ($isData) {\n          out += \"' + \" + $schemaValue + \" + '\";\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \" items' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \"} \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/_limitLength.js\nvar require__limitLength = __commonJS((exports, module) => {\n  module.exports = function generate__limitLength(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (!($isData || typeof $schema == \"number\")) {\n      throw new Error($keyword + \" must be number\");\n    }\n    var $op = $keyword == \"maxLength\" ? \">\" : \"<\";\n    out += \"if ( \";\n    if ($isData) {\n      out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n    }\n    if (it.opts.unicode === false) {\n      out += \" \" + $data + \".length \";\n    } else {\n      out += \" ucs2length(\" + $data + \") \";\n    }\n    out += \" \" + $op + \" \" + $schemaValue + \") { \";\n    var $errorKeyword = $keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + ($errorKeyword || \"_limitLength\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { limit: \" + $schemaValue + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should NOT be \";\n        if ($keyword == \"maxLength\") {\n          out += \"longer\";\n        } else {\n          out += \"shorter\";\n        }\n        out += \" than \";\n        if ($isData) {\n          out += \"' + \" + $schemaValue + \" + '\";\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \" characters' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \"} \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/_limitProperties.js\nvar require__limitProperties = __commonJS((exports, module) => {\n  module.exports = function generate__limitProperties(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (!($isData || typeof $schema == \"number\")) {\n      throw new Error($keyword + \" must be number\");\n    }\n    var $op = $keyword == \"maxProperties\" ? \">\" : \"<\";\n    out += \"if ( \";\n    if ($isData) {\n      out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'number') || \";\n    }\n    out += \" Object.keys(\" + $data + \").length \" + $op + \" \" + $schemaValue + \") { \";\n    var $errorKeyword = $keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + ($errorKeyword || \"_limitProperties\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { limit: \" + $schemaValue + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should NOT have \";\n        if ($keyword == \"maxProperties\") {\n          out += \"more\";\n        } else {\n          out += \"fewer\";\n        }\n        out += \" than \";\n        if ($isData) {\n          out += \"' + \" + $schemaValue + \" + '\";\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \" properties' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \"} \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/multipleOf.js\nvar require_multipleOf = __commonJS((exports, module) => {\n  module.exports = function generate_multipleOf(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (!($isData || typeof $schema == \"number\")) {\n      throw new Error($keyword + \" must be number\");\n    }\n    out += \"var division\" + $lvl + \";if (\";\n    if ($isData) {\n      out += \" \" + $schemaValue + \" !== undefined && ( typeof \" + $schemaValue + \" != 'number' || \";\n    }\n    out += \" (division\" + $lvl + \" = \" + $data + \" / \" + $schemaValue + \", \";\n    if (it.opts.multipleOfPrecision) {\n      out += \" Math.abs(Math.round(division\" + $lvl + \") - division\" + $lvl + \") > 1e-\" + it.opts.multipleOfPrecision + \" \";\n    } else {\n      out += \" division\" + $lvl + \" !== parseInt(division\" + $lvl + \") \";\n    }\n    out += \" ) \";\n    if ($isData) {\n      out += \"  )  \";\n    }\n    out += \" ) {   \";\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"multipleOf\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { multipleOf: \" + $schemaValue + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should be multiple of \";\n        if ($isData) {\n          out += \"' + \" + $schemaValue;\n        } else {\n          out += \"\" + $schemaValue + \"'\";\n        }\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + $schema;\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \"} \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/not.js\nvar require_not = __commonJS((exports, module) => {\n  module.exports = function generate_not(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    if (it.opts.strictKeywords ? typeof $schema == \"object\" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {\n      $it.schema = $schema;\n      $it.schemaPath = $schemaPath;\n      $it.errSchemaPath = $errSchemaPath;\n      out += \" var \" + $errs + \" = errors;  \";\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      $it.createErrors = false;\n      var $allErrorsOption;\n      if ($it.opts.allErrors) {\n        $allErrorsOption = $it.opts.allErrors;\n        $it.opts.allErrors = false;\n      }\n      out += \" \" + it.validate($it) + \" \";\n      $it.createErrors = true;\n      if ($allErrorsOption)\n        $it.opts.allErrors = $allErrorsOption;\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      out += \" if (\" + $nextValid + \") {   \";\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"not\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n        if (it.opts.messages !== false) {\n          out += \" , message: 'should NOT be valid' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError([\" + __err + \"]); \";\n        } else {\n          out += \" validate.errors = [\" + __err + \"]; return false; \";\n        }\n      } else {\n        out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      }\n      out += \" } else {  errors = \" + $errs + \"; if (vErrors !== null) { if (\" + $errs + \") vErrors.length = \" + $errs + \"; else vErrors = null; } \";\n      if (it.opts.allErrors) {\n        out += \" } \";\n      }\n    } else {\n      out += \"  var err =   \";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"not\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: {} \";\n        if (it.opts.messages !== false) {\n          out += \" , message: 'should NOT be valid' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      if ($breakOnError) {\n        out += \" if (false) { \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/oneOf.js\nvar require_oneOf = __commonJS((exports, module) => {\n  module.exports = function generate_oneOf(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $currentBaseId = $it.baseId, $prevValid = \"prevValid\" + $lvl, $passingSchemas = \"passingSchemas\" + $lvl;\n    out += \"var \" + $errs + \" = errors , \" + $prevValid + \" = false , \" + $valid + \" = false , \" + $passingSchemas + \" = null; \";\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1, l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + \"[\" + $i + \"]\";\n          $it.errSchemaPath = $errSchemaPath + \"/\" + $i;\n          out += \"  \" + it.validate($it) + \" \";\n          $it.baseId = $currentBaseId;\n        } else {\n          out += \" var \" + $nextValid + \" = true; \";\n        }\n        if ($i) {\n          out += \" if (\" + $nextValid + \" && \" + $prevValid + \") { \" + $valid + \" = false; \" + $passingSchemas + \" = [\" + $passingSchemas + \", \" + $i + \"]; } else { \";\n          $closingBraces += \"}\";\n        }\n        out += \" if (\" + $nextValid + \") { \" + $valid + \" = \" + $prevValid + \" = true; \" + $passingSchemas + \" = \" + $i + \"; }\";\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += \"\" + $closingBraces + \"if (!\" + $valid + \") {   var err =   \";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"oneOf\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { passingSchemas: \" + $passingSchemas + \" } \";\n      if (it.opts.messages !== false) {\n        out += \" , message: 'should match exactly one schema in oneOf' \";\n      }\n      if (it.opts.verbose) {\n        out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError(vErrors); \";\n      } else {\n        out += \" validate.errors = vErrors; return false; \";\n      }\n    }\n    out += \"} else {  errors = \" + $errs + \"; if (vErrors !== null) { if (\" + $errs + \") vErrors.length = \" + $errs + \"; else vErrors = null; }\";\n    if (it.opts.allErrors) {\n      out += \" } \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/pattern.js\nvar require_pattern = __commonJS((exports, module) => {\n  module.exports = function generate_pattern(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $regexp = $isData ? \"(new RegExp(\" + $schemaValue + \"))\" : it.usePattern($schema);\n    out += \"if ( \";\n    if ($isData) {\n      out += \" (\" + $schemaValue + \" !== undefined && typeof \" + $schemaValue + \" != 'string') || \";\n    }\n    out += \" !\" + $regexp + \".test(\" + $data + \") ) {   \";\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = \"\";\n    if (it.createErrors !== false) {\n      out += \" { keyword: '\" + \"pattern\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { pattern:  \";\n      if ($isData) {\n        out += \"\" + $schemaValue;\n      } else {\n        out += \"\" + it.util.toQuotedString($schema);\n      }\n      out += \"  } \";\n      if (it.opts.messages !== false) {\n        out += ` , message: 'should match pattern \"`;\n        if ($isData) {\n          out += \"' + \" + $schemaValue + \" + '\";\n        } else {\n          out += \"\" + it.util.escapeQuotes($schema);\n        }\n        out += `\"' `;\n      }\n      if (it.opts.verbose) {\n        out += \" , schema:  \";\n        if ($isData) {\n          out += \"validate.schema\" + $schemaPath;\n        } else {\n          out += \"\" + it.util.toQuotedString($schema);\n        }\n        out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n      }\n      out += \" } \";\n    } else {\n      out += \" {} \";\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      if (it.async) {\n        out += \" throw new ValidationError([\" + __err + \"]); \";\n      } else {\n        out += \" validate.errors = [\" + __err + \"]; return false; \";\n      }\n    } else {\n      out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n    }\n    out += \"} \";\n    if ($breakOnError) {\n      out += \" else { \";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/properties.js\nvar require_properties = __commonJS((exports, module) => {\n  module.exports = function generate_properties(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    var $key = \"key\" + $lvl, $idx = \"idx\" + $lvl, $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = \"data\" + $dataNxt, $dataProperties = \"dataProperties\" + $lvl;\n    var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == \"object\" && Object.keys($aProperties).length, $removeAdditional = it.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;\n    var $required = it.schema.required;\n    if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {\n      var $requiredHash = it.util.toHash($required);\n    }\n    function notProto(p) {\n      return p !== \"__proto__\";\n    }\n    out += \"var \" + $errs + \" = errors;var \" + $nextValid + \" = true;\";\n    if ($ownProperties) {\n      out += \" var \" + $dataProperties + \" = undefined;\";\n    }\n    if ($checkAdditional) {\n      if ($ownProperties) {\n        out += \" \" + $dataProperties + \" = \" + $dataProperties + \" || Object.keys(\" + $data + \"); for (var \" + $idx + \"=0; \" + $idx + \"<\" + $dataProperties + \".length; \" + $idx + \"++) { var \" + $key + \" = \" + $dataProperties + \"[\" + $idx + \"]; \";\n      } else {\n        out += \" for (var \" + $key + \" in \" + $data + \") { \";\n      }\n      if ($someProperties) {\n        out += \" var isAdditional\" + $lvl + \" = !(false \";\n        if ($schemaKeys.length) {\n          if ($schemaKeys.length > 8) {\n            out += \" || validate.schema\" + $schemaPath + \".hasOwnProperty(\" + $key + \") \";\n          } else {\n            var arr1 = $schemaKeys;\n            if (arr1) {\n              var $propertyKey, i1 = -1, l1 = arr1.length - 1;\n              while (i1 < l1) {\n                $propertyKey = arr1[i1 += 1];\n                out += \" || \" + $key + \" == \" + it.util.toQuotedString($propertyKey) + \" \";\n              }\n            }\n          }\n        }\n        if ($pPropertyKeys.length) {\n          var arr2 = $pPropertyKeys;\n          if (arr2) {\n            var $pProperty, $i = -1, l2 = arr2.length - 1;\n            while ($i < l2) {\n              $pProperty = arr2[$i += 1];\n              out += \" || \" + it.usePattern($pProperty) + \".test(\" + $key + \") \";\n            }\n          }\n        }\n        out += \" ); if (isAdditional\" + $lvl + \") { \";\n      }\n      if ($removeAdditional == \"all\") {\n        out += \" delete \" + $data + \"[\" + $key + \"]; \";\n      } else {\n        var $currentErrorPath = it.errorPath;\n        var $additionalProperty = \"' + \" + $key + \" + '\";\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n        }\n        if ($noAdditional) {\n          if ($removeAdditional) {\n            out += \" delete \" + $data + \"[\" + $key + \"]; \";\n          } else {\n            out += \" \" + $nextValid + \" = false; \";\n            var $currErrSchemaPath = $errSchemaPath;\n            $errSchemaPath = it.errSchemaPath + \"/additionalProperties\";\n            var $$outStack = $$outStack || [];\n            $$outStack.push(out);\n            out = \"\";\n            if (it.createErrors !== false) {\n              out += \" { keyword: '\" + \"additionalProperties\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { additionalProperty: '\" + $additionalProperty + \"' } \";\n              if (it.opts.messages !== false) {\n                out += \" , message: '\";\n                if (it.opts._errorDataPathProperty) {\n                  out += \"is an invalid additional property\";\n                } else {\n                  out += \"should NOT have additional properties\";\n                }\n                out += \"' \";\n              }\n              if (it.opts.verbose) {\n                out += \" , schema: false , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n              }\n              out += \" } \";\n            } else {\n              out += \" {} \";\n            }\n            var __err = out;\n            out = $$outStack.pop();\n            if (!it.compositeRule && $breakOnError) {\n              if (it.async) {\n                out += \" throw new ValidationError([\" + __err + \"]); \";\n              } else {\n                out += \" validate.errors = [\" + __err + \"]; return false; \";\n              }\n            } else {\n              out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n            }\n            $errSchemaPath = $currErrSchemaPath;\n            if ($breakOnError) {\n              out += \" break; \";\n            }\n          }\n        } else if ($additionalIsSchema) {\n          if ($removeAdditional == \"failing\") {\n            out += \" var \" + $errs + \" = errors;  \";\n            var $wasComposite = it.compositeRule;\n            it.compositeRule = $it.compositeRule = true;\n            $it.schema = $aProperties;\n            $it.schemaPath = it.schemaPath + \".additionalProperties\";\n            $it.errSchemaPath = it.errSchemaPath + \"/additionalProperties\";\n            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n            var $passData = $data + \"[\" + $key + \"]\";\n            $it.dataPathArr[$dataNxt] = $key;\n            var $code = it.validate($it);\n            $it.baseId = $currentBaseId;\n            if (it.util.varOccurences($code, $nextData) < 2) {\n              out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n            } else {\n              out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n            }\n            out += \" if (!\" + $nextValid + \") { errors = \" + $errs + \"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete \" + $data + \"[\" + $key + \"]; }  \";\n            it.compositeRule = $it.compositeRule = $wasComposite;\n          } else {\n            $it.schema = $aProperties;\n            $it.schemaPath = it.schemaPath + \".additionalProperties\";\n            $it.errSchemaPath = it.errSchemaPath + \"/additionalProperties\";\n            $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n            var $passData = $data + \"[\" + $key + \"]\";\n            $it.dataPathArr[$dataNxt] = $key;\n            var $code = it.validate($it);\n            $it.baseId = $currentBaseId;\n            if (it.util.varOccurences($code, $nextData) < 2) {\n              out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n            } else {\n              out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n            }\n            if ($breakOnError) {\n              out += \" if (!\" + $nextValid + \") break; \";\n            }\n          }\n        }\n        it.errorPath = $currentErrorPath;\n      }\n      if ($someProperties) {\n        out += \" } \";\n      }\n      out += \" }  \";\n      if ($breakOnError) {\n        out += \" if (\" + $nextValid + \") { \";\n        $closingBraces += \"}\";\n      }\n    }\n    var $useDefaults = it.opts.useDefaults && !it.compositeRule;\n    if ($schemaKeys.length) {\n      var arr3 = $schemaKeys;\n      if (arr3) {\n        var $propertyKey, i3 = -1, l3 = arr3.length - 1;\n        while (i3 < l3) {\n          $propertyKey = arr3[i3 += 1];\n          var $sch = $schema[$propertyKey];\n          if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n            var $prop = it.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== undefined;\n            $it.schema = $sch;\n            $it.schemaPath = $schemaPath + $prop;\n            $it.errSchemaPath = $errSchemaPath + \"/\" + it.util.escapeFragment($propertyKey);\n            $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n            $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);\n            var $code = it.validate($it);\n            $it.baseId = $currentBaseId;\n            if (it.util.varOccurences($code, $nextData) < 2) {\n              $code = it.util.varReplace($code, $nextData, $passData);\n              var $useData = $passData;\n            } else {\n              var $useData = $nextData;\n              out += \" var \" + $nextData + \" = \" + $passData + \"; \";\n            }\n            if ($hasDefault) {\n              out += \" \" + $code + \" \";\n            } else {\n              if ($requiredHash && $requiredHash[$propertyKey]) {\n                out += \" if ( \" + $useData + \" === undefined \";\n                if ($ownProperties) {\n                  out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n                }\n                out += \") { \" + $nextValid + \" = false; \";\n                var $currentErrorPath = it.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it.util.escapeQuotes($propertyKey);\n                if (it.opts._errorDataPathProperty) {\n                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n                }\n                $errSchemaPath = it.errSchemaPath + \"/required\";\n                var $$outStack = $$outStack || [];\n                $$outStack.push(out);\n                out = \"\";\n                if (it.createErrors !== false) {\n                  out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n                  if (it.opts.messages !== false) {\n                    out += \" , message: '\";\n                    if (it.opts._errorDataPathProperty) {\n                      out += \"is a required property\";\n                    } else {\n                      out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n                    }\n                    out += \"' \";\n                  }\n                  if (it.opts.verbose) {\n                    out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n                  }\n                  out += \" } \";\n                } else {\n                  out += \" {} \";\n                }\n                var __err = out;\n                out = $$outStack.pop();\n                if (!it.compositeRule && $breakOnError) {\n                  if (it.async) {\n                    out += \" throw new ValidationError([\" + __err + \"]); \";\n                  } else {\n                    out += \" validate.errors = [\" + __err + \"]; return false; \";\n                  }\n                } else {\n                  out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n                }\n                $errSchemaPath = $currErrSchemaPath;\n                it.errorPath = $currentErrorPath;\n                out += \" } else { \";\n              } else {\n                if ($breakOnError) {\n                  out += \" if ( \" + $useData + \" === undefined \";\n                  if ($ownProperties) {\n                    out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n                  }\n                  out += \") { \" + $nextValid + \" = true; } else { \";\n                } else {\n                  out += \" if (\" + $useData + \" !== undefined \";\n                  if ($ownProperties) {\n                    out += \" &&   Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n                  }\n                  out += \" ) { \";\n                }\n              }\n              out += \" \" + $code + \" } \";\n            }\n          }\n          if ($breakOnError) {\n            out += \" if (\" + $nextValid + \") { \";\n            $closingBraces += \"}\";\n          }\n        }\n      }\n    }\n    if ($pPropertyKeys.length) {\n      var arr4 = $pPropertyKeys;\n      if (arr4) {\n        var $pProperty, i4 = -1, l4 = arr4.length - 1;\n        while (i4 < l4) {\n          $pProperty = arr4[i4 += 1];\n          var $sch = $pProperties[$pProperty];\n          if (it.opts.strictKeywords ? typeof $sch == \"object\" && Object.keys($sch).length > 0 || $sch === false : it.util.schemaHasRules($sch, it.RULES.all)) {\n            $it.schema = $sch;\n            $it.schemaPath = it.schemaPath + \".patternProperties\" + it.util.getProperty($pProperty);\n            $it.errSchemaPath = it.errSchemaPath + \"/patternProperties/\" + it.util.escapeFragment($pProperty);\n            if ($ownProperties) {\n              out += \" \" + $dataProperties + \" = \" + $dataProperties + \" || Object.keys(\" + $data + \"); for (var \" + $idx + \"=0; \" + $idx + \"<\" + $dataProperties + \".length; \" + $idx + \"++) { var \" + $key + \" = \" + $dataProperties + \"[\" + $idx + \"]; \";\n            } else {\n              out += \" for (var \" + $key + \" in \" + $data + \") { \";\n            }\n            out += \" if (\" + it.usePattern($pProperty) + \".test(\" + $key + \")) { \";\n            $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n            var $passData = $data + \"[\" + $key + \"]\";\n            $it.dataPathArr[$dataNxt] = $key;\n            var $code = it.validate($it);\n            $it.baseId = $currentBaseId;\n            if (it.util.varOccurences($code, $nextData) < 2) {\n              out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n            } else {\n              out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n            }\n            if ($breakOnError) {\n              out += \" if (!\" + $nextValid + \") break; \";\n            }\n            out += \" } \";\n            if ($breakOnError) {\n              out += \" else \" + $nextValid + \" = true; \";\n            }\n            out += \" }  \";\n            if ($breakOnError) {\n              out += \" if (\" + $nextValid + \") { \";\n              $closingBraces += \"}\";\n            }\n          }\n        }\n      }\n    }\n    if ($breakOnError) {\n      out += \" \" + $closingBraces + \" if (\" + $errs + \" == errors) {\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/propertyNames.js\nvar require_propertyNames = __commonJS((exports, module) => {\n  module.exports = function generate_propertyNames(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $errs = \"errs__\" + $lvl;\n    var $it = it.util.copy(it);\n    var $closingBraces = \"\";\n    $it.level++;\n    var $nextValid = \"valid\" + $it.level;\n    out += \"var \" + $errs + \" = errors;\";\n    if (it.opts.strictKeywords ? typeof $schema == \"object\" && Object.keys($schema).length > 0 || $schema === false : it.util.schemaHasRules($schema, it.RULES.all)) {\n      $it.schema = $schema;\n      $it.schemaPath = $schemaPath;\n      $it.errSchemaPath = $errSchemaPath;\n      var $key = \"key\" + $lvl, $idx = \"idx\" + $lvl, $i = \"i\" + $lvl, $invalidName = \"' + \" + $key + \" + '\", $dataNxt = $it.dataLevel = it.dataLevel + 1, $nextData = \"data\" + $dataNxt, $dataProperties = \"dataProperties\" + $lvl, $ownProperties = it.opts.ownProperties, $currentBaseId = it.baseId;\n      if ($ownProperties) {\n        out += \" var \" + $dataProperties + \" = undefined; \";\n      }\n      if ($ownProperties) {\n        out += \" \" + $dataProperties + \" = \" + $dataProperties + \" || Object.keys(\" + $data + \"); for (var \" + $idx + \"=0; \" + $idx + \"<\" + $dataProperties + \".length; \" + $idx + \"++) { var \" + $key + \" = \" + $dataProperties + \"[\" + $idx + \"]; \";\n      } else {\n        out += \" for (var \" + $key + \" in \" + $data + \") { \";\n      }\n      out += \" var startErrs\" + $lvl + \" = errors; \";\n      var $passData = $key;\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += \" \" + it.util.varReplace($code, $nextData, $passData) + \" \";\n      } else {\n        out += \" var \" + $nextData + \" = \" + $passData + \"; \" + $code + \" \";\n      }\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      out += \" if (!\" + $nextValid + \") { for (var \" + $i + \"=startErrs\" + $lvl + \"; \" + $i + \"<errors; \" + $i + \"++) { vErrors[\" + $i + \"].propertyName = \" + $key + \"; }   var err =   \";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"propertyNames\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { propertyName: '\" + $invalidName + \"' } \";\n        if (it.opts.messages !== false) {\n          out += \" , message: 'property name \\\\'\" + $invalidName + \"\\\\' is invalid' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError(vErrors); \";\n        } else {\n          out += \" validate.errors = vErrors; return false; \";\n        }\n      }\n      if ($breakOnError) {\n        out += \" break; \";\n      }\n      out += \" } }\";\n    }\n    if ($breakOnError) {\n      out += \" \" + $closingBraces + \" if (\" + $errs + \" == errors) {\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/required.js\nvar require_required = __commonJS((exports, module) => {\n  module.exports = function generate_required(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $vSchema = \"schema\" + $lvl;\n    if (!$isData) {\n      if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {\n        var $required = [];\n        var arr1 = $schema;\n        if (arr1) {\n          var $property, i1 = -1, l1 = arr1.length - 1;\n          while (i1 < l1) {\n            $property = arr1[i1 += 1];\n            var $propertySch = it.schema.properties[$property];\n            if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == \"object\" && Object.keys($propertySch).length > 0 || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {\n              $required[$required.length] = $property;\n            }\n          }\n        }\n      } else {\n        var $required = $schema;\n      }\n    }\n    if ($isData || $required.length) {\n      var $currentErrorPath = it.errorPath, $loopRequired = $isData || $required.length >= it.opts.loopRequired, $ownProperties = it.opts.ownProperties;\n      if ($breakOnError) {\n        out += \" var missing\" + $lvl + \"; \";\n        if ($loopRequired) {\n          if (!$isData) {\n            out += \" var \" + $vSchema + \" = validate.schema\" + $schemaPath + \"; \";\n          }\n          var $i = \"i\" + $lvl, $propertyPath = \"schema\" + $lvl + \"[\" + $i + \"]\", $missingProperty = \"' + \" + $propertyPath + \" + '\";\n          if (it.opts._errorDataPathProperty) {\n            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n          }\n          out += \" var \" + $valid + \" = true; \";\n          if ($isData) {\n            out += \" if (schema\" + $lvl + \" === undefined) \" + $valid + \" = true; else if (!Array.isArray(schema\" + $lvl + \")) \" + $valid + \" = false; else {\";\n          }\n          out += \" for (var \" + $i + \" = 0; \" + $i + \" < \" + $vSchema + \".length; \" + $i + \"++) { \" + $valid + \" = \" + $data + \"[\" + $vSchema + \"[\" + $i + \"]] !== undefined \";\n          if ($ownProperties) {\n            out += \" &&   Object.prototype.hasOwnProperty.call(\" + $data + \", \" + $vSchema + \"[\" + $i + \"]) \";\n          }\n          out += \"; if (!\" + $valid + \") break; } \";\n          if ($isData) {\n            out += \"  }  \";\n          }\n          out += \"  if (!\" + $valid + \") {   \";\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: '\";\n              if (it.opts._errorDataPathProperty) {\n                out += \"is a required property\";\n              } else {\n                out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n              }\n              out += \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n          out += \" } else { \";\n        } else {\n          out += \" if ( \";\n          var arr2 = $required;\n          if (arr2) {\n            var $propertyKey, $i = -1, l2 = arr2.length - 1;\n            while ($i < l2) {\n              $propertyKey = arr2[$i += 1];\n              if ($i) {\n                out += \" || \";\n              }\n              var $prop = it.util.getProperty($propertyKey), $useData = $data + $prop;\n              out += \" ( ( \" + $useData + \" === undefined \";\n              if ($ownProperties) {\n                out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n              }\n              out += \") && (missing\" + $lvl + \" = \" + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + \") ) \";\n            }\n          }\n          out += \") {  \";\n          var $propertyPath = \"missing\" + $lvl, $missingProperty = \"' + \" + $propertyPath + \" + '\";\n          if (it.opts._errorDataPathProperty) {\n            it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + \" + \" + $propertyPath;\n          }\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = \"\";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: '\";\n              if (it.opts._errorDataPathProperty) {\n                out += \"is a required property\";\n              } else {\n                out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n              }\n              out += \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            if (it.async) {\n              out += \" throw new ValidationError([\" + __err + \"]); \";\n            } else {\n              out += \" validate.errors = [\" + __err + \"]; return false; \";\n            }\n          } else {\n            out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n          }\n          out += \" } else { \";\n        }\n      } else {\n        if ($loopRequired) {\n          if (!$isData) {\n            out += \" var \" + $vSchema + \" = validate.schema\" + $schemaPath + \"; \";\n          }\n          var $i = \"i\" + $lvl, $propertyPath = \"schema\" + $lvl + \"[\" + $i + \"]\", $missingProperty = \"' + \" + $propertyPath + \" + '\";\n          if (it.opts._errorDataPathProperty) {\n            it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n          }\n          if ($isData) {\n            out += \" if (\" + $vSchema + \" && !Array.isArray(\" + $vSchema + \")) {  var err =   \";\n            if (it.createErrors !== false) {\n              out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n              if (it.opts.messages !== false) {\n                out += \" , message: '\";\n                if (it.opts._errorDataPathProperty) {\n                  out += \"is a required property\";\n                } else {\n                  out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n                }\n                out += \"' \";\n              }\n              if (it.opts.verbose) {\n                out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n              }\n              out += \" } \";\n            } else {\n              out += \" {} \";\n            }\n            out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (\" + $vSchema + \" !== undefined) { \";\n          }\n          out += \" for (var \" + $i + \" = 0; \" + $i + \" < \" + $vSchema + \".length; \" + $i + \"++) { if (\" + $data + \"[\" + $vSchema + \"[\" + $i + \"]] === undefined \";\n          if ($ownProperties) {\n            out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", \" + $vSchema + \"[\" + $i + \"]) \";\n          }\n          out += \") {  var err =   \";\n          if (it.createErrors !== false) {\n            out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n            if (it.opts.messages !== false) {\n              out += \" , message: '\";\n              if (it.opts._errorDataPathProperty) {\n                out += \"is a required property\";\n              } else {\n                out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n              }\n              out += \"' \";\n            }\n            if (it.opts.verbose) {\n              out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n            }\n            out += \" } \";\n          } else {\n            out += \" {} \";\n          }\n          out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } \";\n          if ($isData) {\n            out += \"  }  \";\n          }\n        } else {\n          var arr3 = $required;\n          if (arr3) {\n            var $propertyKey, i3 = -1, l3 = arr3.length - 1;\n            while (i3 < l3) {\n              $propertyKey = arr3[i3 += 1];\n              var $prop = it.util.getProperty($propertyKey), $missingProperty = it.util.escapeQuotes($propertyKey), $useData = $data + $prop;\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              out += \" if ( \" + $useData + \" === undefined \";\n              if ($ownProperties) {\n                out += \" || ! Object.prototype.hasOwnProperty.call(\" + $data + \", '\" + it.util.escapeQuotes($propertyKey) + \"') \";\n              }\n              out += \") {  var err =   \";\n              if (it.createErrors !== false) {\n                out += \" { keyword: '\" + \"required\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { missingProperty: '\" + $missingProperty + \"' } \";\n                if (it.opts.messages !== false) {\n                  out += \" , message: '\";\n                  if (it.opts._errorDataPathProperty) {\n                    out += \"is a required property\";\n                  } else {\n                    out += \"should have required property \\\\'\" + $missingProperty + \"\\\\'\";\n                  }\n                  out += \"' \";\n                }\n                if (it.opts.verbose) {\n                  out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n                }\n                out += \" } \";\n              } else {\n                out += \" {} \";\n              }\n              out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } \";\n            }\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    } else if ($breakOnError) {\n      out += \" if (true) {\";\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/uniqueItems.js\nvar require_uniqueItems = __commonJS((exports, module) => {\n  module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    if (($schema || $isData) && it.opts.uniqueItems !== false) {\n      if ($isData) {\n        out += \" var \" + $valid + \"; if (\" + $schemaValue + \" === false || \" + $schemaValue + \" === undefined) \" + $valid + \" = true; else if (typeof \" + $schemaValue + \" != 'boolean') \" + $valid + \" = false; else { \";\n      }\n      out += \" var i = \" + $data + \".length , \" + $valid + \" = true , j; if (i > 1) { \";\n      var $itemType = it.schema.items && it.schema.items.type, $typeIsArray = Array.isArray($itemType);\n      if (!$itemType || $itemType == \"object\" || $itemType == \"array\" || $typeIsArray && ($itemType.indexOf(\"object\") >= 0 || $itemType.indexOf(\"array\") >= 0)) {\n        out += \" outer: for (;i--;) { for (j = i; j--;) { if (equal(\" + $data + \"[i], \" + $data + \"[j])) { \" + $valid + \" = false; break outer; } } } \";\n      } else {\n        out += \" var itemIndices = {}, item; for (;i--;) { var item = \" + $data + \"[i]; \";\n        var $method = \"checkDataType\" + ($typeIsArray ? \"s\" : \"\");\n        out += \" if (\" + it.util[$method]($itemType, \"item\", it.opts.strictNumbers, true) + \") continue; \";\n        if ($typeIsArray) {\n          out += ` if (typeof item == 'string') item = '\"' + item; `;\n        }\n        out += \" if (typeof itemIndices[item] == 'number') { \" + $valid + \" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } \";\n      }\n      out += \" } \";\n      if ($isData) {\n        out += \"  }  \";\n      }\n      out += \" if (!\" + $valid + \") {   \";\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + \"uniqueItems\" + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { i: i, j: j } \";\n        if (it.opts.messages !== false) {\n          out += \" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' \";\n        }\n        if (it.opts.verbose) {\n          out += \" , schema:  \";\n          if ($isData) {\n            out += \"validate.schema\" + $schemaPath;\n          } else {\n            out += \"\" + $schema;\n          }\n          out += \"         , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError([\" + __err + \"]); \";\n        } else {\n          out += \" validate.errors = [\" + __err + \"]; return false; \";\n        }\n      } else {\n        out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      }\n      out += \" } \";\n      if ($breakOnError) {\n        out += \" else { \";\n      }\n    } else {\n      if ($breakOnError) {\n        out += \" if (true) { \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/dotjs/index.js\nvar require_dotjs = __commonJS((exports, module) => {\n  module.exports = {\n    $ref: require_ref(),\n    allOf: require_allOf(),\n    anyOf: require_anyOf(),\n    $comment: require_comment(),\n    const: require_const(),\n    contains: require_contains(),\n    dependencies: require_dependencies(),\n    enum: require_enum(),\n    format: require_format(),\n    if: require_if(),\n    items: require_items(),\n    maximum: require__limit(),\n    minimum: require__limit(),\n    maxItems: require__limitItems(),\n    minItems: require__limitItems(),\n    maxLength: require__limitLength(),\n    minLength: require__limitLength(),\n    maxProperties: require__limitProperties(),\n    minProperties: require__limitProperties(),\n    multipleOf: require_multipleOf(),\n    not: require_not(),\n    oneOf: require_oneOf(),\n    pattern: require_pattern(),\n    properties: require_properties(),\n    propertyNames: require_propertyNames(),\n    required: require_required(),\n    uniqueItems: require_uniqueItems(),\n    validate: require_validate()\n  };\n});\n\n// ../node_modules/ajv/lib/compile/rules.js\nvar require_rules = __commonJS((exports, module) => {\n  var ruleModules = require_dotjs();\n  var toHash = require_util().toHash;\n  module.exports = function rules() {\n    var RULES = [\n      {\n        type: \"number\",\n        rules: [\n          { maximum: [\"exclusiveMaximum\"] },\n          { minimum: [\"exclusiveMinimum\"] },\n          \"multipleOf\",\n          \"format\"\n        ]\n      },\n      {\n        type: \"string\",\n        rules: [\"maxLength\", \"minLength\", \"pattern\", \"format\"]\n      },\n      {\n        type: \"array\",\n        rules: [\"maxItems\", \"minItems\", \"items\", \"contains\", \"uniqueItems\"]\n      },\n      {\n        type: \"object\",\n        rules: [\n          \"maxProperties\",\n          \"minProperties\",\n          \"required\",\n          \"dependencies\",\n          \"propertyNames\",\n          { properties: [\"additionalProperties\", \"patternProperties\"] }\n        ]\n      },\n      { rules: [\"$ref\", \"const\", \"enum\", \"not\", \"anyOf\", \"oneOf\", \"allOf\", \"if\"] }\n    ];\n    var ALL = [\"type\", \"$comment\"];\n    var KEYWORDS = [\n      \"$schema\",\n      \"$id\",\n      \"id\",\n      \"$data\",\n      \"$async\",\n      \"title\",\n      \"description\",\n      \"default\",\n      \"definitions\",\n      \"examples\",\n      \"readOnly\",\n      \"writeOnly\",\n      \"contentMediaType\",\n      \"contentEncoding\",\n      \"additionalItems\",\n      \"then\",\n      \"else\"\n    ];\n    var TYPES = [\"number\", \"integer\", \"string\", \"array\", \"object\", \"boolean\", \"null\"];\n    RULES.all = toHash(ALL);\n    RULES.types = toHash(TYPES);\n    RULES.forEach(function(group) {\n      group.rules = group.rules.map(function(keyword) {\n        var implKeywords;\n        if (typeof keyword == \"object\") {\n          var key = Object.keys(keyword)[0];\n          implKeywords = keyword[key];\n          keyword = key;\n          implKeywords.forEach(function(k) {\n            ALL.push(k);\n            RULES.all[k] = true;\n          });\n        }\n        ALL.push(keyword);\n        var rule = RULES.all[keyword] = {\n          keyword,\n          code: ruleModules[keyword],\n          implements: implKeywords\n        };\n        return rule;\n      });\n      RULES.all.$comment = {\n        keyword: \"$comment\",\n        code: ruleModules.$comment\n      };\n      if (group.type)\n        RULES.types[group.type] = group;\n    });\n    RULES.keywords = toHash(ALL.concat(KEYWORDS));\n    RULES.custom = {};\n    return RULES;\n  };\n});\n\n// ../node_modules/ajv/lib/data.js\nvar require_data = __commonJS((exports, module) => {\n  var KEYWORDS = [\n    \"multipleOf\",\n    \"maximum\",\n    \"exclusiveMaximum\",\n    \"minimum\",\n    \"exclusiveMinimum\",\n    \"maxLength\",\n    \"minLength\",\n    \"pattern\",\n    \"additionalItems\",\n    \"maxItems\",\n    \"minItems\",\n    \"uniqueItems\",\n    \"maxProperties\",\n    \"minProperties\",\n    \"required\",\n    \"additionalProperties\",\n    \"enum\",\n    \"format\",\n    \"const\"\n  ];\n  module.exports = function(metaSchema, keywordsJsonPointers) {\n    for (var i = 0;i < keywordsJsonPointers.length; i++) {\n      metaSchema = JSON.parse(JSON.stringify(metaSchema));\n      var segments = keywordsJsonPointers[i].split(\"/\");\n      var keywords = metaSchema;\n      var j;\n      for (j = 1;j < segments.length; j++)\n        keywords = keywords[segments[j]];\n      for (j = 0;j < KEYWORDS.length; j++) {\n        var key = KEYWORDS[j];\n        var schema = keywords[key];\n        if (schema) {\n          keywords[key] = {\n            anyOf: [\n              schema,\n              { $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\" }\n            ]\n          };\n        }\n      }\n    }\n    return metaSchema;\n  };\n});\n\n// ../node_modules/ajv/lib/compile/async.js\nvar require_async = __commonJS((exports, module) => {\n  var MissingRefError = require_error_classes().MissingRef;\n  module.exports = compileAsync;\n  function compileAsync(schema, meta, callback) {\n    var self2 = this;\n    if (typeof this._opts.loadSchema != \"function\")\n      throw new Error(\"options.loadSchema should be a function\");\n    if (typeof meta == \"function\") {\n      callback = meta;\n      meta = undefined;\n    }\n    var p = loadMetaSchemaOf(schema).then(function() {\n      var schemaObj = self2._addSchema(schema, undefined, meta);\n      return schemaObj.validate || _compileAsync(schemaObj);\n    });\n    if (callback) {\n      p.then(function(v) {\n        callback(null, v);\n      }, callback);\n    }\n    return p;\n    function loadMetaSchemaOf(sch) {\n      var $schema = sch.$schema;\n      return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, { $ref: $schema }, true) : Promise.resolve();\n    }\n    function _compileAsync(schemaObj) {\n      try {\n        return self2._compile(schemaObj);\n      } catch (e) {\n        if (e instanceof MissingRefError)\n          return loadMissingSchema(e);\n        throw e;\n      }\n      function loadMissingSchema(e) {\n        var ref = e.missingSchema;\n        if (added(ref))\n          throw new Error(\"Schema \" + ref + \" is loaded but \" + e.missingRef + \" cannot be resolved\");\n        var schemaPromise = self2._loadingSchemas[ref];\n        if (!schemaPromise) {\n          schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);\n          schemaPromise.then(removePromise, removePromise);\n        }\n        return schemaPromise.then(function(sch) {\n          if (!added(ref)) {\n            return loadMetaSchemaOf(sch).then(function() {\n              if (!added(ref))\n                self2.addSchema(sch, ref, undefined, meta);\n            });\n          }\n        }).then(function() {\n          return _compileAsync(schemaObj);\n        });\n        function removePromise() {\n          delete self2._loadingSchemas[ref];\n        }\n        function added(ref2) {\n          return self2._refs[ref2] || self2._schemas[ref2];\n        }\n      }\n    }\n  }\n});\n\n// ../node_modules/ajv/lib/dotjs/custom.js\nvar require_custom = __commonJS((exports, module) => {\n  module.exports = function generate_custom(it, $keyword, $ruleType) {\n    var out = \" \";\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + \"/\" + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = \"data\" + ($dataLvl || \"\");\n    var $valid = \"valid\" + $lvl;\n    var $errs = \"errs__\" + $lvl;\n    var $isData = it.opts.$data && $schema && $schema.$data, $schemaValue;\n    if ($isData) {\n      out += \" var schema\" + $lvl + \" = \" + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + \"; \";\n      $schemaValue = \"schema\" + $lvl;\n    } else {\n      $schemaValue = $schema;\n    }\n    var $rule = this, $definition = \"definition\" + $lvl, $rDef = $rule.definition, $closingBraces = \"\";\n    var $compile, $inline, $macro, $ruleValidate, $validateCode;\n    if ($isData && $rDef.$data) {\n      $validateCode = \"keywordValidate\" + $lvl;\n      var $validateSchema = $rDef.validateSchema;\n      out += \" var \" + $definition + \" = RULES.custom['\" + $keyword + \"'].definition; var \" + $validateCode + \" = \" + $definition + \".validate;\";\n    } else {\n      $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);\n      if (!$ruleValidate)\n        return;\n      $schemaValue = \"validate.schema\" + $schemaPath;\n      $validateCode = $ruleValidate.code;\n      $compile = $rDef.compile;\n      $inline = $rDef.inline;\n      $macro = $rDef.macro;\n    }\n    var $ruleErrs = $validateCode + \".errors\", $i = \"i\" + $lvl, $ruleErr = \"ruleErr\" + $lvl, $asyncKeyword = $rDef.async;\n    if ($asyncKeyword && !it.async)\n      throw new Error(\"async keyword in sync schema\");\n    if (!($inline || $macro)) {\n      out += \"\" + $ruleErrs + \" = null;\";\n    }\n    out += \"var \" + $errs + \" = errors;var \" + $valid + \";\";\n    if ($isData && $rDef.$data) {\n      $closingBraces += \"}\";\n      out += \" if (\" + $schemaValue + \" === undefined) { \" + $valid + \" = true; } else { \";\n      if ($validateSchema) {\n        $closingBraces += \"}\";\n        out += \" \" + $valid + \" = \" + $definition + \".validateSchema(\" + $schemaValue + \"); if (\" + $valid + \") { \";\n      }\n    }\n    if ($inline) {\n      if ($rDef.statements) {\n        out += \" \" + $ruleValidate.validate + \" \";\n      } else {\n        out += \" \" + $valid + \" = \" + $ruleValidate.validate + \"; \";\n      }\n    } else if ($macro) {\n      var $it = it.util.copy(it);\n      var $closingBraces = \"\";\n      $it.level++;\n      var $nextValid = \"valid\" + $it.level;\n      $it.schema = $ruleValidate.validate;\n      $it.schemaPath = \"\";\n      var $wasComposite = it.compositeRule;\n      it.compositeRule = $it.compositeRule = true;\n      var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);\n      it.compositeRule = $it.compositeRule = $wasComposite;\n      out += \" \" + $code;\n    } else {\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      out += \"  \" + $validateCode + \".call( \";\n      if (it.opts.passContext) {\n        out += \"this\";\n      } else {\n        out += \"self\";\n      }\n      if ($compile || $rDef.schema === false) {\n        out += \" , \" + $data + \" \";\n      } else {\n        out += \" , \" + $schemaValue + \" , \" + $data + \" , validate.schema\" + it.schemaPath + \" \";\n      }\n      out += \" , (dataPath || '')\";\n      if (it.errorPath != '\"\"') {\n        out += \" + \" + it.errorPath;\n      }\n      var $parentData = $dataLvl ? \"data\" + ($dataLvl - 1 || \"\") : \"parentData\", $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : \"parentDataProperty\";\n      out += \" , \" + $parentData + \" , \" + $parentDataProperty + \" , rootData )  \";\n      var def_callRuleValidate = out;\n      out = $$outStack.pop();\n      if ($rDef.errors === false) {\n        out += \" \" + $valid + \" = \";\n        if ($asyncKeyword) {\n          out += \"await \";\n        }\n        out += \"\" + def_callRuleValidate + \"; \";\n      } else {\n        if ($asyncKeyword) {\n          $ruleErrs = \"customErrors\" + $lvl;\n          out += \" var \" + $ruleErrs + \" = null; try { \" + $valid + \" = await \" + def_callRuleValidate + \"; } catch (e) { \" + $valid + \" = false; if (e instanceof ValidationError) \" + $ruleErrs + \" = e.errors; else throw e; } \";\n        } else {\n          out += \" \" + $ruleErrs + \" = null; \" + $valid + \" = \" + def_callRuleValidate + \"; \";\n        }\n      }\n    }\n    if ($rDef.modifying) {\n      out += \" if (\" + $parentData + \") \" + $data + \" = \" + $parentData + \"[\" + $parentDataProperty + \"];\";\n    }\n    out += \"\" + $closingBraces;\n    if ($rDef.valid) {\n      if ($breakOnError) {\n        out += \" if (true) { \";\n      }\n    } else {\n      out += \" if ( \";\n      if ($rDef.valid === undefined) {\n        out += \" !\";\n        if ($macro) {\n          out += \"\" + $nextValid;\n        } else {\n          out += \"\" + $valid;\n        }\n      } else {\n        out += \" \" + !$rDef.valid + \" \";\n      }\n      out += \") { \";\n      $errorKeyword = $rule.keyword;\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = \"\";\n      if (it.createErrors !== false) {\n        out += \" { keyword: '\" + ($errorKeyword || \"custom\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { keyword: '\" + $rule.keyword + \"' } \";\n        if (it.opts.messages !== false) {\n          out += ` , message: 'should pass \"` + $rule.keyword + `\" keyword validation' `;\n        }\n        if (it.opts.verbose) {\n          out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n        }\n        out += \" } \";\n      } else {\n        out += \" {} \";\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        if (it.async) {\n          out += \" throw new ValidationError([\" + __err + \"]); \";\n        } else {\n          out += \" validate.errors = [\" + __err + \"]; return false; \";\n        }\n      } else {\n        out += \" var err = \" + __err + \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n      }\n      var def_customError = out;\n      out = $$outStack.pop();\n      if ($inline) {\n        if ($rDef.errors) {\n          if ($rDef.errors != \"full\") {\n            out += \"  for (var \" + $i + \"=\" + $errs + \"; \" + $i + \"<errors; \" + $i + \"++) { var \" + $ruleErr + \" = vErrors[\" + $i + \"]; if (\" + $ruleErr + \".dataPath === undefined) \" + $ruleErr + \".dataPath = (dataPath || '') + \" + it.errorPath + \"; if (\" + $ruleErr + \".schemaPath === undefined) { \" + $ruleErr + '.schemaPath = \"' + $errSchemaPath + '\"; } ';\n            if (it.opts.verbose) {\n              out += \" \" + $ruleErr + \".schema = \" + $schemaValue + \"; \" + $ruleErr + \".data = \" + $data + \"; \";\n            }\n            out += \" } \";\n          }\n        } else {\n          if ($rDef.errors === false) {\n            out += \" \" + def_customError + \" \";\n          } else {\n            out += \" if (\" + $errs + \" == errors) { \" + def_customError + \" } else {  for (var \" + $i + \"=\" + $errs + \"; \" + $i + \"<errors; \" + $i + \"++) { var \" + $ruleErr + \" = vErrors[\" + $i + \"]; if (\" + $ruleErr + \".dataPath === undefined) \" + $ruleErr + \".dataPath = (dataPath || '') + \" + it.errorPath + \"; if (\" + $ruleErr + \".schemaPath === undefined) { \" + $ruleErr + '.schemaPath = \"' + $errSchemaPath + '\"; } ';\n            if (it.opts.verbose) {\n              out += \" \" + $ruleErr + \".schema = \" + $schemaValue + \"; \" + $ruleErr + \".data = \" + $data + \"; \";\n            }\n            out += \" } } \";\n          }\n        }\n      } else if ($macro) {\n        out += \"   var err =   \";\n        if (it.createErrors !== false) {\n          out += \" { keyword: '\" + ($errorKeyword || \"custom\") + \"' , dataPath: (dataPath || '') + \" + it.errorPath + \" , schemaPath: \" + it.util.toQuotedString($errSchemaPath) + \" , params: { keyword: '\" + $rule.keyword + \"' } \";\n          if (it.opts.messages !== false) {\n            out += ` , message: 'should pass \"` + $rule.keyword + `\" keyword validation' `;\n          }\n          if (it.opts.verbose) {\n            out += \" , schema: validate.schema\" + $schemaPath + \" , parentSchema: validate.schema\" + it.schemaPath + \" , data: \" + $data + \" \";\n          }\n          out += \" } \";\n        } else {\n          out += \" {} \";\n        }\n        out += \";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; \";\n        if (!it.compositeRule && $breakOnError) {\n          if (it.async) {\n            out += \" throw new ValidationError(vErrors); \";\n          } else {\n            out += \" validate.errors = vErrors; return false; \";\n          }\n        }\n      } else {\n        if ($rDef.errors === false) {\n          out += \" \" + def_customError + \" \";\n        } else {\n          out += \" if (Array.isArray(\" + $ruleErrs + \")) { if (vErrors === null) vErrors = \" + $ruleErrs + \"; else vErrors = vErrors.concat(\" + $ruleErrs + \"); errors = vErrors.length;  for (var \" + $i + \"=\" + $errs + \"; \" + $i + \"<errors; \" + $i + \"++) { var \" + $ruleErr + \" = vErrors[\" + $i + \"]; if (\" + $ruleErr + \".dataPath === undefined) \" + $ruleErr + \".dataPath = (dataPath || '') + \" + it.errorPath + \";  \" + $ruleErr + '.schemaPath = \"' + $errSchemaPath + '\";  ';\n          if (it.opts.verbose) {\n            out += \" \" + $ruleErr + \".schema = \" + $schemaValue + \"; \" + $ruleErr + \".data = \" + $data + \"; \";\n          }\n          out += \" } } else { \" + def_customError + \" } \";\n        }\n      }\n      out += \" } \";\n      if ($breakOnError) {\n        out += \" else { \";\n      }\n    }\n    return out;\n  };\n});\n\n// ../node_modules/ajv/lib/refs/json-schema-draft-07.json\nvar require_json_schema_draft_07 = __commonJS((exports, module) => {\n  module.exports = {\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    $id: \"http://json-schema.org/draft-07/schema#\",\n    title: \"Core schema meta-schema\",\n    definitions: {\n      schemaArray: {\n        type: \"array\",\n        minItems: 1,\n        items: { $ref: \"#\" }\n      },\n      nonNegativeInteger: {\n        type: \"integer\",\n        minimum: 0\n      },\n      nonNegativeIntegerDefault0: {\n        allOf: [\n          { $ref: \"#/definitions/nonNegativeInteger\" },\n          { default: 0 }\n        ]\n      },\n      simpleTypes: {\n        enum: [\n          \"array\",\n          \"boolean\",\n          \"integer\",\n          \"null\",\n          \"number\",\n          \"object\",\n          \"string\"\n        ]\n      },\n      stringArray: {\n        type: \"array\",\n        items: { type: \"string\" },\n        uniqueItems: true,\n        default: []\n      }\n    },\n    type: [\"object\", \"boolean\"],\n    properties: {\n      $id: {\n        type: \"string\",\n        format: \"uri-reference\"\n      },\n      $schema: {\n        type: \"string\",\n        format: \"uri\"\n      },\n      $ref: {\n        type: \"string\",\n        format: \"uri-reference\"\n      },\n      $comment: {\n        type: \"string\"\n      },\n      title: {\n        type: \"string\"\n      },\n      description: {\n        type: \"string\"\n      },\n      default: true,\n      readOnly: {\n        type: \"boolean\",\n        default: false\n      },\n      examples: {\n        type: \"array\",\n        items: true\n      },\n      multipleOf: {\n        type: \"number\",\n        exclusiveMinimum: 0\n      },\n      maximum: {\n        type: \"number\"\n      },\n      exclusiveMaximum: {\n        type: \"number\"\n      },\n      minimum: {\n        type: \"number\"\n      },\n      exclusiveMinimum: {\n        type: \"number\"\n      },\n      maxLength: { $ref: \"#/definitions/nonNegativeInteger\" },\n      minLength: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n      pattern: {\n        type: \"string\",\n        format: \"regex\"\n      },\n      additionalItems: { $ref: \"#\" },\n      items: {\n        anyOf: [\n          { $ref: \"#\" },\n          { $ref: \"#/definitions/schemaArray\" }\n        ],\n        default: true\n      },\n      maxItems: { $ref: \"#/definitions/nonNegativeInteger\" },\n      minItems: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n      uniqueItems: {\n        type: \"boolean\",\n        default: false\n      },\n      contains: { $ref: \"#\" },\n      maxProperties: { $ref: \"#/definitions/nonNegativeInteger\" },\n      minProperties: { $ref: \"#/definitions/nonNegativeIntegerDefault0\" },\n      required: { $ref: \"#/definitions/stringArray\" },\n      additionalProperties: { $ref: \"#\" },\n      definitions: {\n        type: \"object\",\n        additionalProperties: { $ref: \"#\" },\n        default: {}\n      },\n      properties: {\n        type: \"object\",\n        additionalProperties: { $ref: \"#\" },\n        default: {}\n      },\n      patternProperties: {\n        type: \"object\",\n        additionalProperties: { $ref: \"#\" },\n        propertyNames: { format: \"regex\" },\n        default: {}\n      },\n      dependencies: {\n        type: \"object\",\n        additionalProperties: {\n          anyOf: [\n            { $ref: \"#\" },\n            { $ref: \"#/definitions/stringArray\" }\n          ]\n        }\n      },\n      propertyNames: { $ref: \"#\" },\n      const: true,\n      enum: {\n        type: \"array\",\n        items: true,\n        minItems: 1,\n        uniqueItems: true\n      },\n      type: {\n        anyOf: [\n          { $ref: \"#/definitions/simpleTypes\" },\n          {\n            type: \"array\",\n            items: { $ref: \"#/definitions/simpleTypes\" },\n            minItems: 1,\n            uniqueItems: true\n          }\n        ]\n      },\n      format: { type: \"string\" },\n      contentMediaType: { type: \"string\" },\n      contentEncoding: { type: \"string\" },\n      if: { $ref: \"#\" },\n      then: { $ref: \"#\" },\n      else: { $ref: \"#\" },\n      allOf: { $ref: \"#/definitions/schemaArray\" },\n      anyOf: { $ref: \"#/definitions/schemaArray\" },\n      oneOf: { $ref: \"#/definitions/schemaArray\" },\n      not: { $ref: \"#\" }\n    },\n    default: true\n  };\n});\n\n// ../node_modules/ajv/lib/definition_schema.js\nvar require_definition_schema = __commonJS((exports, module) => {\n  var metaSchema = require_json_schema_draft_07();\n  module.exports = {\n    $id: \"https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js\",\n    definitions: {\n      simpleTypes: metaSchema.definitions.simpleTypes\n    },\n    type: \"object\",\n    dependencies: {\n      schema: [\"validate\"],\n      $data: [\"validate\"],\n      statements: [\"inline\"],\n      valid: { not: { required: [\"macro\"] } }\n    },\n    properties: {\n      type: metaSchema.properties.type,\n      schema: { type: \"boolean\" },\n      statements: { type: \"boolean\" },\n      dependencies: {\n        type: \"array\",\n        items: { type: \"string\" }\n      },\n      metaSchema: { type: \"object\" },\n      modifying: { type: \"boolean\" },\n      valid: { type: \"boolean\" },\n      $data: { type: \"boolean\" },\n      async: { type: \"boolean\" },\n      errors: {\n        anyOf: [\n          { type: \"boolean\" },\n          { const: \"full\" }\n        ]\n      }\n    }\n  };\n});\n\n// ../node_modules/ajv/lib/keyword.js\nvar require_keyword = __commonJS((exports, module) => {\n  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\n  var customRuleCode = require_custom();\n  var definitionSchema = require_definition_schema();\n  module.exports = {\n    add: addKeyword,\n    get: getKeyword,\n    remove: removeKeyword,\n    validate: validateKeyword\n  };\n  function addKeyword(keyword, definition) {\n    var RULES = this.RULES;\n    if (RULES.keywords[keyword])\n      throw new Error(\"Keyword \" + keyword + \" is already defined\");\n    if (!IDENTIFIER.test(keyword))\n      throw new Error(\"Keyword \" + keyword + \" is not a valid identifier\");\n    if (definition) {\n      this.validateKeyword(definition, true);\n      var dataType = definition.type;\n      if (Array.isArray(dataType)) {\n        for (var i = 0;i < dataType.length; i++)\n          _addRule(keyword, dataType[i], definition);\n      } else {\n        _addRule(keyword, dataType, definition);\n      }\n      var metaSchema = definition.metaSchema;\n      if (metaSchema) {\n        if (definition.$data && this._opts.$data) {\n          metaSchema = {\n            anyOf: [\n              metaSchema,\n              { $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\" }\n            ]\n          };\n        }\n        definition.validateSchema = this.compile(metaSchema, true);\n      }\n    }\n    RULES.keywords[keyword] = RULES.all[keyword] = true;\n    function _addRule(keyword2, dataType2, definition2) {\n      var ruleGroup;\n      for (var i2 = 0;i2 < RULES.length; i2++) {\n        var rg = RULES[i2];\n        if (rg.type == dataType2) {\n          ruleGroup = rg;\n          break;\n        }\n      }\n      if (!ruleGroup) {\n        ruleGroup = { type: dataType2, rules: [] };\n        RULES.push(ruleGroup);\n      }\n      var rule = {\n        keyword: keyword2,\n        definition: definition2,\n        custom: true,\n        code: customRuleCode,\n        implements: definition2.implements\n      };\n      ruleGroup.rules.push(rule);\n      RULES.custom[keyword2] = rule;\n    }\n    return this;\n  }\n  function getKeyword(keyword) {\n    var rule = this.RULES.custom[keyword];\n    return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n  }\n  function removeKeyword(keyword) {\n    var RULES = this.RULES;\n    delete RULES.keywords[keyword];\n    delete RULES.all[keyword];\n    delete RULES.custom[keyword];\n    for (var i = 0;i < RULES.length; i++) {\n      var rules = RULES[i].rules;\n      for (var j = 0;j < rules.length; j++) {\n        if (rules[j].keyword == keyword) {\n          rules.splice(j, 1);\n          break;\n        }\n      }\n    }\n    return this;\n  }\n  function validateKeyword(definition, throwError) {\n    validateKeyword.errors = null;\n    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);\n    if (v(definition))\n      return true;\n    validateKeyword.errors = v.errors;\n    if (throwError)\n      throw new Error(\"custom keyword definition is invalid: \" + this.errorsText(v.errors));\n    else\n      return false;\n  }\n});\n\n// ../node_modules/ajv/lib/refs/data.json\nvar require_data2 = __commonJS((exports, module) => {\n  module.exports = {\n    $schema: \"http://json-schema.org/draft-07/schema#\",\n    $id: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n    description: \"Meta-schema for $data reference (JSON Schema extension proposal)\",\n    type: \"object\",\n    required: [\"$data\"],\n    properties: {\n      $data: {\n        type: \"string\",\n        anyOf: [\n          { format: \"relative-json-pointer\" },\n          { format: \"json-pointer\" }\n        ]\n      }\n    },\n    additionalProperties: false\n  };\n});\n\n// ../node_modules/ajv/lib/ajv.js\nvar require_ajv = __commonJS((exports, module) => {\n  var compileSchema = require_compile();\n  var resolve = require_resolve();\n  var Cache = require_cache();\n  var SchemaObject = require_schema_obj();\n  var stableStringify = require_fast_json_stable_stringify();\n  var formats = require_formats();\n  var rules = require_rules();\n  var $dataMetaSchema = require_data();\n  var util3 = require_util();\n  module.exports = Ajv;\n  Ajv.prototype.validate = validate;\n  Ajv.prototype.compile = compile;\n  Ajv.prototype.addSchema = addSchema;\n  Ajv.prototype.addMetaSchema = addMetaSchema;\n  Ajv.prototype.validateSchema = validateSchema;\n  Ajv.prototype.getSchema = getSchema;\n  Ajv.prototype.removeSchema = removeSchema;\n  Ajv.prototype.addFormat = addFormat;\n  Ajv.prototype.errorsText = errorsText;\n  Ajv.prototype._addSchema = _addSchema;\n  Ajv.prototype._compile = _compile;\n  Ajv.prototype.compileAsync = require_async();\n  var customKeyword = require_keyword();\n  Ajv.prototype.addKeyword = customKeyword.add;\n  Ajv.prototype.getKeyword = customKeyword.get;\n  Ajv.prototype.removeKeyword = customKeyword.remove;\n  Ajv.prototype.validateKeyword = customKeyword.validate;\n  var errorClasses = require_error_classes();\n  Ajv.ValidationError = errorClasses.Validation;\n  Ajv.MissingRefError = errorClasses.MissingRef;\n  Ajv.$dataMetaSchema = $dataMetaSchema;\n  var META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\";\n  var META_IGNORE_OPTIONS = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\", \"strictDefaults\"];\n  var META_SUPPORT_DATA = [\"/properties\"];\n  function Ajv(opts) {\n    if (!(this instanceof Ajv))\n      return new Ajv(opts);\n    opts = this._opts = util3.copy(opts) || {};\n    setLogger(this);\n    this._schemas = {};\n    this._refs = {};\n    this._fragments = {};\n    this._formats = formats(opts.format);\n    this._cache = opts.cache || new Cache;\n    this._loadingSchemas = {};\n    this._compilations = [];\n    this.RULES = rules();\n    this._getId = chooseGetId(opts);\n    opts.loopRequired = opts.loopRequired || Infinity;\n    if (opts.errorDataPath == \"property\")\n      opts._errorDataPathProperty = true;\n    if (opts.serialize === undefined)\n      opts.serialize = stableStringify;\n    this._metaOpts = getMetaSchemaOptions(this);\n    if (opts.formats)\n      addInitialFormats(this);\n    if (opts.keywords)\n      addInitialKeywords(this);\n    addDefaultMetaSchema(this);\n    if (typeof opts.meta == \"object\")\n      this.addMetaSchema(opts.meta);\n    if (opts.nullable)\n      this.addKeyword(\"nullable\", { metaSchema: { type: \"boolean\" } });\n    addInitialSchemas(this);\n  }\n  function validate(schemaKeyRef, data) {\n    var v;\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema(schemaKeyRef);\n      if (!v)\n        throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n    } else {\n      var schemaObj = this._addSchema(schemaKeyRef);\n      v = schemaObj.validate || this._compile(schemaObj);\n    }\n    var valid = v(data);\n    if (v.$async !== true)\n      this.errors = v.errors;\n    return valid;\n  }\n  function compile(schema, _meta) {\n    var schemaObj = this._addSchema(schema, undefined, _meta);\n    return schemaObj.validate || this._compile(schemaObj);\n  }\n  function addSchema(schema, key, _skipValidation, _meta) {\n    if (Array.isArray(schema)) {\n      for (var i = 0;i < schema.length; i++)\n        this.addSchema(schema[i], undefined, _skipValidation, _meta);\n      return this;\n    }\n    var id = this._getId(schema);\n    if (id !== undefined && typeof id != \"string\")\n      throw new Error(\"schema id must be string\");\n    key = resolve.normalizeId(key || id);\n    checkUnique(this, key);\n    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n    return this;\n  }\n  function addMetaSchema(schema, key, skipValidation) {\n    this.addSchema(schema, key, skipValidation, true);\n    return this;\n  }\n  function validateSchema(schema, throwOrLogError) {\n    var $schema = schema.$schema;\n    if ($schema !== undefined && typeof $schema != \"string\")\n      throw new Error(\"$schema must be a string\");\n    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\");\n      this.errors = null;\n      return true;\n    }\n    var valid = this.validate($schema, schema);\n    if (!valid && throwOrLogError) {\n      var message = \"schema is invalid: \" + this.errorsText();\n      if (this._opts.validateSchema == \"log\")\n        this.logger.error(message);\n      else\n        throw new Error(message);\n    }\n    return valid;\n  }\n  function defaultMeta(self2) {\n    var meta = self2._opts.meta;\n    self2._opts.defaultMeta = typeof meta == \"object\" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;\n    return self2._opts.defaultMeta;\n  }\n  function getSchema(keyRef) {\n    var schemaObj = _getSchemaObj(this, keyRef);\n    switch (typeof schemaObj) {\n      case \"object\":\n        return schemaObj.validate || this._compile(schemaObj);\n      case \"string\":\n        return this.getSchema(schemaObj);\n      case \"undefined\":\n        return _getSchemaFragment(this, keyRef);\n    }\n  }\n  function _getSchemaFragment(self2, ref) {\n    var res = resolve.schema.call(self2, { schema: {} }, ref);\n    if (res) {\n      var { schema, root: root2, baseId } = res;\n      var v = compileSchema.call(self2, schema, root2, undefined, baseId);\n      self2._fragments[ref] = new SchemaObject({\n        ref,\n        fragment: true,\n        schema,\n        root: root2,\n        baseId,\n        validate: v\n      });\n      return v;\n    }\n  }\n  function _getSchemaObj(self2, keyRef) {\n    keyRef = resolve.normalizeId(keyRef);\n    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];\n  }\n  function removeSchema(schemaKeyRef) {\n    if (schemaKeyRef instanceof RegExp) {\n      _removeAllSchemas(this, this._schemas, schemaKeyRef);\n      _removeAllSchemas(this, this._refs, schemaKeyRef);\n      return this;\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        _removeAllSchemas(this, this._schemas);\n        _removeAllSchemas(this, this._refs);\n        this._cache.clear();\n        return this;\n      case \"string\":\n        var schemaObj = _getSchemaObj(this, schemaKeyRef);\n        if (schemaObj)\n          this._cache.del(schemaObj.cacheKey);\n        delete this._schemas[schemaKeyRef];\n        delete this._refs[schemaKeyRef];\n        return this;\n      case \"object\":\n        var serialize = this._opts.serialize;\n        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n        this._cache.del(cacheKey);\n        var id = this._getId(schemaKeyRef);\n        if (id) {\n          id = resolve.normalizeId(id);\n          delete this._schemas[id];\n          delete this._refs[id];\n        }\n    }\n    return this;\n  }\n  function _removeAllSchemas(self2, schemas, regex) {\n    for (var keyRef in schemas) {\n      var schemaObj = schemas[keyRef];\n      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n        self2._cache.del(schemaObj.cacheKey);\n        delete schemas[keyRef];\n      }\n    }\n  }\n  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n    if (typeof schema != \"object\" && typeof schema != \"boolean\")\n      throw new Error(\"schema should be object or boolean\");\n    var serialize = this._opts.serialize;\n    var cacheKey = serialize ? serialize(schema) : schema;\n    var cached = this._cache.get(cacheKey);\n    if (cached)\n      return cached;\n    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n    var id = resolve.normalizeId(this._getId(schema));\n    if (id && shouldAddSchema)\n      checkUnique(this, id);\n    var willValidate = this._opts.validateSchema !== false && !skipValidation;\n    var recursiveMeta;\n    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n      this.validateSchema(schema, true);\n    var localRefs = resolve.ids.call(this, schema);\n    var schemaObj = new SchemaObject({\n      id,\n      schema,\n      localRefs,\n      cacheKey,\n      meta\n    });\n    if (id[0] != \"#\" && shouldAddSchema)\n      this._refs[id] = schemaObj;\n    this._cache.put(cacheKey, schemaObj);\n    if (willValidate && recursiveMeta)\n      this.validateSchema(schema, true);\n    return schemaObj;\n  }\n  function _compile(schemaObj, root2) {\n    if (schemaObj.compiling) {\n      schemaObj.validate = callValidate;\n      callValidate.schema = schemaObj.schema;\n      callValidate.errors = null;\n      callValidate.root = root2 ? root2 : callValidate;\n      if (schemaObj.schema.$async === true)\n        callValidate.$async = true;\n      return callValidate;\n    }\n    schemaObj.compiling = true;\n    var currentOpts;\n    if (schemaObj.meta) {\n      currentOpts = this._opts;\n      this._opts = this._metaOpts;\n    }\n    var v;\n    try {\n      v = compileSchema.call(this, schemaObj.schema, root2, schemaObj.localRefs);\n    } catch (e) {\n      delete schemaObj.validate;\n      throw e;\n    } finally {\n      schemaObj.compiling = false;\n      if (schemaObj.meta)\n        this._opts = currentOpts;\n    }\n    schemaObj.validate = v;\n    schemaObj.refs = v.refs;\n    schemaObj.refVal = v.refVal;\n    schemaObj.root = v.root;\n    return v;\n    function callValidate() {\n      var _validate = schemaObj.validate;\n      var result = _validate.apply(this, arguments);\n      callValidate.errors = _validate.errors;\n      return result;\n    }\n  }\n  function chooseGetId(opts) {\n    switch (opts.schemaId) {\n      case \"auto\":\n        return _get$IdOrId;\n      case \"id\":\n        return _getId;\n      default:\n        return _get$Id;\n    }\n  }\n  function _getId(schema) {\n    if (schema.$id)\n      this.logger.warn(\"schema $id ignored\", schema.$id);\n    return schema.id;\n  }\n  function _get$Id(schema) {\n    if (schema.id)\n      this.logger.warn(\"schema id ignored\", schema.id);\n    return schema.$id;\n  }\n  function _get$IdOrId(schema) {\n    if (schema.$id && schema.id && schema.$id != schema.id)\n      throw new Error(\"schema $id is different from id\");\n    return schema.$id || schema.id;\n  }\n  function errorsText(errors2, options) {\n    errors2 = errors2 || this.errors;\n    if (!errors2)\n      return \"No errors\";\n    options = options || {};\n    var separator = options.separator === undefined ? \", \" : options.separator;\n    var dataVar = options.dataVar === undefined ? \"data\" : options.dataVar;\n    var text = \"\";\n    for (var i = 0;i < errors2.length; i++) {\n      var e = errors2[i];\n      if (e)\n        text += dataVar + e.dataPath + \" \" + e.message + separator;\n    }\n    return text.slice(0, -separator.length);\n  }\n  function addFormat(name, format) {\n    if (typeof format == \"string\")\n      format = new RegExp(format);\n    this._formats[name] = format;\n    return this;\n  }\n  function addDefaultMetaSchema(self2) {\n    var $dataSchema;\n    if (self2._opts.$data) {\n      $dataSchema = require_data2();\n      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);\n    }\n    if (self2._opts.meta === false)\n      return;\n    var metaSchema = require_json_schema_draft_07();\n    if (self2._opts.$data)\n      metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n    self2._refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID;\n  }\n  function addInitialSchemas(self2) {\n    var optsSchemas = self2._opts.schemas;\n    if (!optsSchemas)\n      return;\n    if (Array.isArray(optsSchemas))\n      self2.addSchema(optsSchemas);\n    else\n      for (var key in optsSchemas)\n        self2.addSchema(optsSchemas[key], key);\n  }\n  function addInitialFormats(self2) {\n    for (var name in self2._opts.formats) {\n      var format = self2._opts.formats[name];\n      self2.addFormat(name, format);\n    }\n  }\n  function addInitialKeywords(self2) {\n    for (var name in self2._opts.keywords) {\n      var keyword = self2._opts.keywords[name];\n      self2.addKeyword(name, keyword);\n    }\n  }\n  function checkUnique(self2, id) {\n    if (self2._schemas[id] || self2._refs[id])\n      throw new Error('schema with key or id \"' + id + '\" already exists');\n  }\n  function getMetaSchemaOptions(self2) {\n    var metaOpts = util3.copy(self2._opts);\n    for (var i = 0;i < META_IGNORE_OPTIONS.length; i++)\n      delete metaOpts[META_IGNORE_OPTIONS[i]];\n    return metaOpts;\n  }\n  function setLogger(self2) {\n    var logger = self2._opts.logger;\n    if (logger === false) {\n      self2.logger = { log: noop, warn: noop, error: noop };\n    } else {\n      if (logger === undefined)\n        logger = console;\n      if (!(typeof logger == \"object\" && logger.log && logger.warn && logger.error))\n        throw new Error(\"logger must implement log, warn and error methods\");\n      self2.logger = logger;\n    }\n  }\n  function noop() {}\n});\n\n// ../src/entrypoints/agentSdk.ts\n\n\n\n// ../src/utils/abortController.ts\n\nvar DEFAULT_MAX_LISTENERS = 50;\nfunction createAbortController(maxListeners = DEFAULT_MAX_LISTENERS) {\n  const controller = new AbortController;\n  (0,events__WEBPACK_IMPORTED_MODULE_2__.setMaxListeners)(maxListeners, controller.signal);\n  return controller;\n}\n\n// ../src/transport/ProcessTransport.ts\n\n\n\n// ../src/utils/fsOperations.ts\n\n\nvar NodeFsOperations = {\n  cwd() {\n    return process.cwd();\n  },\n  existsSync(fsPath) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.existsSync(fsPath);\n  },\n  async stat(fsPath) {\n    return (0,fs_promises__WEBPACK_IMPORTED_MODULE_6__.stat)(fsPath);\n  },\n  statSync(fsPath) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.statSync(fsPath);\n  },\n  readFileSync(fsPath, options) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.readFileSync(fsPath, { encoding: options.encoding });\n  },\n  readFileBytesSync(fsPath) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.readFileSync(fsPath);\n  },\n  readSync(fsPath, options) {\n    let fd = undefined;\n    try {\n      fd = fs__WEBPACK_IMPORTED_MODULE_5__.openSync(fsPath, \"r\");\n      const buffer = Buffer.alloc(options.length);\n      const bytesRead = fs__WEBPACK_IMPORTED_MODULE_5__.readSync(fd, buffer, 0, options.length, 0);\n      return { buffer, bytesRead };\n    } finally {\n      if (fd)\n        fs__WEBPACK_IMPORTED_MODULE_5__.closeSync(fd);\n    }\n  },\n  writeFileSync(fsPath, data, options) {\n    if (!options.flush) {\n      const writeOptions = {\n        encoding: options.encoding\n      };\n      if (options.mode !== undefined) {\n        writeOptions.mode = options.mode;\n      }\n      fs__WEBPACK_IMPORTED_MODULE_5__.writeFileSync(fsPath, data, writeOptions);\n      return;\n    }\n    let fd;\n    try {\n      const mode = options.mode !== undefined ? options.mode : undefined;\n      fd = fs__WEBPACK_IMPORTED_MODULE_5__.openSync(fsPath, \"w\", mode);\n      fs__WEBPACK_IMPORTED_MODULE_5__.writeFileSync(fd, data, { encoding: options.encoding });\n      fs__WEBPACK_IMPORTED_MODULE_5__.fsyncSync(fd);\n    } finally {\n      if (fd) {\n        fs__WEBPACK_IMPORTED_MODULE_5__.closeSync(fd);\n      }\n    }\n  },\n  appendFileSync(path, data) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.appendFileSync(path, data);\n  },\n  copyFileSync(src, dest) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.copyFileSync(src, dest);\n  },\n  unlinkSync(path) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.unlinkSync(path);\n  },\n  renameSync(oldPath, newPath) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.renameSync(oldPath, newPath);\n  },\n  linkSync(target, path) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.linkSync(target, path);\n  },\n  symlinkSync(target, path) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.symlinkSync(target, path);\n  },\n  readlinkSync(path) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.readlinkSync(path);\n  },\n  realpathSync(path) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.realpathSync(path);\n  },\n  mkdirSync(dirPath) {\n    if (!fs__WEBPACK_IMPORTED_MODULE_5__.existsSync(dirPath)) {\n      fs__WEBPACK_IMPORTED_MODULE_5__.mkdirSync(dirPath, { recursive: true, mode: 448 });\n    }\n  },\n  readdirSync(dirPath) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.readdirSync(dirPath, { withFileTypes: true });\n  },\n  readdirStringSync(dirPath) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.readdirSync(dirPath);\n  },\n  isDirEmptySync(dirPath) {\n    const files = this.readdirSync(dirPath);\n    return files.length === 0;\n  },\n  rmdirSync(dirPath) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.rmdirSync(dirPath);\n  },\n  rmSync(path, options) {\n    fs__WEBPACK_IMPORTED_MODULE_5__.rmSync(path, options);\n  },\n  createWriteStream(path) {\n    return fs__WEBPACK_IMPORTED_MODULE_5__.createWriteStream(path);\n  }\n};\nvar activeFs = NodeFsOperations;\nfunction getFsImplementation() {\n  return activeFs;\n}\n\n// ../src/entrypoints/sdkTypes.ts\nclass AbortError extends Error {\n}\n\n// ../src/utils/bundledMode.ts\nfunction isRunningWithBun() {\n  return process.versions.bun !== undefined;\n}\n\n// ../src/transport/ProcessTransport.ts\nclass ProcessTransport {\n  options;\n  child;\n  childStdin;\n  childStdout;\n  ready = false;\n  abortController;\n  exitError;\n  exitListeners = [];\n  processExitHandler;\n  abortHandler;\n  constructor(options) {\n    this.options = options;\n    this.abortController = options.abortController || createAbortController();\n    this.initialize();\n  }\n  initialize() {\n    try {\n      const {\n        additionalDirectories = [],\n        agents,\n        cwd,\n        executable = isRunningWithBun() ? \"bun\" : \"node\",\n        executableArgs = [],\n        extraArgs = {},\n        pathToClaudeCodeExecutable,\n        env = { ...process.env },\n        stderr,\n        customSystemPrompt,\n        appendSystemPrompt,\n        maxThinkingTokens,\n        maxTurns,\n        model,\n        fallbackModel,\n        permissionMode,\n        permissionPromptToolName,\n        continueConversation,\n        resume,\n        settingSources,\n        allowedTools = [],\n        disallowedTools = [],\n        mcpServers,\n        strictMcpConfig,\n        canUseTool,\n        includePartialMessages\n      } = this.options;\n      const args = [\n        \"--output-format\",\n        \"stream-json\",\n        \"--verbose\",\n        \"--input-format\",\n        \"stream-json\"\n      ];\n      if (typeof customSystemPrompt === \"string\")\n        args.push(\"--system-prompt\", customSystemPrompt);\n      if (appendSystemPrompt)\n        args.push(\"--append-system-prompt\", appendSystemPrompt);\n      if (maxThinkingTokens !== undefined) {\n        args.push(\"--max-thinking-tokens\", maxThinkingTokens.toString());\n      }\n      if (maxTurns)\n        args.push(\"--max-turns\", maxTurns.toString());\n      if (model)\n        args.push(\"--model\", model);\n      if (env.DEBUG)\n        args.push(\"--debug-to-stderr\");\n      if (canUseTool) {\n        if (permissionPromptToolName) {\n          throw new Error(\"canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.\");\n        }\n        args.push(\"--permission-prompt-tool\", \"stdio\");\n      } else if (permissionPromptToolName) {\n        args.push(\"--permission-prompt-tool\", permissionPromptToolName);\n      }\n      if (continueConversation)\n        args.push(\"--continue\");\n      if (resume)\n        args.push(\"--resume\", resume);\n      if (allowedTools.length > 0) {\n        args.push(\"--allowedTools\", allowedTools.join(\",\"));\n      }\n      if (disallowedTools.length > 0) {\n        args.push(\"--disallowedTools\", disallowedTools.join(\",\"));\n      }\n      if (mcpServers && Object.keys(mcpServers).length > 0) {\n        args.push(\"--mcp-config\", JSON.stringify({ mcpServers }));\n      }\n      if (agents && Object.keys(agents).length > 0) {\n        args.push(\"--agents\", JSON.stringify(agents));\n      }\n      if (settingSources) {\n        args.push(\"--setting-sources\", settingSources.join(\",\"));\n      }\n      if (strictMcpConfig) {\n        args.push(\"--strict-mcp-config\");\n      }\n      if (permissionMode) {\n        args.push(\"--permission-mode\", permissionMode);\n      }\n      if (fallbackModel) {\n        if (model && fallbackModel === model) {\n          throw new Error(\"Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.\");\n        }\n        args.push(\"--fallback-model\", fallbackModel);\n      }\n      if (includePartialMessages) {\n        args.push(\"--include-partial-messages\");\n      }\n      for (const dir of additionalDirectories) {\n        args.push(\"--add-dir\", dir);\n      }\n      if (this.options.forkSession) {\n        args.push(\"--fork-session\");\n      }\n      if (this.options.resumeSessionAt) {\n        args.push(\"--resume-session-at\", this.options.resumeSessionAt);\n      }\n      for (const [flag, value] of Object.entries(extraArgs)) {\n        if (value === null) {\n          args.push(`--${flag}`);\n        } else {\n          args.push(`--${flag}`, value);\n        }\n      }\n      if (!env.CLAUDE_CODE_ENTRYPOINT) {\n        env.CLAUDE_CODE_ENTRYPOINT = \"sdk-ts\";\n      }\n      const fs2 = getFsImplementation();\n      if (!fs2.existsSync(pathToClaudeCodeExecutable)) {\n        const errorMessage = isNativeBinary(pathToClaudeCodeExecutable) ? `Claude Code native binary not found at ${pathToClaudeCodeExecutable}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${pathToClaudeCodeExecutable}. Is options.pathToClaudeCodeExecutable set?`;\n        throw new ReferenceError(errorMessage);\n      }\n      const isNative = isNativeBinary(pathToClaudeCodeExecutable);\n      const spawnCommand = isNative ? pathToClaudeCodeExecutable : executable;\n      const spawnArgs = isNative ? args : [...executableArgs, pathToClaudeCodeExecutable, ...args];\n      this.logForDebugging(isNative ? `Spawning Claude Code native binary: ${pathToClaudeCodeExecutable} ${args.join(\" \")}` : `Spawning Claude Code process: ${executable} ${[...executableArgs, pathToClaudeCodeExecutable, ...args].join(\" \")}`);\n      const stderrMode = env.DEBUG || stderr ? \"pipe\" : \"ignore\";\n      this.child = (0,child_process__WEBPACK_IMPORTED_MODULE_3__.spawn)(spawnCommand, spawnArgs, {\n        cwd,\n        stdio: [\"pipe\", \"pipe\", stderrMode],\n        signal: this.abortController.signal,\n        env\n      });\n      this.childStdin = this.child.stdin;\n      this.childStdout = this.child.stdout;\n      if (env.DEBUG || stderr) {\n        this.child.stderr.on(\"data\", (data) => {\n          this.logForDebugging(data.toString());\n        });\n      }\n      const cleanup = () => {\n        if (this.child && !this.child.killed) {\n          this.child.kill(\"SIGTERM\");\n        }\n      };\n      this.processExitHandler = cleanup;\n      this.abortHandler = cleanup;\n      process.on(\"exit\", this.processExitHandler);\n      this.abortController.signal.addEventListener(\"abort\", this.abortHandler);\n      this.child.on(\"error\", (error) => {\n        this.ready = false;\n        if (this.abortController.signal.aborted) {\n          this.exitError = new AbortError(\"Claude Code process aborted by user\");\n        } else {\n          this.exitError = new Error(`Failed to spawn Claude Code process: ${error.message}`);\n          this.logForDebugging(this.exitError.message);\n        }\n      });\n      this.child.on(\"close\", (code, signal) => {\n        this.ready = false;\n        if (this.abortController.signal.aborted) {\n          this.exitError = new AbortError(\"Claude Code process aborted by user\");\n        } else {\n          const error = this.getProcessExitError(code, signal);\n          if (error) {\n            this.exitError = error;\n            this.logForDebugging(error.message);\n          }\n        }\n      });\n      this.ready = true;\n    } catch (error) {\n      this.ready = false;\n      throw error;\n    }\n  }\n  getProcessExitError(code, signal) {\n    if (code !== 0 && code !== null) {\n      return new Error(`Claude Code process exited with code ${code}`);\n    } else if (signal) {\n      return new Error(`Claude Code process terminated by signal ${signal}`);\n    }\n    return;\n  }\n  logForDebugging(message) {\n    if (process.env.DEBUG) {\n      process.stderr.write(`${message}\n`);\n    }\n    if (this.options.stderr) {\n      this.options.stderr(message);\n    }\n  }\n  write(data) {\n    if (this.abortController.signal.aborted) {\n      throw new AbortError(\"Operation aborted\");\n    }\n    if (!this.ready || !this.childStdin) {\n      throw new Error(\"ProcessTransport is not ready for writing\");\n    }\n    if (this.child?.killed || this.child?.exitCode !== null) {\n      throw new Error(\"Cannot write to terminated process\");\n    }\n    if (this.exitError) {\n      throw new Error(`Cannot write to process that exited with error: ${this.exitError.message}`);\n    }\n    if (process.env.DEBUG_SDK) {\n      process.stderr.write(`[ProcessTransport] Writing to stdin: ${data.substring(0, 100)}\n`);\n    }\n    try {\n      const written = this.childStdin.write(data);\n      if (!written && process.env.DEBUG_SDK) {\n        console.warn(\"[ProcessTransport] Write buffer full, data queued\");\n      }\n    } catch (error) {\n      this.ready = false;\n      throw new Error(`Failed to write to process stdin: ${error.message}`);\n    }\n  }\n  close() {\n    if (this.childStdin) {\n      this.childStdin.end();\n      this.childStdin = undefined;\n    }\n    if (this.processExitHandler) {\n      process.off(\"exit\", this.processExitHandler);\n      this.processExitHandler = undefined;\n    }\n    if (this.abortHandler) {\n      this.abortController.signal.removeEventListener(\"abort\", this.abortHandler);\n      this.abortHandler = undefined;\n    }\n    for (const { handler } of this.exitListeners) {\n      this.child?.off(\"exit\", handler);\n    }\n    this.exitListeners = [];\n    if (this.child && !this.child.killed) {\n      this.child.kill(\"SIGTERM\");\n      setTimeout(() => {\n        if (this.child && !this.child.killed) {\n          this.child.kill(\"SIGKILL\");\n        }\n      }, 5000);\n    }\n    this.ready = false;\n  }\n  isReady() {\n    return this.ready;\n  }\n  async* readMessages() {\n    if (!this.childStdout) {\n      throw new Error(\"ProcessTransport output stream not available\");\n    }\n    const rl = (0,readline__WEBPACK_IMPORTED_MODULE_4__.createInterface)({ input: this.childStdout });\n    try {\n      for await (const line of rl) {\n        if (line.trim()) {\n          const message = JSON.parse(line);\n          yield message;\n        }\n      }\n      await this.waitForExit();\n    } catch (error) {\n      throw error;\n    } finally {\n      rl.close();\n    }\n  }\n  endInput() {\n    if (this.childStdin) {\n      this.childStdin.end();\n    }\n  }\n  getInputStream() {\n    return this.childStdin;\n  }\n  onExit(callback) {\n    if (!this.child)\n      return () => {};\n    const handler = (code, signal) => {\n      const error = this.getProcessExitError(code, signal);\n      callback(error);\n    };\n    this.child.on(\"exit\", handler);\n    this.exitListeners.push({ callback, handler });\n    return () => {\n      if (this.child) {\n        this.child.off(\"exit\", handler);\n      }\n      const index = this.exitListeners.findIndex((l) => l.handler === handler);\n      if (index !== -1) {\n        this.exitListeners.splice(index, 1);\n      }\n    };\n  }\n  async waitForExit() {\n    if (!this.child) {\n      if (this.exitError) {\n        throw this.exitError;\n      }\n      return;\n    }\n    if (this.child.exitCode !== null || this.child.killed) {\n      if (this.exitError) {\n        throw this.exitError;\n      }\n      return;\n    }\n    return new Promise((resolve, reject) => {\n      const exitHandler = (code, signal) => {\n        if (this.abortController.signal.aborted) {\n          reject(new AbortError(\"Operation aborted\"));\n          return;\n        }\n        const error = this.getProcessExitError(code, signal);\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n      this.child.once(\"exit\", exitHandler);\n      const errorHandler = (error) => {\n        this.child.off(\"exit\", exitHandler);\n        reject(error);\n      };\n      this.child.once(\"error\", errorHandler);\n      this.child.once(\"exit\", () => {\n        this.child.off(\"error\", errorHandler);\n      });\n    });\n  }\n}\nfunction isNativeBinary(executablePath) {\n  const jsExtensions = [\".js\", \".mjs\", \".tsx\", \".ts\", \".jsx\"];\n  return !jsExtensions.some((ext) => executablePath.endsWith(ext));\n}\n\n// ../src/utils/stream.ts\nclass Stream {\n  returned;\n  queue = [];\n  readResolve;\n  readReject;\n  isDone = false;\n  hasError;\n  started = false;\n  constructor(returned) {\n    this.returned = returned;\n  }\n  [Symbol.asyncIterator]() {\n    if (this.started) {\n      throw new Error(\"Stream can only be iterated once\");\n    }\n    this.started = true;\n    return this;\n  }\n  next() {\n    if (this.queue.length > 0) {\n      return Promise.resolve({\n        done: false,\n        value: this.queue.shift()\n      });\n    }\n    if (this.isDone) {\n      return Promise.resolve({ done: true, value: undefined });\n    }\n    if (this.hasError) {\n      return Promise.reject(this.hasError);\n    }\n    return new Promise((resolve, reject) => {\n      this.readResolve = resolve;\n      this.readReject = reject;\n    });\n  }\n  enqueue(value) {\n    if (this.readResolve) {\n      const resolve = this.readResolve;\n      this.readResolve = undefined;\n      this.readReject = undefined;\n      resolve({ done: false, value });\n    } else {\n      this.queue.push(value);\n    }\n  }\n  done() {\n    this.isDone = true;\n    if (this.readResolve) {\n      const resolve = this.readResolve;\n      this.readResolve = undefined;\n      this.readReject = undefined;\n      resolve({ done: true, value: undefined });\n    }\n  }\n  error(error) {\n    this.hasError = error;\n    if (this.readReject) {\n      const reject = this.readReject;\n      this.readResolve = undefined;\n      this.readReject = undefined;\n      reject(error);\n    }\n  }\n  return() {\n    this.isDone = true;\n    if (this.returned) {\n      this.returned();\n    }\n    return Promise.resolve({ done: true, value: undefined });\n  }\n}\n\n// ../src/services/mcp/SdkControlTransport.ts\nclass SdkControlServerTransport {\n  sendMcpMessage;\n  isClosed = false;\n  constructor(sendMcpMessage) {\n    this.sendMcpMessage = sendMcpMessage;\n  }\n  onclose;\n  onerror;\n  onmessage;\n  async start() {}\n  async send(message) {\n    if (this.isClosed) {\n      throw new Error(\"Transport is closed\");\n    }\n    this.sendMcpMessage(message);\n  }\n  async close() {\n    if (this.isClosed) {\n      return;\n    }\n    this.isClosed = true;\n    this.onclose?.();\n  }\n}\n\n// ../node_modules/lodash-es/_freeGlobal.js\nvar freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\nvar _freeGlobal_default = freeGlobal;\n\n// ../node_modules/lodash-es/_root.js\nvar freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\nvar root = _freeGlobal_default || freeSelf || Function(\"return this\")();\nvar _root_default = root;\n\n// ../node_modules/lodash-es/_Symbol.js\nvar Symbol2 = _root_default.Symbol;\nvar _Symbol_default = Symbol2;\n\n// ../node_modules/lodash-es/_getRawTag.js\nvar objectProto = Object.prototype;\nvar hasOwnProperty = objectProto.hasOwnProperty;\nvar nativeObjectToString = objectProto.toString;\nvar symToStringTag = _Symbol_default ? _Symbol_default.toStringTag : undefined;\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\nvar _getRawTag_default = getRawTag;\n\n// ../node_modules/lodash-es/_objectToString.js\nvar objectProto2 = Object.prototype;\nvar nativeObjectToString2 = objectProto2.toString;\nfunction objectToString(value) {\n  return nativeObjectToString2.call(value);\n}\nvar _objectToString_default = objectToString;\n\n// ../node_modules/lodash-es/_baseGetTag.js\nvar nullTag = \"[object Null]\";\nvar undefinedTag = \"[object Undefined]\";\nvar symToStringTag2 = _Symbol_default ? _Symbol_default.toStringTag : undefined;\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return symToStringTag2 && symToStringTag2 in Object(value) ? _getRawTag_default(value) : _objectToString_default(value);\n}\nvar _baseGetTag_default = baseGetTag;\n\n// ../node_modules/lodash-es/isObject.js\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == \"object\" || type == \"function\");\n}\nvar isObject_default = isObject;\n\n// ../node_modules/lodash-es/isFunction.js\nvar asyncTag = \"[object AsyncFunction]\";\nvar funcTag = \"[object Function]\";\nvar genTag = \"[object GeneratorFunction]\";\nvar proxyTag = \"[object Proxy]\";\nfunction isFunction(value) {\n  if (!isObject_default(value)) {\n    return false;\n  }\n  var tag = _baseGetTag_default(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\nvar isFunction_default = isFunction;\n\n// ../node_modules/lodash-es/_coreJsData.js\nvar coreJsData = _root_default[\"__core-js_shared__\"];\nvar _coreJsData_default = coreJsData;\n\n// ../node_modules/lodash-es/_isMasked.js\nvar maskSrcKey = function() {\n  var uid = /[^.]+$/.exec(_coreJsData_default && _coreJsData_default.keys && _coreJsData_default.keys.IE_PROTO || \"\");\n  return uid ? \"Symbol(src)_1.\" + uid : \"\";\n}();\nfunction isMasked(func) {\n  return !!maskSrcKey && maskSrcKey in func;\n}\nvar _isMasked_default = isMasked;\n\n// ../node_modules/lodash-es/_toSource.js\nvar funcProto = Function.prototype;\nvar funcToString = funcProto.toString;\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return func + \"\";\n    } catch (e) {}\n  }\n  return \"\";\n}\nvar _toSource_default = toSource;\n\n// ../node_modules/lodash-es/_baseIsNative.js\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\nvar funcProto2 = Function.prototype;\nvar objectProto3 = Object.prototype;\nvar funcToString2 = funcProto2.toString;\nvar hasOwnProperty2 = objectProto3.hasOwnProperty;\nvar reIsNative = RegExp(\"^\" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\nfunction baseIsNative(value) {\n  if (!isObject_default(value) || _isMasked_default(value)) {\n    return false;\n  }\n  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(_toSource_default(value));\n}\nvar _baseIsNative_default = baseIsNative;\n\n// ../node_modules/lodash-es/_getValue.js\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\nvar _getValue_default = getValue;\n\n// ../node_modules/lodash-es/_getNative.js\nfunction getNative(object, key) {\n  var value = _getValue_default(object, key);\n  return _baseIsNative_default(value) ? value : undefined;\n}\nvar _getNative_default = getNative;\n\n// ../node_modules/lodash-es/eq.js\nfunction eq(value, other) {\n  return value === other || value !== value && other !== other;\n}\nvar eq_default = eq;\n\n// ../node_modules/lodash-es/_nativeCreate.js\nvar nativeCreate = _getNative_default(Object, \"create\");\nvar _nativeCreate_default = nativeCreate;\n\n// ../node_modules/lodash-es/_hashClear.js\nfunction hashClear() {\n  this.__data__ = _nativeCreate_default ? _nativeCreate_default(null) : {};\n  this.size = 0;\n}\nvar _hashClear_default = hashClear;\n\n// ../node_modules/lodash-es/_hashDelete.js\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _hashDelete_default = hashDelete;\n\n// ../node_modules/lodash-es/_hashGet.js\nvar HASH_UNDEFINED = \"__lodash_hash_undefined__\";\nvar objectProto4 = Object.prototype;\nvar hasOwnProperty3 = objectProto4.hasOwnProperty;\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (_nativeCreate_default) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty3.call(data, key) ? data[key] : undefined;\n}\nvar _hashGet_default = hashGet;\n\n// ../node_modules/lodash-es/_hashHas.js\nvar objectProto5 = Object.prototype;\nvar hasOwnProperty4 = objectProto5.hasOwnProperty;\nfunction hashHas(key) {\n  var data = this.__data__;\n  return _nativeCreate_default ? data[key] !== undefined : hasOwnProperty4.call(data, key);\n}\nvar _hashHas_default = hashHas;\n\n// ../node_modules/lodash-es/_hashSet.js\nvar HASH_UNDEFINED2 = \"__lodash_hash_undefined__\";\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = _nativeCreate_default && value === undefined ? HASH_UNDEFINED2 : value;\n  return this;\n}\nvar _hashSet_default = hashSet;\n\n// ../node_modules/lodash-es/_Hash.js\nfunction Hash(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nHash.prototype.clear = _hashClear_default;\nHash.prototype[\"delete\"] = _hashDelete_default;\nHash.prototype.get = _hashGet_default;\nHash.prototype.has = _hashHas_default;\nHash.prototype.set = _hashSet_default;\nvar _Hash_default = Hash;\n\n// ../node_modules/lodash-es/_listCacheClear.js\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\nvar _listCacheClear_default = listCacheClear;\n\n// ../node_modules/lodash-es/_assocIndexOf.js\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq_default(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\nvar _assocIndexOf_default = assocIndexOf;\n\n// ../node_modules/lodash-es/_listCacheDelete.js\nvar arrayProto = Array.prototype;\nvar splice = arrayProto.splice;\nfunction listCacheDelete(key) {\n  var data = this.__data__, index = _assocIndexOf_default(data, key);\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\nvar _listCacheDelete_default = listCacheDelete;\n\n// ../node_modules/lodash-es/_listCacheGet.js\nfunction listCacheGet(key) {\n  var data = this.__data__, index = _assocIndexOf_default(data, key);\n  return index < 0 ? undefined : data[index][1];\n}\nvar _listCacheGet_default = listCacheGet;\n\n// ../node_modules/lodash-es/_listCacheHas.js\nfunction listCacheHas(key) {\n  return _assocIndexOf_default(this.__data__, key) > -1;\n}\nvar _listCacheHas_default = listCacheHas;\n\n// ../node_modules/lodash-es/_listCacheSet.js\nfunction listCacheSet(key, value) {\n  var data = this.__data__, index = _assocIndexOf_default(data, key);\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\nvar _listCacheSet_default = listCacheSet;\n\n// ../node_modules/lodash-es/_ListCache.js\nfunction ListCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nListCache.prototype.clear = _listCacheClear_default;\nListCache.prototype[\"delete\"] = _listCacheDelete_default;\nListCache.prototype.get = _listCacheGet_default;\nListCache.prototype.has = _listCacheHas_default;\nListCache.prototype.set = _listCacheSet_default;\nvar _ListCache_default = ListCache;\n\n// ../node_modules/lodash-es/_Map.js\nvar Map2 = _getNative_default(_root_default, \"Map\");\nvar _Map_default = Map2;\n\n// ../node_modules/lodash-es/_mapCacheClear.js\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    hash: new _Hash_default,\n    map: new (_Map_default || _ListCache_default),\n    string: new _Hash_default\n  };\n}\nvar _mapCacheClear_default = mapCacheClear;\n\n// ../node_modules/lodash-es/_isKeyable.js\nfunction isKeyable(value) {\n  var type = typeof value;\n  return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n}\nvar _isKeyable_default = isKeyable;\n\n// ../node_modules/lodash-es/_getMapData.js\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return _isKeyable_default(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n}\nvar _getMapData_default = getMapData;\n\n// ../node_modules/lodash-es/_mapCacheDelete.js\nfunction mapCacheDelete(key) {\n  var result = _getMapData_default(this, key)[\"delete\"](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\nvar _mapCacheDelete_default = mapCacheDelete;\n\n// ../node_modules/lodash-es/_mapCacheGet.js\nfunction mapCacheGet(key) {\n  return _getMapData_default(this, key).get(key);\n}\nvar _mapCacheGet_default = mapCacheGet;\n\n// ../node_modules/lodash-es/_mapCacheHas.js\nfunction mapCacheHas(key) {\n  return _getMapData_default(this, key).has(key);\n}\nvar _mapCacheHas_default = mapCacheHas;\n\n// ../node_modules/lodash-es/_mapCacheSet.js\nfunction mapCacheSet(key, value) {\n  var data = _getMapData_default(this, key), size = data.size;\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\nvar _mapCacheSet_default = mapCacheSet;\n\n// ../node_modules/lodash-es/_MapCache.js\nfunction MapCache(entries) {\n  var index = -1, length = entries == null ? 0 : entries.length;\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\nMapCache.prototype.clear = _mapCacheClear_default;\nMapCache.prototype[\"delete\"] = _mapCacheDelete_default;\nMapCache.prototype.get = _mapCacheGet_default;\nMapCache.prototype.has = _mapCacheHas_default;\nMapCache.prototype.set = _mapCacheSet_default;\nvar _MapCache_default = MapCache;\n\n// ../node_modules/lodash-es/memoize.js\nvar FUNC_ERROR_TEXT = \"Expected a function\";\nfunction memoize(func, resolver) {\n  if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || _MapCache_default);\n  return memoized;\n}\nmemoize.Cache = _MapCache_default;\nvar memoize_default = memoize;\n// ../src/utils/process.ts\nvar CHUNK_SIZE = 2000;\nfunction writeToStderr(data) {\n  for (let i = 0;i < data.length; i += CHUNK_SIZE) {\n    process.stderr.write(data.substring(i, i + CHUNK_SIZE));\n  }\n}\n\n// ../src/utils/debugFilter.ts\nvar parseDebugFilter = memoize_default((filterString) => {\n  if (!filterString || filterString.trim() === \"\") {\n    return null;\n  }\n  const filters = filterString.split(\",\").map((f) => f.trim()).filter(Boolean);\n  if (filters.length === 0) {\n    return null;\n  }\n  const hasExclusive = filters.some((f) => f.startsWith(\"!\"));\n  const hasInclusive = filters.some((f) => !f.startsWith(\"!\"));\n  if (hasExclusive && hasInclusive) {\n    return null;\n  }\n  const cleanFilters = filters.map((f) => f.replace(/^!/, \"\").toLowerCase());\n  return {\n    include: hasExclusive ? [] : cleanFilters,\n    exclude: hasExclusive ? cleanFilters : [],\n    isExclusive: hasExclusive\n  };\n});\nfunction extractDebugCategories(message) {\n  const categories = [];\n  const mcpMatch = message.match(/^MCP server [\"']([^\"']+)[\"']/);\n  if (mcpMatch && mcpMatch[1]) {\n    categories.push(\"mcp\");\n    categories.push(mcpMatch[1].toLowerCase());\n  } else {\n    const prefixMatch = message.match(/^([^:[]+):/);\n    if (prefixMatch && prefixMatch[1]) {\n      categories.push(prefixMatch[1].trim().toLowerCase());\n    }\n  }\n  const bracketMatch = message.match(/^\\[([^\\]]+)]/);\n  if (bracketMatch && bracketMatch[1]) {\n    categories.push(bracketMatch[1].trim().toLowerCase());\n  }\n  if (message.toLowerCase().includes(\"statsig event:\")) {\n    categories.push(\"statsig\");\n  }\n  const secondaryMatch = message.match(/:\\s*([^:]+?)(?:\\s+(?:type|mode|status|event))?:/);\n  if (secondaryMatch && secondaryMatch[1]) {\n    const secondary = secondaryMatch[1].trim().toLowerCase();\n    if (secondary.length < 30 && !secondary.includes(\" \")) {\n      categories.push(secondary);\n    }\n  }\n  return Array.from(new Set(categories));\n}\nfunction shouldShowDebugCategories(categories, filter) {\n  if (!filter) {\n    return true;\n  }\n  if (categories.length === 0) {\n    return false;\n  }\n  if (filter.isExclusive) {\n    return !categories.some((cat) => filter.exclude.includes(cat));\n  } else {\n    return categories.some((cat) => filter.include.includes(cat));\n  }\n}\nfunction shouldShowDebugMessage(message, filter) {\n  if (!filter) {\n    return true;\n  }\n  const categories = extractDebugCategories(message);\n  return shouldShowDebugCategories(categories, filter);\n}\n\n// ../src/utils/envUtils.ts\n\n\nfunction getClaudeConfigHomeDir() {\n  return process.env.CLAUDE_CONFIG_DIR ?? (0,path__WEBPACK_IMPORTED_MODULE_0__.join)((0,os__WEBPACK_IMPORTED_MODULE_7__.homedir)(), \".claude\");\n}\nfunction isEnvTruthy(envVar) {\n  if (!envVar)\n    return false;\n  if (typeof envVar === \"boolean\")\n    return envVar;\n  const normalizedValue = envVar.toLowerCase().trim();\n  return [\"1\", \"true\", \"yes\", \"on\"].includes(normalizedValue);\n}\n\n// ../src/utils/debug.ts\n\n\n// ../src/bootstrap/state.ts\n\n\n\n// ../src/bootstrap/envValidators.ts\nvar bashMaxOutputLengthValidator = {\n  name: \"BASH_MAX_OUTPUT_LENGTH\",\n  default: 30000,\n  validate: (value) => {\n    const MAX_OUTPUT_LENGTH = 150000;\n    const DEFAULT_MAX_OUTPUT_LENGTH = 30000;\n    if (!value) {\n      return {\n        effective: DEFAULT_MAX_OUTPUT_LENGTH,\n        status: \"valid\"\n      };\n    }\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed) || parsed <= 0) {\n      return {\n        effective: DEFAULT_MAX_OUTPUT_LENGTH,\n        status: \"invalid\",\n        message: `Invalid value \"${value}\" (using default: ${DEFAULT_MAX_OUTPUT_LENGTH})`\n      };\n    }\n    if (parsed > MAX_OUTPUT_LENGTH) {\n      return {\n        effective: MAX_OUTPUT_LENGTH,\n        status: \"capped\",\n        message: `Capped from ${parsed} to ${MAX_OUTPUT_LENGTH}`\n      };\n    }\n    return { effective: parsed, status: \"valid\" };\n  }\n};\nvar maxOutputTokensValidator = {\n  name: \"CLAUDE_CODE_MAX_OUTPUT_TOKENS\",\n  default: 32000,\n  validate: (value) => {\n    if (!value) {\n      return { effective: 32000, status: \"valid\" };\n    }\n    const parsed = parseInt(value, 10);\n    if (isNaN(parsed) || parsed <= 0) {\n      return {\n        effective: 32000,\n        status: \"invalid\",\n        message: `Invalid value \"${value}\" (using default: 32000)`\n      };\n    }\n    if (parsed > 32000) {\n      return {\n        effective: 32000,\n        status: \"capped\",\n        message: `Capped from ${parsed} to 32000`\n      };\n    }\n    return { effective: parsed, status: \"valid\" };\n  }\n};\n\n// ../src/bootstrap/state.ts\nfunction getInitialState() {\n  return {\n    originalCwd: (0,process__WEBPACK_IMPORTED_MODULE_8__.cwd)(),\n    totalCostUSD: 0,\n    totalAPIDuration: 0,\n    totalAPIDurationWithoutRetries: 0,\n    totalToolDuration: 0,\n    startTime: Date.now(),\n    lastInteractionTime: Date.now(),\n    totalLinesAdded: 0,\n    totalLinesRemoved: 0,\n    hasUnknownModelCost: false,\n    cwd: (0,process__WEBPACK_IMPORTED_MODULE_8__.cwd)(),\n    modelUsage: {},\n    mainLoopModelOverride: undefined,\n    maxRateLimitFallbackActive: false,\n    initialMainLoopModel: null,\n    modelStrings: null,\n    isNonInteractiveSession: true,\n    isInteractive: false,\n    clientType: \"cli\",\n    sessionIngressToken: undefined,\n    oauthTokenFromFd: undefined,\n    apiKeyFromFd: undefined,\n    flagSettingsPath: undefined,\n    allowedSettingSources: [\n      \"userSettings\",\n      \"projectSettings\",\n      \"localSettings\",\n      \"flagSettings\",\n      \"policySettings\"\n    ],\n    meter: null,\n    sessionCounter: null,\n    locCounter: null,\n    prCounter: null,\n    commitCounter: null,\n    costCounter: null,\n    tokenCounter: null,\n    codeEditToolDecisionCounter: null,\n    activeTimeCounter: null,\n    sessionId: (0,crypto__WEBPACK_IMPORTED_MODULE_9__.randomUUID)(),\n    loggerProvider: null,\n    eventLogger: null,\n    meterProvider: null,\n    agentColorMap: new Map,\n    agentColorIndex: 0,\n    envVarValidators: [bashMaxOutputLengthValidator, maxOutputTokensValidator],\n    lastAPIRequest: null,\n    inMemoryErrorLog: []\n  };\n}\nvar STATE = getInitialState();\nfunction getSessionId() {\n  return STATE.sessionId;\n}\n\n// ../src/utils/debug.ts\nvar isDebugMode = memoize_default(() => {\n  return isEnvTruthy(process.env.DEBUG) || isEnvTruthy(process.env.DEBUG_SDK) || process.argv.includes(\"--debug\") || process.argv.includes(\"-d\") || isDebugToStdErr() || process.argv.some((arg) => arg.startsWith(\"--debug=\"));\n});\nvar getDebugFilter = memoize_default(() => {\n  const debugArg = process.argv.find((arg) => arg.startsWith(\"--debug=\"));\n  if (!debugArg) {\n    return null;\n  }\n  const filterPattern = debugArg.substring(\"--debug=\".length);\n  return parseDebugFilter(filterPattern);\n});\nvar isDebugToStdErr = memoize_default(() => {\n  return process.argv.includes(\"--debug-to-stderr\") || process.argv.includes(\"-d2e\");\n});\nfunction shouldLogDebugMessage(message) {\n  const filter = getDebugFilter();\n  return shouldShowDebugMessage(message, filter);\n}\nvar hasFormattedOutput = false;\nfunction logForDebugging(message, { level } = {\n  level: \"debug\"\n}) {\n  if (!shouldLogDebugMessage(message)) {\n    return;\n  }\n  if (hasFormattedOutput && message.includes(`\n`)) {\n    message = JSON.stringify(message);\n  }\n  const output = `[${level.toUpperCase()}] ${message.trim()}\n`;\n  if (isDebugToStdErr()) {\n    writeToStderr(output);\n    return;\n  }\n  if (!getFsImplementation().existsSync((0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(getDebugLogPath()))) {\n    getFsImplementation().mkdirSync((0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(getDebugLogPath()));\n  }\n  getFsImplementation().appendFileSync(getDebugLogPath(), output);\n  updateLatestDebugLogSymlink();\n}\nfunction getDebugLogPath() {\n  return process.env.CLAUDE_CODE_DEBUG_LOGS_DIR ?? (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(getClaudeConfigHomeDir(), \"debug\", `${getSessionId()}.txt`);\n}\nvar updateLatestDebugLogSymlink = memoize_default(() => {\n  try {\n    const debugLogPath = getDebugLogPath();\n    const debugLogsDir = (0,path__WEBPACK_IMPORTED_MODULE_0__.dirname)(debugLogPath);\n    const latestSymlinkPath = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(debugLogsDir, \"latest\");\n    if (!getFsImplementation().existsSync(debugLogsDir)) {\n      getFsImplementation().mkdirSync(debugLogsDir);\n    }\n    if (getFsImplementation().existsSync(latestSymlinkPath)) {\n      try {\n        getFsImplementation().unlinkSync(latestSymlinkPath);\n      } catch {}\n    }\n    getFsImplementation().symlinkSync(debugLogPath, latestSymlinkPath);\n  } catch {}\n});\n\n// ../src/core/Query.ts\nclass Query {\n  transport;\n  isSingleUserTurn;\n  canUseTool;\n  hooks;\n  abortController;\n  pendingControlResponses = new Map;\n  cleanupPerformed = false;\n  sdkMessages;\n  inputStream = new Stream;\n  initialization;\n  cancelControllers = new Map;\n  hookCallbacks = new Map;\n  nextCallbackId = 0;\n  sdkMcpTransports = new Map;\n  pendingMcpResponses = new Map;\n  firstResultReceivedPromise;\n  firstResultReceivedResolve;\n  constructor(transport, isSingleUserTurn, canUseTool, hooks, abortController, sdkMcpServers = new Map) {\n    this.transport = transport;\n    this.isSingleUserTurn = isSingleUserTurn;\n    this.canUseTool = canUseTool;\n    this.hooks = hooks;\n    this.abortController = abortController;\n    for (const [name, server] of sdkMcpServers) {\n      const sdkTransport = new SdkControlServerTransport((message) => this.sendMcpServerMessageToCli(name, message));\n      this.sdkMcpTransports.set(name, sdkTransport);\n      server.connect(sdkTransport);\n    }\n    this.sdkMessages = this.readSdkMessages();\n    this.firstResultReceivedPromise = new Promise((resolve) => {\n      this.firstResultReceivedResolve = resolve;\n    });\n    this.readMessages();\n    this.initialization = this.initialize();\n    this.initialization.catch(() => {});\n  }\n  setError(error) {\n    this.inputStream.error(error);\n  }\n  cleanup(error) {\n    if (this.cleanupPerformed)\n      return;\n    this.cleanupPerformed = true;\n    try {\n      this.transport.close();\n      this.pendingControlResponses.clear();\n      this.pendingMcpResponses.clear();\n      if (error) {\n        this.inputStream.error(error);\n      } else {\n        this.inputStream.done();\n      }\n    } catch (_error) {}\n  }\n  next(...[value]) {\n    return this.sdkMessages.next(...[value]);\n  }\n  return(value) {\n    return this.sdkMessages.return(value);\n  }\n  throw(e) {\n    return this.sdkMessages.throw(e);\n  }\n  [Symbol.asyncIterator]() {\n    return this.sdkMessages;\n  }\n  [Symbol.asyncDispose]() {\n    return this.sdkMessages[Symbol.asyncDispose]();\n  }\n  async readMessages() {\n    try {\n      for await (const message of this.transport.readMessages()) {\n        if (message.type === \"control_response\") {\n          const handler = this.pendingControlResponses.get(message.response.request_id);\n          if (handler) {\n            handler(message.response);\n          }\n          continue;\n        } else if (message.type === \"control_request\") {\n          this.handleControlRequest(message);\n          continue;\n        } else if (message.type === \"control_cancel_request\") {\n          this.handleControlCancelRequest(message);\n          continue;\n        } else if (message.type === \"keep_alive\") {\n          continue;\n        }\n        if (message.type === \"result\") {\n          if (this.firstResultReceivedResolve) {\n            this.firstResultReceivedResolve();\n          }\n          if (this.isSingleUserTurn) {\n            this.transport.endInput();\n          }\n        }\n        this.inputStream.enqueue(message);\n      }\n      this.inputStream.done();\n      this.cleanup();\n    } catch (error) {\n      this.inputStream.error(error);\n      this.cleanup(error);\n    }\n  }\n  async handleControlRequest(request) {\n    const controller = new AbortController;\n    this.cancelControllers.set(request.request_id, controller);\n    try {\n      const response = await this.processControlRequest(request, controller.signal);\n      const controlResponse = {\n        type: \"control_response\",\n        response: {\n          subtype: \"success\",\n          request_id: request.request_id,\n          response\n        }\n      };\n      await Promise.resolve(this.transport.write(JSON.stringify(controlResponse) + `\n`));\n    } catch (error) {\n      const controlErrorResponse = {\n        type: \"control_response\",\n        response: {\n          subtype: \"error\",\n          request_id: request.request_id,\n          error: error.message || String(error)\n        }\n      };\n      await Promise.resolve(this.transport.write(JSON.stringify(controlErrorResponse) + `\n`));\n    } finally {\n      this.cancelControllers.delete(request.request_id);\n    }\n  }\n  handleControlCancelRequest(request) {\n    const controller = this.cancelControllers.get(request.request_id);\n    if (controller) {\n      controller.abort();\n      this.cancelControllers.delete(request.request_id);\n    }\n  }\n  async processControlRequest(request, signal) {\n    if (request.request.subtype === \"can_use_tool\") {\n      if (!this.canUseTool) {\n        throw new Error(\"canUseTool callback is not provided.\");\n      }\n      return this.canUseTool(request.request.tool_name, request.request.input, {\n        signal,\n        suggestions: request.request.permission_suggestions\n      });\n    } else if (request.request.subtype === \"hook_callback\") {\n      const result = await this.handleHookCallbacks(request.request.callback_id, request.request.input, request.request.tool_use_id, signal);\n      return result;\n    } else if (request.request.subtype === \"mcp_message\") {\n      const mcpRequest = request.request;\n      const transport = this.sdkMcpTransports.get(mcpRequest.server_name);\n      if (!transport) {\n        throw new Error(`SDK MCP server not found: ${mcpRequest.server_name}`);\n      }\n      if (\"method\" in mcpRequest.message && \"id\" in mcpRequest.message && mcpRequest.message.id !== null) {\n        const response = await this.handleMcpControlRequest(mcpRequest.server_name, mcpRequest, transport);\n        return { mcp_response: response };\n      } else {\n        if (transport.onmessage) {\n          transport.onmessage(mcpRequest.message);\n        }\n        return { mcp_response: { jsonrpc: \"2.0\", result: {}, id: 0 } };\n      }\n    }\n    throw new Error(\"Unsupported control request subtype: \" + request.request.subtype);\n  }\n  async* readSdkMessages() {\n    for await (const message of this.inputStream) {\n      yield message;\n    }\n  }\n  async initialize() {\n    let hooks;\n    if (this.hooks) {\n      hooks = {};\n      for (const [event, matchers] of Object.entries(this.hooks)) {\n        if (matchers.length > 0) {\n          hooks[event] = matchers.map((matcher) => {\n            const callbackIds = [];\n            for (const callback of matcher.hooks) {\n              const callbackId = `hook_${this.nextCallbackId++}`;\n              this.hookCallbacks.set(callbackId, callback);\n              callbackIds.push(callbackId);\n            }\n            return {\n              matcher: matcher.matcher,\n              hookCallbackIds: callbackIds\n            };\n          });\n        }\n      }\n    }\n    const sdkMcpServers = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : undefined;\n    const initRequest = {\n      subtype: \"initialize\",\n      hooks,\n      sdkMcpServers\n    };\n    const response = await this.request(initRequest);\n    return response.response;\n  }\n  async interrupt() {\n    await this.request({\n      subtype: \"interrupt\"\n    });\n  }\n  async setPermissionMode(mode) {\n    await this.request({\n      subtype: \"set_permission_mode\",\n      mode\n    });\n  }\n  async setModel(model) {\n    await this.request({\n      subtype: \"set_model\",\n      model\n    });\n  }\n  request(request) {\n    const requestId = Math.random().toString(36).substring(2, 15);\n    const sdkRequest = {\n      request_id: requestId,\n      type: \"control_request\",\n      request\n    };\n    return new Promise((resolve, reject) => {\n      this.pendingControlResponses.set(requestId, (response) => {\n        if (response.subtype === \"success\") {\n          resolve(response);\n        } else {\n          reject(new Error(response.error));\n        }\n      });\n      Promise.resolve(this.transport.write(JSON.stringify(sdkRequest) + `\n`));\n    });\n  }\n  async supportedCommands() {\n    return (await this.initialization).commands;\n  }\n  async supportedModels() {\n    return (await this.initialization).models;\n  }\n  async mcpServerStatus() {\n    const response = await this.request({\n      subtype: \"mcp_status\"\n    });\n    const mcpStatusResponse = response.response;\n    return mcpStatusResponse.mcpServers;\n  }\n  async accountInfo() {\n    return (await this.initialization).account;\n  }\n  async streamInput(stream) {\n    logForDebugging(`[Query.streamInput] Starting to process input stream`);\n    logForDebugging(`[Query.streamInput] this.sdkMcpTransports.size = ${this.sdkMcpTransports.size}`);\n    try {\n      let messageCount = 0;\n      for await (const message of stream) {\n        messageCount++;\n        logForDebugging(`[Query.streamInput] Processing message ${messageCount}: ${message.type}`);\n        if (this.abortController?.signal.aborted)\n          break;\n        await Promise.resolve(this.transport.write(JSON.stringify(message) + `\n`));\n      }\n      logForDebugging(`[Query.streamInput] Finished processing ${messageCount} messages from input stream`);\n      logForDebugging(`[Query.streamInput] About to check MCP servers. this.sdkMcpTransports.size = ${this.sdkMcpTransports.size}`);\n      if (this.sdkMcpTransports.size > 0 && this.firstResultReceivedPromise) {\n        logForDebugging(`[Query.streamInput] Entering Promise.race to wait for result`);\n        const STREAM_CLOSE_TIMEOUT = 1e4;\n        let timeoutId;\n        await Promise.race([\n          this.firstResultReceivedPromise.then(() => {\n            logForDebugging(`[Query.streamInput] Received first result, closing input stream`);\n            if (timeoutId) {\n              clearTimeout(timeoutId);\n            }\n          }),\n          new Promise((resolve) => {\n            timeoutId = setTimeout(() => {\n              logForDebugging(`[Query.streamInput] Timed out waiting for first result, closing input stream`);\n              resolve();\n            }, STREAM_CLOSE_TIMEOUT);\n          })\n        ]);\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n      }\n      logForDebugging(`[Query] Calling transport.endInput() to close stdin to CLI process`);\n      this.transport.endInput();\n    } catch (error) {\n      if (!(error instanceof AbortError)) {\n        throw error;\n      }\n    }\n  }\n  handleHookCallbacks(callbackId, input, toolUseID, abortSignal) {\n    const callback = this.hookCallbacks.get(callbackId);\n    if (!callback) {\n      throw new Error(`No hook callback found for ID: ${callbackId}`);\n    }\n    return callback(input, toolUseID, {\n      signal: abortSignal\n    });\n  }\n  sendMcpServerMessageToCli(serverName, message) {\n    if (\"id\" in message && message.id !== null && message.id !== undefined) {\n      const key = `${serverName}:${message.id}`;\n      const pending = this.pendingMcpResponses.get(key);\n      if (pending) {\n        pending.resolve(message);\n        this.pendingMcpResponses.delete(key);\n        return;\n      }\n    }\n    throw new Error(\"No pending request found\");\n  }\n  handleMcpControlRequest(serverName, mcpRequest, transport) {\n    const messageId = \"id\" in mcpRequest.message ? mcpRequest.message.id : null;\n    const key = `${serverName}:${messageId}`;\n    return new Promise((resolve, reject) => {\n      let timeoutId = null;\n      const cleanup = () => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        this.pendingMcpResponses.delete(key);\n      };\n      const resolveAndCleanup = (response) => {\n        cleanup();\n        resolve(response);\n      };\n      const rejectAndCleanup = (error) => {\n        cleanup();\n        reject(error);\n      };\n      this.pendingMcpResponses.set(key, {\n        resolve: resolveAndCleanup,\n        reject: rejectAndCleanup\n      });\n      if (transport.onmessage) {\n        transport.onmessage(mcpRequest.message);\n      } else {\n        cleanup();\n        reject(new Error(\"No message handler registered\"));\n        return;\n      }\n      const MCP_REQUEST_TIMEOUT_MS = Number(process.env.MCP_REQUEST_TIMEOUT_MS ?? 180000);\n      timeoutId = setTimeout(() => {\n        if (this.pendingMcpResponses.has(key)) {\n          cleanup();\n          reject(new Error(\"Request timeout\"));\n        }\n      }, MCP_REQUEST_TIMEOUT_MS);\n    });\n  }\n}\n\n// ../src/core/sharedQuery.ts\nfunction createSharedQuery({\n  prompt,\n  options: {\n    abortController = createAbortController(),\n    additionalDirectories = [],\n    agents,\n    allowedTools = [],\n    appendSystemPrompt,\n    canUseTool,\n    continue: continueConversation,\n    customSystemPrompt,\n    cwd: cwd2,\n    disallowedTools = [],\n    env,\n    executable = isRunningWithBun() ? \"bun\" : \"node\",\n    executableArgs = [],\n    extraArgs = {},\n    fallbackModel,\n    forkSession,\n    hooks,\n    includePartialMessages,\n    maxThinkingTokens,\n    maxTurns,\n    mcpServers,\n    model,\n    pathToClaudeCodeExecutable,\n    permissionMode = \"default\",\n    permissionPromptToolName,\n    resume,\n    resumeSessionAt,\n    settingSources,\n    stderr,\n    strictMcpConfig\n  } = {}\n}) {\n  if (!env) {\n    env = { ...process.env };\n  }\n  if (!env.CLAUDE_CODE_ENTRYPOINT) {\n    env.CLAUDE_CODE_ENTRYPOINT = \"sdk-ts\";\n  }\n  if (!pathToClaudeCodeExecutable) {\n    throw new Error(\"pathToClaudeCodeExecutable is required\");\n  }\n  const allMcpServers = {};\n  const sdkMcpServers = new Map;\n  if (mcpServers) {\n    for (const [name, config] of Object.entries(mcpServers)) {\n      if (config.type === \"sdk\" && \"instance\" in config) {\n        sdkMcpServers.set(name, config.instance);\n        allMcpServers[name] = {\n          type: \"sdk\",\n          name\n        };\n      } else {\n        allMcpServers[name] = config;\n      }\n    }\n  }\n  const isSingleUserTurn = typeof prompt === \"string\";\n  const transport = new ProcessTransport({\n    abortController,\n    additionalDirectories,\n    agents,\n    cwd: cwd2,\n    executable,\n    executableArgs,\n    extraArgs,\n    pathToClaudeCodeExecutable,\n    env,\n    forkSession,\n    stderr,\n    customSystemPrompt,\n    appendSystemPrompt,\n    maxThinkingTokens,\n    maxTurns,\n    model,\n    fallbackModel,\n    permissionMode,\n    permissionPromptToolName,\n    continueConversation,\n    resume,\n    resumeSessionAt,\n    settingSources,\n    allowedTools,\n    disallowedTools,\n    mcpServers: allMcpServers,\n    strictMcpConfig,\n    canUseTool: !!canUseTool,\n    hooks: !!hooks,\n    includePartialMessages\n  });\n  const query = new Query(transport, isSingleUserTurn, canUseTool, hooks, abortController, sdkMcpServers);\n  if (typeof prompt === \"string\") {\n    transport.write(JSON.stringify({\n      type: \"user\",\n      session_id: \"\",\n      message: {\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt }]\n      },\n      parent_tool_use_id: null\n    }) + `\n`);\n  } else {\n    query.streamInput(prompt);\n  }\n  return query;\n}\n\n// ../node_modules/zod/v3/external.js\nvar exports_external = {};\n__export(exports_external, {\n  void: () => voidType,\n  util: () => util,\n  unknown: () => unknownType,\n  union: () => unionType,\n  undefined: () => undefinedType,\n  tuple: () => tupleType,\n  transformer: () => effectsType,\n  symbol: () => symbolType,\n  string: () => stringType,\n  strictObject: () => strictObjectType,\n  setErrorMap: () => setErrorMap,\n  set: () => setType,\n  record: () => recordType,\n  quotelessJson: () => quotelessJson,\n  promise: () => promiseType,\n  preprocess: () => preprocessType,\n  pipeline: () => pipelineType,\n  ostring: () => ostring,\n  optional: () => optionalType,\n  onumber: () => onumber,\n  oboolean: () => oboolean,\n  objectUtil: () => objectUtil,\n  object: () => objectType,\n  number: () => numberType,\n  nullable: () => nullableType,\n  null: () => nullType,\n  never: () => neverType,\n  nativeEnum: () => nativeEnumType,\n  nan: () => nanType,\n  map: () => mapType,\n  makeIssue: () => makeIssue,\n  literal: () => literalType,\n  lazy: () => lazyType,\n  late: () => late,\n  isValid: () => isValid,\n  isDirty: () => isDirty,\n  isAsync: () => isAsync,\n  isAborted: () => isAborted,\n  intersection: () => intersectionType,\n  instanceof: () => instanceOfType,\n  getParsedType: () => getParsedType,\n  getErrorMap: () => getErrorMap,\n  function: () => functionType,\n  enum: () => enumType,\n  effect: () => effectsType,\n  discriminatedUnion: () => discriminatedUnionType,\n  defaultErrorMap: () => en_default,\n  datetimeRegex: () => datetimeRegex,\n  date: () => dateType,\n  custom: () => custom,\n  coerce: () => coerce,\n  boolean: () => booleanType,\n  bigint: () => bigIntType,\n  array: () => arrayType,\n  any: () => anyType,\n  addIssueToContext: () => addIssueToContext,\n  ZodVoid: () => ZodVoid,\n  ZodUnknown: () => ZodUnknown,\n  ZodUnion: () => ZodUnion,\n  ZodUndefined: () => ZodUndefined,\n  ZodType: () => ZodType,\n  ZodTuple: () => ZodTuple,\n  ZodTransformer: () => ZodEffects,\n  ZodSymbol: () => ZodSymbol,\n  ZodString: () => ZodString,\n  ZodSet: () => ZodSet,\n  ZodSchema: () => ZodType,\n  ZodRecord: () => ZodRecord,\n  ZodReadonly: () => ZodReadonly,\n  ZodPromise: () => ZodPromise,\n  ZodPipeline: () => ZodPipeline,\n  ZodParsedType: () => ZodParsedType,\n  ZodOptional: () => ZodOptional,\n  ZodObject: () => ZodObject,\n  ZodNumber: () => ZodNumber,\n  ZodNullable: () => ZodNullable,\n  ZodNull: () => ZodNull,\n  ZodNever: () => ZodNever,\n  ZodNativeEnum: () => ZodNativeEnum,\n  ZodNaN: () => ZodNaN,\n  ZodMap: () => ZodMap,\n  ZodLiteral: () => ZodLiteral,\n  ZodLazy: () => ZodLazy,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodIntersection: () => ZodIntersection,\n  ZodFunction: () => ZodFunction,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodError: () => ZodError,\n  ZodEnum: () => ZodEnum,\n  ZodEffects: () => ZodEffects,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodDefault: () => ZodDefault,\n  ZodDate: () => ZodDate,\n  ZodCatch: () => ZodCatch,\n  ZodBranded: () => ZodBranded,\n  ZodBoolean: () => ZodBoolean,\n  ZodBigInt: () => ZodBigInt,\n  ZodArray: () => ZodArray,\n  ZodAny: () => ZodAny,\n  Schema: () => ZodType,\n  ParseStatus: () => ParseStatus,\n  OK: () => OK,\n  NEVER: () => NEVER,\n  INVALID: () => INVALID,\n  EMPTY_PATH: () => EMPTY_PATH,\n  DIRTY: () => DIRTY,\n  BRAND: () => BRAND\n});\n\n// ../node_modules/zod/v3/helpers/util.js\nvar util;\n(function(util2) {\n  util2.assertEqual = (_) => {};\n  function assertIs(_arg) {}\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error;\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === \"function\" ? (obj) => Object.keys(obj) : (object) => {\n    const keys = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return;\n  };\n  util2.isInteger = typeof Number.isInteger === \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val === \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map((val) => typeof val === \"string\" ? `'${val}'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === \"bigint\") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== \"undefined\" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== \"undefined\" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== \"undefined\" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n\n// ../node_modules/zod/v3/ZodError.js\nvar ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\n\nclass ZodError extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = \"ZodError\";\n    this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === \"invalid_union\") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === \"invalid_return_type\") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === \"invalid_arguments\") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0];\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\n\n// ../node_modules/zod/v3/locales/en.js\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = \"Required\";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === \"object\") {\n        if (\"includes\" in issue.validation) {\n          message = `Invalid input: must include \"${issue.validation.includes}\"`;\n          if (typeof issue.validation.position === \"number\") {\n            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if (\"startsWith\" in issue.validation) {\n          message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n        } else if (\"endsWith\" in issue.validation) {\n          message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== \"regex\") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = \"Invalid\";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === \"bigint\")\n        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === \"array\")\n        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === \"string\")\n        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === \"number\")\n        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"bigint\")\n        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === \"date\")\n        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n      else\n        message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\nvar en_default = errorMap;\n\n// ../node_modules/zod/v3/errors.js\nvar overrideErrorMap = en_default;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\n// ../node_modules/zod/v3/helpers/parseUtil.js\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== undefined) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      ctx.schemaErrorMap,\n      overrideMap,\n      overrideMap === en_default ? undefined : en_default\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\n\nclass ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    if (this.value === \"valid\")\n      this.value = \"dirty\";\n  }\n  abort() {\n    if (this.value !== \"aborted\")\n      this.value = \"aborted\";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      if (s.status === \"dirty\")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\")\n        return INVALID;\n      if (value.status === \"aborted\")\n        return INVALID;\n      if (key.status === \"dirty\")\n        status.dirty();\n      if (value.status === \"dirty\")\n        status.dirty();\n      if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n}\nvar INVALID = Object.freeze({\n  status: \"aborted\"\n});\nvar DIRTY = (value) => ({ status: \"dirty\", value });\nvar OK = (value) => ({ status: \"valid\", value });\nvar isAborted = (x) => x.status === \"aborted\";\nvar isDirty = (x) => x.status === \"dirty\";\nvar isValid = (x) => x.status === \"valid\";\nvar isAsync = (x) => typeof Promise !== \"undefined\" && x instanceof Promise;\n// ../node_modules/zod/v3/helpers/errorUtil.js\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === \"string\" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n\n// ../node_modules/zod/v3/types.js\nclass ParseInputLazyPath {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n}\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error(\"Validation failed but no issues detected.\");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error = new ZodError(ctx.common.issues);\n        this._error = error;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    const { message } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n\nclass ZodType {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus,\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error(\"Synchronous parse encountered promise.\");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  \"~validate\"(data) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    if (!this[\"~standard\"].async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        if (err?.message?.toLowerCase()?.includes(\"encountered\")) {\n          this[\"~standard\"].async = true;\n        }\n        ctx.common = {\n          issues: [],\n          async: true\n        };\n      }\n    }\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === \"string\" || typeof message === \"undefined\") {\n        return { message };\n      } else if (typeof message === \"function\") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (data) => this[\"~validate\"](data)\n    };\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(undefined).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\nvar ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nvar ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? \"+\" : \"?\";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join(\"|\")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT(jwt, alg) {\n  if (!jwtRegex.test(jwt))\n    return false;\n  try {\n    const [header] = jwt.split(\".\");\n    if (!header)\n      return false;\n    const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\");\n    const decoded = JSON.parse(atob(base64));\n    if (typeof decoded !== \"object\" || decoded === null)\n      return false;\n    if (\"typ\" in decoded && decoded?.typ !== \"JWT\")\n      return false;\n    if (!decoded.alg)\n      return false;\n    if (alg && decoded.alg !== alg)\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version) {\n  if ((version === \"v4\" || !version) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version === \"v6\" || !version) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\n\nclass ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"string\",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: \"string\",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === \"email\") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"email\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"emoji\") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, \"u\");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"emoji\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"uuid\") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"uuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"nanoid\") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"nanoid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid\") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cuid2\") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cuid2\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ulid\") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ulid\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"url\") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"regex\") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"regex\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"trim\") {\n        input.data = input.data.trim();\n      } else if (check.kind === \"includes\") {\n        if (!input.data.includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"toLowerCase\") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === \"toUpperCase\") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === \"startsWith\") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"endsWith\") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"datetime\") {\n        const regex = datetimeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"datetime\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"date\") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"date\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"time\") {\n        const regex = timeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: \"time\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"duration\") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"duration\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"ip\") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"ip\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"jwt\") {\n        if (!isValidJWT(input.data, check.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"jwt\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"cidr\") {\n        if (!isValidCidr(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"cidr\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64\") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"base64url\") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: \"base64url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check) {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n  cidr(options) {\n    return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"datetime\",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"datetime\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: \"date\", message });\n  }\n  time(options) {\n    if (typeof options === \"string\") {\n      return this._addCheck({\n        kind: \"time\",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: \"time\",\n      precision: typeof options?.precision === \"undefined\" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodString.create = (params) => {\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n  const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\n\nclass ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check of this._def.checks) {\n      if (check.kind === \"int\") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: \"integer\",\n            received: \"float\",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: \"number\",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"finite\") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null;\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n        return true;\n      } else if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n}\nZodNumber.create = (params) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n    let ctx = undefined;\n    const status = new ParseStatus;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: \"bigint\",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: \"bigint\",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"multipleOf\") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n}\nZodBigInt.create = (params) => {\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodBoolean extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodBoolean.create = (params) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus;\n    let ctx = undefined;\n    for (const check of this._def.checks) {\n      if (check.kind === \"min\") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === \"max\") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: \"date\"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"min\") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"max\") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n}\nZodDate.create = (params) => {\n  return new ZodDate({\n    checks: [],\n    coerce: params?.coerce || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSymbol extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodSymbol.create = (params) => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUndefined extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodUndefined.create = (params) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNull extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodNull.create = (params) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodAny extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodAny.create = (params) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnknown extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n}\nZodUnknown.create = (params) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNever extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n}\nZodNever.create = (params) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodVoid extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n}\nZodVoid.create = (params) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : undefined,\n          maximum: tooBig ? def.exactLength.value : undefined,\n          type: \"array\",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: \"array\",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\n\nclass ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === \"strict\") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === \"strip\") {} else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message !== undefined ? {\n        errorMap: (issue, ctx) => {\n          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n          if (issue.code === \"unrecognized_keys\")\n            return {\n              message: errorUtil.errToObj(message).message ?? defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  extend(augmentation) {\n    return new ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  merge(merging) {\n    const merged = new ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  catchall(index) {\n    return new ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    }\n    return new ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n}\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: \"strict\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: \"strip\",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === \"valid\") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === \"dirty\") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = undefined;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\") {\n          return result;\n        } else if (result.status === \"dirty\" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type) => {\n  if (type instanceof ZodLazy) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral) {\n    return [type.value];\n  } else if (type instanceof ZodEnum) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined) {\n    return [undefined];\n  } else if (type instanceof ZodNull) {\n    return [null];\n  } else if (type instanceof ZodOptional) {\n    return [undefined, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\n\nclass ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  static create(discriminator, options, params) {\n    const optionsMap = new Map;\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n}\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0;index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\n\nclass ZodIntersection extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n}\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: \"array\"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n}\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n}\n\nclass ZodMap extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = new Map;\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\") {\n            return INVALID;\n          }\n          if (key.status === \"dirty\" || value.status === \"dirty\") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = new Map;\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\") {\n          return INVALID;\n        }\n        if (key.status === \"dirty\" || value.status === \"dirty\") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n}\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: \"set\",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = new Set;\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        if (element.status === \"dirty\")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n}\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\n          error.addIssue(makeReturnsIssue(result, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me = this;\n      return OK(function(...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n}\n\nclass ZodLazy extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n}\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodLiteral extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\n\nclass ZodEnum extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== \"string\") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n}\nZodEnum.create = createZodEnum;\n\nclass ZodNativeEnum extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodPromise extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n}\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodEffects extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === \"aborted\")\n            return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === \"aborted\")\n            return INVALID;\n          if (result.status === \"dirty\")\n            return DIRTY(result.value);\n          if (status.value === \"dirty\")\n            return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === \"aborted\")\n          return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === \"aborted\")\n          return INVALID;\n        if (result.status === \"dirty\")\n          return DIRTY(result.value);\n        if (status.value === \"dirty\")\n          return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === \"aborted\")\n          return INVALID;\n        if (inner.status === \"dirty\")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === \"aborted\")\n            return INVALID;\n          if (inner.status === \"dirty\")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === \"transform\") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return INVALID;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return INVALID;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result\n          }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n}\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: \"preprocess\", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nclass ZodOptional extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(undefined);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodOptional.create = (type, params) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNullable extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodNullable.create = (type, params) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodDefault extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\nZodDefault.create = (type, params) => {\n  return new ZodDefault({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === \"function\" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodCatch extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then((result2) => {\n        return {\n          status: \"valid\",\n          value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: \"valid\",\n        value: result.status === \"valid\" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nZodCatch.create = (type, params) => {\n  return new ZodCatch({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === \"function\" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\n\nclass ZodNaN extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n}\nZodNaN.create = (params) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol(\"zod_brand\");\n\nclass ZodBranded extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\n\nclass ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === \"aborted\")\n          return INVALID;\n        if (inResult.status === \"dirty\") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === \"aborted\")\n        return INVALID;\n      if (inResult.status === \"dirty\") {\n        status.dirty();\n        return {\n          status: \"dirty\",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b) {\n    return new ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n}\n\nclass ZodReadonly extends ZodType {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZodReadonly.create = (type, params) => {\n  return new ZodReadonly({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nfunction cleanParams(params, data) {\n  const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? { message: params } : params;\n  const p2 = typeof p === \"string\" ? { message: p } : p;\n  return p2;\n}\nfunction custom(check, _params = {}, fatal) {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      const r = check(data);\n      if (r instanceof Promise) {\n        return r.then((r2) => {\n          if (!r2) {\n            const params = cleanParams(_params, data);\n            const _fatal = params.fatal ?? fatal ?? true;\n            ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n          }\n        });\n      }\n      if (!r) {\n        const params = cleanParams(_params, data);\n        const _fatal = params.fatal ?? fatal ?? true;\n        ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n      }\n      return;\n    });\n  return ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n  ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n  ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n  ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n  ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n  ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n  ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n  ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n  ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n  ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n  ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n  ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n  ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n  ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n  ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n  ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n  ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n  ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n  ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n  ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n  ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n  ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n  ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n  ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n  ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n  ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n  ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n  ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n  ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n  ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n  ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n  ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n  ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n  ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n  ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n  ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: true }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: true })\n};\nvar NEVER = INVALID;\n// ../node_modules/@modelcontextprotocol/sdk/dist/esm/types.js\nvar LATEST_PROTOCOL_VERSION = \"2025-06-18\";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  \"2025-03-26\",\n  \"2024-11-05\",\n  \"2024-10-07\"\n];\nvar JSONRPC_VERSION = \"2.0\";\nvar ProgressTokenSchema = exports_external.union([exports_external.string(), exports_external.number().int()]);\nvar CursorSchema = exports_external.string();\nvar RequestMetaSchema = exports_external.object({\n  progressToken: exports_external.optional(ProgressTokenSchema)\n}).passthrough();\nvar BaseRequestParamsSchema = exports_external.object({\n  _meta: exports_external.optional(RequestMetaSchema)\n}).passthrough();\nvar RequestSchema = exports_external.object({\n  method: exports_external.string(),\n  params: exports_external.optional(BaseRequestParamsSchema)\n});\nvar BaseNotificationParamsSchema = exports_external.object({\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar NotificationSchema = exports_external.object({\n  method: exports_external.string(),\n  params: exports_external.optional(BaseNotificationParamsSchema)\n});\nvar ResultSchema = exports_external.object({\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar RequestIdSchema = exports_external.union([exports_external.string(), exports_external.number().int()]);\nvar JSONRPCRequestSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: RequestIdSchema\n}).merge(RequestSchema).strict();\nvar isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;\nvar JSONRPCNotificationSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION)\n}).merge(NotificationSchema).strict();\nvar isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;\nvar JSONRPCResponseSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: RequestIdSchema,\n  result: ResultSchema\n}).strict();\nvar isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;\nvar ErrorCode;\n(function(ErrorCode2) {\n  ErrorCode2[ErrorCode2[\"ConnectionClosed\"] = -32000] = \"ConnectionClosed\";\n  ErrorCode2[ErrorCode2[\"RequestTimeout\"] = -32001] = \"RequestTimeout\";\n  ErrorCode2[ErrorCode2[\"ParseError\"] = -32700] = \"ParseError\";\n  ErrorCode2[ErrorCode2[\"InvalidRequest\"] = -32600] = \"InvalidRequest\";\n  ErrorCode2[ErrorCode2[\"MethodNotFound\"] = -32601] = \"MethodNotFound\";\n  ErrorCode2[ErrorCode2[\"InvalidParams\"] = -32602] = \"InvalidParams\";\n  ErrorCode2[ErrorCode2[\"InternalError\"] = -32603] = \"InternalError\";\n})(ErrorCode || (ErrorCode = {}));\nvar JSONRPCErrorSchema = exports_external.object({\n  jsonrpc: exports_external.literal(JSONRPC_VERSION),\n  id: RequestIdSchema,\n  error: exports_external.object({\n    code: exports_external.number().int(),\n    message: exports_external.string(),\n    data: exports_external.optional(exports_external.unknown())\n  })\n}).strict();\nvar isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;\nvar JSONRPCMessageSchema = exports_external.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\nvar EmptyResultSchema = ResultSchema.strict();\nvar CancelledNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/cancelled\"),\n  params: BaseNotificationParamsSchema.extend({\n    requestId: RequestIdSchema,\n    reason: exports_external.string().optional()\n  })\n});\nvar BaseMetadataSchema = exports_external.object({\n  name: exports_external.string(),\n  title: exports_external.optional(exports_external.string())\n}).passthrough();\nvar ImplementationSchema = BaseMetadataSchema.extend({\n  version: exports_external.string()\n});\nvar ClientCapabilitiesSchema = exports_external.object({\n  experimental: exports_external.optional(exports_external.object({}).passthrough()),\n  sampling: exports_external.optional(exports_external.object({}).passthrough()),\n  elicitation: exports_external.optional(exports_external.object({}).passthrough()),\n  roots: exports_external.optional(exports_external.object({\n    listChanged: exports_external.optional(exports_external.boolean())\n  }).passthrough())\n}).passthrough();\nvar InitializeRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"initialize\"),\n  params: BaseRequestParamsSchema.extend({\n    protocolVersion: exports_external.string(),\n    capabilities: ClientCapabilitiesSchema,\n    clientInfo: ImplementationSchema\n  })\n});\nvar ServerCapabilitiesSchema = exports_external.object({\n  experimental: exports_external.optional(exports_external.object({}).passthrough()),\n  logging: exports_external.optional(exports_external.object({}).passthrough()),\n  completions: exports_external.optional(exports_external.object({}).passthrough()),\n  prompts: exports_external.optional(exports_external.object({\n    listChanged: exports_external.optional(exports_external.boolean())\n  }).passthrough()),\n  resources: exports_external.optional(exports_external.object({\n    subscribe: exports_external.optional(exports_external.boolean()),\n    listChanged: exports_external.optional(exports_external.boolean())\n  }).passthrough()),\n  tools: exports_external.optional(exports_external.object({\n    listChanged: exports_external.optional(exports_external.boolean())\n  }).passthrough())\n}).passthrough();\nvar InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: exports_external.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ImplementationSchema,\n  instructions: exports_external.optional(exports_external.string())\n});\nvar InitializedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/initialized\")\n});\nvar PingRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"ping\")\n});\nvar ProgressSchema = exports_external.object({\n  progress: exports_external.number(),\n  total: exports_external.optional(exports_external.number()),\n  message: exports_external.optional(exports_external.string())\n}).passthrough();\nvar ProgressNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/progress\"),\n  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({\n    progressToken: ProgressTokenSchema\n  })\n});\nvar PaginatedRequestSchema = RequestSchema.extend({\n  params: BaseRequestParamsSchema.extend({\n    cursor: exports_external.optional(CursorSchema)\n  }).optional()\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: exports_external.optional(CursorSchema)\n});\nvar ResourceContentsSchema = exports_external.object({\n  uri: exports_external.string(),\n  mimeType: exports_external.optional(exports_external.string()),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: exports_external.string()\n});\nvar Base64Schema = exports_external.string().refine((val) => {\n  try {\n    atob(val);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}, { message: \"Invalid Base64 string\" });\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: Base64Schema\n});\nvar ResourceSchema = BaseMetadataSchema.extend({\n  uri: exports_external.string(),\n  description: exports_external.optional(exports_external.string()),\n  mimeType: exports_external.optional(exports_external.string()),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n});\nvar ResourceTemplateSchema = BaseMetadataSchema.extend({\n  uriTemplate: exports_external.string(),\n  description: exports_external.optional(exports_external.string()),\n  mimeType: exports_external.optional(exports_external.string()),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n});\nvar ListResourcesRequestSchema = PaginatedRequestSchema.extend({\n  method: exports_external.literal(\"resources/list\")\n});\nvar ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: exports_external.array(ResourceSchema)\n});\nvar ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({\n  method: exports_external.literal(\"resources/templates/list\")\n});\nvar ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({\n  resourceTemplates: exports_external.array(ResourceTemplateSchema)\n});\nvar ReadResourceRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"resources/read\"),\n  params: BaseRequestParamsSchema.extend({\n    uri: exports_external.string()\n  })\n});\nvar ReadResourceResultSchema = ResultSchema.extend({\n  contents: exports_external.array(exports_external.union([TextResourceContentsSchema, BlobResourceContentsSchema]))\n});\nvar ResourceListChangedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/resources/list_changed\")\n});\nvar SubscribeRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"resources/subscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    uri: exports_external.string()\n  })\n});\nvar UnsubscribeRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"resources/unsubscribe\"),\n  params: BaseRequestParamsSchema.extend({\n    uri: exports_external.string()\n  })\n});\nvar ResourceUpdatedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/resources/updated\"),\n  params: BaseNotificationParamsSchema.extend({\n    uri: exports_external.string()\n  })\n});\nvar PromptArgumentSchema = exports_external.object({\n  name: exports_external.string(),\n  description: exports_external.optional(exports_external.string()),\n  required: exports_external.optional(exports_external.boolean())\n}).passthrough();\nvar PromptSchema = BaseMetadataSchema.extend({\n  description: exports_external.optional(exports_external.string()),\n  arguments: exports_external.optional(exports_external.array(PromptArgumentSchema)),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n});\nvar ListPromptsRequestSchema = PaginatedRequestSchema.extend({\n  method: exports_external.literal(\"prompts/list\")\n});\nvar ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: exports_external.array(PromptSchema)\n});\nvar GetPromptRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"prompts/get\"),\n  params: BaseRequestParamsSchema.extend({\n    name: exports_external.string(),\n    arguments: exports_external.optional(exports_external.record(exports_external.string()))\n  })\n});\nvar TextContentSchema = exports_external.object({\n  type: exports_external.literal(\"text\"),\n  text: exports_external.string(),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar ImageContentSchema = exports_external.object({\n  type: exports_external.literal(\"image\"),\n  data: Base64Schema,\n  mimeType: exports_external.string(),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar AudioContentSchema = exports_external.object({\n  type: exports_external.literal(\"audio\"),\n  data: Base64Schema,\n  mimeType: exports_external.string(),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar EmbeddedResourceSchema = exports_external.object({\n  type: exports_external.literal(\"resource\"),\n  resource: exports_external.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar ResourceLinkSchema = ResourceSchema.extend({\n  type: exports_external.literal(\"resource_link\")\n});\nvar ContentBlockSchema = exports_external.union([\n  TextContentSchema,\n  ImageContentSchema,\n  AudioContentSchema,\n  ResourceLinkSchema,\n  EmbeddedResourceSchema\n]);\nvar PromptMessageSchema = exports_external.object({\n  role: exports_external.enum([\"user\", \"assistant\"]),\n  content: ContentBlockSchema\n}).passthrough();\nvar GetPromptResultSchema = ResultSchema.extend({\n  description: exports_external.optional(exports_external.string()),\n  messages: exports_external.array(PromptMessageSchema)\n});\nvar PromptListChangedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/prompts/list_changed\")\n});\nvar ToolAnnotationsSchema = exports_external.object({\n  title: exports_external.optional(exports_external.string()),\n  readOnlyHint: exports_external.optional(exports_external.boolean()),\n  destructiveHint: exports_external.optional(exports_external.boolean()),\n  idempotentHint: exports_external.optional(exports_external.boolean()),\n  openWorldHint: exports_external.optional(exports_external.boolean())\n}).passthrough();\nvar ToolSchema = BaseMetadataSchema.extend({\n  description: exports_external.optional(exports_external.string()),\n  inputSchema: exports_external.object({\n    type: exports_external.literal(\"object\"),\n    properties: exports_external.optional(exports_external.object({}).passthrough()),\n    required: exports_external.optional(exports_external.array(exports_external.string()))\n  }).passthrough(),\n  outputSchema: exports_external.optional(exports_external.object({\n    type: exports_external.literal(\"object\"),\n    properties: exports_external.optional(exports_external.object({}).passthrough()),\n    required: exports_external.optional(exports_external.array(exports_external.string()))\n  }).passthrough()),\n  annotations: exports_external.optional(ToolAnnotationsSchema),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n});\nvar ListToolsRequestSchema = PaginatedRequestSchema.extend({\n  method: exports_external.literal(\"tools/list\")\n});\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: exports_external.array(ToolSchema)\n});\nvar CallToolResultSchema = ResultSchema.extend({\n  content: exports_external.array(ContentBlockSchema).default([]),\n  structuredContent: exports_external.object({}).passthrough().optional(),\n  isError: exports_external.optional(exports_external.boolean())\n});\nvar CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({\n  toolResult: exports_external.unknown()\n}));\nvar CallToolRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"tools/call\"),\n  params: BaseRequestParamsSchema.extend({\n    name: exports_external.string(),\n    arguments: exports_external.optional(exports_external.record(exports_external.unknown()))\n  })\n});\nvar ToolListChangedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/tools/list_changed\")\n});\nvar LoggingLevelSchema = exports_external.enum([\n  \"debug\",\n  \"info\",\n  \"notice\",\n  \"warning\",\n  \"error\",\n  \"critical\",\n  \"alert\",\n  \"emergency\"\n]);\nvar SetLevelRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"logging/setLevel\"),\n  params: BaseRequestParamsSchema.extend({\n    level: LoggingLevelSchema\n  })\n});\nvar LoggingMessageNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/message\"),\n  params: BaseNotificationParamsSchema.extend({\n    level: LoggingLevelSchema,\n    logger: exports_external.optional(exports_external.string()),\n    data: exports_external.unknown()\n  })\n});\nvar ModelHintSchema = exports_external.object({\n  name: exports_external.string().optional()\n}).passthrough();\nvar ModelPreferencesSchema = exports_external.object({\n  hints: exports_external.optional(exports_external.array(ModelHintSchema)),\n  costPriority: exports_external.optional(exports_external.number().min(0).max(1)),\n  speedPriority: exports_external.optional(exports_external.number().min(0).max(1)),\n  intelligencePriority: exports_external.optional(exports_external.number().min(0).max(1))\n}).passthrough();\nvar SamplingMessageSchema = exports_external.object({\n  role: exports_external.enum([\"user\", \"assistant\"]),\n  content: exports_external.union([TextContentSchema, ImageContentSchema, AudioContentSchema])\n}).passthrough();\nvar CreateMessageRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"sampling/createMessage\"),\n  params: BaseRequestParamsSchema.extend({\n    messages: exports_external.array(SamplingMessageSchema),\n    systemPrompt: exports_external.optional(exports_external.string()),\n    includeContext: exports_external.optional(exports_external.enum([\"none\", \"thisServer\", \"allServers\"])),\n    temperature: exports_external.optional(exports_external.number()),\n    maxTokens: exports_external.number().int(),\n    stopSequences: exports_external.optional(exports_external.array(exports_external.string())),\n    metadata: exports_external.optional(exports_external.object({}).passthrough()),\n    modelPreferences: exports_external.optional(ModelPreferencesSchema)\n  })\n});\nvar CreateMessageResultSchema = ResultSchema.extend({\n  model: exports_external.string(),\n  stopReason: exports_external.optional(exports_external.enum([\"endTurn\", \"stopSequence\", \"maxTokens\"]).or(exports_external.string())),\n  role: exports_external.enum([\"user\", \"assistant\"]),\n  content: exports_external.discriminatedUnion(\"type\", [\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema\n  ])\n});\nvar BooleanSchemaSchema = exports_external.object({\n  type: exports_external.literal(\"boolean\"),\n  title: exports_external.optional(exports_external.string()),\n  description: exports_external.optional(exports_external.string()),\n  default: exports_external.optional(exports_external.boolean())\n}).passthrough();\nvar StringSchemaSchema = exports_external.object({\n  type: exports_external.literal(\"string\"),\n  title: exports_external.optional(exports_external.string()),\n  description: exports_external.optional(exports_external.string()),\n  minLength: exports_external.optional(exports_external.number()),\n  maxLength: exports_external.optional(exports_external.number()),\n  format: exports_external.optional(exports_external.enum([\"email\", \"uri\", \"date\", \"date-time\"]))\n}).passthrough();\nvar NumberSchemaSchema = exports_external.object({\n  type: exports_external.enum([\"number\", \"integer\"]),\n  title: exports_external.optional(exports_external.string()),\n  description: exports_external.optional(exports_external.string()),\n  minimum: exports_external.optional(exports_external.number()),\n  maximum: exports_external.optional(exports_external.number())\n}).passthrough();\nvar EnumSchemaSchema = exports_external.object({\n  type: exports_external.literal(\"string\"),\n  title: exports_external.optional(exports_external.string()),\n  description: exports_external.optional(exports_external.string()),\n  enum: exports_external.array(exports_external.string()),\n  enumNames: exports_external.optional(exports_external.array(exports_external.string()))\n}).passthrough();\nvar PrimitiveSchemaDefinitionSchema = exports_external.union([\n  BooleanSchemaSchema,\n  StringSchemaSchema,\n  NumberSchemaSchema,\n  EnumSchemaSchema\n]);\nvar ElicitRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"elicitation/create\"),\n  params: BaseRequestParamsSchema.extend({\n    message: exports_external.string(),\n    requestedSchema: exports_external.object({\n      type: exports_external.literal(\"object\"),\n      properties: exports_external.record(exports_external.string(), PrimitiveSchemaDefinitionSchema),\n      required: exports_external.optional(exports_external.array(exports_external.string()))\n    }).passthrough()\n  })\n});\nvar ElicitResultSchema = ResultSchema.extend({\n  action: exports_external.enum([\"accept\", \"decline\", \"cancel\"]),\n  content: exports_external.optional(exports_external.record(exports_external.string(), exports_external.unknown()))\n});\nvar ResourceTemplateReferenceSchema = exports_external.object({\n  type: exports_external.literal(\"ref/resource\"),\n  uri: exports_external.string()\n}).passthrough();\nvar PromptReferenceSchema = exports_external.object({\n  type: exports_external.literal(\"ref/prompt\"),\n  name: exports_external.string()\n}).passthrough();\nvar CompleteRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"completion/complete\"),\n  params: BaseRequestParamsSchema.extend({\n    ref: exports_external.union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),\n    argument: exports_external.object({\n      name: exports_external.string(),\n      value: exports_external.string()\n    }).passthrough(),\n    context: exports_external.optional(exports_external.object({\n      arguments: exports_external.optional(exports_external.record(exports_external.string(), exports_external.string()))\n    }))\n  })\n});\nvar CompleteResultSchema = ResultSchema.extend({\n  completion: exports_external.object({\n    values: exports_external.array(exports_external.string()).max(100),\n    total: exports_external.optional(exports_external.number().int()),\n    hasMore: exports_external.optional(exports_external.boolean())\n  }).passthrough()\n});\nvar RootSchema = exports_external.object({\n  uri: exports_external.string().startsWith(\"file://\"),\n  name: exports_external.optional(exports_external.string()),\n  _meta: exports_external.optional(exports_external.object({}).passthrough())\n}).passthrough();\nvar ListRootsRequestSchema = RequestSchema.extend({\n  method: exports_external.literal(\"roots/list\")\n});\nvar ListRootsResultSchema = ResultSchema.extend({\n  roots: exports_external.array(RootSchema)\n});\nvar RootsListChangedNotificationSchema = NotificationSchema.extend({\n  method: exports_external.literal(\"notifications/roots/list_changed\")\n});\nvar ClientRequestSchema = exports_external.union([\n  PingRequestSchema,\n  InitializeRequestSchema,\n  CompleteRequestSchema,\n  SetLevelRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  CallToolRequestSchema,\n  ListToolsRequestSchema\n]);\nvar ClientNotificationSchema = exports_external.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  InitializedNotificationSchema,\n  RootsListChangedNotificationSchema\n]);\nvar ClientResultSchema = exports_external.union([\n  EmptyResultSchema,\n  CreateMessageResultSchema,\n  ElicitResultSchema,\n  ListRootsResultSchema\n]);\nvar ServerRequestSchema = exports_external.union([\n  PingRequestSchema,\n  CreateMessageRequestSchema,\n  ElicitRequestSchema,\n  ListRootsRequestSchema\n]);\nvar ServerNotificationSchema = exports_external.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  LoggingMessageNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  ToolListChangedNotificationSchema,\n  PromptListChangedNotificationSchema\n]);\nvar ServerResultSchema = exports_external.union([\n  EmptyResultSchema,\n  InitializeResultSchema,\n  CompleteResultSchema,\n  GetPromptResultSchema,\n  ListPromptsResultSchema,\n  ListResourcesResultSchema,\n  ListResourceTemplatesResultSchema,\n  ReadResourceResultSchema,\n  CallToolResultSchema,\n  ListToolsResultSchema\n]);\n\nclass McpError extends Error {\n  constructor(code, message, data) {\n    super(`MCP error ${code}: ${message}`);\n    this.code = code;\n    this.data = data;\n    this.name = \"McpError\";\n  }\n}\n\n// ../node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js\nvar DEFAULT_REQUEST_TIMEOUT_MSEC = 60000;\n\nclass Protocol {\n  constructor(_options) {\n    this._options = _options;\n    this._requestMessageId = 0;\n    this._requestHandlers = new Map;\n    this._requestHandlerAbortControllers = new Map;\n    this._notificationHandlers = new Map;\n    this._responseHandlers = new Map;\n    this._progressHandlers = new Map;\n    this._timeoutInfo = new Map;\n    this._pendingDebouncedNotifications = new Set;\n    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {\n      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);\n      controller === null || controller === undefined || controller.abort(notification.params.reason);\n    });\n    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {\n      this._onprogress(notification);\n    });\n    this.setRequestHandler(PingRequestSchema, (_request) => ({}));\n  }\n  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {\n    this._timeoutInfo.set(messageId, {\n      timeoutId: setTimeout(onTimeout, timeout),\n      startTime: Date.now(),\n      timeout,\n      maxTotalTimeout,\n      resetTimeoutOnProgress,\n      onTimeout\n    });\n  }\n  _resetTimeout(messageId) {\n    const info = this._timeoutInfo.get(messageId);\n    if (!info)\n      return false;\n    const totalElapsed = Date.now() - info.startTime;\n    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {\n      this._timeoutInfo.delete(messageId);\n      throw new McpError(ErrorCode.RequestTimeout, \"Maximum total timeout exceeded\", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });\n    }\n    clearTimeout(info.timeoutId);\n    info.timeoutId = setTimeout(info.onTimeout, info.timeout);\n    return true;\n  }\n  _cleanupTimeout(messageId) {\n    const info = this._timeoutInfo.get(messageId);\n    if (info) {\n      clearTimeout(info.timeoutId);\n      this._timeoutInfo.delete(messageId);\n    }\n  }\n  async connect(transport) {\n    var _a, _b, _c;\n    this._transport = transport;\n    const _onclose = (_a = this.transport) === null || _a === undefined ? undefined : _a.onclose;\n    this._transport.onclose = () => {\n      _onclose === null || _onclose === undefined || _onclose();\n      this._onclose();\n    };\n    const _onerror = (_b = this.transport) === null || _b === undefined ? undefined : _b.onerror;\n    this._transport.onerror = (error) => {\n      _onerror === null || _onerror === undefined || _onerror(error);\n      this._onerror(error);\n    };\n    const _onmessage = (_c = this._transport) === null || _c === undefined ? undefined : _c.onmessage;\n    this._transport.onmessage = (message, extra) => {\n      _onmessage === null || _onmessage === undefined || _onmessage(message, extra);\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        this._onresponse(message);\n      } else if (isJSONRPCRequest(message)) {\n        this._onrequest(message, extra);\n      } else if (isJSONRPCNotification(message)) {\n        this._onnotification(message);\n      } else {\n        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));\n      }\n    };\n    await this._transport.start();\n  }\n  _onclose() {\n    var _a;\n    const responseHandlers = this._responseHandlers;\n    this._responseHandlers = new Map;\n    this._progressHandlers.clear();\n    this._pendingDebouncedNotifications.clear();\n    this._transport = undefined;\n    (_a = this.onclose) === null || _a === undefined || _a.call(this);\n    const error = new McpError(ErrorCode.ConnectionClosed, \"Connection closed\");\n    for (const handler of responseHandlers.values()) {\n      handler(error);\n    }\n  }\n  _onerror(error) {\n    var _a;\n    (_a = this.onerror) === null || _a === undefined || _a.call(this, error);\n  }\n  _onnotification(notification) {\n    var _a;\n    const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== undefined ? _a : this.fallbackNotificationHandler;\n    if (handler === undefined) {\n      return;\n    }\n    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));\n  }\n  _onrequest(request, extra) {\n    var _a, _b;\n    const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== undefined ? _a : this.fallbackRequestHandler;\n    const capturedTransport = this._transport;\n    if (handler === undefined) {\n      capturedTransport === null || capturedTransport === undefined || capturedTransport.send({\n        jsonrpc: \"2.0\",\n        id: request.id,\n        error: {\n          code: ErrorCode.MethodNotFound,\n          message: \"Method not found\"\n        }\n      }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));\n      return;\n    }\n    const abortController = new AbortController;\n    this._requestHandlerAbortControllers.set(request.id, abortController);\n    const fullExtra = {\n      signal: abortController.signal,\n      sessionId: capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.sessionId,\n      _meta: (_b = request.params) === null || _b === undefined ? undefined : _b._meta,\n      sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),\n      sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),\n      authInfo: extra === null || extra === undefined ? undefined : extra.authInfo,\n      requestId: request.id,\n      requestInfo: extra === null || extra === undefined ? undefined : extra.requestInfo\n    };\n    Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {\n      if (abortController.signal.aborted) {\n        return;\n      }\n      return capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.send({\n        result,\n        jsonrpc: \"2.0\",\n        id: request.id\n      });\n    }, (error) => {\n      var _a2;\n      if (abortController.signal.aborted) {\n        return;\n      }\n      return capturedTransport === null || capturedTransport === undefined ? undefined : capturedTransport.send({\n        jsonrpc: \"2.0\",\n        id: request.id,\n        error: {\n          code: Number.isSafeInteger(error[\"code\"]) ? error[\"code\"] : ErrorCode.InternalError,\n          message: (_a2 = error.message) !== null && _a2 !== undefined ? _a2 : \"Internal error\"\n        }\n      });\n    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {\n      this._requestHandlerAbortControllers.delete(request.id);\n    });\n  }\n  _onprogress(notification) {\n    const { progressToken, ...params } = notification.params;\n    const messageId = Number(progressToken);\n    const handler = this._progressHandlers.get(messageId);\n    if (!handler) {\n      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n      return;\n    }\n    const responseHandler = this._responseHandlers.get(messageId);\n    const timeoutInfo = this._timeoutInfo.get(messageId);\n    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {\n      try {\n        this._resetTimeout(messageId);\n      } catch (error) {\n        responseHandler(error);\n        return;\n      }\n    }\n    handler(params);\n  }\n  _onresponse(response) {\n    const messageId = Number(response.id);\n    const handler = this._responseHandlers.get(messageId);\n    if (handler === undefined) {\n      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));\n      return;\n    }\n    this._responseHandlers.delete(messageId);\n    this._progressHandlers.delete(messageId);\n    this._cleanupTimeout(messageId);\n    if (isJSONRPCResponse(response)) {\n      handler(response);\n    } else {\n      const error = new McpError(response.error.code, response.error.message, response.error.data);\n      handler(error);\n    }\n  }\n  get transport() {\n    return this._transport;\n  }\n  async close() {\n    var _a;\n    await ((_a = this._transport) === null || _a === undefined ? undefined : _a.close());\n  }\n  request(request, resultSchema, options) {\n    const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== undefined ? options : {};\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (!this._transport) {\n        reject(new Error(\"Not connected\"));\n        return;\n      }\n      if (((_a = this._options) === null || _a === undefined ? undefined : _a.enforceStrictCapabilities) === true) {\n        this.assertCapabilityForMethod(request.method);\n      }\n      (_b = options === null || options === undefined ? undefined : options.signal) === null || _b === undefined || _b.throwIfAborted();\n      const messageId = this._requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: \"2.0\",\n        id: messageId\n      };\n      if (options === null || options === undefined ? undefined : options.onprogress) {\n        this._progressHandlers.set(messageId, options.onprogress);\n        jsonrpcRequest.params = {\n          ...request.params,\n          _meta: {\n            ...((_c = request.params) === null || _c === undefined ? undefined : _c._meta) || {},\n            progressToken: messageId\n          }\n        };\n      }\n      const cancel = (reason) => {\n        var _a2;\n        this._responseHandlers.delete(messageId);\n        this._progressHandlers.delete(messageId);\n        this._cleanupTimeout(messageId);\n        (_a2 = this._transport) === null || _a2 === undefined || _a2.send({\n          jsonrpc: \"2.0\",\n          method: \"notifications/cancelled\",\n          params: {\n            requestId: messageId,\n            reason: String(reason)\n          }\n        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));\n        reject(reason);\n      };\n      this._responseHandlers.set(messageId, (response) => {\n        var _a2;\n        if ((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.aborted) {\n          return;\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      (_d = options === null || options === undefined ? undefined : options.signal) === null || _d === undefined || _d.addEventListener(\"abort\", () => {\n        var _a2;\n        cancel((_a2 = options === null || options === undefined ? undefined : options.signal) === null || _a2 === undefined ? undefined : _a2.reason);\n      });\n      const timeout = (_e = options === null || options === undefined ? undefined : options.timeout) !== null && _e !== undefined ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;\n      const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, \"Request timed out\", { timeout }));\n      this._setupTimeout(messageId, timeout, options === null || options === undefined ? undefined : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === undefined ? undefined : options.resetTimeoutOnProgress) !== null && _f !== undefined ? _f : false);\n      this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {\n        this._cleanupTimeout(messageId);\n        reject(error);\n      });\n    });\n  }\n  async notification(notification, options) {\n    var _a, _b;\n    if (!this._transport) {\n      throw new Error(\"Not connected\");\n    }\n    this.assertNotificationCapability(notification.method);\n    const debouncedMethods = (_b = (_a = this._options) === null || _a === undefined ? undefined : _a.debouncedNotificationMethods) !== null && _b !== undefined ? _b : [];\n    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === undefined ? undefined : options.relatedRequestId);\n    if (canDebounce) {\n      if (this._pendingDebouncedNotifications.has(notification.method)) {\n        return;\n      }\n      this._pendingDebouncedNotifications.add(notification.method);\n      Promise.resolve().then(() => {\n        var _a2;\n        this._pendingDebouncedNotifications.delete(notification.method);\n        if (!this._transport) {\n          return;\n        }\n        const jsonrpcNotification2 = {\n          ...notification,\n          jsonrpc: \"2.0\"\n        };\n        (_a2 = this._transport) === null || _a2 === undefined || _a2.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));\n      });\n      return;\n    }\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: \"2.0\"\n    };\n    await this._transport.send(jsonrpcNotification, options);\n  }\n  setRequestHandler(requestSchema, handler) {\n    const method = requestSchema.shape.method.value;\n    this.assertRequestHandlerCapability(method);\n    this._requestHandlers.set(method, (request, extra) => {\n      return Promise.resolve(handler(requestSchema.parse(request), extra));\n    });\n  }\n  removeRequestHandler(method) {\n    this._requestHandlers.delete(method);\n  }\n  assertCanSetRequestHandler(method) {\n    if (this._requestHandlers.has(method)) {\n      throw new Error(`A request handler for ${method} already exists, which would be overridden`);\n    }\n  }\n  setNotificationHandler(notificationSchema, handler) {\n    this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));\n  }\n  removeNotificationHandler(method) {\n    this._notificationHandlers.delete(method);\n  }\n}\nfunction mergeCapabilities(base, additional) {\n  return Object.entries(additional).reduce((acc, [key, value]) => {\n    if (value && typeof value === \"object\") {\n      acc[key] = acc[key] ? { ...acc[key], ...value } : value;\n    } else {\n      acc[key] = value;\n    }\n    return acc;\n  }, { ...base });\n}\n\n// ../node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js\nvar import_ajv = __toESM(require_ajv(), 1);\n\nclass Server extends Protocol {\n  constructor(_serverInfo, options) {\n    var _a;\n    super(options);\n    this._serverInfo = _serverInfo;\n    this._capabilities = (_a = options === null || options === undefined ? undefined : options.capabilities) !== null && _a !== undefined ? _a : {};\n    this._instructions = options === null || options === undefined ? undefined : options.instructions;\n    this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));\n    this.setNotificationHandler(InitializedNotificationSchema, () => {\n      var _a2;\n      return (_a2 = this.oninitialized) === null || _a2 === undefined ? undefined : _a2.call(this);\n    });\n  }\n  registerCapabilities(capabilities) {\n    if (this.transport) {\n      throw new Error(\"Cannot register capabilities after connecting to transport\");\n    }\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n  assertCapabilityForMethod(method) {\n    var _a, _b, _c;\n    switch (method) {\n      case \"sampling/createMessage\":\n        if (!((_a = this._clientCapabilities) === null || _a === undefined ? undefined : _a.sampling)) {\n          throw new Error(`Client does not support sampling (required for ${method})`);\n        }\n        break;\n      case \"elicitation/create\":\n        if (!((_b = this._clientCapabilities) === null || _b === undefined ? undefined : _b.elicitation)) {\n          throw new Error(`Client does not support elicitation (required for ${method})`);\n        }\n        break;\n      case \"roots/list\":\n        if (!((_c = this._clientCapabilities) === null || _c === undefined ? undefined : _c.roots)) {\n          throw new Error(`Client does not support listing roots (required for ${method})`);\n        }\n        break;\n      case \"ping\":\n        break;\n    }\n  }\n  assertNotificationCapability(method) {\n    switch (method) {\n      case \"notifications/message\":\n        if (!this._capabilities.logging) {\n          throw new Error(`Server does not support logging (required for ${method})`);\n        }\n        break;\n      case \"notifications/resources/updated\":\n      case \"notifications/resources/list_changed\":\n        if (!this._capabilities.resources) {\n          throw new Error(`Server does not support notifying about resources (required for ${method})`);\n        }\n        break;\n      case \"notifications/tools/list_changed\":\n        if (!this._capabilities.tools) {\n          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);\n        }\n        break;\n      case \"notifications/prompts/list_changed\":\n        if (!this._capabilities.prompts) {\n          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);\n        }\n        break;\n      case \"notifications/cancelled\":\n        break;\n      case \"notifications/progress\":\n        break;\n    }\n  }\n  assertRequestHandlerCapability(method) {\n    switch (method) {\n      case \"sampling/createMessage\":\n        if (!this._capabilities.sampling) {\n          throw new Error(`Server does not support sampling (required for ${method})`);\n        }\n        break;\n      case \"logging/setLevel\":\n        if (!this._capabilities.logging) {\n          throw new Error(`Server does not support logging (required for ${method})`);\n        }\n        break;\n      case \"prompts/get\":\n      case \"prompts/list\":\n        if (!this._capabilities.prompts) {\n          throw new Error(`Server does not support prompts (required for ${method})`);\n        }\n        break;\n      case \"resources/list\":\n      case \"resources/templates/list\":\n      case \"resources/read\":\n        if (!this._capabilities.resources) {\n          throw new Error(`Server does not support resources (required for ${method})`);\n        }\n        break;\n      case \"tools/call\":\n      case \"tools/list\":\n        if (!this._capabilities.tools) {\n          throw new Error(`Server does not support tools (required for ${method})`);\n        }\n        break;\n      case \"ping\":\n      case \"initialize\":\n        break;\n    }\n  }\n  async _oninitialize(request) {\n    const requestedVersion = request.params.protocolVersion;\n    this._clientCapabilities = request.params.capabilities;\n    this._clientVersion = request.params.clientInfo;\n    const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;\n    return {\n      protocolVersion,\n      capabilities: this.getCapabilities(),\n      serverInfo: this._serverInfo,\n      ...this._instructions && { instructions: this._instructions }\n    };\n  }\n  getClientCapabilities() {\n    return this._clientCapabilities;\n  }\n  getClientVersion() {\n    return this._clientVersion;\n  }\n  getCapabilities() {\n    return this._capabilities;\n  }\n  async ping() {\n    return this.request({ method: \"ping\" }, EmptyResultSchema);\n  }\n  async createMessage(params, options) {\n    return this.request({ method: \"sampling/createMessage\", params }, CreateMessageResultSchema, options);\n  }\n  async elicitInput(params, options) {\n    const result = await this.request({ method: \"elicitation/create\", params }, ElicitResultSchema, options);\n    if (result.action === \"accept\" && result.content) {\n      try {\n        const ajv = new import_ajv.default;\n        const validate = ajv.compile(params.requestedSchema);\n        const isValid2 = validate(result.content);\n        if (!isValid2) {\n          throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${ajv.errorsText(validate.errors)}`);\n        }\n      } catch (error) {\n        if (error instanceof McpError) {\n          throw error;\n        }\n        throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error}`);\n      }\n    }\n    return result;\n  }\n  async listRoots(params, options) {\n    return this.request({ method: \"roots/list\", params }, ListRootsResultSchema, options);\n  }\n  async sendLoggingMessage(params) {\n    return this.notification({ method: \"notifications/message\", params });\n  }\n  async sendResourceUpdated(params) {\n    return this.notification({\n      method: \"notifications/resources/updated\",\n      params\n    });\n  }\n  async sendResourceListChanged() {\n    return this.notification({\n      method: \"notifications/resources/list_changed\"\n    });\n  }\n  async sendToolListChanged() {\n    return this.notification({ method: \"notifications/tools/list_changed\" });\n  }\n  async sendPromptListChanged() {\n    return this.notification({ method: \"notifications/prompts/list_changed\" });\n  }\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/Options.js\nvar ignoreOverride = Symbol(\"Let zodToJsonSchema decide on which parser to use\");\nvar defaultOptions = {\n  name: undefined,\n  $refStrategy: \"root\",\n  basePath: [\"#\"],\n  effectStrategy: \"input\",\n  pipeStrategy: \"all\",\n  dateStrategy: \"format:date-time\",\n  mapStrategy: \"entries\",\n  removeAdditionalStrategy: \"passthrough\",\n  allowedAdditionalProperties: true,\n  rejectedAdditionalProperties: false,\n  definitionPath: \"definitions\",\n  target: \"jsonSchema7\",\n  strictUnions: false,\n  definitions: {},\n  errorMessages: false,\n  markdownDescription: false,\n  patternStrategy: \"escape\",\n  applyRegexFlags: false,\n  emailStrategy: \"format:email\",\n  base64Strategy: \"contentEncoding:base64\",\n  nameStrategy: \"ref\"\n};\nvar getDefaultOptions = (options) => typeof options === \"string\" ? {\n  ...defaultOptions,\n  name: options\n} : {\n  ...defaultOptions,\n  ...options\n};\n// ../node_modules/zod-to-json-schema/dist/esm/Refs.js\nvar getRefs = (options) => {\n  const _options = getDefaultOptions(options);\n  const currentPath = _options.name !== undefined ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;\n  return {\n    ..._options,\n    currentPath,\n    propertyPath: undefined,\n    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [\n      def._def,\n      {\n        def: def._def,\n        path: [..._options.basePath, _options.definitionPath, name],\n        jsonSchema: undefined\n      }\n    ]))\n  };\n};\n// ../node_modules/zod-to-json-schema/dist/esm/errorMessages.js\nfunction addErrorMessage(res, key, errorMessage, refs) {\n  if (!refs?.errorMessages)\n    return;\n  if (errorMessage) {\n    res.errorMessage = {\n      ...res.errorMessage,\n      [key]: errorMessage\n    };\n  }\n}\nfunction setResponseValueAndErrors(res, key, value, errorMessage, refs) {\n  res[key] = value;\n  addErrorMessage(res, key, errorMessage, refs);\n}\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/any.js\nfunction parseAnyDef() {\n  return {};\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/array.js\nfunction parseArrayDef(def, refs) {\n  const res = {\n    type: \"array\"\n  };\n  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {\n    res.items = parseDef(def.type._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"items\"]\n    });\n  }\n  if (def.minLength) {\n    setResponseValueAndErrors(res, \"minItems\", def.minLength.value, def.minLength.message, refs);\n  }\n  if (def.maxLength) {\n    setResponseValueAndErrors(res, \"maxItems\", def.maxLength.value, def.maxLength.message, refs);\n  }\n  if (def.exactLength) {\n    setResponseValueAndErrors(res, \"minItems\", def.exactLength.value, def.exactLength.message, refs);\n    setResponseValueAndErrors(res, \"maxItems\", def.exactLength.value, def.exactLength.message, refs);\n  }\n  return res;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js\nfunction parseBigintDef(def, refs) {\n  const res = {\n    type: \"integer\",\n    format: \"int64\"\n  };\n  if (!def.checks)\n    return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true;\n          }\n          setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true;\n          }\n          setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js\nfunction parseBooleanDef() {\n  return {\n    type: \"boolean\"\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/branded.js\nfunction parseBrandedDef(_def, refs) {\n  return parseDef(_def.type._def, refs);\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/catch.js\nvar parseCatchDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/date.js\nfunction parseDateDef(def, refs, overrideDateStrategy) {\n  const strategy = overrideDateStrategy ?? refs.dateStrategy;\n  if (Array.isArray(strategy)) {\n    return {\n      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))\n    };\n  }\n  switch (strategy) {\n    case \"string\":\n    case \"format:date-time\":\n      return {\n        type: \"string\",\n        format: \"date-time\"\n      };\n    case \"format:date\":\n      return {\n        type: \"string\",\n        format: \"date\"\n      };\n    case \"integer\":\n      return integerDateParser(def, refs);\n  }\n}\nvar integerDateParser = (def, refs) => {\n  const res = {\n    type: \"integer\",\n    format: \"unix-time\"\n  };\n  if (refs.target === \"openApi3\") {\n    return res;\n  }\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"min\":\n        setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n        break;\n      case \"max\":\n        setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n        break;\n    }\n  }\n  return res;\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/default.js\nfunction parseDefaultDef(_def, refs) {\n  return {\n    ...parseDef(_def.innerType._def, refs),\n    default: _def.defaultValue()\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/effects.js\nfunction parseEffectsDef(_def, refs) {\n  return refs.effectStrategy === \"input\" ? parseDef(_def.schema._def, refs) : {};\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/enum.js\nfunction parseEnumDef(def) {\n  return {\n    type: \"string\",\n    enum: Array.from(def.values)\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js\nvar isJsonSchema7AllOfType = (type) => {\n  if (\"type\" in type && type.type === \"string\")\n    return false;\n  return \"allOf\" in type;\n};\nfunction parseIntersectionDef(def, refs) {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n    })\n  ].filter((x) => !!x);\n  let unevaluatedProperties = refs.target === \"jsonSchema2019-09\" ? { unevaluatedProperties: false } : undefined;\n  const mergedAllOf = [];\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? {\n    allOf: mergedAllOf,\n    ...unevaluatedProperties\n  } : undefined;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/literal.js\nfunction parseLiteralDef(def, refs) {\n  const parsedType = typeof def.value;\n  if (parsedType !== \"bigint\" && parsedType !== \"number\" && parsedType !== \"boolean\" && parsedType !== \"string\") {\n    return {\n      type: Array.isArray(def.value) ? \"array\" : \"object\"\n    };\n  }\n  if (refs.target === \"openApi3\") {\n    return {\n      type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n      enum: [def.value]\n    };\n  }\n  return {\n    type: parsedType === \"bigint\" ? \"integer\" : parsedType,\n    const: def.value\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/string.js\nvar emojiRegex2 = undefined;\nvar zodPatterns = {\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  emoji: () => {\n    if (emojiRegex2 === undefined) {\n      emojiRegex2 = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n    }\n    return emojiRegex2;\n  },\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nfunction parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"max\":\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n          break;\n        case \"endsWith\":\n          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"includes\": {\n          addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n          break;\n        }\n        case \"ip\": {\n          if (check.version !== \"v6\") {\n            addFormat(res, \"ipv4\", check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addFormat(res, \"ipv6\", check.message, refs);\n          }\n          break;\n        }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\": {\n          if (check.version !== \"v6\") {\n            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n          }\n          if (check.version !== \"v4\") {\n            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n          }\n          break;\n        }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\": {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case \"base64\": {\n          switch (refs.base64Strategy) {\n            case \"format:binary\": {\n              addFormat(res, \"binary\", check.message, refs);\n              break;\n            }\n            case \"contentEncoding:base64\": {\n              setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n              break;\n            }\n            case \"pattern:zod\": {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case \"nanoid\": {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          ((_) => {})(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nvar ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0;i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\nfunction addFormat(schema, value, message, refs) {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format,\n        ...schema.errorMessage && refs.errorMessages && {\n          errorMessage: { format: schema.errorMessage.format }\n        }\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.anyOf.push({\n      format: value,\n      ...message && refs.errorMessages && { errorMessage: { format: message } }\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\nfunction addPattern(schema, regex, message, refs) {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern,\n        ...schema.errorMessage && refs.errorMessages && {\n          errorMessage: { pattern: schema.errorMessage.pattern }\n        }\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...message && refs.errorMessages && { errorMessage: { pattern: message } }\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n  }\n}\nfunction stringifyRegExpWithFlags(regex, refs) {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    m: regex.flags.includes(\"m\"),\n    s: regex.flags.includes(\"s\")\n  };\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0;i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\n` : `[${source[i]}\\r\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/record.js\nfunction parseRecordDef(def, refs) {\n  if (refs.target === \"openAi\") {\n    console.warn(\"Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.\");\n  }\n  if (refs.target === \"openApi3\" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      type: \"object\",\n      required: def.keyType._def.values,\n      properties: def.keyType._def.values.reduce((acc, key) => ({\n        ...acc,\n        [key]: parseDef(def.valueType._def, {\n          ...refs,\n          currentPath: [...refs.currentPath, \"properties\", key]\n        }) ?? {}\n      }), {}),\n      additionalProperties: refs.rejectedAdditionalProperties\n    };\n  }\n  const schema = {\n    type: \"object\",\n    additionalProperties: parseDef(def.valueType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    }) ?? refs.allowedAdditionalProperties\n  };\n  if (refs.target === \"openApi3\") {\n    return schema;\n  }\n  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {\n    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {\n    return {\n      ...schema,\n      propertyNames: {\n        enum: def.keyType._def.values\n      }\n    };\n  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {\n    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);\n    return {\n      ...schema,\n      propertyNames: keyType\n    };\n  }\n  return schema;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/map.js\nfunction parseMapDef(def, refs) {\n  if (refs.mapStrategy === \"record\") {\n    return parseRecordDef(def, refs);\n  }\n  const keys = parseDef(def.keyType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"0\"]\n  }) || {};\n  const values = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\", \"items\", \"1\"]\n  }) || {};\n  return {\n    type: \"array\",\n    maxItems: 125,\n    items: {\n      type: \"array\",\n      items: [keys, values],\n      minItems: 2,\n      maxItems: 2\n    }\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js\nfunction parseNativeEnumDef(def) {\n  const object = def.values;\n  const actualKeys = Object.keys(def.values).filter((key) => {\n    return typeof object[object[key]] !== \"number\";\n  });\n  const actualValues = actualKeys.map((key) => object[key]);\n  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));\n  return {\n    type: parsedTypes.length === 1 ? parsedTypes[0] === \"string\" ? \"string\" : \"number\" : [\"string\", \"number\"],\n    enum: actualValues\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/never.js\nfunction parseNeverDef() {\n  return {\n    not: {}\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/null.js\nfunction parseNullDef(refs) {\n  return refs.target === \"openApi3\" ? {\n    enum: [\"null\"],\n    nullable: true\n  } : {\n    type: \"null\"\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/union.js\nvar primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nfunction parseUnionDef(def, refs) {\n  if (refs.target === \"openApi3\")\n    return asAnyOf(def, refs);\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  if (options.every((x) => (x._def.typeName in primitiveMappings) && (!x._def.checks || !x._def.checks.length))) {\n    const types2 = options.reduce((types3, x) => {\n      const type = primitiveMappings[x._def.typeName];\n      return type && !types3.includes(type) ? [...types3, type] : types3;\n    }, []);\n    return {\n      type: types2.length > 1 ? types2 : types2[0]\n    };\n  } else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    const types2 = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          return [...acc, type];\n        case \"bigint\":\n          return [...acc, \"integer\"];\n        case \"object\":\n          if (x._def.value === null)\n            return [...acc, \"null\"];\n        case \"symbol\":\n        case \"undefined\":\n        case \"function\":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types2.length === options.length) {\n      const uniqueTypes = types2.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce((acc, x) => [\n        ...acc,\n        ...x._def.values.filter((x2) => !acc.includes(x2))\n      ], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nvar asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n  })).filter((x) => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0));\n  return anyOf.length ? { anyOf } : undefined;\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js\nfunction parseNullableDef(def, refs) {\n  if ([\"ZodString\", \"ZodNumber\", \"ZodBigInt\", \"ZodBoolean\", \"ZodNull\"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {\n    if (refs.target === \"openApi3\") {\n      return {\n        type: primitiveMappings[def.innerType._def.typeName],\n        nullable: true\n      };\n    }\n    return {\n      type: [\n        primitiveMappings[def.innerType._def.typeName],\n        \"null\"\n      ]\n    };\n  }\n  if (refs.target === \"openApi3\") {\n    const base2 = parseDef(def.innerType._def, {\n      ...refs,\n      currentPath: [...refs.currentPath]\n    });\n    if (base2 && \"$ref\" in base2)\n      return { allOf: [base2], nullable: true };\n    return base2 && { ...base2, nullable: true };\n  }\n  const base = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"0\"]\n  });\n  return base && { anyOf: [base, { type: \"null\" }] };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/number.js\nfunction parseNumberDef(def, refs) {\n  const res = {\n    type: \"number\"\n  };\n  if (!def.checks)\n    return res;\n  for (const check of def.checks) {\n    switch (check.kind) {\n      case \"int\":\n        res.type = \"integer\";\n        addErrorMessage(res, \"type\", check.message, refs);\n        break;\n      case \"min\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMinimum\", check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMinimum = true;\n          }\n          setResponseValueAndErrors(res, \"minimum\", check.value, check.message, refs);\n        }\n        break;\n      case \"max\":\n        if (refs.target === \"jsonSchema7\") {\n          if (check.inclusive) {\n            setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n          } else {\n            setResponseValueAndErrors(res, \"exclusiveMaximum\", check.value, check.message, refs);\n          }\n        } else {\n          if (!check.inclusive) {\n            res.exclusiveMaximum = true;\n          }\n          setResponseValueAndErrors(res, \"maximum\", check.value, check.message, refs);\n        }\n        break;\n      case \"multipleOf\":\n        setResponseValueAndErrors(res, \"multipleOf\", check.value, check.message, refs);\n        break;\n    }\n  }\n  return res;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/object.js\nfunction parseObjectDef(def, refs) {\n  const forceOptionalIntoNullable = refs.target === \"openAi\";\n  const result = {\n    type: \"object\",\n    properties: {}\n  };\n  const required = [];\n  const shape = def.shape();\n  for (const propName in shape) {\n    let propDef = shape[propName];\n    if (propDef === undefined || propDef._def === undefined) {\n      continue;\n    }\n    let propOptional = safeIsOptional(propDef);\n    if (propOptional && forceOptionalIntoNullable) {\n      if (propDef instanceof ZodOptional) {\n        propDef = propDef._def.innerType;\n      }\n      if (!propDef.isNullable()) {\n        propDef = propDef.nullable();\n      }\n      propOptional = false;\n    }\n    const parsedDef = parseDef(propDef._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"properties\", propName],\n      propertyPath: [...refs.currentPath, \"properties\", propName]\n    });\n    if (parsedDef === undefined) {\n      continue;\n    }\n    result.properties[propName] = parsedDef;\n    if (!propOptional) {\n      required.push(propName);\n    }\n  }\n  if (required.length) {\n    result.required = required;\n  }\n  const additionalProperties = decideAdditionalProperties(def, refs);\n  if (additionalProperties !== undefined) {\n    result.additionalProperties = additionalProperties;\n  }\n  return result;\n}\nfunction decideAdditionalProperties(def, refs) {\n  if (def.catchall._def.typeName !== \"ZodNever\") {\n    return parseDef(def.catchall._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, \"additionalProperties\"]\n    });\n  }\n  switch (def.unknownKeys) {\n    case \"passthrough\":\n      return refs.allowedAdditionalProperties;\n    case \"strict\":\n      return refs.rejectedAdditionalProperties;\n    case \"strip\":\n      return refs.removeAdditionalStrategy === \"strict\" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;\n  }\n}\nfunction safeIsOptional(schema) {\n  try {\n    return schema.isOptional();\n  } catch {\n    return true;\n  }\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/optional.js\nvar parseOptionalDef = (def, refs) => {\n  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {\n    return parseDef(def.innerType._def, refs);\n  }\n  const innerSchema = parseDef(def.innerType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", \"1\"]\n  });\n  return innerSchema ? {\n    anyOf: [\n      {\n        not: {}\n      },\n      innerSchema\n    ]\n  } : {};\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js\nvar parsePipelineDef = (def, refs) => {\n  if (refs.pipeStrategy === \"input\") {\n    return parseDef(def.in._def, refs);\n  } else if (refs.pipeStrategy === \"output\") {\n    return parseDef(def.out._def, refs);\n  }\n  const a = parseDef(def.in._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  });\n  const b = parseDef(def.out._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", a ? \"1\" : \"0\"]\n  });\n  return {\n    allOf: [a, b].filter((x) => x !== undefined)\n  };\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/promise.js\nfunction parsePromiseDef(def, refs) {\n  return parseDef(def.type._def, refs);\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/set.js\nfunction parseSetDef(def, refs) {\n  const items = parseDef(def.valueType._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"items\"]\n  });\n  const schema = {\n    type: \"array\",\n    uniqueItems: true,\n    items\n  };\n  if (def.minSize) {\n    setResponseValueAndErrors(schema, \"minItems\", def.minSize.value, def.minSize.message, refs);\n  }\n  if (def.maxSize) {\n    setResponseValueAndErrors(schema, \"maxItems\", def.maxSize.value, def.maxSize.message, refs);\n  }\n  return schema;\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js\nfunction parseTupleDef(def, refs) {\n  if (def.rest) {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      items: def.items.map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], []),\n      additionalItems: parseDef(def.rest._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"additionalItems\"]\n      })\n    };\n  } else {\n    return {\n      type: \"array\",\n      minItems: def.items.length,\n      maxItems: def.items.length,\n      items: def.items.map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"items\", `${i}`]\n      })).reduce((acc, x) => x === undefined ? acc : [...acc, x], [])\n    };\n  }\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js\nfunction parseUndefinedDef() {\n  return {\n    not: {}\n  };\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js\nfunction parseUnknownDef() {\n  return {};\n}\n\n// ../node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js\nvar parseReadonlyDef = (def, refs) => {\n  return parseDef(def.innerType._def, refs);\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/selectParser.js\nvar selectParser = (def, typeName, refs) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return () => def.getter()._def;\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return;\n    default:\n      return ((_) => {\n        return;\n      })(typeName);\n  }\n};\n\n// ../node_modules/zod-to-json-schema/dist/esm/parseDef.js\nfunction parseDef(def, refs, forceResolution = false) {\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      return seenSchema;\n    }\n  }\n  const newItem = { def, path: refs.currentPath, jsonSchema: undefined };\n  refs.seen.set(def, newItem);\n  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);\n  const jsonSchema = typeof jsonSchemaOrGetter === \"function\" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n  if (refs.postProcess) {\n    const postProcessResult = refs.postProcess(jsonSchema, def, refs);\n    newItem.jsonSchema = jsonSchema;\n    return postProcessResult;\n  }\n  newItem.jsonSchema = jsonSchema;\n  return jsonSchema;\n}\nvar get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case \"root\":\n      return { $ref: item.path.join(\"/\") };\n    case \"relative\":\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case \"none\":\n    case \"seen\": {\n      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n        console.warn(`Recursive reference detected at ${refs.currentPath.join(\"/\")}! Defaulting to any`);\n        return {};\n      }\n      return refs.$refStrategy === \"seen\" ? {} : undefined;\n    }\n  }\n};\nvar getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (;i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i])\n      break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join(\"/\");\n};\nvar addMeta = (def, refs, jsonSchema) => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};\n// ../node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js\nvar zodToJsonSchema = (schema, options) => {\n  const refs = getRefs(options);\n  const definitions = typeof options === \"object\" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({\n    ...acc,\n    [name2]: parseDef(schema2._def, {\n      ...refs,\n      currentPath: [...refs.basePath, refs.definitionPath, name2]\n    }, true) ?? {}\n  }), {}) : undefined;\n  const name = typeof options === \"string\" ? options : options?.nameStrategy === \"title\" ? undefined : options?.name;\n  const main = parseDef(schema._def, name === undefined ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name]\n  }, false) ?? {};\n  const title = typeof options === \"object\" && options.name !== undefined && options.nameStrategy === \"title\" ? options.name : undefined;\n  if (title !== undefined) {\n    main.title = title;\n  }\n  const combined = name === undefined ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : {\n    $ref: [\n      ...refs.$refStrategy === \"relative\" ? [] : refs.basePath,\n      refs.definitionPath,\n      name\n    ].join(\"/\"),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name]: main\n    }\n  };\n  if (refs.target === \"jsonSchema7\") {\n    combined.$schema = \"http://json-schema.org/draft-07/schema#\";\n  } else if (refs.target === \"jsonSchema2019-09\" || refs.target === \"openAi\") {\n    combined.$schema = \"https://json-schema.org/draft/2019-09/schema#\";\n  }\n  if (refs.target === \"openAi\" && ((\"anyOf\" in combined) || (\"oneOf\" in combined) || (\"allOf\" in combined) || (\"type\" in combined) && Array.isArray(combined.type))) {\n    console.warn(\"Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.\");\n  }\n  return combined;\n};\n// ../node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js\nvar McpZodTypeKind;\n(function(McpZodTypeKind2) {\n  McpZodTypeKind2[\"Completable\"] = \"McpCompletable\";\n})(McpZodTypeKind || (McpZodTypeKind = {}));\n\nclass Completable extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\nCompletable.create = (type, params) => {\n  return new Completable({\n    type,\n    typeName: McpZodTypeKind.Completable,\n    complete: params.complete,\n    ...processCreateParams2(params)\n  });\n};\nfunction processCreateParams2(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    var _a, _b;\n    const { message } = params;\n    if (iss.code === \"invalid_enum_value\") {\n      return { message: message !== null && message !== undefined ? message : ctx.defaultError };\n    }\n    if (typeof ctx.data === \"undefined\") {\n      return { message: (_a = message !== null && message !== undefined ? message : required_error) !== null && _a !== undefined ? _a : ctx.defaultError };\n    }\n    if (iss.code !== \"invalid_type\")\n      return { message: ctx.defaultError };\n    return { message: (_b = message !== null && message !== undefined ? message : invalid_type_error) !== null && _b !== undefined ? _b : ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\n\n// ../node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js\nclass McpServer {\n  constructor(serverInfo, options) {\n    this._registeredResources = {};\n    this._registeredResourceTemplates = {};\n    this._registeredTools = {};\n    this._registeredPrompts = {};\n    this._toolHandlersInitialized = false;\n    this._completionHandlerInitialized = false;\n    this._resourceHandlersInitialized = false;\n    this._promptHandlersInitialized = false;\n    this.server = new Server(serverInfo, options);\n  }\n  async connect(transport) {\n    return await this.server.connect(transport);\n  }\n  async close() {\n    await this.server.close();\n  }\n  setToolRequestHandlers() {\n    if (this._toolHandlersInitialized) {\n      return;\n    }\n    this.server.assertCanSetRequestHandler(ListToolsRequestSchema.shape.method.value);\n    this.server.assertCanSetRequestHandler(CallToolRequestSchema.shape.method.value);\n    this.server.registerCapabilities({\n      tools: {\n        listChanged: true\n      }\n    });\n    this.server.setRequestHandler(ListToolsRequestSchema, () => ({\n      tools: Object.entries(this._registeredTools).filter(([, tool]) => tool.enabled).map(([name, tool]) => {\n        const toolDefinition = {\n          name,\n          title: tool.title,\n          description: tool.description,\n          inputSchema: tool.inputSchema ? zodToJsonSchema(tool.inputSchema, {\n            strictUnions: true\n          }) : EMPTY_OBJECT_JSON_SCHEMA,\n          annotations: tool.annotations\n        };\n        if (tool.outputSchema) {\n          toolDefinition.outputSchema = zodToJsonSchema(tool.outputSchema, { strictUnions: true });\n        }\n        return toolDefinition;\n      })\n    }));\n    this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {\n      const tool = this._registeredTools[request.params.name];\n      if (!tool) {\n        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);\n      }\n      if (!tool.enabled) {\n        throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} disabled`);\n      }\n      let result;\n      if (tool.inputSchema) {\n        const parseResult = await tool.inputSchema.safeParseAsync(request.params.arguments);\n        if (!parseResult.success) {\n          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for tool ${request.params.name}: ${parseResult.error.message}`);\n        }\n        const args = parseResult.data;\n        const cb = tool.callback;\n        try {\n          result = await Promise.resolve(cb(args, extra));\n        } catch (error) {\n          result = {\n            content: [\n              {\n                type: \"text\",\n                text: error instanceof Error ? error.message : String(error)\n              }\n            ],\n            isError: true\n          };\n        }\n      } else {\n        const cb = tool.callback;\n        try {\n          result = await Promise.resolve(cb(extra));\n        } catch (error) {\n          result = {\n            content: [\n              {\n                type: \"text\",\n                text: error instanceof Error ? error.message : String(error)\n              }\n            ],\n            isError: true\n          };\n        }\n      }\n      if (tool.outputSchema && !result.isError) {\n        if (!result.structuredContent) {\n          throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} has an output schema but no structured content was provided`);\n        }\n        const parseResult = await tool.outputSchema.safeParseAsync(result.structuredContent);\n        if (!parseResult.success) {\n          throw new McpError(ErrorCode.InvalidParams, `Invalid structured content for tool ${request.params.name}: ${parseResult.error.message}`);\n        }\n      }\n      return result;\n    });\n    this._toolHandlersInitialized = true;\n  }\n  setCompletionRequestHandler() {\n    if (this._completionHandlerInitialized) {\n      return;\n    }\n    this.server.assertCanSetRequestHandler(CompleteRequestSchema.shape.method.value);\n    this.server.registerCapabilities({\n      completions: {}\n    });\n    this.server.setRequestHandler(CompleteRequestSchema, async (request) => {\n      switch (request.params.ref.type) {\n        case \"ref/prompt\":\n          return this.handlePromptCompletion(request, request.params.ref);\n        case \"ref/resource\":\n          return this.handleResourceCompletion(request, request.params.ref);\n        default:\n          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);\n      }\n    });\n    this._completionHandlerInitialized = true;\n  }\n  async handlePromptCompletion(request, ref) {\n    const prompt = this._registeredPrompts[ref.name];\n    if (!prompt) {\n      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} not found`);\n    }\n    if (!prompt.enabled) {\n      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} disabled`);\n    }\n    if (!prompt.argsSchema) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n    const field = prompt.argsSchema.shape[request.params.argument.name];\n    if (!(field instanceof Completable)) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n    const def = field._def;\n    const suggestions = await def.complete(request.params.argument.value, request.params.context);\n    return createCompletionResult(suggestions);\n  }\n  async handleResourceCompletion(request, ref) {\n    const template = Object.values(this._registeredResourceTemplates).find((t) => t.resourceTemplate.uriTemplate.toString() === ref.uri);\n    if (!template) {\n      if (this._registeredResources[ref.uri]) {\n        return EMPTY_COMPLETION_RESULT;\n      }\n      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);\n    }\n    const completer = template.resourceTemplate.completeCallback(request.params.argument.name);\n    if (!completer) {\n      return EMPTY_COMPLETION_RESULT;\n    }\n    const suggestions = await completer(request.params.argument.value, request.params.context);\n    return createCompletionResult(suggestions);\n  }\n  setResourceRequestHandlers() {\n    if (this._resourceHandlersInitialized) {\n      return;\n    }\n    this.server.assertCanSetRequestHandler(ListResourcesRequestSchema.shape.method.value);\n    this.server.assertCanSetRequestHandler(ListResourceTemplatesRequestSchema.shape.method.value);\n    this.server.assertCanSetRequestHandler(ReadResourceRequestSchema.shape.method.value);\n    this.server.registerCapabilities({\n      resources: {\n        listChanged: true\n      }\n    });\n    this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {\n      const resources = Object.entries(this._registeredResources).filter(([_, resource]) => resource.enabled).map(([uri, resource]) => ({\n        uri,\n        name: resource.name,\n        ...resource.metadata\n      }));\n      const templateResources = [];\n      for (const template of Object.values(this._registeredResourceTemplates)) {\n        if (!template.resourceTemplate.listCallback) {\n          continue;\n        }\n        const result = await template.resourceTemplate.listCallback(extra);\n        for (const resource of result.resources) {\n          templateResources.push({\n            ...template.metadata,\n            ...resource\n          });\n        }\n      }\n      return { resources: [...resources, ...templateResources] };\n    });\n    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {\n      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({\n        name,\n        uriTemplate: template.resourceTemplate.uriTemplate.toString(),\n        ...template.metadata\n      }));\n      return { resourceTemplates };\n    });\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {\n      const uri = new URL(request.params.uri);\n      const resource = this._registeredResources[uri.toString()];\n      if (resource) {\n        if (!resource.enabled) {\n          throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);\n        }\n        return resource.readCallback(uri, extra);\n      }\n      for (const template of Object.values(this._registeredResourceTemplates)) {\n        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());\n        if (variables) {\n          return template.readCallback(uri, variables, extra);\n        }\n      }\n      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);\n    });\n    this.setCompletionRequestHandler();\n    this._resourceHandlersInitialized = true;\n  }\n  setPromptRequestHandlers() {\n    if (this._promptHandlersInitialized) {\n      return;\n    }\n    this.server.assertCanSetRequestHandler(ListPromptsRequestSchema.shape.method.value);\n    this.server.assertCanSetRequestHandler(GetPromptRequestSchema.shape.method.value);\n    this.server.registerCapabilities({\n      prompts: {\n        listChanged: true\n      }\n    });\n    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({\n      prompts: Object.entries(this._registeredPrompts).filter(([, prompt]) => prompt.enabled).map(([name, prompt]) => {\n        return {\n          name,\n          title: prompt.title,\n          description: prompt.description,\n          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : undefined\n        };\n      })\n    }));\n    this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {\n      const prompt = this._registeredPrompts[request.params.name];\n      if (!prompt) {\n        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);\n      }\n      if (!prompt.enabled) {\n        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} disabled`);\n      }\n      if (prompt.argsSchema) {\n        const parseResult = await prompt.argsSchema.safeParseAsync(request.params.arguments);\n        if (!parseResult.success) {\n          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${parseResult.error.message}`);\n        }\n        const args = parseResult.data;\n        const cb = prompt.callback;\n        return await Promise.resolve(cb(args, extra));\n      } else {\n        const cb = prompt.callback;\n        return await Promise.resolve(cb(extra));\n      }\n    });\n    this.setCompletionRequestHandler();\n    this._promptHandlersInitialized = true;\n  }\n  resource(name, uriOrTemplate, ...rest) {\n    let metadata;\n    if (typeof rest[0] === \"object\") {\n      metadata = rest.shift();\n    }\n    const readCallback = rest[0];\n    if (typeof uriOrTemplate === \"string\") {\n      if (this._registeredResources[uriOrTemplate]) {\n        throw new Error(`Resource ${uriOrTemplate} is already registered`);\n      }\n      const registeredResource = this._createRegisteredResource(name, undefined, uriOrTemplate, metadata, readCallback);\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResource;\n    } else {\n      if (this._registeredResourceTemplates[name]) {\n        throw new Error(`Resource template ${name} is already registered`);\n      }\n      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, undefined, uriOrTemplate, metadata, readCallback);\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResourceTemplate;\n    }\n  }\n  registerResource(name, uriOrTemplate, config, readCallback) {\n    if (typeof uriOrTemplate === \"string\") {\n      if (this._registeredResources[uriOrTemplate]) {\n        throw new Error(`Resource ${uriOrTemplate} is already registered`);\n      }\n      const registeredResource = this._createRegisteredResource(name, config.title, uriOrTemplate, config, readCallback);\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResource;\n    } else {\n      if (this._registeredResourceTemplates[name]) {\n        throw new Error(`Resource template ${name} is already registered`);\n      }\n      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, config.title, uriOrTemplate, config, readCallback);\n      this.setResourceRequestHandlers();\n      this.sendResourceListChanged();\n      return registeredResourceTemplate;\n    }\n  }\n  _createRegisteredResource(name, title, uri, metadata, readCallback) {\n    const registeredResource = {\n      name,\n      title,\n      metadata,\n      readCallback,\n      enabled: true,\n      disable: () => registeredResource.update({ enabled: false }),\n      enable: () => registeredResource.update({ enabled: true }),\n      remove: () => registeredResource.update({ uri: null }),\n      update: (updates) => {\n        if (typeof updates.uri !== \"undefined\" && updates.uri !== uri) {\n          delete this._registeredResources[uri];\n          if (updates.uri)\n            this._registeredResources[updates.uri] = registeredResource;\n        }\n        if (typeof updates.name !== \"undefined\")\n          registeredResource.name = updates.name;\n        if (typeof updates.title !== \"undefined\")\n          registeredResource.title = updates.title;\n        if (typeof updates.metadata !== \"undefined\")\n          registeredResource.metadata = updates.metadata;\n        if (typeof updates.callback !== \"undefined\")\n          registeredResource.readCallback = updates.callback;\n        if (typeof updates.enabled !== \"undefined\")\n          registeredResource.enabled = updates.enabled;\n        this.sendResourceListChanged();\n      }\n    };\n    this._registeredResources[uri] = registeredResource;\n    return registeredResource;\n  }\n  _createRegisteredResourceTemplate(name, title, template, metadata, readCallback) {\n    const registeredResourceTemplate = {\n      resourceTemplate: template,\n      title,\n      metadata,\n      readCallback,\n      enabled: true,\n      disable: () => registeredResourceTemplate.update({ enabled: false }),\n      enable: () => registeredResourceTemplate.update({ enabled: true }),\n      remove: () => registeredResourceTemplate.update({ name: null }),\n      update: (updates) => {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredResourceTemplates[name];\n          if (updates.name)\n            this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;\n        }\n        if (typeof updates.title !== \"undefined\")\n          registeredResourceTemplate.title = updates.title;\n        if (typeof updates.template !== \"undefined\")\n          registeredResourceTemplate.resourceTemplate = updates.template;\n        if (typeof updates.metadata !== \"undefined\")\n          registeredResourceTemplate.metadata = updates.metadata;\n        if (typeof updates.callback !== \"undefined\")\n          registeredResourceTemplate.readCallback = updates.callback;\n        if (typeof updates.enabled !== \"undefined\")\n          registeredResourceTemplate.enabled = updates.enabled;\n        this.sendResourceListChanged();\n      }\n    };\n    this._registeredResourceTemplates[name] = registeredResourceTemplate;\n    return registeredResourceTemplate;\n  }\n  _createRegisteredPrompt(name, title, description, argsSchema, callback) {\n    const registeredPrompt = {\n      title,\n      description,\n      argsSchema: argsSchema === undefined ? undefined : exports_external.object(argsSchema),\n      callback,\n      enabled: true,\n      disable: () => registeredPrompt.update({ enabled: false }),\n      enable: () => registeredPrompt.update({ enabled: true }),\n      remove: () => registeredPrompt.update({ name: null }),\n      update: (updates) => {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredPrompts[name];\n          if (updates.name)\n            this._registeredPrompts[updates.name] = registeredPrompt;\n        }\n        if (typeof updates.title !== \"undefined\")\n          registeredPrompt.title = updates.title;\n        if (typeof updates.description !== \"undefined\")\n          registeredPrompt.description = updates.description;\n        if (typeof updates.argsSchema !== \"undefined\")\n          registeredPrompt.argsSchema = exports_external.object(updates.argsSchema);\n        if (typeof updates.callback !== \"undefined\")\n          registeredPrompt.callback = updates.callback;\n        if (typeof updates.enabled !== \"undefined\")\n          registeredPrompt.enabled = updates.enabled;\n        this.sendPromptListChanged();\n      }\n    };\n    this._registeredPrompts[name] = registeredPrompt;\n    return registeredPrompt;\n  }\n  _createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, callback) {\n    const registeredTool = {\n      title,\n      description,\n      inputSchema: inputSchema === undefined ? undefined : exports_external.object(inputSchema),\n      outputSchema: outputSchema === undefined ? undefined : exports_external.object(outputSchema),\n      annotations,\n      callback,\n      enabled: true,\n      disable: () => registeredTool.update({ enabled: false }),\n      enable: () => registeredTool.update({ enabled: true }),\n      remove: () => registeredTool.update({ name: null }),\n      update: (updates) => {\n        if (typeof updates.name !== \"undefined\" && updates.name !== name) {\n          delete this._registeredTools[name];\n          if (updates.name)\n            this._registeredTools[updates.name] = registeredTool;\n        }\n        if (typeof updates.title !== \"undefined\")\n          registeredTool.title = updates.title;\n        if (typeof updates.description !== \"undefined\")\n          registeredTool.description = updates.description;\n        if (typeof updates.paramsSchema !== \"undefined\")\n          registeredTool.inputSchema = exports_external.object(updates.paramsSchema);\n        if (typeof updates.callback !== \"undefined\")\n          registeredTool.callback = updates.callback;\n        if (typeof updates.annotations !== \"undefined\")\n          registeredTool.annotations = updates.annotations;\n        if (typeof updates.enabled !== \"undefined\")\n          registeredTool.enabled = updates.enabled;\n        this.sendToolListChanged();\n      }\n    };\n    this._registeredTools[name] = registeredTool;\n    this.setToolRequestHandlers();\n    this.sendToolListChanged();\n    return registeredTool;\n  }\n  tool(name, ...rest) {\n    if (this._registeredTools[name]) {\n      throw new Error(`Tool ${name} is already registered`);\n    }\n    let description;\n    let inputSchema;\n    let outputSchema;\n    let annotations;\n    if (typeof rest[0] === \"string\") {\n      description = rest.shift();\n    }\n    if (rest.length > 1) {\n      const firstArg = rest[0];\n      if (isZodRawShape(firstArg)) {\n        inputSchema = rest.shift();\n        if (rest.length > 1 && typeof rest[0] === \"object\" && rest[0] !== null && !isZodRawShape(rest[0])) {\n          annotations = rest.shift();\n        }\n      } else if (typeof firstArg === \"object\" && firstArg !== null) {\n        annotations = rest.shift();\n      }\n    }\n    const callback = rest[0];\n    return this._createRegisteredTool(name, undefined, description, inputSchema, outputSchema, annotations, callback);\n  }\n  registerTool(name, config, cb) {\n    if (this._registeredTools[name]) {\n      throw new Error(`Tool ${name} is already registered`);\n    }\n    const { title, description, inputSchema, outputSchema, annotations } = config;\n    return this._createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, cb);\n  }\n  prompt(name, ...rest) {\n    if (this._registeredPrompts[name]) {\n      throw new Error(`Prompt ${name} is already registered`);\n    }\n    let description;\n    if (typeof rest[0] === \"string\") {\n      description = rest.shift();\n    }\n    let argsSchema;\n    if (rest.length > 1) {\n      argsSchema = rest.shift();\n    }\n    const cb = rest[0];\n    const registeredPrompt = this._createRegisteredPrompt(name, undefined, description, argsSchema, cb);\n    this.setPromptRequestHandlers();\n    this.sendPromptListChanged();\n    return registeredPrompt;\n  }\n  registerPrompt(name, config, cb) {\n    if (this._registeredPrompts[name]) {\n      throw new Error(`Prompt ${name} is already registered`);\n    }\n    const { title, description, argsSchema } = config;\n    const registeredPrompt = this._createRegisteredPrompt(name, title, description, argsSchema, cb);\n    this.setPromptRequestHandlers();\n    this.sendPromptListChanged();\n    return registeredPrompt;\n  }\n  isConnected() {\n    return this.server.transport !== undefined;\n  }\n  sendResourceListChanged() {\n    if (this.isConnected()) {\n      this.server.sendResourceListChanged();\n    }\n  }\n  sendToolListChanged() {\n    if (this.isConnected()) {\n      this.server.sendToolListChanged();\n    }\n  }\n  sendPromptListChanged() {\n    if (this.isConnected()) {\n      this.server.sendPromptListChanged();\n    }\n  }\n}\nvar EMPTY_OBJECT_JSON_SCHEMA = {\n  type: \"object\",\n  properties: {}\n};\nfunction isZodRawShape(obj) {\n  if (typeof obj !== \"object\" || obj === null)\n    return false;\n  const isEmptyObject = Object.keys(obj).length === 0;\n  return isEmptyObject || Object.values(obj).some(isZodTypeLike);\n}\nfunction isZodTypeLike(value) {\n  return value !== null && typeof value === \"object\" && \"parse\" in value && typeof value.parse === \"function\" && \"safeParse\" in value && typeof value.safeParse === \"function\";\n}\nfunction promptArgumentsFromSchema(schema) {\n  return Object.entries(schema.shape).map(([name, field]) => ({\n    name,\n    description: field.description,\n    required: !field.isOptional()\n  }));\n}\nfunction createCompletionResult(suggestions) {\n  return {\n    completion: {\n      values: suggestions.slice(0, 100),\n      total: suggestions.length,\n      hasMore: suggestions.length > 100\n    }\n  };\n}\nvar EMPTY_COMPLETION_RESULT = {\n  completion: {\n    values: [],\n    hasMore: false\n  }\n};\n\n// ../src/services/mcp/createSdkMcpServer.ts\nfunction tool(name, description, inputSchema, handler) {\n  return { name, description, inputSchema, handler };\n}\nfunction createSdkMcpServer(options) {\n  const server = new McpServer({\n    name: options.name,\n    version: options.version ?? \"1.0.0\"\n  }, {\n    capabilities: {\n      tools: options.tools ? {} : undefined\n    }\n  });\n  if (options.tools) {\n    options.tools.forEach((toolDef) => {\n      server.tool(toolDef.name, toolDef.description, toolDef.inputSchema, toolDef.handler);\n    });\n  }\n  return {\n    type: \"sdk\",\n    name: options.name,\n    instance: server\n  };\n}\n// ../src/entrypoints/agentSdk.ts\nfunction query({\n  prompt,\n  options\n}) {\n  const { systemPrompt, settingSources, ...rest } = options ?? {};\n  let customSystemPrompt;\n  let appendSystemPrompt;\n  if (systemPrompt === undefined) {\n    customSystemPrompt = \"\";\n  } else if (typeof systemPrompt === \"string\") {\n    customSystemPrompt = systemPrompt;\n  } else if (systemPrompt.type === \"preset\") {\n    appendSystemPrompt = systemPrompt.append;\n  }\n  let pathToClaudeCodeExecutable = rest.pathToClaudeCodeExecutable;\n  if (!pathToClaudeCodeExecutable) {\n    const filename = (0,url__WEBPACK_IMPORTED_MODULE_1__.fileURLToPath)(\"file:///Users/bc/Desktop/pip-agent-autonomous/node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs\");\n    const dirname2 = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(filename, \"..\");\n    pathToClaudeCodeExecutable = (0,path__WEBPACK_IMPORTED_MODULE_0__.join)(dirname2, \"cli.js\");\n  }\n  process.env.CLAUDE_AGENT_SDK_VERSION = \"0.1.14\";\n  return createSharedQuery({\n    prompt,\n    options: {\n      ...rest,\n      pathToClaudeCodeExecutable,\n      customSystemPrompt,\n      appendSystemPrompt,\n      settingSources: settingSources ?? []\n    }\n  });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvY2xhdWRlLWFnZW50LXNkay9zZGsubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw4QkFBOEI7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseU1BQXlNO0FBQ3pNLEdBQUc7QUFDSDtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNlQUFzZSwrN0JBQSs3QixJQUFJLHNIQUFzSCxFQUFFLHVFQUF1RSxFQUFFLHVGQUF1RixFQUFFLG1FQUFtRSxJQUFJLGlEQUFpRCxFQUFFLG1FQUFtRSxJQUFJLGlEQUFpRCxFQUFFLG1FQUFtRSxJQUFJLHNHQUFzRyxJQUFJLHVGQUF1RixJQUFJLHNGQUFzRixJQUFJLCtZQUErWSxFQUFFLDB2RUFBMHZFLEVBQUU7QUFDMTZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLEVBQUU7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwrQkFBK0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnRUFBZ0U7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1FQUFtRTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLG1FQUFtRTtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZ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QUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1C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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxzQ0FBc0MsSUFBSTtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU0sMEJBQTBCLEtBQUssb0NBQW9DLEtBQUs7QUFDdEcseUVBQXlFLGNBQWMsRUFBRSwrQkFBK0IsSUFBSSxHQUFHLEVBQUUsZUFBZSxJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksZ0JBQWdCLElBQUksR0FBRyxFQUFFLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksYUFBYSxJQUFJLGlCQUFpQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksaUJBQWlCLElBQUksVUFBVSxJQUFJLHVDQUF1QyxFQUFFLGdEQUFnRCxJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUksMkNBQTJDLDhDQUE4QyxFQUFFLHlEQUF5RCxhQUFhLEVBQUUsMENBQTBDLGVBQWUsRUFBRSxtQ0FBbUMsZUFBZSxFQUFFLGdDQUFnQyxlQUFlLEVBQUUsZ0NBQWdDLGVBQWUsRUFBRSxnQ0FBZ0MsZUFBZSxFQUFFLG1DQUFtQyxpQkFBaUIsRUFBRSxpQ0FBaUMsaUJBQWlCLEVBQUU7QUFDbm9DLDZFQUE2RSxjQUFjLEVBQUUsK0JBQStCLElBQUksR0FBRyxFQUFFLGVBQWUsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGdCQUFnQixJQUFJLEdBQUcsRUFBRSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxpQkFBaUIsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGlCQUFpQixJQUFJLFVBQVUsSUFBSSx1Q0FBdUMsRUFBRSxnREFBZ0QsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxHQUFHLElBQUksU0FBUyxJQUFJLDJDQUEyQyw4Q0FBOEMsRUFBRSwwREFBMEQsYUFBYSxFQUFFLDJDQUEyQyxlQUFlLEVBQUUsb0NBQW9DLGVBQWUsRUFBRSxpQ0FBaUMsZUFBZSxFQUFFLGlDQUFpQyxlQUFlLEVBQUUsaUNBQWlDLGVBQWUsRUFBRSxxQ0FBcUMsaUJBQWlCLEVBQUUsa0NBQWtDLGlCQUFpQixFQUFFO0FBQ2hwQyxpREFBaUQsRUFBRSxZQUFZLEVBQUUsSUFBSSxNQUFNLGdDQUFnQyxFQUFFLGlCQUFpQixJQUFJLGdDQUFnQyxFQUFFLGlCQUFpQixJQUFJLFNBQVM7QUFDbE0sNmpCQUE2akIsSUFBSSxFQUFFLEVBQUUsa0JBQWtCLElBQUksRUFBRSxFQUFFLHVCQUF1QixJQUFJLEVBQUUsRUFBRSx1QkFBdUIsSUFBSSxFQUFFLEVBQUUsMkNBQTJDLElBQUksRUFBRSxFQUFFLCtEQUErRCxJQUFJLHVCQUF1QixFQUFFLHduQkFBd25CLEdBQUcsYUFBYSxJQUFJO0FBQ3g3QyxzQ0FBc0MsRUFBRSxhQUFhLEVBQUUsR0FBRyxFQUFFLFNBQVMsR0FBRztBQUN4RTtBQUNBLGtFQUFrRSxlQUFlLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLDBCQUEwQixLQUFLLG9DQUFvQyxLQUFLO0FBQzlHO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQsaUNBQWlDLElBQUksR0FBRyxFQUFFLFlBQVksSUFBSSxvQkFBb0IsSUFBSSxHQUFHLEVBQUUsYUFBYSxJQUFJLGlGQUFpRixFQUFFLHFCQUFxQixJQUFJLEdBQUcsRUFBRSxtQkFBbUIsSUFBSSxFQUFFLElBQUksbUZBQW1GLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLG1CQUFtQixJQUFJLEVBQUUsSUFBSSxrQkFBa0IsSUFBSSxtRkFBbUYsRUFBRSxzQkFBc0IsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLGtCQUFrQixJQUFJLEVBQUUsSUFBSSxpRkFBaUYsRUFBRSxzQkFBc0IsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLGtCQUFrQixJQUFJLEVBQUUsSUFBSSxpRkFBaUYsRUFBRSxzQkFBc0IsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLGtCQUFrQixJQUFJLEVBQUUsSUFBSSxpRkFBaUYsRUFBRSw4QkFBOEIsSUFBSSxFQUFFLElBQUksa0JBQWtCLElBQUksRUFBRSxJQUFJLGlGQUFpRixFQUFFO0FBQ3pvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUUsK0JBQStCLEVBQUU7QUFDdEU7QUFDQSxrREFBa0QsRUFBRTtBQUNwRCxpQ0FBaUMsSUFBSSxHQUFHLEVBQUUsWUFBWSxJQUFJLG9CQUFvQixJQUFJLEdBQUcsRUFBRSxhQUFhLElBQUksaUZBQWlGLEVBQUUscUJBQXFCLElBQUksR0FBRyxFQUFFLG1CQUFtQixJQUFJLEVBQUUsSUFBSSxtRkFBbUYsRUFBRSxxQkFBcUIsSUFBSSxHQUFHLEVBQUUsbUJBQW1CLElBQUksRUFBRSxJQUFJLGtCQUFrQixJQUFJLG1GQUFtRixFQUFFLHNCQUFzQixJQUFJLEdBQUcsRUFBRSxtQkFBbUIsSUFBSSxFQUFFLElBQUksa0JBQWtCLElBQUksRUFBRSxJQUFJLGlGQUFpRixFQUFFLHNCQUFzQixJQUFJLEdBQUcsRUFBRSxtQkFBbUIsSUFBSSxFQUFFLElBQUksa0JBQWtCLElBQUksRUFBRSxJQUFJLGlGQUFpRixFQUFFLHNCQUFzQixJQUFJLEdBQUcsRUFBRSxtQkFBbUIsSUFBSSxFQUFFLElBQUksa0JBQWtCLElBQUksRUFBRSxJQUFJLGlGQUFpRixFQUFFLDhCQUE4QixJQUFJLEVBQUUsSUFBSSxrQkFBa0IsSUFBSSxFQUFFLElBQUksaUZBQWlGLEVBQUU7QUFDem9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVKQUF1SiwrQ0FBK0M7QUFDN047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFlBQVk7QUFDWix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxjQUFjO0FBQ2QsMERBQTBELGNBQWM7QUFDeEU7QUFDQSxZQUFZO0FBQ1osK0NBQStDLHVDQUF1Qyx3QkFBd0IsVUFBVTtBQUN4SDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLHVCQUF1Qiw4QkFBOEI7QUFDckQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxtQkFBbUIsWUFBWSw4Q0FBOEMsMENBQTBDLHlDQUF5Qyx5QkFBeUI7QUFDekw7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxRQUFRO0FBQ1IsZ0RBQWdELHlEQUF5RCx3REFBd0QsMkJBQTJCO0FBQzVMO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyw2QkFBNkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLHVCQUF1QjtBQUNqRyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsbUJBQW1CLHlKQUF5SjtBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBLGlCQUFpQix1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxVQUFVO0FBQ1YsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBLGlCQUFpQixRQUFRLHdCQUF3Qix3QkFBd0IsbURBQW1ELHVCQUF1QjtBQUNuSjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE1BQU07QUFDTjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLE1BQU07QUFDTiwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBLDJFQUEyRSx5QkFBeUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0pBQXdKLG1DQUFtQztBQUM1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCLHFDQUFxQyxrQkFBa0I7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNERBQTREO0FBQzVEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsZ0VBQWdFO0FBQ2hFLE1BQU07QUFDTiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0SkFBNEo7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxRQUFRO0FBQ1Isb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSxNQUFNO0FBQ04seUNBQXlDLHVDQUF1Qyx3QkFBd0IsVUFBVTtBQUNsSDtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLHdDQUF3Qyx3QkFBd0IsbURBQW1ELHVCQUF1QjtBQUMxSTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0pBQStKLDJOQUEyTjtBQUNqWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsY0FBYztBQUNkLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0EsWUFBWTtBQUNaLCtDQUErQyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDeEg7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLCtKQUErSiwyTkFBMk47QUFDclo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsZ0JBQWdCO0FBQ2hCLDRCQUE0QjtBQUM1QjtBQUNBLHlCQUF5Qix1Q0FBdUMsd0JBQXdCLFlBQVk7QUFDcEc7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsNkNBQTZDO0FBQzdDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSw0RUFBNEUscUVBQXFFLE1BQU07QUFDdko7QUFDQSxtQ0FBbUMsdUJBQXVCLG9DQUFvQyx3RUFBd0UsdUJBQXVCLFFBQVE7QUFDck07QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUpBQXVKLG9DQUFvQztBQUM1TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdJQUFnSSxpRkFBaUYseUJBQXlCO0FBQzlTO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlKQUF5SjtBQUMxSztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsUUFBUTtBQUNSLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsTUFBTTtBQUNOLHlDQUF5Qyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDbEg7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDRCQUE0QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHdCQUF3QixtREFBbUQsd0JBQXdCO0FBQzNJO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFVBQVU7QUFDVjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsUUFBUTtBQUNSLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELFVBQVU7QUFDVjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0EsbUJBQW1CLHFKQUFxSixvQ0FBb0M7QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsdUNBQXVDLHdCQUF3QixVQUFVO0FBQzFGO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsVUFBVTtBQUNWLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0tBQWtLLGdDQUFnQztBQUN2TjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsVUFBVTtBQUNWLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLFlBQVk7QUFDWix3REFBd0QsY0FBYztBQUN0RTtBQUNBLFVBQVU7QUFDViw2Q0FBNkMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ3RIO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtFQUFrRTtBQUNsRTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLGlEQUFpRDtBQUNqRCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzREFBc0QsZ0RBQWdELHFDQUFxQyxrQkFBa0I7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw2Q0FBNkM7QUFDN0MsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHFDQUFxQyxrQkFBa0I7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLHVDQUF1Qyx5REFBeUQsMkdBQTJHO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0xBQXNMO0FBQ3pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRO0FBQ1Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsVUFBVTtBQUNWLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDcEg7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc2VBQXNlLDBFQUEwRTtBQUNoakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK1BBQStQO0FBQy9QLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRLQUE0SywwRkFBMEY7QUFDdlI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlMQUFpTCw4QkFBOEI7QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxRQUFRO0FBQ1Isb0RBQW9ELGNBQWM7QUFDbEU7QUFDQSxNQUFNO0FBQ04seUNBQXlDLHVDQUF1Qyx3QkFBd0IsVUFBVTtBQUNsSDtBQUNBLGNBQWM7QUFDZDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrTEFBa0wsOEJBQThCO0FBQ2pPO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsUUFBUTtBQUNSLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsTUFBTTtBQUNOLHlDQUF5Qyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDbEg7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0xBQXNMLDhCQUE4QjtBQUNyTztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZKQUE2SixtQ0FBbUM7QUFDak47QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUpBQXVKO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixRQUFRO0FBQ1Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0QsVUFBVTtBQUNWLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0EsUUFBUTtBQUNSLDJDQUEyQyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDcEg7QUFDQSxpQkFBaUIsUUFBUSx3QkFBd0Isd0JBQXdCLG1EQUFtRCx1QkFBdUI7QUFDbko7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQix1SkFBdUo7QUFDMUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUixvQkFBb0I7QUFDcEI7QUFDQSxpQkFBaUIsdUNBQXVDLHdCQUF3QixVQUFVO0FBQzFGO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0g7QUFDL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxtRUFBbUUsd0JBQXdCLG1FQUFtRSxPQUFPO0FBQ3JLLDhCQUE4QjtBQUM5QjtBQUNBLDJDQUEyQyw0Q0FBNEMsdUNBQXVDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLGlCQUFpQix3SkFBd0osMENBQTBDO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0EsZUFBZSx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDeEY7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxRQUFRO0FBQ1IsNENBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBLGNBQWMsUUFBUSx3QkFBd0Isd0JBQXdCLG1EQUFtRCxzQkFBc0I7QUFDL0k7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwSkFBMEo7QUFDM0s7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELFFBQVE7QUFDUixvREFBb0QsY0FBYztBQUNsRTtBQUNBLE1BQU07QUFDTix5Q0FBeUMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ2xIO0FBQ0EsY0FBYztBQUNkO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvRUFBb0U7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOEJBQThCO0FBQ3JFO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRyx5QkFBeUIsNkNBQTZDLGtCQUFrQiwwREFBMEQ7QUFDcFAsUUFBUTtBQUNSLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsWUFBWTtBQUNaLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUtBQXVLLG9EQUFvRDtBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsZ0JBQWdCO0FBQ2hCLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0EsY0FBYztBQUNkLGlEQUFpRCx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDMUg7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtFQUFrRTtBQUNsRTtBQUNBLGdEQUFnRCx3QkFBd0IsZ0NBQWdDLDZDQUE2QywrQkFBK0IsdUNBQXVDO0FBQzNOO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLDJDQUEyQztBQUMzQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwySkFBMkosOENBQThDO0FBQ3RPO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RSxvQkFBb0I7QUFDcEIsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQSxrQkFBa0I7QUFDbEIscURBQXFELHVDQUF1Qyx3QkFBd0IsVUFBVTtBQUM5SDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkIsT0FBTztBQUNsRSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLHlCQUF5Qiw2Q0FBNkMsa0JBQWtCLDBEQUEwRDtBQUMxUCxjQUFjO0FBQ2QsaUVBQWlFO0FBQ2pFO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsaURBQWlEO0FBQ2pELGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGtHQUFrRyx5QkFBeUIsNkNBQTZDLGtCQUFrQiwwREFBMEQ7QUFDcFAsUUFBUTtBQUNSLDJEQUEyRDtBQUMzRDtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkMsbUJBQW1CLGdCQUFnQixxREFBcUQ7QUFDN0s7QUFDQSxtQkFBbUIsZ0tBQWdLLHVDQUF1QztBQUMxTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBLGlCQUFpQix1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDMUY7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxVQUFVO0FBQ1YsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGtGQUFrRixxRUFBcUUsTUFBTTtBQUM3SjtBQUNBLDRDQUE0QyxzQ0FBc0MsZ0JBQWdCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkpBQTJKLDhDQUE4QztBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkUsY0FBYztBQUNkLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0EsWUFBWTtBQUNaLCtDQUErQyx1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDeEg7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJKQUEySiw4Q0FBOEM7QUFDaE87QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsWUFBWTtBQUNaLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGNBQWM7QUFDZCwwREFBMEQsY0FBYztBQUN4RTtBQUNBLFlBQVk7QUFDWiwrQ0FBK0MsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ3hIO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSx5QkFBeUIsMkpBQTJKLDhDQUE4QztBQUNsTztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCO0FBQ0EsdUJBQXVCLHVDQUF1Qyx3QkFBd0IsWUFBWSwyQ0FBMkM7QUFDN0k7QUFDQSw0Q0FBNEMsc0NBQXNDLGdCQUFnQjtBQUNsRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSx1QkFBdUIsMkpBQTJKLDhDQUE4QztBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCO0FBQ0EscUJBQXFCLHVDQUF1Qyx3QkFBd0IsY0FBYztBQUNsRztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDJCQUEyQiwySkFBMkosOENBQThDO0FBQ3BPO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLGdCQUFnQjtBQUNoQiw0QkFBNEI7QUFDNUI7QUFDQSx5QkFBeUIsdUNBQXVDLHdCQUF3QixZQUFZO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRztBQUMxRztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpR0FBaUcsMkVBQTJFLE9BQU87QUFDeE47QUFDQSx5RUFBeUUsYUFBYTtBQUN0RjtBQUNBO0FBQ0EsOEJBQThCLElBQUksSUFBSSxZQUFZLElBQUksSUFBSSxpREFBaUQsd0JBQXdCLG1CQUFtQjtBQUN0SixRQUFRO0FBQ1IscUNBQXFDLFFBQVEsTUFBTSxJQUFJLElBQUksNkJBQTZCO0FBQ3hGO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsNkRBQTZELHdCQUF3Qix1QkFBdUIsU0FBUyx5QkFBeUI7QUFDOUk7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEpBQThKLGFBQWE7QUFDOUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELFVBQVU7QUFDVixzREFBc0QsY0FBYztBQUNwRTtBQUNBLFFBQVE7QUFDUiwyQ0FBMkMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ3BIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtCQUErQjtBQUMzQyxZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHlEQUF5RDtBQUMvSSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0EsMEJBQTBCO0FBQzFCLHlEQUF5RCx5QkFBeUIsT0FBTztBQUN6RjtBQUNBLDRCQUE0QjtBQUM1Qiw0RkFBNEYsc0JBQXNCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0VBQWtFO0FBQ2xFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlEQUFpRCxNQUFNLHVEQUF1RCxZQUFZLHdCQUF3QixnRUFBZ0UsZ0JBQWdCO0FBQ2xPLFVBQVU7QUFDViw2Q0FBNkMsK0NBQStDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEtBQTRLLG1DQUFtQztBQUNsTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsUUFBUTtBQUNSLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELFVBQVU7QUFDVixzREFBc0QsY0FBYztBQUNwRTtBQUNBLFFBQVE7QUFDUiwyQ0FBMkMsdUNBQXVDLHdCQUF3QixVQUFVO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxtQkFBbUIsZ0JBQWdCLDRDQUE0QyxrSEFBa0gsaURBQWlELDBEQUEwRDtBQUNyVztBQUNBLHVFQUF1RSx1Q0FBdUM7QUFDOUc7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWixvREFBb0QsMEJBQTBCLFFBQVEsbUNBQW1DLG1CQUFtQixnQkFBZ0IsNENBQTRDLGtIQUFrSCxpREFBaUQsMERBQTBEO0FBQ3JhO0FBQ0EsdUVBQXVFLHVDQUF1QztBQUM5RztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQkFBcUIsNEtBQTRLLG1DQUFtQztBQUNwTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsVUFBVTtBQUNWLHNCQUFzQjtBQUN0QjtBQUNBLG1CQUFtQix1Q0FBdUMsd0JBQXdCLFVBQVU7QUFDNUY7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxZQUFZO0FBQ1osZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDJEQUEyRCxtREFBbUQsa0RBQWtELDBCQUEwQixtQ0FBbUMsbUJBQW1CLGdCQUFnQiw0Q0FBNEMsbUhBQW1ILHlEQUF5RDtBQUN4ZDtBQUNBLHFFQUFxRSx1Q0FBdUM7QUFDNUc7QUFDQSx1QkFBdUIsT0FBTywwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQsWUFBWTtBQUNaO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLG1CQUFtQiwwQ0FBMEM7QUFDN0QsbUJBQW1CLGtEQUFrRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNBLE9BQU87QUFDUCxrQkFBa0IsMENBQTBDO0FBQzVELGtCQUFrQixrREFBa0Q7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtCQUFrQixXQUFXO0FBQzdCLHVCQUF1QiwwQ0FBMEM7QUFDakUsdUJBQXVCLGtEQUFrRDtBQUN6RSxrQkFBa0IsbUNBQW1DO0FBQ3JELDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQSxnQ0FBZ0MsV0FBVztBQUMzQztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQztBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLDBCQUEwQixnQkFBZ0I7QUFDMUMseUJBQXlCLGdCQUFnQjtBQUN6QyxZQUFZLFdBQVc7QUFDdkIsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsV0FBVztBQUN6QixlQUFlLG1DQUFtQztBQUNsRCxlQUFlLG1DQUFtQztBQUNsRCxlQUFlLG1DQUFtQztBQUNsRCxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQyxtQkFBbUIsaUJBQWlCO0FBQ3BDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0MsWUFBWTtBQUNaO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYyxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0EsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Qyw4QkFBOEIsMENBQUs7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0osQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDRCQUE0QjtBQUNoRCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsSUFBSTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlEQUFpRDtBQUMzRTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFnRDtBQUM1RTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0EsNEJBQTRCLCtDQUErQztBQUMzRTtBQUNBO0FBQ0EsNEJBQTRCLDhDQUE4QztBQUMxRTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFnRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsNkNBQTZDO0FBQ3pFO0FBQ0E7QUFDQSw0QkFBNEIsNENBQTRDO0FBQ3hFO0FBQ0E7QUFDQSw0QkFBNEIsOENBQThDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QjtBQUM1QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCO0FBQ3JCLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUSxxQ0FBcUM7QUFDN0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUIsc0JBQXNCLGNBQWM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiLElBQUk7QUFDSixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2REFBNkQ7QUFDN0QsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixLQUFLLElBQUksUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixxREFBcUQ7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0EsK0JBQStCLHlDQUF5QztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IsNENBQTRDO0FBQzNFO0FBQ0E7QUFDQSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPLEtBQUs7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQsR0FBRztBQUNILDBCQUEwQixRQUFRO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Ysc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQixnQkFBZ0IsY0FBYztBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxFQUFFO0FBQ3pELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEVBQUU7QUFDekQsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsd0NBQXdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtEQUFhLENBQUMsbUdBQWU7QUFDbEQscUJBQXFCLDBDQUFLO0FBQzFCLGlDQUFpQywwQ0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBS0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL2NsYXVkZS1hZ2VudC1zZGsvc2RrLm1qcz9lMTIzIl0sInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5vZGVcbi8vIChjKSBBbnRocm9waWMgUEJDLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBVc2UgaXMgc3ViamVjdCB0byB0aGUgTGVnYWwgQWdyZWVtZW50cyBvdXRsaW5lZCBoZXJlOiBodHRwczovL2RvY3MuY2xhdWRlLmNvbS9lbi9kb2NzL2NsYXVkZS1jb2RlL2xlZ2FsLWFuZC1jb21wbGlhbmNlLlxuXG4vLyBWZXJzaW9uOiAwLjEuMTRcblxuLy8gV2FudCB0byBzZWUgdGhlIHVubWluaWZpZWQgc291cmNlPyBXZSdyZSBoaXJpbmchXG4vLyBodHRwczovL2pvYi1ib2FyZHMuZ3JlZW5ob3VzZS5pby9hbnRocm9waWMvam9icy80ODE2MTk5MDA4XG52YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+IHtcbiAgdGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fTtcbiAgY29uc3QgdG8gPSBpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHsgdmFsdWU6IG1vZCwgZW51bWVyYWJsZTogdHJ1ZSB9KSA6IHRhcmdldDtcbiAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKG1vZCkpXG4gICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSlcbiAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7XG4gICAgICAgIGdldDogKCkgPT4gbW9kW2tleV0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICByZXR1cm4gdG87XG59O1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gKCkgPT4gKG1vZCB8fCBjYigobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cyk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuICAgICAgZ2V0OiBhbGxbbmFtZV0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiAobmV3VmFsdWUpID0+IGFsbFtuYW1lXSA9ICgpID0+IG5ld1ZhbHVlXG4gICAgfSk7XG59O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvdXJpLWpzL2Rpc3QvZXM1L3VyaS5hbGwuanNcbnZhciByZXF1aXJlX3VyaV9hbGwgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgKGZ1bmN0aW9uKGdsb2JhbDIsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiID8gZmFjdG9yeShleHBvcnRzKSA6IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFtcImV4cG9ydHNcIl0sIGZhY3RvcnkpIDogZmFjdG9yeShnbG9iYWwyLlVSSSA9IGdsb2JhbDIuVVJJIHx8IHt9KTtcbiAgfSkoZXhwb3J0cywgZnVuY3Rpb24oZXhwb3J0czIpIHtcbiAgICBmdW5jdGlvbiBtZXJnZSgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZXRzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwO19rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc2V0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc2V0c1swXSA9IHNldHNbMF0uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgeGwgPSBzZXRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGZvciAodmFyIHggPSAxO3ggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgc2V0c1t4XSA9IHNldHNbeF0uc2xpY2UoMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHNldHNbeGxdID0gc2V0c1t4bF0uc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBzZXRzLmpvaW4oXCJcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2V0c1swXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3ViZXhwKHN0cikge1xuICAgICAgcmV0dXJuIFwiKD86XCIgKyBzdHIgKyBcIilcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHlwZU9mKG8pIHtcbiAgICAgIHJldHVybiBvID09PSB1bmRlZmluZWQgPyBcInVuZGVmaW5lZFwiIDogbyA9PT0gbnVsbCA/IFwibnVsbFwiIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNwbGl0KFwiIFwiKS5wb3AoKS5zcGxpdChcIl1cIikuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1VwcGVyQ2FzZShzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IG51bGwgPyBvYmogaW5zdGFuY2VvZiBBcnJheSA/IG9iaiA6IHR5cGVvZiBvYmoubGVuZ3RoICE9PSBcIm51bWJlclwiIHx8IG9iai5zcGxpdCB8fCBvYmouc2V0SW50ZXJ2YWwgfHwgb2JqLmNhbGwgPyBbb2JqXSA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaikgOiBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gICAgICB2YXIgb2JqID0gdGFyZ2V0O1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZnVuY3Rpb24gYnVpbGRFeHBzKGlzSVJJMikge1xuICAgICAgdmFyIEFMUEhBJCQgPSBcIltBLVphLXpdXCIsIENSJCA9IFwiW1xcXFx4MERdXCIsIERJR0lUJCQgPSBcIlswLTldXCIsIERRVU9URSQkID0gXCJbXFxcXHgyMl1cIiwgSEVYRElHJCQyID0gbWVyZ2UoRElHSVQkJCwgXCJbQS1GYS1mXVwiKSwgTEYkJCA9IFwiW1xcXFx4MEFdXCIsIFNQJCQgPSBcIltcXFxceDIwXVwiLCBQQ1RfRU5DT0RFRCQyID0gc3ViZXhwKHN1YmV4cChcIiVbRUZlZl1cIiArIEhFWERJRyQkMiArIFwiJVwiICsgSEVYRElHJCQyICsgSEVYRElHJCQyICsgXCIlXCIgKyBIRVhESUckJDIgKyBIRVhESUckJDIpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQyICsgXCIlXCIgKyBIRVhESUckJDIgKyBIRVhESUckJDIpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJDIgKyBIRVhESUckJDIpKSwgR0VOX0RFTElNUyQkID0gXCJbXFxcXDpcXFxcL1xcXFw/XFxcXCNcXFxcW1xcXFxdXFxcXEBdXCIsIFNVQl9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJlxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFw7XFxcXD1dXCIsIFJFU0VSVkVEJCQgPSBtZXJnZShHRU5fREVMSU1TJCQsIFNVQl9ERUxJTVMkJCksIFVDU0NIQVIkJCA9IGlzSVJJMiA/IFwiW1xcXFx4QTAtXFxcXHUyMDBEXFxcXHUyMDEwLVxcXFx1MjAyOVxcXFx1MjAyRi1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl1cIiA6IFwiW11cIiwgSVBSSVZBVEUkJCA9IGlzSVJJMiA/IFwiW1xcXFx1RTAwMC1cXFxcdUY4RkZdXCIgOiBcIltdXCIsIFVOUkVTRVJWRUQkJDIgPSBtZXJnZShBTFBIQSQkLCBESUdJVCQkLCBcIltcXFxcLVxcXFwuXFxcXF9cXFxcfl1cIiwgVUNTQ0hBUiQkKSwgU0NIRU1FJCA9IHN1YmV4cChBTFBIQSQkICsgbWVyZ2UoQUxQSEEkJCwgRElHSVQkJCwgXCJbXFxcXCtcXFxcLVxcXFwuXVwiKSArIFwiKlwiKSwgVVNFUklORk8kID0gc3ViZXhwKHN1YmV4cChQQ1RfRU5DT0RFRCQyICsgXCJ8XCIgKyBtZXJnZShVTlJFU0VSVkVEJCQyLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XVwiKSkgKyBcIipcIiksIERFQ19PQ1RFVCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCJbMS05XVwiICsgRElHSVQkJCkgKyBcInxcIiArIERJR0lUJCQpLCBERUNfT0NURVRfUkVMQVhFRCQgPSBzdWJleHAoc3ViZXhwKFwiMjVbMC01XVwiKSArIFwifFwiICsgc3ViZXhwKFwiMlswLTRdXCIgKyBESUdJVCQkKSArIFwifFwiICsgc3ViZXhwKFwiMVwiICsgRElHSVQkJCArIERJR0lUJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIwP1sxLTldXCIgKyBESUdJVCQkKSArIFwifDA/MD9cIiArIERJR0lUJCQpLCBJUFY0QUREUkVTUyQgPSBzdWJleHAoREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkICsgXCJcXFxcLlwiICsgREVDX09DVEVUX1JFTEFYRUQkKSwgSDE2JCA9IHN1YmV4cChIRVhESUckJDIgKyBcInsxLDR9XCIpLCBMUzMyJCA9IHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIiArIEgxNiQpICsgXCJ8XCIgKyBJUFY0QUREUkVTUyQpLCBJUFY2QUREUkVTUzEkID0gc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezZ9XCIgKyBMUzMyJCksIElQVjZBRERSRVNTMiQgPSBzdWJleHAoXCJcXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcIns1fVwiICsgTFMzMiQpLCBJUFY2QUREUkVTUzMkID0gc3ViZXhwKHN1YmV4cChIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezR9XCIgKyBMUzMyJCksIElQVjZBRERSRVNTNCQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsMX1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7M31cIiArIExTMzIkKSwgSVBWNkFERFJFU1M1JCA9IHN1YmV4cChzdWJleHAoc3ViZXhwKEgxNiQgKyBcIlxcXFw6XCIpICsgXCJ7MCwyfVwiICsgSDE2JCkgKyBcIj9cXFxcOlxcXFw6XCIgKyBzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInsyfVwiICsgTFMzMiQpLCBJUFY2QUREUkVTUzYkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDN9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQgKyBcIlxcXFw6XCIgKyBMUzMyJCksIElQVjZBRERSRVNTNyQgPSBzdWJleHAoc3ViZXhwKHN1YmV4cChIMTYkICsgXCJcXFxcOlwiKSArIFwiezAsNH1cIiArIEgxNiQpICsgXCI/XFxcXDpcXFxcOlwiICsgTFMzMiQpLCBJUFY2QUREUkVTUzgkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDV9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiArIEgxNiQpLCBJUFY2QUREUkVTUzkkID0gc3ViZXhwKHN1YmV4cChzdWJleHAoSDE2JCArIFwiXFxcXDpcIikgKyBcInswLDZ9XCIgKyBIMTYkKSArIFwiP1xcXFw6XFxcXDpcIiksIElQVjZBRERSRVNTJCA9IHN1YmV4cChbSVBWNkFERFJFU1MxJCwgSVBWNkFERFJFU1MyJCwgSVBWNkFERFJFU1MzJCwgSVBWNkFERFJFU1M0JCwgSVBWNkFERFJFU1M1JCwgSVBWNkFERFJFU1M2JCwgSVBWNkFERFJFU1M3JCwgSVBWNkFERFJFU1M4JCwgSVBWNkFERFJFU1M5JF0uam9pbihcInxcIikpLCBaT05FSUQkID0gc3ViZXhwKHN1YmV4cChVTlJFU0VSVkVEJCQyICsgXCJ8XCIgKyBQQ1RfRU5DT0RFRCQyKSArIFwiK1wiKSwgSVBWNkFERFJaJCA9IHN1YmV4cChJUFY2QUREUkVTUyQgKyBcIlxcXFwlMjVcIiArIFpPTkVJRCQpLCBJUFY2QUREUlpfUkVMQVhFRCQgPSBzdWJleHAoSVBWNkFERFJFU1MkICsgc3ViZXhwKFwiXFxcXCUyNXxcXFxcJSg/IVwiICsgSEVYRElHJCQyICsgXCJ7Mn0pXCIpICsgWk9ORUlEJCksIElQVkZVVFVSRSQgPSBzdWJleHAoXCJbdlZdXCIgKyBIRVhESUckJDIgKyBcIitcXFxcLlwiICsgbWVyZ2UoVU5SRVNFUlZFRCQkMiwgU1VCX0RFTElNUyQkLCBcIltcXFxcOl1cIikgKyBcIitcIiksIElQX0xJVEVSQUwkID0gc3ViZXhwKFwiXFxcXFtcIiArIHN1YmV4cChJUFY2QUREUlpfUkVMQVhFRCQgKyBcInxcIiArIElQVjZBRERSRVNTJCArIFwifFwiICsgSVBWRlVUVVJFJCkgKyBcIlxcXFxdXCIpLCBSRUdfTkFNRSQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJDIgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJDIsIFNVQl9ERUxJTVMkJCkpICsgXCIqXCIpLCBIT1NUJCA9IHN1YmV4cChJUF9MSVRFUkFMJCArIFwifFwiICsgSVBWNEFERFJFU1MkICsgXCIoPyFcIiArIFJFR19OQU1FJCArIFwiKVwiICsgXCJ8XCIgKyBSRUdfTkFNRSQpLCBQT1JUJCA9IHN1YmV4cChESUdJVCQkICsgXCIqXCIpLCBBVVRIT1JJVFkkID0gc3ViZXhwKHN1YmV4cChVU0VSSU5GTyQgKyBcIkBcIikgKyBcIj9cIiArIEhPU1QkICsgc3ViZXhwKFwiXFxcXDpcIiArIFBPUlQkKSArIFwiP1wiKSwgUENIQVIkID0gc3ViZXhwKFBDVF9FTkNPREVEJDIgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJDIsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXDpcXFxcQF1cIikpLCBTRUdNRU5UJCA9IHN1YmV4cChQQ0hBUiQgKyBcIipcIiksIFNFR01FTlRfTlokID0gc3ViZXhwKFBDSEFSJCArIFwiK1wiKSwgU0VHTUVOVF9OWl9OQyQgPSBzdWJleHAoc3ViZXhwKFBDVF9FTkNPREVEJDIgKyBcInxcIiArIG1lcmdlKFVOUkVTRVJWRUQkJDIsIFNVQl9ERUxJTVMkJCwgXCJbXFxcXEBdXCIpKSArIFwiK1wiKSwgUEFUSF9BQkVNUFRZJCA9IHN1YmV4cChzdWJleHAoXCJcXFxcL1wiICsgU0VHTUVOVCQpICsgXCIqXCIpLCBQQVRIX0FCU09MVVRFJCA9IHN1YmV4cChcIlxcXFwvXCIgKyBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSArIFwiP1wiKSwgUEFUSF9OT1NDSEVNRSQgPSBzdWJleHAoU0VHTUVOVF9OWl9OQyQgKyBQQVRIX0FCRU1QVFkkKSwgUEFUSF9ST09UTEVTUyQgPSBzdWJleHAoU0VHTUVOVF9OWiQgKyBQQVRIX0FCRU1QVFkkKSwgUEFUSF9FTVBUWSQgPSBcIig/IVwiICsgUENIQVIkICsgXCIpXCIsIFBBVEgkID0gc3ViZXhwKFBBVEhfQUJFTVBUWSQgKyBcInxcIiArIFBBVEhfQUJTT0xVVEUkICsgXCJ8XCIgKyBQQVRIX05PU0NIRU1FJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgUVVFUlkkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxcIiArIG1lcmdlKFwiW1xcXFwvXFxcXD9dXCIsIElQUklWQVRFJCQpKSArIFwiKlwiKSwgRlJBR01FTlQkID0gc3ViZXhwKHN1YmV4cChQQ0hBUiQgKyBcInxbXFxcXC9cXFxcP11cIikgKyBcIipcIiksIEhJRVJfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgVVJJJCA9IHN1YmV4cChTQ0hFTUUkICsgXCJcXFxcOlwiICsgSElFUl9QQVJUJCArIHN1YmV4cChcIlxcXFw/XCIgKyBRVUVSWSQpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcI1wiICsgRlJBR01FTlQkKSArIFwiP1wiKSwgUkVMQVRJVkVfUEFSVCQgPSBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcL1wiICsgQVVUSE9SSVRZJCArIFBBVEhfQUJFTVBUWSQpICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkKSwgUkVMQVRJVkUkID0gc3ViZXhwKFJFTEFUSVZFX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjXCIgKyBGUkFHTUVOVCQpICsgXCI/XCIpLCBVUklfUkVGRVJFTkNFJCA9IHN1YmV4cChVUkkkICsgXCJ8XCIgKyBSRUxBVElWRSQpLCBBQlNPTFVURV9VUkkkID0gc3ViZXhwKFNDSEVNRSQgKyBcIlxcXFw6XCIgKyBISUVSX1BBUlQkICsgc3ViZXhwKFwiXFxcXD9cIiArIFFVRVJZJCkgKyBcIj9cIiksIEdFTkVSSUNfUkVGJCA9IFwiXihcIiArIFNDSEVNRSQgKyBcIilcXFxcOlwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwvXFxcXC8oXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8pXCIpICsgXCI/KFwiICsgUEFUSF9BQkVNUFRZJCArIFwifFwiICsgUEFUSF9BQlNPTFVURSQgKyBcInxcIiArIFBBVEhfUk9PVExFU1MkICsgXCJ8XCIgKyBQQVRIX0VNUFRZJCArIFwiKVwiKSArIHN1YmV4cChcIlxcXFw/KFwiICsgUVVFUlkkICsgXCIpXCIpICsgXCI/XCIgKyBzdWJleHAoXCJcXFxcIyhcIiArIEZSQUdNRU5UJCArIFwiKVwiKSArIFwiPyRcIiwgUkVMQVRJVkVfUkVGJCA9IFwiXigpezB9XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9OT1NDSEVNRSQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj9cIiArIHN1YmV4cChcIlxcXFwjKFwiICsgRlJBR01FTlQkICsgXCIpXCIpICsgXCI/JFwiLCBBQlNPTFVURV9SRUYkID0gXCJeKFwiICsgU0NIRU1FJCArIFwiKVxcXFw6XCIgKyBzdWJleHAoc3ViZXhwKFwiXFxcXC9cXFxcLyhcIiArIHN1YmV4cChcIihcIiArIFVTRVJJTkZPJCArIFwiKUBcIikgKyBcIj8oXCIgKyBIT1NUJCArIFwiKVwiICsgc3ViZXhwKFwiXFxcXDooXCIgKyBQT1JUJCArIFwiKVwiKSArIFwiPylcIikgKyBcIj8oXCIgKyBQQVRIX0FCRU1QVFkkICsgXCJ8XCIgKyBQQVRIX0FCU09MVVRFJCArIFwifFwiICsgUEFUSF9ST09UTEVTUyQgKyBcInxcIiArIFBBVEhfRU1QVFkkICsgXCIpXCIpICsgc3ViZXhwKFwiXFxcXD8oXCIgKyBRVUVSWSQgKyBcIilcIikgKyBcIj8kXCIsIFNBTUVET0NfUkVGJCA9IFwiXlwiICsgc3ViZXhwKFwiXFxcXCMoXCIgKyBGUkFHTUVOVCQgKyBcIilcIikgKyBcIj8kXCIsIEFVVEhPUklUWV9SRUYkID0gXCJeXCIgKyBzdWJleHAoXCIoXCIgKyBVU0VSSU5GTyQgKyBcIilAXCIpICsgXCI/KFwiICsgSE9TVCQgKyBcIilcIiArIHN1YmV4cChcIlxcXFw6KFwiICsgUE9SVCQgKyBcIilcIikgKyBcIj8kXCI7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBOT1RfU0NIRU1FOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIEFMUEhBJCQsIERJR0lUJCQsIFwiW1xcXFwrXFxcXC1cXFxcLl1cIiksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1VTRVJJTkZPOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFw6XVwiLCBVTlJFU0VSVkVEJCQyLCBTVUJfREVMSU1TJCQpLCBcImdcIiksXG4gICAgICAgIE5PVF9IT1NUOiBuZXcgUmVnRXhwKG1lcmdlKFwiW15cXFxcJVxcXFxbXFxcXF1cXFxcOl1cIiwgVU5SRVNFUlZFRCQkMiwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUEFUSDogbmV3IFJlZ0V4cChtZXJnZShcIlteXFxcXCVcXFxcL1xcXFw6XFxcXEBdXCIsIFVOUkVTRVJWRUQkJDIsIFNVQl9ERUxJTVMkJCksIFwiZ1wiKSxcbiAgICAgICAgTk9UX1BBVEhfTk9TQ0hFTUU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXFxcXC9cXFxcQF1cIiwgVU5SRVNFUlZFRCQkMiwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfUVVFUlk6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQyLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiLCBJUFJJVkFURSQkKSwgXCJnXCIpLFxuICAgICAgICBOT1RfRlJBR01FTlQ6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQyLCBTVUJfREVMSU1TJCQsIFwiW1xcXFw6XFxcXEBcXFxcL1xcXFw/XVwiKSwgXCJnXCIpLFxuICAgICAgICBFU0NBUEU6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXl1cIiwgVU5SRVNFUlZFRCQkMiwgU1VCX0RFTElNUyQkKSwgXCJnXCIpLFxuICAgICAgICBVTlJFU0VSVkVEOiBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJDIsIFwiZ1wiKSxcbiAgICAgICAgT1RIRVJfQ0hBUlM6IG5ldyBSZWdFeHAobWVyZ2UoXCJbXlxcXFwlXVwiLCBVTlJFU0VSVkVEJCQyLCBSRVNFUlZFRCQkKSwgXCJnXCIpLFxuICAgICAgICBQQ1RfRU5DT0RFRDogbmV3IFJlZ0V4cChQQ1RfRU5DT0RFRCQyLCBcImdcIiksXG4gICAgICAgIElQVjRBRERSRVNTOiBuZXcgUmVnRXhwKFwiXihcIiArIElQVjRBRERSRVNTJCArIFwiKSRcIiksXG4gICAgICAgIElQVjZBRERSRVNTOiBuZXcgUmVnRXhwKFwiXlxcXFxbPyhcIiArIElQVjZBRERSRVNTJCArIFwiKVwiICsgc3ViZXhwKHN1YmV4cChcIlxcXFwlMjV8XFxcXCUoPyFcIiArIEhFWERJRyQkMiArIFwiezJ9KVwiKSArIFwiKFwiICsgWk9ORUlEJCArIFwiKVwiKSArIFwiP1xcXFxdPyRcIilcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBVUklfUFJPVE9DT0wgPSBidWlsZEV4cHMoZmFsc2UpO1xuICAgIHZhciBJUklfUFJPVE9DT0wgPSBidWlsZEV4cHModHJ1ZSk7XG4gICAgdmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgICAgIHZhciBfYXJyID0gW107XG4gICAgICAgIHZhciBfbiA9IHRydWU7XG4gICAgICAgIHZhciBfZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczshKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2QgPSB0cnVlO1xuICAgICAgICAgIF9lID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKVxuICAgICAgICAgICAgICBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2QpXG4gICAgICAgICAgICAgIHRocm93IF9lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2FycjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbihhcnIsIGkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7XG4gICAgICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KCk7XG4gICAgdmFyIHRvQ29uc3VtYWJsZUFycmF5ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7aSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgICAgICBhcnIyW2ldID0gYXJyW2ldO1xuICAgICAgICByZXR1cm4gYXJyMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbWF4SW50ID0gMjE0NzQ4MzY0NztcbiAgICB2YXIgYmFzZSA9IDM2O1xuICAgIHZhciB0TWluID0gMTtcbiAgICB2YXIgdE1heCA9IDI2O1xuICAgIHZhciBza2V3ID0gMzg7XG4gICAgdmFyIGRhbXAgPSA3MDA7XG4gICAgdmFyIGluaXRpYWxCaWFzID0gNzI7XG4gICAgdmFyIGluaXRpYWxOID0gMTI4O1xuICAgIHZhciBkZWxpbWl0ZXIgPSBcIi1cIjtcbiAgICB2YXIgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS87XG4gICAgdmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx4N0VdLztcbiAgICB2YXIgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZztcbiAgICB2YXIgZXJyb3JzMiA9IHtcbiAgICAgIG92ZXJmbG93OiBcIk92ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzXCIsXG4gICAgICBcIm5vdC1iYXNpY1wiOiBcIklsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludClcIixcbiAgICAgIFwiaW52YWxpZC1pbnB1dFwiOiBcIkludmFsaWQgaW5wdXRcIlxuICAgIH07XG4gICAgdmFyIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbjtcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAgIGZ1bmN0aW9uIGVycm9yJDEodHlwZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzMlt0eXBlXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG4gICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoXCJAXCIpO1xuICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXN1bHQgPSBwYXJ0c1swXSArIFwiQFwiO1xuICAgICAgICBzdHJpbmcgPSBwYXJ0c1sxXTtcbiAgICAgIH1cbiAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgXCIuXCIpO1xuICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKFwiLlwiKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gNTUyOTYgJiYgdmFsdWUgPD0gNTYzMTkgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgICAgaWYgKChleHRyYSAmIDY0NTEyKSA9PSA1NjMyMCkge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDEwMjMpIDw8IDEwKSArIChleHRyYSAmIDEwMjMpICsgNjU1MzYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBjb3VudGVyLS07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgdmFyIHVjczJlbmNvZGUgPSBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkoU3RyaW5nLCB0b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xuICAgIH07XG4gICAgdmFyIGJhc2ljVG9EaWdpdCA9IGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcbiAgICAgIGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSAyMjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA2NTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA5NztcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH07XG4gICAgdmFyIGRpZ2l0VG9CYXNpYyA9IGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuICAgICAgcmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcbiAgICB9O1xuICAgIHZhciBhZGFwdCA9IGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuICAgICAgdmFyIGsgPSAwO1xuICAgICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgICAgIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcbiAgICAgIGZvciAoO2RlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG4gICAgICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuICAgIH07XG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG4gPSBpbml0aWFsTjtcbiAgICAgIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG4gICAgICB2YXIgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgICAgaWYgKGJhc2ljIDwgMCkge1xuICAgICAgICBiYXNpYyA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgYmFzaWM7ICsraikge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAxMjgpIHtcbiAgICAgICAgICBlcnJvciQxKFwibm90LWJhc2ljXCIpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwO2luZGV4IDwgaW5wdXRMZW5ndGg7ICkge1xuICAgICAgICB2YXIgb2xkaSA9IGk7XG4gICAgICAgIGZvciAodmFyIHcgPSAxLCBrID0gYmFzZTs7IGsgKz0gYmFzZSkge1xuICAgICAgICAgIGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuICAgICAgICAgICAgZXJyb3IkMShcImludmFsaWQtaW5wdXRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcbiAgICAgICAgICBpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG4gICAgICAgICAgICBlcnJvciQxKFwib3ZlcmZsb3dcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gZGlnaXQgKiB3O1xuICAgICAgICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICAgICAgZXJyb3IkMShcIm92ZXJmbG93XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3ICo9IGJhc2VNaW51c1Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuICAgICAgICBiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcbiAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgIGVycm9yJDEoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IGZsb29yKGkgLyBvdXQpO1xuICAgICAgICBpICU9IG91dDtcbiAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KFN0cmluZywgb3V0cHV0KTtcbiAgICB9O1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG4gICAgICB2YXIgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICB2YXIgbiA9IGluaXRpYWxOO1xuICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgIHZhciBiaWFzID0gaW5pdGlhbEJpYXM7XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGlucHV0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7IShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50VmFsdWUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKF9jdXJyZW50VmFsdWUyIDwgMTI4KSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoX2N1cnJlbnRWYWx1ZTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAgIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICB2YXIgbSA9IG1heEludDtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjshKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcbiAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICAgICAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgICAgIGVycm9yJDEoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuICAgICAgICBuID0gbTtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjMgPSBpbnB1dFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzshKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gKF9zdGVwMyA9IF9pdGVyYXRvcjMubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRWYWx1ZSA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIGlmIChfY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgICAgICAgIGVycm9yJDEoXCJvdmVyZmxvd1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgICAgICAgdmFyIHEgPSBkZWx0YTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgayA9IGJhc2U7OyBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBxTWludXNUID0gcSAtIHQ7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcbiAgICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcbiAgICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICArK2hhbmRsZWRDUENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IzID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjMgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjMgJiYgX2l0ZXJhdG9yMy5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yMy5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMykge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICsrZGVsdGE7XG4gICAgICAgICsrbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbiAgICB9O1xuICAgIHZhciB0b1VuaWNvZGUgPSBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdG9BU0NJSSA9IGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcbiAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZykgPyBcInhuLS1cIiArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgcHVueWNvZGUgPSB7XG4gICAgICB2ZXJzaW9uOiBcIjIuMS4wXCIsXG4gICAgICB1Y3MyOiB7XG4gICAgICAgIGRlY29kZTogdWNzMmRlY29kZSxcbiAgICAgICAgZW5jb2RlOiB1Y3MyZW5jb2RlXG4gICAgICB9LFxuICAgICAgZGVjb2RlLFxuICAgICAgZW5jb2RlLFxuICAgICAgdG9BU0NJSSxcbiAgICAgIHRvVW5pY29kZVxuICAgIH07XG4gICAgdmFyIFNDSEVNRVMgPSB7fTtcbiAgICBmdW5jdGlvbiBwY3RFbmNDaGFyKGNocikge1xuICAgICAgdmFyIGMgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAgIHZhciBlID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGMgPCAxNilcbiAgICAgICAgZSA9IFwiJTBcIiArIGMudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgICBlbHNlIGlmIChjIDwgMTI4KVxuICAgICAgICBlID0gXCIlXCIgKyBjLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXG4gICAgICAgIGUgPSBcIiVcIiArIChjID4+IDYgfCAxOTIpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgZSA9IFwiJVwiICsgKGMgPj4gMTIgfCAyMjQpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyA+PiA2ICYgNjMgfCAxMjgpLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgXCIlXCIgKyAoYyAmIDYzIHwgMTI4KS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwY3REZWNDaGFycyhzdHIpIHtcbiAgICAgIHZhciBuZXdTdHIgPSBcIlwiO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGlsID0gc3RyLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpIDwgaWwpIHtcbiAgICAgICAgdmFyIGMgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyAxLCAyKSwgMTYpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgfSBlbHNlIGlmIChjID49IDE5NCAmJiBjIDwgMjI0KSB7XG4gICAgICAgICAgaWYgKGlsIC0gaSA+PSA2KSB7XG4gICAgICAgICAgICB2YXIgYzIgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgbmV3U3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMgJiAzMSkgPDwgNiB8IGMyICYgNjMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCA2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSA2O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPj0gMjI0KSB7XG4gICAgICAgICAgaWYgKGlsIC0gaSA+PSA5KSB7XG4gICAgICAgICAgICB2YXIgX2MgPSBwYXJzZUludChzdHIuc3Vic3RyKGkgKyA0LCAyKSwgMTYpO1xuICAgICAgICAgICAgdmFyIGMzID0gcGFyc2VJbnQoc3RyLnN1YnN0cihpICsgNywgMiksIDE2KTtcbiAgICAgICAgICAgIG5ld1N0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjICYgMTUpIDw8IDEyIHwgKF9jICYgNjMpIDw8IDYgfCBjMyAmIDYzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U3RyICs9IHN0ci5zdWJzdHIoaSwgOSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTdHIgKz0gc3RyLnN1YnN0cihpLCAzKTtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTdHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9ub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhjb21wb25lbnRzLCBwcm90b2NvbCkge1xuICAgICAgZnVuY3Rpb24gZGVjb2RlVW5yZXNlcnZlZDIoc3RyKSB7XG4gICAgICAgIHZhciBkZWNTdHIgPSBwY3REZWNDaGFycyhzdHIpO1xuICAgICAgICByZXR1cm4gIWRlY1N0ci5tYXRjaChwcm90b2NvbC5VTlJFU0VSVkVEKSA/IHN0ciA6IGRlY1N0cjtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wb25lbnRzLnNjaGVtZSlcbiAgICAgICAgY29tcG9uZW50cy5zY2hlbWUgPSBTdHJpbmcoY29tcG9uZW50cy5zY2hlbWUpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQyKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocHJvdG9jb2wuTk9UX1NDSEVNRSwgXCJcIik7XG4gICAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBjb21wb25lbnRzLnVzZXJpbmZvID0gU3RyaW5nKGNvbXBvbmVudHMudXNlcmluZm8pLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQyKS5yZXBsYWNlKHByb3RvY29sLk5PVF9VU0VSSU5GTywgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBjb21wb25lbnRzLmhvc3QgPSBTdHJpbmcoY29tcG9uZW50cy5ob3N0KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkMikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHByb3RvY29sLk5PVF9IT1NULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgICBpZiAoY29tcG9uZW50cy5wYXRoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGNvbXBvbmVudHMucGF0aCA9IFN0cmluZyhjb21wb25lbnRzLnBhdGgpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIGRlY29kZVVucmVzZXJ2ZWQyKS5yZXBsYWNlKGNvbXBvbmVudHMuc2NoZW1lID8gcHJvdG9jb2wuTk9UX1BBVEggOiBwcm90b2NvbC5OT1RfUEFUSF9OT1NDSEVNRSwgcGN0RW5jQ2hhcikucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpO1xuICAgICAgaWYgKGNvbXBvbmVudHMucXVlcnkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgY29tcG9uZW50cy5xdWVyeSA9IFN0cmluZyhjb21wb25lbnRzLnF1ZXJ5KS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCBkZWNvZGVVbnJlc2VydmVkMikucmVwbGFjZShwcm90b2NvbC5OT1RfUVVFUlksIHBjdEVuY0NoYXIpLnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHRvVXBwZXJDYXNlKTtcbiAgICAgIGlmIChjb21wb25lbnRzLmZyYWdtZW50ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBTdHJpbmcoY29tcG9uZW50cy5mcmFnbWVudCkucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZDIpLnJlcGxhY2UocHJvdG9jb2wuTk9UX0ZSQUdNRU5ULCBwY3RFbmNDaGFyKS5yZXBsYWNlKHByb3RvY29sLlBDVF9FTkNPREVELCB0b1VwcGVyQ2FzZSk7XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gX3N0cmlwTGVhZGluZ1plcm9zKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eMCooLiopLywgXCIkMVwiKSB8fCBcIjBcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjQoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY0QUREUkVTUykgfHwgW107XG4gICAgICB2YXIgX21hdGNoZXMgPSBzbGljZWRUb0FycmF5KG1hdGNoZXMsIDIpLCBhZGRyZXNzID0gX21hdGNoZXNbMV07XG4gICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5zcGxpdChcIi5cIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcykuam9pbihcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaG9zdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gX25vcm1hbGl6ZUlQdjYoaG9zdCwgcHJvdG9jb2wpIHtcbiAgICAgIHZhciBtYXRjaGVzID0gaG9zdC5tYXRjaChwcm90b2NvbC5JUFY2QUREUkVTUykgfHwgW107XG4gICAgICB2YXIgX21hdGNoZXMyID0gc2xpY2VkVG9BcnJheShtYXRjaGVzLCAzKSwgYWRkcmVzcyA9IF9tYXRjaGVzMlsxXSwgem9uZSA9IF9tYXRjaGVzMlsyXTtcbiAgICAgIGlmIChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCI6OlwiKS5yZXZlcnNlKCksIF9hZGRyZXNzJHRvTG93ZXJDYXNlJDIgPSBzbGljZWRUb0FycmF5KF9hZGRyZXNzJHRvTG93ZXJDYXNlJCwgMiksIGxhc3QgPSBfYWRkcmVzcyR0b0xvd2VyQ2FzZSQyWzBdLCBmaXJzdCA9IF9hZGRyZXNzJHRvTG93ZXJDYXNlJDJbMV07XG4gICAgICAgIHZhciBmaXJzdEZpZWxkcyA9IGZpcnN0ID8gZmlyc3Quc3BsaXQoXCI6XCIpLm1hcChfc3RyaXBMZWFkaW5nWmVyb3MpIDogW107XG4gICAgICAgIHZhciBsYXN0RmllbGRzID0gbGFzdC5zcGxpdChcIjpcIikubWFwKF9zdHJpcExlYWRpbmdaZXJvcyk7XG4gICAgICAgIHZhciBpc0xhc3RGaWVsZElQdjRBZGRyZXNzID0gcHJvdG9jb2wuSVBWNEFERFJFU1MudGVzdChsYXN0RmllbGRzW2xhc3RGaWVsZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgZmllbGRDb3VudCA9IGlzTGFzdEZpZWxkSVB2NEFkZHJlc3MgPyA3IDogODtcbiAgICAgICAgdmFyIGxhc3RGaWVsZHNTdGFydCA9IGxhc3RGaWVsZHMubGVuZ3RoIC0gZmllbGRDb3VudDtcbiAgICAgICAgdmFyIGZpZWxkcyA9IEFycmF5KGZpZWxkQ291bnQpO1xuICAgICAgICBmb3IgKHZhciB4ID0gMDt4IDwgZmllbGRDb3VudDsgKyt4KSB7XG4gICAgICAgICAgZmllbGRzW3hdID0gZmlyc3RGaWVsZHNbeF0gfHwgbGFzdEZpZWxkc1tsYXN0RmllbGRzU3RhcnQgKyB4XSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xhc3RGaWVsZElQdjRBZGRyZXNzKSB7XG4gICAgICAgICAgZmllbGRzW2ZpZWxkQ291bnQgLSAxXSA9IF9ub3JtYWxpemVJUHY0KGZpZWxkc1tmaWVsZENvdW50IC0gMV0sIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxsWmVyb0ZpZWxkcyA9IGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBmaWVsZCwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoIWZpZWxkIHx8IGZpZWxkID09PSBcIjBcIikge1xuICAgICAgICAgICAgdmFyIGxhc3RMb25nZXN0ID0gYWNjW2FjYy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0TG9uZ2VzdCAmJiBsYXN0TG9uZ2VzdC5pbmRleCArIGxhc3RMb25nZXN0Lmxlbmd0aCA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgbGFzdExvbmdlc3QubGVuZ3RoKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhY2MucHVzaCh7IGluZGV4LCBsZW5ndGg6IDEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIFtdKTtcbiAgICAgICAgdmFyIGxvbmdlc3RaZXJvRmllbGRzID0gYWxsWmVyb0ZpZWxkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfSlbMF07XG4gICAgICAgIHZhciBuZXdIb3N0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAobG9uZ2VzdFplcm9GaWVsZHMgJiYgbG9uZ2VzdFplcm9GaWVsZHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBuZXdGaXJzdCA9IGZpZWxkcy5zbGljZSgwLCBsb25nZXN0WmVyb0ZpZWxkcy5pbmRleCk7XG4gICAgICAgICAgdmFyIG5ld0xhc3QgPSBmaWVsZHMuc2xpY2UobG9uZ2VzdFplcm9GaWVsZHMuaW5kZXggKyBsb25nZXN0WmVyb0ZpZWxkcy5sZW5ndGgpO1xuICAgICAgICAgIG5ld0hvc3QgPSBuZXdGaXJzdC5qb2luKFwiOlwiKSArIFwiOjpcIiArIG5ld0xhc3Quam9pbihcIjpcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SG9zdCA9IGZpZWxkcy5qb2luKFwiOlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9uZSkge1xuICAgICAgICAgIG5ld0hvc3QgKz0gXCIlXCIgKyB6b25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdIb3N0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBVUklfUEFSU0UgPSAvXig/OihbXjpcXC8/I10rKTopPyg/OlxcL1xcLygoPzooW15cXC8/I0BdKilAKT8oXFxbW15cXC8/I1xcXV0rXFxdfFteXFwvPyM6XSopKD86XFw6KFxcZCopKT8pKT8oW14/I10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxcXG58XFxyKSopKT8vaTtcbiAgICB2YXIgTk9fTUFUQ0hfSVNfVU5ERUZJTkVEID0gXCJcIi5tYXRjaCgvKCl7MH0vKVsxXSA9PT0gdW5kZWZpbmVkO1xuICAgIGZ1bmN0aW9uIHBhcnNlKHVyaVN0cmluZykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpICE9PSBmYWxzZSA/IElSSV9QUk9UT0NPTCA6IFVSSV9QUk9UT0NPTDtcbiAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gXCJzdWZmaXhcIilcbiAgICAgICAgdXJpU3RyaW5nID0gKG9wdGlvbnMuc2NoZW1lID8gb3B0aW9ucy5zY2hlbWUgKyBcIjpcIiA6IFwiXCIpICsgXCIvL1wiICsgdXJpU3RyaW5nO1xuICAgICAgdmFyIG1hdGNoZXMgPSB1cmlTdHJpbmcubWF0Y2goVVJJX1BBUlNFKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmIChOT19NQVRDSF9JU19VTkRFRklORUQpIHtcbiAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgY29tcG9uZW50cy51c2VyaW5mbyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gbWF0Y2hlc1s0XTtcbiAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gbWF0Y2hlc1s2XSB8fCBcIlwiO1xuICAgICAgICAgIGNvbXBvbmVudHMucXVlcnkgPSBtYXRjaGVzWzddO1xuICAgICAgICAgIGNvbXBvbmVudHMuZnJhZ21lbnQgPSBtYXRjaGVzWzhdO1xuICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSBtYXRjaGVzWzVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wb25lbnRzLnNjaGVtZSA9IG1hdGNoZXNbMV0gfHwgdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbXBvbmVudHMudXNlcmluZm8gPSB1cmlTdHJpbmcuaW5kZXhPZihcIkBcIikgIT09IC0xID8gbWF0Y2hlc1szXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb21wb25lbnRzLmhvc3QgPSB1cmlTdHJpbmcuaW5kZXhPZihcIi8vXCIpICE9PSAtMSA/IG1hdGNoZXNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgICAgICAgIGNvbXBvbmVudHMucGF0aCA9IG1hdGNoZXNbNl0gfHwgXCJcIjtcbiAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gdXJpU3RyaW5nLmluZGV4T2YoXCI/XCIpICE9PSAtMSA/IG1hdGNoZXNbN10gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29tcG9uZW50cy5mcmFnbWVudCA9IHVyaVN0cmluZy5pbmRleE9mKFwiI1wiKSAhPT0gLTEgPyBtYXRjaGVzWzhdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGlmIChpc05hTihjb21wb25lbnRzLnBvcnQpKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLnBvcnQgPSB1cmlTdHJpbmcubWF0Y2goL1xcL1xcLyg/Oi58XFxuKSpcXDooPzpcXC98XFw/fFxcI3wkKS8pID8gbWF0Y2hlc1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9IF9ub3JtYWxpemVJUHY2KF9ub3JtYWxpemVJUHY0KGNvbXBvbmVudHMuaG9zdCwgcHJvdG9jb2wpLCBwcm90b2NvbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudHMuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgY29tcG9uZW50cy51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMuaG9zdCA9PT0gdW5kZWZpbmVkICYmIGNvbXBvbmVudHMucG9ydCA9PT0gdW5kZWZpbmVkICYmICFjb21wb25lbnRzLnBhdGggJiYgY29tcG9uZW50cy5xdWVyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInNhbWUtZG9jdW1lbnRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjb21wb25lbnRzLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInJlbGF0aXZlXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG9uZW50cy5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcImFic29sdXRlXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcG9uZW50cy5yZWZlcmVuY2UgPSBcInVyaVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gY29tcG9uZW50cy5yZWZlcmVuY2UpIHtcbiAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIlVSSSBpcyBub3QgYSBcIiArIG9wdGlvbnMucmVmZXJlbmNlICsgXCIgcmVmZXJlbmNlLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlbWVIYW5kbGVyID0gU0NIRU1FU1sob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50cy5zY2hlbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudHMuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5ob3N0ID0gcHVueWNvZGUudG9BU0NJSShjb21wb25lbnRzLmhvc3QucmVwbGFjZShwcm90b2NvbC5QQ1RfRU5DT0RFRCwgcGN0RGVjQ2hhcnMpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmVycm9yID0gY29tcG9uZW50cy5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSSB2aWEgcHVueWNvZGU6IFwiICsgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIFVSSV9QUk9UT0NPTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9uZW50cy5lcnJvciA9IGNvbXBvbmVudHMuZXJyb3IgfHwgXCJVUkkgY2FuIG5vdCBiZSBwYXJzZWQuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29tcG9uZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gX3JlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBvcHRpb25zLmlyaSAhPT0gZmFsc2UgPyBJUklfUFJPVE9DT0wgOiBVUklfUFJPVE9DT0w7XG4gICAgICB2YXIgdXJpVG9rZW5zID0gW107XG4gICAgICBpZiAoY29tcG9uZW50cy51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudHMudXNlcmluZm8pO1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIkBcIik7XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50cy5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goX25vcm1hbGl6ZUlQdjYoX25vcm1hbGl6ZUlQdjQoU3RyaW5nKGNvbXBvbmVudHMuaG9zdCksIHByb3RvY29sKSwgcHJvdG9jb2wpLnJlcGxhY2UocHJvdG9jb2wuSVBWNkFERFJFU1MsIGZ1bmN0aW9uKF8sICQxLCAkMikge1xuICAgICAgICAgIHJldHVybiBcIltcIiArICQxICsgKCQyID8gXCIlMjVcIiArICQyIDogXCJcIikgKyBcIl1cIjtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRzLnBvcnQgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGNvbXBvbmVudHMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChcIjpcIik7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnRzLnBvcnQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oXCJcIikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBSRFMxID0gL15cXC5cXC4/XFwvLztcbiAgICB2YXIgUkRTMiA9IC9eXFwvXFwuKFxcL3wkKS87XG4gICAgdmFyIFJEUzMgPSAvXlxcL1xcLlxcLihcXC98JCkvO1xuICAgIHZhciBSRFM1ID0gL15cXC8/KD86LnxcXG4pKj8oPz1cXC98JCkvO1xuICAgIGZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzKGlucHV0KSB7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaChSRFMxKSkge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMxLCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5tYXRjaChSRFMyKSkge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQucmVwbGFjZShSRFMyLCBcIi9cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQubWF0Y2goUkRTMykpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoUkRTMywgXCIvXCIpO1xuICAgICAgICAgIG91dHB1dC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gXCIuXCIgfHwgaW5wdXQgPT09IFwiLi5cIikge1xuICAgICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW0gPSBpbnB1dC5tYXRjaChSRFM1KTtcbiAgICAgICAgICBpZiAoaW0pIHtcbiAgICAgICAgICAgIHZhciBzID0gaW1bMF07XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKHMubGVuZ3RoKTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGRvdCBzZWdtZW50IGNvbmRpdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VyaWFsaXplKGNvbXBvbmVudHMpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBwcm90b2NvbCA9IG9wdGlvbnMuaXJpID8gSVJJX1BST1RPQ09MIDogVVJJX1BST1RPQ09MO1xuICAgICAgdmFyIHVyaVRva2VucyA9IFtdO1xuICAgICAgdmFyIHNjaGVtZUhhbmRsZXIgPSBTQ0hFTUVTWyhvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnRzLnNjaGVtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKVxuICAgICAgICBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnRzLCBvcHRpb25zKTtcbiAgICAgIGlmIChjb21wb25lbnRzLmhvc3QpIHtcbiAgICAgICAgaWYgKHByb3RvY29sLklQVjZBRERSRVNTLnRlc3QoY29tcG9uZW50cy5ob3N0KSkge30gZWxzZSBpZiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuaG9zdCA9ICFvcHRpb25zLmlyaSA/IHB1bnljb2RlLnRvQVNDSUkoY29tcG9uZW50cy5ob3N0LnJlcGxhY2UocHJvdG9jb2wuUENUX0VOQ09ERUQsIHBjdERlY0NoYXJzKS50b0xvd2VyQ2FzZSgpKSA6IHB1bnljb2RlLnRvVW5pY29kZShjb21wb25lbnRzLmhvc3QpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX25vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKGNvbXBvbmVudHMsIHByb3RvY29sKTtcbiAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIiAmJiBjb21wb25lbnRzLnNjaGVtZSkge1xuICAgICAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnRzLnNjaGVtZSk7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiOlwiKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRob3JpdHkgPSBfcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gXCJzdWZmaXhcIikge1xuICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiLy9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KTtcbiAgICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAmJiBjb21wb25lbnRzLnBhdGguY2hhckF0KDApICE9PSBcIi9cIikge1xuICAgICAgICAgIHVyaVRva2Vucy5wdXNoKFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbXBvbmVudHMucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBzID0gY29tcG9uZW50cy5wYXRoO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRob3JpdHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXC9cXC8vLCBcIi8lMkZcIik7XG4gICAgICAgIH1cbiAgICAgICAgdXJpVG9rZW5zLnB1c2gocyk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50cy5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiP1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5xdWVyeSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcG9uZW50cy5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVyaVRva2Vucy5wdXNoKFwiI1wiKTtcbiAgICAgICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50cy5mcmFnbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzKGJhc2UyLCByZWxhdGl2ZSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHNraXBOb3JtYWxpemF0aW9uID0gYXJndW1lbnRzWzNdO1xuICAgICAgdmFyIHRhcmdldCA9IHt9O1xuICAgICAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgICAgICBiYXNlMiA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlMiwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWU7XG4gICAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvO1xuICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8IFwiXCIpO1xuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mbztcbiAgICAgICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCBcIlwiKTtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZTIucGF0aDtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZTIucXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoLmNoYXJBdCgwKSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgoYmFzZTIudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlMi5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZTIucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZTIucGF0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gXCIvXCIgKyByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlMi5wYXRoKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZTIucGF0aC5zbGljZSgwLCBiYXNlMi5wYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpICsgcmVsYXRpdmUucGF0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlMi51c2VyaW5mbztcbiAgICAgICAgICB0YXJnZXQuaG9zdCA9IGJhc2UyLmhvc3Q7XG4gICAgICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlMi5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlMi5zY2hlbWU7XG4gICAgICB9XG4gICAgICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudDtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmUoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzY2hlbWVsZXNzT3B0aW9ucyA9IGFzc2lnbih7IHNjaGVtZTogXCJudWxsXCIgfSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVDb21wb25lbnRzKHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpLCBzY2hlbWVsZXNzT3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaSA9IHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpID0gcGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVyaTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWwodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiB1cmlBID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHVyaUEgPSBzZXJpYWxpemUocGFyc2UodXJpQSwgb3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlT2YodXJpQSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdXJpQSA9IHNlcmlhbGl6ZSh1cmlBLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdXJpQiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmlCID0gc2VyaWFsaXplKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZU9mKHVyaUIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHVyaUIgPSBzZXJpYWxpemUodXJpQiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXJpQSA9PT0gdXJpQjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXNjYXBlQ29tcG9uZW50KHN0ciwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHN0ciAmJiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKCFvcHRpb25zIHx8ICFvcHRpb25zLmlyaSA/IFVSSV9QUk9UT0NPTC5FU0NBUEUgOiBJUklfUFJPVE9DT0wuRVNDQVBFLCBwY3RFbmNDaGFyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVDb21wb25lbnQoc3RyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gc3RyICYmIHN0ci50b1N0cmluZygpLnJlcGxhY2UoIW9wdGlvbnMgfHwgIW9wdGlvbnMuaXJpID8gVVJJX1BST1RPQ09MLlBDVF9FTkNPREVEIDogSVJJX1BST1RPQ09MLlBDVF9FTkNPREVELCBwY3REZWNDaGFycyk7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgc2NoZW1lOiBcImh0dHBcIixcbiAgICAgIGRvbWFpbkhvc3Q6IHRydWUsXG4gICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbXBvbmVudHMuaG9zdCkge1xuICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICB9LFxuICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoY29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudHMuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSBcImh0dHBzXCI7XG4gICAgICAgIGlmIChjb21wb25lbnRzLnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50cy5wb3J0ID09PSBcIlwiKSB7XG4gICAgICAgICAgY29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29tcG9uZW50cy5wYXRoKSB7XG4gICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlciQxID0ge1xuICAgICAgc2NoZW1lOiBcImh0dHBzXCIsXG4gICAgICBkb21haW5Ib3N0OiBoYW5kbGVyLmRvbWFpbkhvc3QsXG4gICAgICBwYXJzZTogaGFuZGxlci5wYXJzZSxcbiAgICAgIHNlcmlhbGl6ZTogaGFuZGxlci5zZXJpYWxpemVcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzU2VjdXJlKHdzQ29tcG9uZW50cykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB3c0NvbXBvbmVudHMuc2VjdXJlID09PSBcImJvb2xlYW5cIiA/IHdzQ29tcG9uZW50cy5zZWN1cmUgOiBTdHJpbmcod3NDb21wb25lbnRzLnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gXCJ3c3NcIjtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXIkMiA9IHtcbiAgICAgIHNjaGVtZTogXCJ3c1wiLFxuICAgICAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3c0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB3c0NvbXBvbmVudHMuc2VjdXJlID0gaXNTZWN1cmUod3NDb21wb25lbnRzKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudHMucGF0aCB8fCBcIi9cIikgKyAod3NDb21wb25lbnRzLnF1ZXJ5ID8gXCI/XCIgKyB3c0NvbXBvbmVudHMucXVlcnkgOiBcIlwiKTtcbiAgICAgICAgd3NDb21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHdzQ29tcG9uZW50cztcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSh3c0NvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHdzQ29tcG9uZW50cy5wb3J0ID09PSAoaXNTZWN1cmUod3NDb21wb25lbnRzKSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudHMucG9ydCA9PT0gXCJcIikge1xuICAgICAgICAgIHdzQ29tcG9uZW50cy5wb3J0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd3NDb21wb25lbnRzLnNlY3VyZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB3c0NvbXBvbmVudHMuc2NoZW1lID0gd3NDb21wb25lbnRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICAgICAgd3NDb21wb25lbnRzLnNlY3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3NDb21wb25lbnRzLnJlc291cmNlTmFtZSkge1xuICAgICAgICAgIHZhciBfd3NDb21wb25lbnRzJHJlc291cmMgPSB3c0NvbXBvbmVudHMucmVzb3VyY2VOYW1lLnNwbGl0KFwiP1wiKSwgX3dzQ29tcG9uZW50cyRyZXNvdXJjMiA9IHNsaWNlZFRvQXJyYXkoX3dzQ29tcG9uZW50cyRyZXNvdXJjLCAyKSwgcGF0aCA9IF93c0NvbXBvbmVudHMkcmVzb3VyYzJbMF0sIHF1ZXJ5ID0gX3dzQ29tcG9uZW50cyRyZXNvdXJjMlsxXTtcbiAgICAgICAgICB3c0NvbXBvbmVudHMucGF0aCA9IHBhdGggJiYgcGF0aCAhPT0gXCIvXCIgPyBwYXRoIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHdzQ29tcG9uZW50cy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgIHdzQ29tcG9uZW50cy5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgd3NDb21wb25lbnRzLmZyYWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gd3NDb21wb25lbnRzO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZXIkMyA9IHtcbiAgICAgIHNjaGVtZTogXCJ3c3NcIixcbiAgICAgIGRvbWFpbkhvc3Q6IGhhbmRsZXIkMi5kb21haW5Ib3N0LFxuICAgICAgcGFyc2U6IGhhbmRsZXIkMi5wYXJzZSxcbiAgICAgIHNlcmlhbGl6ZTogaGFuZGxlciQyLnNlcmlhbGl6ZVxuICAgIH07XG4gICAgdmFyIE8gPSB7fTtcbiAgICB2YXIgaXNJUkkgPSB0cnVlO1xuICAgIHZhciBVTlJFU0VSVkVEJCQgPSBcIltBLVphLXowLTlcXFxcLVxcXFwuXFxcXF9cXFxcflwiICsgKGlzSVJJID8gXCJcXFxceEEwLVxcXFx1MjAwRFxcXFx1MjAxMC1cXFxcdTIwMjlcXFxcdTIwMkYtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZcIiA6IFwiXCIpICsgXCJdXCI7XG4gICAgdmFyIEhFWERJRyQkID0gXCJbMC05QS1GYS1mXVwiO1xuICAgIHZhciBQQ1RfRU5DT0RFRCQgPSBzdWJleHAoc3ViZXhwKFwiJVtFRmVmXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlWzg5QS1GYS1mXVwiICsgSEVYRElHJCQgKyBcIiVcIiArIEhFWERJRyQkICsgSEVYRElHJCQpICsgXCJ8XCIgKyBzdWJleHAoXCIlXCIgKyBIRVhESUckJCArIEhFWERJRyQkKSk7XG4gICAgdmFyIEFURVhUJCQgPSBcIltBLVphLXowLTlcXFxcIVxcXFwkXFxcXCVcXFxcJ1xcXFwqXFxcXCtcXFxcLVxcXFxeXFxcXF9cXFxcYFxcXFx7XFxcXHxcXFxcfVxcXFx+XVwiO1xuICAgIHZhciBRVEVYVCQkID0gXCJbXFxcXCFcXFxcJFxcXFwlXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC1cXFxcLjAtOVxcXFw8XFxcXD5BLVpcXFxceDVFLVxcXFx4N0VdXCI7XG4gICAgdmFyIFZDSEFSJCQgPSBtZXJnZShRVEVYVCQkLCBcIltcXFxcXFxcIlxcXFxcXFxcXVwiKTtcbiAgICB2YXIgU09NRV9ERUxJTVMkJCA9IFwiW1xcXFwhXFxcXCRcXFxcJ1xcXFwoXFxcXClcXFxcKlxcXFwrXFxcXCxcXFxcO1xcXFw6XFxcXEBdXCI7XG4gICAgdmFyIFVOUkVTRVJWRUQgPSBuZXcgUmVnRXhwKFVOUkVTRVJWRUQkJCwgXCJnXCIpO1xuICAgIHZhciBQQ1RfRU5DT0RFRCA9IG5ldyBSZWdFeHAoUENUX0VOQ09ERUQkLCBcImdcIik7XG4gICAgdmFyIE5PVF9MT0NBTF9QQVJUID0gbmV3IFJlZ0V4cChtZXJnZShcIlteXVwiLCBBVEVYVCQkLCBcIltcXFxcLl1cIiwgXCJbXFxcXFxcXCJdXCIsIFZDSEFSJCQpLCBcImdcIik7XG4gICAgdmFyIE5PVF9IRk5BTUUgPSBuZXcgUmVnRXhwKG1lcmdlKFwiW15dXCIsIFVOUkVTRVJWRUQkJCwgU09NRV9ERUxJTVMkJCksIFwiZ1wiKTtcbiAgICB2YXIgTk9UX0hGVkFMVUUgPSBOT1RfSEZOQU1FO1xuICAgIGZ1bmN0aW9uIGRlY29kZVVucmVzZXJ2ZWQoc3RyKSB7XG4gICAgICB2YXIgZGVjU3RyID0gcGN0RGVjQ2hhcnMoc3RyKTtcbiAgICAgIHJldHVybiAhZGVjU3RyLm1hdGNoKFVOUkVTRVJWRUQpID8gc3RyIDogZGVjU3RyO1xuICAgIH1cbiAgICB2YXIgaGFuZGxlciQ0ID0ge1xuICAgICAgc2NoZW1lOiBcIm1haWx0b1wiLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlJCQxKGNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1haWx0b0NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuICAgICAgICB2YXIgdG8gPSBtYWlsdG9Db21wb25lbnRzLnRvID0gbWFpbHRvQ29tcG9uZW50cy5wYXRoID8gbWFpbHRvQ29tcG9uZW50cy5wYXRoLnNwbGl0KFwiLFwiKSA6IFtdO1xuICAgICAgICBtYWlsdG9Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnF1ZXJ5KSB7XG4gICAgICAgICAgdmFyIHVua25vd25IZWFkZXJzID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgICB2YXIgaGZpZWxkcyA9IG1haWx0b0NvbXBvbmVudHMucXVlcnkuc3BsaXQoXCImXCIpO1xuICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IGhmaWVsZHMubGVuZ3RoO3ggPCB4bDsgKyt4KSB7XG4gICAgICAgICAgICB2YXIgaGZpZWxkID0gaGZpZWxkc1t4XS5zcGxpdChcIj1cIik7XG4gICAgICAgICAgICBzd2l0Y2ggKGhmaWVsZFswXSkge1xuICAgICAgICAgICAgICBjYXNlIFwidG9cIjpcbiAgICAgICAgICAgICAgICB2YXIgdG9BZGRycyA9IGhmaWVsZFsxXS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX3ggPSAwLCBfeGwgPSB0b0FkZHJzLmxlbmd0aDtfeCA8IF94bDsgKytfeCkge1xuICAgICAgICAgICAgICAgICAgdG8ucHVzaCh0b0FkZHJzW194XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwic3ViamVjdFwiOlxuICAgICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuc3ViamVjdCA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICAgICAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5ib2R5ID0gdW5lc2NhcGVDb21wb25lbnQoaGZpZWxkWzFdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB1bmtub3duSGVhZGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1t1bmVzY2FwZUNvbXBvbmVudChoZmllbGRbMF0sIG9wdGlvbnMpXSA9IHVuZXNjYXBlQ29tcG9uZW50KGhmaWVsZFsxXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh1bmtub3duSGVhZGVycylcbiAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgbWFpbHRvQ29tcG9uZW50cy5xdWVyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yICh2YXIgX3gyID0gMCwgX3hsMiA9IHRvLmxlbmd0aDtfeDIgPCBfeGwyOyArK194Mikge1xuICAgICAgICAgIHZhciBhZGRyID0gdG9bX3gyXS5zcGxpdChcIkBcIik7XG4gICAgICAgICAgYWRkclswXSA9IHVuZXNjYXBlQ29tcG9uZW50KGFkZHJbMF0pO1xuICAgICAgICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgYWRkclsxXSA9IHB1bnljb2RlLnRvQVNDSUkodW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIG1haWx0b0NvbXBvbmVudHMuZXJyb3IgPSBtYWlsdG9Db21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRyWzFdID0gdW5lc2NhcGVDb21wb25lbnQoYWRkclsxXSwgb3B0aW9ucykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9bX3gyXSA9IGFkZHIuam9pbihcIkBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1haWx0b0NvbXBvbmVudHM7XG4gICAgICB9LFxuICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUkJDEobWFpbHRvQ29tcG9uZW50cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IG1haWx0b0NvbXBvbmVudHM7XG4gICAgICAgIHZhciB0byA9IHRvQXJyYXkobWFpbHRvQ29tcG9uZW50cy50byk7XG4gICAgICAgIGlmICh0bykge1xuICAgICAgICAgIGZvciAodmFyIHggPSAwLCB4bCA9IHRvLmxlbmd0aDt4IDwgeGw7ICsreCkge1xuICAgICAgICAgICAgdmFyIHRvQWRkciA9IFN0cmluZyh0b1t4XSk7XG4gICAgICAgICAgICB2YXIgYXRJZHggPSB0b0FkZHIubGFzdEluZGV4T2YoXCJAXCIpO1xuICAgICAgICAgICAgdmFyIGxvY2FsUGFydCA9IHRvQWRkci5zbGljZSgwLCBhdElkeCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0xPQ0FMX1BBUlQsIHBjdEVuY0NoYXIpO1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHRvQWRkci5zbGljZShhdElkeCArIDEpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZG9tYWluID0gIW9wdGlvbnMuaXJpID8gcHVueWNvZGUudG9BU0NJSSh1bmVzY2FwZUNvbXBvbmVudChkb21haW4sIG9wdGlvbnMpLnRvTG93ZXJDYXNlKCkpIDogcHVueWNvZGUudG9Vbmljb2RlKGRvbWFpbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHMuZXJyb3IgPSBjb21wb25lbnRzLmVycm9yIHx8IFwiRW1haWwgYWRkcmVzcydzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIFwiICsgKCFvcHRpb25zLmlyaSA/IFwiQVNDSUlcIiA6IFwiVW5pY29kZVwiKSArIFwiIHZpYSBwdW55Y29kZTogXCIgKyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9beF0gPSBsb2NhbFBhcnQgKyBcIkBcIiArIGRvbWFpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcG9uZW50cy5wYXRoID0gdG8uam9pbihcIixcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgPSBtYWlsdG9Db21wb25lbnRzLmhlYWRlcnMgfHwge307XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLnN1YmplY3QpXG4gICAgICAgICAgaGVhZGVyc1tcInN1YmplY3RcIl0gPSBtYWlsdG9Db21wb25lbnRzLnN1YmplY3Q7XG4gICAgICAgIGlmIChtYWlsdG9Db21wb25lbnRzLmJvZHkpXG4gICAgICAgICAgaGVhZGVyc1tcImJvZHlcIl0gPSBtYWlsdG9Db21wb25lbnRzLmJvZHk7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgaWYgKGhlYWRlcnNbbmFtZV0gIT09IE9bbmFtZV0pIHtcbiAgICAgICAgICAgIGZpZWxkcy5wdXNoKG5hbWUucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGTkFNRSwgcGN0RW5jQ2hhcikgKyBcIj1cIiArIGhlYWRlcnNbbmFtZV0ucmVwbGFjZShQQ1RfRU5DT0RFRCwgZGVjb2RlVW5yZXNlcnZlZCkucmVwbGFjZShQQ1RfRU5DT0RFRCwgdG9VcHBlckNhc2UpLnJlcGxhY2UoTk9UX0hGVkFMVUUsIHBjdEVuY0NoYXIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb21wb25lbnRzLnF1ZXJ5ID0gZmllbGRzLmpvaW4oXCImXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIFVSTl9QQVJTRSA9IC9eKFteXFw6XSspXFw6KC4qKS87XG4gICAgdmFyIGhhbmRsZXIkNSA9IHtcbiAgICAgIHNjaGVtZTogXCJ1cm5cIixcbiAgICAgIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSQkMShjb21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gY29tcG9uZW50cy5wYXRoICYmIGNvbXBvbmVudHMucGF0aC5tYXRjaChVUk5fUEFSU0UpO1xuICAgICAgICB2YXIgdXJuQ29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgdmFyIHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudHMuc2NoZW1lIHx8IFwidXJuXCI7XG4gICAgICAgICAgdmFyIG5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgbnNzID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICB2YXIgdXJuU2NoZW1lID0gc2NoZW1lICsgXCI6XCIgKyAob3B0aW9ucy5uaWQgfHwgbmlkKTtcbiAgICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgICB1cm5Db21wb25lbnRzLm5pZCA9IG5pZDtcbiAgICAgICAgICB1cm5Db21wb25lbnRzLm5zcyA9IG5zcztcbiAgICAgICAgICB1cm5Db21wb25lbnRzLnBhdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICAgIHVybkNvbXBvbmVudHMgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cm5Db21wb25lbnRzLmVycm9yID0gdXJuQ29tcG9uZW50cy5lcnJvciB8fCBcIlVSTiBjYW4gbm90IGJlIHBhcnNlZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICAgIH0sXG4gICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSQkMSh1cm5Db21wb25lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnRzLnNjaGVtZSB8fCBcInVyblwiO1xuICAgICAgICB2YXIgbmlkID0gdXJuQ29tcG9uZW50cy5uaWQ7XG4gICAgICAgIHZhciB1cm5TY2hlbWUgPSBzY2hlbWUgKyBcIjpcIiArIChvcHRpb25zLm5pZCB8fCBuaWQpO1xuICAgICAgICB2YXIgc2NoZW1lSGFuZGxlciA9IFNDSEVNRVNbdXJuU2NoZW1lXTtcbiAgICAgICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgICAgICB1cm5Db21wb25lbnRzID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVyaUNvbXBvbmVudHMgPSB1cm5Db21wb25lbnRzO1xuICAgICAgICB2YXIgbnNzID0gdXJuQ29tcG9uZW50cy5uc3M7XG4gICAgICAgIHVyaUNvbXBvbmVudHMucGF0aCA9IChuaWQgfHwgb3B0aW9ucy5uaWQpICsgXCI6XCIgKyBuc3M7XG4gICAgICAgIHJldHVybiB1cmlDb21wb25lbnRzO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIFVVSUQgPSAvXlswLTlBLUZhLWZdezh9KD86XFwtWzAtOUEtRmEtZl17NH0pezN9XFwtWzAtOUEtRmEtZl17MTJ9JC87XG4gICAgdmFyIGhhbmRsZXIkNiA9IHtcbiAgICAgIHNjaGVtZTogXCJ1cm46dXVpZFwiLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKHVybkNvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHV1aWRDb21wb25lbnRzID0gdXJuQ29tcG9uZW50cztcbiAgICAgICAgdXVpZENvbXBvbmVudHMudXVpZCA9IHV1aWRDb21wb25lbnRzLm5zcztcbiAgICAgICAgdXVpZENvbXBvbmVudHMubnNzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50cy51dWlkIHx8ICF1dWlkQ29tcG9uZW50cy51dWlkLm1hdGNoKFVVSUQpKSkge1xuICAgICAgICAgIHV1aWRDb21wb25lbnRzLmVycm9yID0gdXVpZENvbXBvbmVudHMuZXJyb3IgfHwgXCJVVUlEIGlzIG5vdCB2YWxpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXVpZENvbXBvbmVudHM7XG4gICAgICB9LFxuICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUodXVpZENvbXBvbmVudHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVybkNvbXBvbmVudHMgPSB1dWlkQ29tcG9uZW50cztcbiAgICAgICAgdXJuQ29tcG9uZW50cy5uc3MgPSAodXVpZENvbXBvbmVudHMudXVpZCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gdXJuQ29tcG9uZW50cztcbiAgICAgIH1cbiAgICB9O1xuICAgIFNDSEVNRVNbaGFuZGxlci5zY2hlbWVdID0gaGFuZGxlcjtcbiAgICBTQ0hFTUVTW2hhbmRsZXIkMS5zY2hlbWVdID0gaGFuZGxlciQxO1xuICAgIFNDSEVNRVNbaGFuZGxlciQyLnNjaGVtZV0gPSBoYW5kbGVyJDI7XG4gICAgU0NIRU1FU1toYW5kbGVyJDMuc2NoZW1lXSA9IGhhbmRsZXIkMztcbiAgICBTQ0hFTUVTW2hhbmRsZXIkNC5zY2hlbWVdID0gaGFuZGxlciQ0O1xuICAgIFNDSEVNRVNbaGFuZGxlciQ1LnNjaGVtZV0gPSBoYW5kbGVyJDU7XG4gICAgU0NIRU1FU1toYW5kbGVyJDYuc2NoZW1lXSA9IGhhbmRsZXIkNjtcbiAgICBleHBvcnRzMi5TQ0hFTUVTID0gU0NIRU1FUztcbiAgICBleHBvcnRzMi5wY3RFbmNDaGFyID0gcGN0RW5jQ2hhcjtcbiAgICBleHBvcnRzMi5wY3REZWNDaGFycyA9IHBjdERlY0NoYXJzO1xuICAgIGV4cG9ydHMyLnBhcnNlID0gcGFyc2U7XG4gICAgZXhwb3J0czIucmVtb3ZlRG90U2VnbWVudHMgPSByZW1vdmVEb3RTZWdtZW50cztcbiAgICBleHBvcnRzMi5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgZXhwb3J0czIucmVzb2x2ZUNvbXBvbmVudHMgPSByZXNvbHZlQ29tcG9uZW50cztcbiAgICBleHBvcnRzMi5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBleHBvcnRzMi5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4gICAgZXhwb3J0czIuZXF1YWwgPSBlcXVhbDtcbiAgICBleHBvcnRzMi5lc2NhcGVDb21wb25lbnQgPSBlc2NhcGVDb21wb25lbnQ7XG4gICAgZXhwb3J0czIudW5lc2NhcGVDb21wb25lbnQgPSB1bmVzY2FwZUNvbXBvbmVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0czIsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICB9KTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzXG52YXIgcmVxdWlyZV9mYXN0X2RlZXBfZXF1YWwgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDtpLS0gIT09IDA7IClcbiAgICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApXG4gICAgICAgIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZilcbiAgICAgICAgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKVxuICAgICAgICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoO2ktLSAhPT0gMDsgKVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSlcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7aS0tICE9PSAwOyApIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdWNzMmxlbmd0aC5qc1xudmFyIHJlcXVpcmVfdWNzMmxlbmd0aCA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyKSB7XG4gICAgdmFyIGxlbmd0aCA9IDAsIGxlbiA9IHN0ci5sZW5ndGgsIHBvcyA9IDAsIHZhbHVlO1xuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgIGxlbmd0aCsrO1xuICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKyk7XG4gICAgICBpZiAodmFsdWUgPj0gNTUyOTYgJiYgdmFsdWUgPD0gNTYzMTkgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCh2YWx1ZSAmIDY0NTEyKSA9PSA1NjMyMClcbiAgICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlbmd0aDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3V0aWwuanNcbnZhciByZXF1aXJlX3V0aWwgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29weSxcbiAgICBjaGVja0RhdGFUeXBlLFxuICAgIGNoZWNrRGF0YVR5cGVzLFxuICAgIGNvZXJjZVRvVHlwZXMsXG4gICAgdG9IYXNoLFxuICAgIGdldFByb3BlcnR5LFxuICAgIGVzY2FwZVF1b3RlcyxcbiAgICBlcXVhbDogcmVxdWlyZV9mYXN0X2RlZXBfZXF1YWwoKSxcbiAgICB1Y3MybGVuZ3RoOiByZXF1aXJlX3VjczJsZW5ndGgoKSxcbiAgICB2YXJPY2N1cmVuY2VzLFxuICAgIHZhclJlcGxhY2UsXG4gICAgc2NoZW1hSGFzUnVsZXMsXG4gICAgc2NoZW1hSGFzUnVsZXNFeGNlcHQsXG4gICAgc2NoZW1hVW5rbm93blJ1bGVzLFxuICAgIHRvUXVvdGVkU3RyaW5nLFxuICAgIGdldFBhdGhFeHByLFxuICAgIGdldFBhdGgsXG4gICAgZ2V0RGF0YSxcbiAgICB1bmVzY2FwZUZyYWdtZW50LFxuICAgIHVuZXNjYXBlSnNvblBvaW50ZXIsXG4gICAgZXNjYXBlRnJhZ21lbnQsXG4gICAgZXNjYXBlSnNvblBvaW50ZXJcbiAgfTtcbiAgZnVuY3Rpb24gY29weShvLCB0bykge1xuICAgIHRvID0gdG8gfHwge307XG4gICAgZm9yICh2YXIga2V5IGluIG8pXG4gICAgICB0b1trZXldID0gb1trZXldO1xuICAgIHJldHVybiB0bztcbiAgfVxuICBmdW5jdGlvbiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlLCBkYXRhLCBzdHJpY3ROdW1iZXJzLCBuZWdhdGUpIHtcbiAgICB2YXIgRVFVQUwgPSBuZWdhdGUgPyBcIiAhPT0gXCIgOiBcIiA9PT0gXCIsIEFORCA9IG5lZ2F0ZSA/IFwiIHx8IFwiIDogXCIgJiYgXCIsIE9LMiA9IG5lZ2F0ZSA/IFwiIVwiIDogXCJcIiwgTk9UID0gbmVnYXRlID8gXCJcIiA6IFwiIVwiO1xuICAgIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgIHJldHVybiBkYXRhICsgRVFVQUwgKyBcIm51bGxcIjtcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICByZXR1cm4gT0syICsgXCJBcnJheS5pc0FycmF5KFwiICsgZGF0YSArIFwiKVwiO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICByZXR1cm4gXCIoXCIgKyBPSzIgKyBkYXRhICsgQU5EICsgXCJ0eXBlb2YgXCIgKyBkYXRhICsgRVFVQUwgKyAnXCJvYmplY3RcIicgKyBBTkQgKyBOT1QgKyBcIkFycmF5LmlzQXJyYXkoXCIgKyBkYXRhICsgXCIpKVwiO1xuICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgcmV0dXJuIFwiKHR5cGVvZiBcIiArIGRhdGEgKyBFUVVBTCArICdcIm51bWJlclwiJyArIEFORCArIE5PVCArIFwiKFwiICsgZGF0YSArIFwiICUgMSlcIiArIEFORCArIGRhdGEgKyBFUVVBTCArIGRhdGEgKyAoc3RyaWN0TnVtYmVycyA/IEFORCArIE9LMiArIFwiaXNGaW5pdGUoXCIgKyBkYXRhICsgXCIpXCIgOiBcIlwiKSArIFwiKVwiO1xuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICByZXR1cm4gXCIodHlwZW9mIFwiICsgZGF0YSArIEVRVUFMICsgJ1wiJyArIGRhdGFUeXBlICsgJ1wiJyArIChzdHJpY3ROdW1iZXJzID8gQU5EICsgT0syICsgXCJpc0Zpbml0ZShcIiArIGRhdGEgKyBcIilcIiA6IFwiXCIpICsgXCIpXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJ0eXBlb2YgXCIgKyBkYXRhICsgRVFVQUwgKyAnXCInICsgZGF0YVR5cGUgKyAnXCInO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhkYXRhVHlwZXMsIGRhdGEsIHN0cmljdE51bWJlcnMpIHtcbiAgICBzd2l0Y2ggKGRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1iZXJzLCB0cnVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBjb2RlID0gXCJcIjtcbiAgICAgICAgdmFyIHR5cGVzMiA9IHRvSGFzaChkYXRhVHlwZXMpO1xuICAgICAgICBpZiAodHlwZXMyLmFycmF5ICYmIHR5cGVzMi5vYmplY3QpIHtcbiAgICAgICAgICBjb2RlID0gdHlwZXMyLm51bGwgPyBcIihcIiA6IFwiKCFcIiArIGRhdGEgKyBcIiB8fCBcIjtcbiAgICAgICAgICBjb2RlICs9IFwidHlwZW9mIFwiICsgZGF0YSArICcgIT09IFwib2JqZWN0XCIpJztcbiAgICAgICAgICBkZWxldGUgdHlwZXMyLm51bGw7XG4gICAgICAgICAgZGVsZXRlIHR5cGVzMi5hcnJheTtcbiAgICAgICAgICBkZWxldGUgdHlwZXMyLm9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZXMyLm51bWJlcilcbiAgICAgICAgICBkZWxldGUgdHlwZXMyLmludGVnZXI7XG4gICAgICAgIGZvciAodmFyIHQgaW4gdHlwZXMyKVxuICAgICAgICAgIGNvZGUgKz0gKGNvZGUgPyBcIiAmJiBcIiA6IFwiXCIpICsgY2hlY2tEYXRhVHlwZSh0LCBkYXRhLCBzdHJpY3ROdW1iZXJzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuICB9XG4gIHZhciBDT0VSQ0VfVE9fVFlQRVMgPSB0b0hhc2goW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKTtcbiAgZnVuY3Rpb24gY29lcmNlVG9UeXBlcyhvcHRpb25Db2VyY2VUeXBlcywgZGF0YVR5cGVzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YVR5cGVzKSkge1xuICAgICAgdmFyIHR5cGVzMiA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGRhdGFUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IGRhdGFUeXBlc1tpXTtcbiAgICAgICAgaWYgKENPRVJDRV9UT19UWVBFU1t0XSlcbiAgICAgICAgICB0eXBlczJbdHlwZXMyLmxlbmd0aF0gPSB0O1xuICAgICAgICBlbHNlIGlmIChvcHRpb25Db2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICB0eXBlczJbdHlwZXMyLmxlbmd0aF0gPSB0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVzMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0eXBlczI7XG4gICAgfSBlbHNlIGlmIChDT0VSQ0VfVE9fVFlQRVNbZGF0YVR5cGVzXSkge1xuICAgICAgcmV0dXJuIFtkYXRhVHlwZXNdO1xuICAgIH0gZWxzZSBpZiAob3B0aW9uQ29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiBkYXRhVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgICAgcmV0dXJuIFtcImFycmF5XCJdO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB0b0hhc2goYXJyKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgYXJyLmxlbmd0aDsgaSsrKVxuICAgICAgaGFzaFthcnJbaV1dID0gdHJ1ZTtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuICB2YXIgSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pO1xuICB2YXIgU0lOR0xFX1FVT1RFID0gLyd8XFxcXC9nO1xuICBmdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PSBcIm51bWJlclwiID8gXCJbXCIgKyBrZXkgKyBcIl1cIiA6IElERU5USUZJRVIudGVzdChrZXkpID8gXCIuXCIgKyBrZXkgOiBcIlsnXCIgKyBlc2NhcGVRdW90ZXMoa2V5KSArIFwiJ11cIjtcbiAgfVxuICBmdW5jdGlvbiBlc2NhcGVRdW90ZXMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFNJTkdMRV9RVU9URSwgXCJcXFxcJCZcIikucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gdmFyT2NjdXJlbmNlcyhzdHIsIGRhdGFWYXIpIHtcbiAgICBkYXRhVmFyICs9IFwiW14wLTldXCI7XG4gICAgdmFyIG1hdGNoZXMgPSBzdHIubWF0Y2gobmV3IFJlZ0V4cChkYXRhVmFyLCBcImdcIikpO1xuICAgIHJldHVybiBtYXRjaGVzID8gbWF0Y2hlcy5sZW5ndGggOiAwO1xuICB9XG4gIGZ1bmN0aW9uIHZhclJlcGxhY2Uoc3RyLCBkYXRhVmFyLCBleHByKSB7XG4gICAgZGF0YVZhciArPSBcIihbXjAtOV0pXCI7XG4gICAgZXhwciA9IGV4cHIucmVwbGFjZSgvXFwkL2csIFwiJCQkJFwiKTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cChkYXRhVmFyLCBcImdcIiksIGV4cHIgKyBcIiQxXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiAhc2NoZW1hO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpXG4gICAgICBpZiAocnVsZXNba2V5XSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNFeGNlcHQoc2NoZW1hLCBydWxlcywgZXhjZXB0S2V5d29yZCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKVxuICAgICAgcmV0dXJuICFzY2hlbWEgJiYgZXhjZXB0S2V5d29yZCAhPSBcIm5vdFwiO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpXG4gICAgICBpZiAoa2V5ICE9IGV4Y2VwdEtleXdvcmQgJiYgcnVsZXNba2V5XSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gc2NoZW1hVW5rbm93blJ1bGVzKHNjaGVtYSwgcnVsZXMpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKVxuICAgICAgaWYgKCFydWxlc1trZXldKVxuICAgICAgICByZXR1cm4ga2V5O1xuICB9XG4gIGZ1bmN0aW9uIHRvUXVvdGVkU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBcIidcIiArIGVzY2FwZVF1b3RlcyhzdHIpICsgXCInXCI7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGF0aEV4cHIoY3VycmVudFBhdGgsIGV4cHIsIGpzb25Qb2ludGVycywgaXNOdW1iZXIpIHtcbiAgICB2YXIgcGF0aCA9IGpzb25Qb2ludGVycyA/IFwiJy8nICsgXCIgKyBleHByICsgKGlzTnVtYmVyID8gXCJcIiA6IFwiLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFxcXC8vZywgJ34xJylcIikgOiBpc051bWJlciA/IFwiJ1snICsgXCIgKyBleHByICsgXCIgKyAnXSdcIiA6IFwiJ1tcXFxcJycgKyBcIiArIGV4cHIgKyBcIiArICdcXFxcJ10nXCI7XG4gICAgcmV0dXJuIGpvaW5QYXRocyhjdXJyZW50UGF0aCwgcGF0aCk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGF0aChjdXJyZW50UGF0aCwgcHJvcCwganNvblBvaW50ZXJzKSB7XG4gICAgdmFyIHBhdGggPSBqc29uUG9pbnRlcnMgPyB0b1F1b3RlZFN0cmluZyhcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKHByb3ApKSA6IHRvUXVvdGVkU3RyaW5nKGdldFByb3BlcnR5KHByb3ApKTtcbiAgICByZXR1cm4gam9pblBhdGhzKGN1cnJlbnRQYXRoLCBwYXRoKTtcbiAgfVxuICB2YXIgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokLztcbiAgdmFyIFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvO1xuICBmdW5jdGlvbiBnZXREYXRhKCRkYXRhLCBsdmwsIHBhdGhzKSB7XG4gICAgdmFyIHVwLCBqc29uUG9pbnRlciwgZGF0YSwgbWF0Y2hlcztcbiAgICBpZiAoJGRhdGEgPT09IFwiXCIpXG4gICAgICByZXR1cm4gXCJyb290RGF0YVwiO1xuICAgIGlmICgkZGF0YVswXSA9PSBcIi9cIikge1xuICAgICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSlNPTi1wb2ludGVyOiBcIiArICRkYXRhKTtcbiAgICAgIGpzb25Qb2ludGVyID0gJGRhdGE7XG4gICAgICBkYXRhID0gXCJyb290RGF0YVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRjaGVzID0gJGRhdGEubWF0Y2goUkVMQVRJVkVfSlNPTl9QT0lOVEVSKTtcbiAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBKU09OLXBvaW50ZXI6IFwiICsgJGRhdGEpO1xuICAgICAgdXAgPSArbWF0Y2hlc1sxXTtcbiAgICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXTtcbiAgICAgIGlmIChqc29uUG9pbnRlciA9PSBcIiNcIikge1xuICAgICAgICBpZiAodXAgPj0gbHZsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2Nlc3MgcHJvcGVydHkvaW5kZXggXCIgKyB1cCArIFwiIGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyBcIiArIGx2bCk7XG4gICAgICAgIHJldHVybiBwYXRoc1tsdmwgLSB1cF07XG4gICAgICB9XG4gICAgICBpZiAodXAgPiBsdmwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2Nlc3MgZGF0YSBcIiArIHVwICsgXCIgbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzIFwiICsgbHZsKTtcbiAgICAgIGRhdGEgPSBcImRhdGFcIiArIChsdmwgLSB1cCB8fCBcIlwiKTtcbiAgICAgIGlmICghanNvblBvaW50ZXIpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB2YXIgZXhwciA9IGRhdGE7XG4gICAgdmFyIHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgIGZvciAodmFyIGkgPSAwO2kgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGRhdGEgKz0gZ2V0UHJvcGVydHkodW5lc2NhcGVKc29uUG9pbnRlcihzZWdtZW50KSk7XG4gICAgICAgIGV4cHIgKz0gXCIgJiYgXCIgKyBkYXRhO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBmdW5jdGlvbiBqb2luUGF0aHMoYSwgYikge1xuICAgIGlmIChhID09ICdcIlwiJylcbiAgICAgIHJldHVybiBiO1xuICAgIHJldHVybiAoYSArIFwiICsgXCIgKyBiKS5yZXBsYWNlKC8oW15cXFxcXSknIFxcKyAnL2csIFwiJDFcIik7XG4gIH1cbiAgZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHIpIHtcbiAgICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gIH1cbiAgZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKTtcbiAgfVxuICBmdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgfVxuICBmdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKTtcbiAgfVxufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvc2NoZW1hX29iai5qc1xudmFyIHJlcXVpcmVfc2NoZW1hX29iaiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICB2YXIgdXRpbDMgPSByZXF1aXJlX3V0aWwoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTY2hlbWFPYmplY3Q7XG4gIGZ1bmN0aW9uIFNjaGVtYU9iamVjdChvYmopIHtcbiAgICB1dGlsMy5jb3B5KG9iaiwgdGhpcyk7XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanNcbnZhciByZXF1aXJlX2pzb25fc2NoZW1hX3RyYXZlcnNlID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2NoZW1hLCBvcHRzLCBjYikge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNiID0gb3B0cztcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICAgIHZhciBwcmUgPSB0eXBlb2YgY2IgPT0gXCJmdW5jdGlvblwiID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcbiAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIFwiXCIsIHNjaGVtYSk7XG4gIH07XG4gIHRyYXZlcnNlLmtleXdvcmRzID0ge1xuICAgIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgICBpdGVtczogdHJ1ZSxcbiAgICBjb250YWluczogdHJ1ZSxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICAgIG5vdDogdHJ1ZVxuICB9O1xuICB0cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICAgIGl0ZW1zOiB0cnVlLFxuICAgIGFsbE9mOiB0cnVlLFxuICAgIGFueU9mOiB0cnVlLFxuICAgIG9uZU9mOiB0cnVlXG4gIH07XG4gIHRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICAgZGVmaW5pdGlvbnM6IHRydWUsXG4gICAgcHJvcGVydGllczogdHJ1ZSxcbiAgICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgICBkZXBlbmRlbmNpZXM6IHRydWVcbiAgfTtcbiAgdHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgZW51bTogdHJ1ZSxcbiAgICBjb25zdDogdHJ1ZSxcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICBtYXhpbXVtOiB0cnVlLFxuICAgIG1pbmltdW06IHRydWUsXG4gICAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICAgIG11bHRpcGxlT2Y6IHRydWUsXG4gICAgbWF4TGVuZ3RoOiB0cnVlLFxuICAgIG1pbkxlbmd0aDogdHJ1ZSxcbiAgICBwYXR0ZXJuOiB0cnVlLFxuICAgIGZvcm1hdDogdHJ1ZSxcbiAgICBtYXhJdGVtczogdHJ1ZSxcbiAgICBtaW5JdGVtczogdHJ1ZSxcbiAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIG1pblByb3BlcnRpZXM6IHRydWVcbiAgfTtcbiAgZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gICAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgXCIvXCIgKyBrZXkgKyBcIi9cIiArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArIFwiL1wiICsga2V5ICsgXCIvXCIgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCBvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkge1xuICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArIFwiL1wiICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKTtcbiAgfVxufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS5qc1xudmFyIHJlcXVpcmVfcmVzb2x2ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICB2YXIgVVJJID0gcmVxdWlyZV91cmlfYWxsKCk7XG4gIHZhciBlcXVhbCA9IHJlcXVpcmVfZmFzdF9kZWVwX2VxdWFsKCk7XG4gIHZhciB1dGlsMyA9IHJlcXVpcmVfdXRpbCgpO1xuICB2YXIgU2NoZW1hT2JqZWN0ID0gcmVxdWlyZV9zY2hlbWFfb2JqKCk7XG4gIHZhciB0cmF2ZXJzZSA9IHJlcXVpcmVfanNvbl9zY2hlbWFfdHJhdmVyc2UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlO1xuICByZXNvbHZlLm5vcm1hbGl6ZUlkID0gbm9ybWFsaXplSWQ7XG4gIHJlc29sdmUuZnVsbFBhdGggPSBnZXRGdWxsUGF0aDtcbiAgcmVzb2x2ZS51cmwgPSByZXNvbHZlVXJsO1xuICByZXNvbHZlLmlkcyA9IHJlc29sdmVJZHM7XG4gIHJlc29sdmUuaW5saW5lUmVmID0gaW5saW5lUmVmO1xuICByZXNvbHZlLnNjaGVtYSA9IHJlc29sdmVTY2hlbWE7XG4gIGZ1bmN0aW9uIHJlc29sdmUoY29tcGlsZSwgcm9vdDIsIHJlZikge1xuICAgIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW3JlZl07XG4gICAgaWYgKHR5cGVvZiByZWZWYWwgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMuX3JlZnNbcmVmVmFsXSlcbiAgICAgICAgcmVmVmFsID0gdGhpcy5fcmVmc1tyZWZWYWxdO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gcmVzb2x2ZS5jYWxsKHRoaXMsIGNvbXBpbGUsIHJvb3QyLCByZWZWYWwpO1xuICAgIH1cbiAgICByZWZWYWwgPSByZWZWYWwgfHwgdGhpcy5fc2NoZW1hc1tyZWZdO1xuICAgIGlmIChyZWZWYWwgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgIHJldHVybiBpbmxpbmVSZWYocmVmVmFsLnNjaGVtYSwgdGhpcy5fb3B0cy5pbmxpbmVSZWZzKSA/IHJlZlZhbC5zY2hlbWEgOiByZWZWYWwudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICAgIH1cbiAgICB2YXIgcmVzID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QyLCByZWYpO1xuICAgIHZhciBzY2hlbWEsIHYsIGJhc2VJZDtcbiAgICBpZiAocmVzKSB7XG4gICAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgICAgcm9vdDIgPSByZXMucm9vdDtcbiAgICAgIGJhc2VJZCA9IHJlcy5iYXNlSWQ7XG4gICAgfVxuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBTY2hlbWFPYmplY3QpIHtcbiAgICAgIHYgPSBzY2hlbWEudmFsaWRhdGUgfHwgY29tcGlsZS5jYWxsKHRoaXMsIHNjaGVtYS5zY2hlbWEsIHJvb3QyLCB1bmRlZmluZWQsIGJhc2VJZCk7XG4gICAgfSBlbHNlIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdiA9IGlubGluZVJlZihzY2hlbWEsIHRoaXMuX29wdHMuaW5saW5lUmVmcykgPyBzY2hlbWEgOiBjb21waWxlLmNhbGwodGhpcywgc2NoZW1hLCByb290MiwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKHJvb3QyLCByZWYpIHtcbiAgICB2YXIgcCA9IFVSSS5wYXJzZShyZWYpLCByZWZQYXRoID0gX2dldEZ1bGxQYXRoKHApLCBiYXNlSWQgPSBnZXRGdWxsUGF0aCh0aGlzLl9nZXRJZChyb290Mi5zY2hlbWEpKTtcbiAgICBpZiAoT2JqZWN0LmtleXMocm9vdDIuc2NoZW1hKS5sZW5ndGggPT09IDAgfHwgcmVmUGF0aCAhPT0gYmFzZUlkKSB7XG4gICAgICB2YXIgaWQgPSBub3JtYWxpemVJZChyZWZQYXRoKTtcbiAgICAgIHZhciByZWZWYWwgPSB0aGlzLl9yZWZzW2lkXTtcbiAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVSZWN1cnNpdmUuY2FsbCh0aGlzLCByb290MiwgcmVmVmFsLCBwKTtcbiAgICAgIH0gZWxzZSBpZiAocmVmVmFsIGluc3RhbmNlb2YgU2NoZW1hT2JqZWN0KSB7XG4gICAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKVxuICAgICAgICAgIHRoaXMuX2NvbXBpbGUocmVmVmFsKTtcbiAgICAgICAgcm9vdDIgPSByZWZWYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZWYWwgPSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgICAgaWYgKHJlZlZhbCBpbnN0YW5jZW9mIFNjaGVtYU9iamVjdCkge1xuICAgICAgICAgIGlmICghcmVmVmFsLnZhbGlkYXRlKVxuICAgICAgICAgICAgdGhpcy5fY29tcGlsZShyZWZWYWwpO1xuICAgICAgICAgIGlmIChpZCA9PSBub3JtYWxpemVJZChyZWYpKVxuICAgICAgICAgICAgcmV0dXJuIHsgc2NoZW1hOiByZWZWYWwsIHJvb3Q6IHJvb3QyLCBiYXNlSWQgfTtcbiAgICAgICAgICByb290MiA9IHJlZlZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcm9vdDIuc2NoZW1hKVxuICAgICAgICByZXR1cm47XG4gICAgICBiYXNlSWQgPSBnZXRGdWxsUGF0aCh0aGlzLl9nZXRJZChyb290Mi5zY2hlbWEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgYmFzZUlkLCByb290Mi5zY2hlbWEsIHJvb3QyKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlUmVjdXJzaXZlKHJvb3QyLCByZWYsIHBhcnNlZFJlZikge1xuICAgIHZhciByZXMgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdDIsIHJlZik7XG4gICAgaWYgKHJlcykge1xuICAgICAgdmFyIHNjaGVtYSA9IHJlcy5zY2hlbWE7XG4gICAgICB2YXIgYmFzZUlkID0gcmVzLmJhc2VJZDtcbiAgICAgIHJvb3QyID0gcmVzLnJvb3Q7XG4gICAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWEpO1xuICAgICAgaWYgKGlkKVxuICAgICAgICBiYXNlSWQgPSByZXNvbHZlVXJsKGJhc2VJZCwgaWQpO1xuICAgICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdDIpO1xuICAgIH1cbiAgfVxuICB2YXIgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSB1dGlsMy50b0hhc2goW1wicHJvcGVydGllc1wiLCBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsIFwiZW51bVwiLCBcImRlcGVuZGVuY2llc1wiLCBcImRlZmluaXRpb25zXCJdKTtcbiAgZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIocGFyc2VkUmVmLCBiYXNlSWQsIHNjaGVtYSwgcm9vdDIpIHtcbiAgICBwYXJzZWRSZWYuZnJhZ21lbnQgPSBwYXJzZWRSZWYuZnJhZ21lbnQgfHwgXCJcIjtcbiAgICBpZiAocGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDAsIDEpICE9IFwiL1wiKVxuICAgICAgcmV0dXJuO1xuICAgIHZhciBwYXJ0cyA9IHBhcnNlZFJlZi5mcmFnbWVudC5zcGxpdChcIi9cIik7XG4gICAgZm9yICh2YXIgaSA9IDE7aSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQpIHtcbiAgICAgICAgcGFydCA9IHV0aWwzLnVuZXNjYXBlRnJhZ21lbnQocGFydCk7XG4gICAgICAgIHNjaGVtYSA9IHNjaGVtYVtwYXJ0XTtcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB2YXIgaWQ7XG4gICAgICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0VbcGFydF0pIHtcbiAgICAgICAgICBpZCA9IHRoaXMuX2dldElkKHNjaGVtYSk7XG4gICAgICAgICAgaWYgKGlkKVxuICAgICAgICAgICAgYmFzZUlkID0gcmVzb2x2ZVVybChiYXNlSWQsIGlkKTtcbiAgICAgICAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgIHZhciAkcmVmID0gcmVzb2x2ZVVybChiYXNlSWQsIHNjaGVtYS4kcmVmKTtcbiAgICAgICAgICAgIHZhciByZXMgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdDIsICRyZWYpO1xuICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICBzY2hlbWEgPSByZXMuc2NoZW1hO1xuICAgICAgICAgICAgICByb290MiA9IHJlcy5yb290O1xuICAgICAgICAgICAgICBiYXNlSWQgPSByZXMuYmFzZUlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSByb290Mi5zY2hlbWEpXG4gICAgICByZXR1cm4geyBzY2hlbWEsIHJvb3Q6IHJvb3QyLCBiYXNlSWQgfTtcbiAgfVxuICB2YXIgU0lNUExFX0lOTElORUQgPSB1dGlsMy50b0hhc2goW1xuICAgIFwidHlwZVwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImVudW1cIlxuICBdKTtcbiAgZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYSwgbGltaXQpIHtcbiAgICBpZiAobGltaXQgPT09IGZhbHNlKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkIHx8IGxpbWl0ID09PSB0cnVlKVxuICAgICAgcmV0dXJuIGNoZWNrTm9SZWYoc2NoZW1hKTtcbiAgICBlbHNlIGlmIChsaW1pdClcbiAgICAgIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdDtcbiAgfVxuICBmdW5jdGlvbiBjaGVja05vUmVmKHNjaGVtYSkge1xuICAgIHZhciBpdGVtO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwO2kgPCBzY2hlbWEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbSA9IHNjaGVtYVtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09IFwib2JqZWN0XCIgJiYgIWNoZWNrTm9SZWYoaXRlbSkpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIGlmIChrZXkgPT0gXCIkcmVmXCIpXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpdGVtID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PSBcIm9iamVjdFwiICYmICFjaGVja05vUmVmKGl0ZW0pKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYSkge1xuICAgIHZhciBjb3VudCA9IDAsIGl0ZW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IHNjaGVtYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVtID0gc2NoZW1hW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT0gXCJvYmplY3RcIilcbiAgICAgICAgICBjb3VudCArPSBjb3VudEtleXMoaXRlbSk7XG4gICAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSlcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKGtleSA9PSBcIiRyZWZcIilcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgIGlmIChTSU1QTEVfSU5MSU5FRFtrZXldKSB7XG4gICAgICAgICAgY291bnQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtID0gc2NoZW1hW2tleV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBjb3VudCArPSBjb3VudEtleXMoaXRlbSkgKyAxO1xuICAgICAgICAgIGlmIChjb3VudCA9PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RnVsbFBhdGgoaWQsIG5vcm1hbGl6ZSkge1xuICAgIGlmIChub3JtYWxpemUgIT09IGZhbHNlKVxuICAgICAgaWQgPSBub3JtYWxpemVJZChpZCk7XG4gICAgdmFyIHAgPSBVUkkucGFyc2UoaWQpO1xuICAgIHJldHVybiBfZ2V0RnVsbFBhdGgocCk7XG4gIH1cbiAgZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHApIHtcbiAgICByZXR1cm4gVVJJLnNlcmlhbGl6ZShwKS5zcGxpdChcIiNcIilbMF0gKyBcIiNcIjtcbiAgfVxuICB2YXIgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvO1xuICBmdW5jdGlvbiBub3JtYWxpemVJZChpZCkge1xuICAgIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZUlkLCBpZCkge1xuICAgIGlkID0gbm9ybWFsaXplSWQoaWQpO1xuICAgIHJldHVybiBVUkkucmVzb2x2ZShiYXNlSWQsIGlkKTtcbiAgfVxuICBmdW5jdGlvbiByZXNvbHZlSWRzKHNjaGVtYSkge1xuICAgIHZhciBzY2hlbWFJZCA9IG5vcm1hbGl6ZUlkKHRoaXMuX2dldElkKHNjaGVtYSkpO1xuICAgIHZhciBiYXNlSWRzID0geyBcIlwiOiBzY2hlbWFJZCB9O1xuICAgIHZhciBmdWxsUGF0aHMgPSB7IFwiXCI6IGdldEZ1bGxQYXRoKHNjaGVtYUlkLCBmYWxzZSkgfTtcbiAgICB2YXIgbG9jYWxSZWZzID0ge307XG4gICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICB0cmF2ZXJzZShzY2hlbWEsIHsgYWxsS2V5czogdHJ1ZSB9LCBmdW5jdGlvbihzY2gsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgICAgIGlmIChqc29uUHRyID09PSBcIlwiKVxuICAgICAgICByZXR1cm47XG4gICAgICB2YXIgaWQgPSBzZWxmMi5fZ2V0SWQoc2NoKTtcbiAgICAgIHZhciBiYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdO1xuICAgICAgdmFyIGZ1bGxQYXRoID0gZnVsbFBhdGhzW3BhcmVudEpzb25QdHJdICsgXCIvXCIgKyBwYXJlbnRLZXl3b3JkO1xuICAgICAgaWYgKGtleUluZGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGZ1bGxQYXRoICs9IFwiL1wiICsgKHR5cGVvZiBrZXlJbmRleCA9PSBcIm51bWJlclwiID8ga2V5SW5kZXggOiB1dGlsMy5lc2NhcGVGcmFnbWVudChrZXlJbmRleCkpO1xuICAgICAgaWYgKHR5cGVvZiBpZCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlkID0gYmFzZUlkID0gbm9ybWFsaXplSWQoYmFzZUlkID8gVVJJLnJlc29sdmUoYmFzZUlkLCBpZCkgOiBpZCk7XG4gICAgICAgIHZhciByZWZWYWwgPSBzZWxmMi5fcmVmc1tpZF07XG4gICAgICAgIGlmICh0eXBlb2YgcmVmVmFsID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmVmVmFsID0gc2VsZjIuX3JlZnNbcmVmVmFsXTtcbiAgICAgICAgaWYgKHJlZlZhbCAmJiByZWZWYWwuc2NoZW1hKSB7XG4gICAgICAgICAgaWYgKCFlcXVhbChzY2gsIHJlZlZhbC5zY2hlbWEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpZCBcIicgKyBpZCArICdcIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYScpO1xuICAgICAgICB9IGVsc2UgaWYgKGlkICE9IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICAgIGlmIChpZFswXSA9PSBcIiNcIikge1xuICAgICAgICAgICAgaWYgKGxvY2FsUmVmc1tpZF0gJiYgIWVxdWFsKHNjaCwgbG9jYWxSZWZzW2lkXSkpXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaWQgXCInICsgaWQgKyAnXCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWEnKTtcbiAgICAgICAgICAgIGxvY2FsUmVmc1tpZF0gPSBzY2g7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYyLl9yZWZzW2lkXSA9IGZ1bGxQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZUlkc1tqc29uUHRyXSA9IGJhc2VJZDtcbiAgICAgIGZ1bGxQYXRoc1tqc29uUHRyXSA9IGZ1bGxQYXRoO1xuICAgIH0pO1xuICAgIHJldHVybiBsb2NhbFJlZnM7XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9yX2NsYXNzZXMuanNcbnZhciByZXF1aXJlX2Vycm9yX2NsYXNzZXMgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgdmFyIHJlc29sdmUgPSByZXF1aXJlX3Jlc29sdmUoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgVmFsaWRhdGlvbjogZXJyb3JTdWJjbGFzcyhWYWxpZGF0aW9uRXJyb3IpLFxuICAgIE1pc3NpbmdSZWY6IGVycm9yU3ViY2xhc3MoTWlzc2luZ1JlZkVycm9yKVxuICB9O1xuICBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3IoZXJyb3JzMikge1xuICAgIHRoaXMubWVzc2FnZSA9IFwidmFsaWRhdGlvbiBmYWlsZWRcIjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yczI7XG4gICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlO1xuICB9XG4gIE1pc3NpbmdSZWZFcnJvci5tZXNzYWdlID0gZnVuY3Rpb24oYmFzZUlkLCByZWYpIHtcbiAgICByZXR1cm4gXCJjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSBcIiArIHJlZiArIFwiIGZyb20gaWQgXCIgKyBiYXNlSWQ7XG4gIH07XG4gIGZ1bmN0aW9uIE1pc3NpbmdSZWZFcnJvcihiYXNlSWQsIHJlZiwgbWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgTWlzc2luZ1JlZkVycm9yLm1lc3NhZ2UoYmFzZUlkLCByZWYpO1xuICAgIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmUudXJsKGJhc2VJZCwgcmVmKTtcbiAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKHJlc29sdmUuZnVsbFBhdGgodGhpcy5taXNzaW5nUmVmKSk7XG4gIH1cbiAgZnVuY3Rpb24gZXJyb3JTdWJjbGFzcyhTdWJjbGFzcykge1xuICAgIFN1YmNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBTdWJjbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWJjbGFzcztcbiAgICByZXR1cm4gU3ViY2xhc3M7XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvZmFzdC1qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanNcbnZhciByZXF1aXJlX2Zhc3RfanNvbl9zdGFibGVfc3RyaW5naWZ5ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgb3B0cykge1xuICAgIGlmICghb3B0cylcbiAgICAgIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBjeWNsZXMgPSB0eXBlb2Ygb3B0cy5jeWNsZXMgPT09IFwiYm9vbGVhblwiID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICB2YXIgYW9iaiA9IHsga2V5OiBhLCB2YWx1ZTogbm9kZVthXSB9O1xuICAgICAgICAgIHZhciBib2JqID0geyBrZXk6IGIsIHZhbHVlOiBub2RlW2JdIH07XG4gICAgICAgICAgcmV0dXJuIGYoYW9iaiwgYm9iaik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH0ob3B0cy5jbXApO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gaXNGaW5pdGUobm9kZSkgPyBcIlwiICsgbm9kZSA6IFwibnVsbFwiO1xuICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICB2YXIgaSwgb3V0O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgb3V0ID0gXCJbXCI7XG4gICAgICAgIGZvciAoaSA9IDA7aSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgIG91dCArPSBcIixcIjtcbiAgICAgICAgICBvdXQgKz0gc3RyaW5naWZ5KG5vZGVbaV0pIHx8IFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQgKyBcIl1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICBpZiAoc2Vlbi5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICBpZiAoY3ljbGVzKVxuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShcIl9fY3ljbGVfX1wiKTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT05cIik7XG4gICAgICB9XG4gICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5wdXNoKG5vZGUpIC0gMTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgIG91dCA9IFwiXCI7XG4gICAgICBmb3IgKGkgPSAwO2kgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZVtrZXldKTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG91dClcbiAgICAgICAgICBvdXQgKz0gXCIsXCI7XG4gICAgICAgIG91dCArPSBKU09OLnN0cmluZ2lmeShrZXkpICsgXCI6XCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHNlZW4uc3BsaWNlKHNlZW5JbmRleCwgMSk7XG4gICAgICByZXR1cm4gXCJ7XCIgKyBvdXQgKyBcIn1cIjtcbiAgICB9KGRhdGEpO1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3ZhbGlkYXRlLmpzXG52YXIgcmVxdWlyZV92YWxpZGF0ZSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3ZhbGlkYXRlKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiXCI7XG4gICAgdmFyICRhc3luYyA9IGl0LnNjaGVtYS4kYXN5bmMgPT09IHRydWUsICRyZWZLZXl3b3JkcyA9IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXNFeGNlcHQoaXQuc2NoZW1hLCBpdC5SVUxFUy5hbGwsIFwiJHJlZlwiKSwgJGlkID0gaXQuc2VsZi5fZ2V0SWQoaXQuc2NoZW1hKTtcbiAgICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3Jkcykge1xuICAgICAgdmFyICR1bmtub3duS3dkID0gaXQudXRpbC5zY2hlbWFVbmtub3duUnVsZXMoaXQuc2NoZW1hLCBpdC5SVUxFUy5rZXl3b3Jkcyk7XG4gICAgICBpZiAoJHVua25vd25Ld2QpIHtcbiAgICAgICAgdmFyICRrZXl3b3Jkc01zZyA9IFwidW5rbm93biBrZXl3b3JkOiBcIiArICR1bmtub3duS3dkO1xuICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA9PT0gXCJsb2dcIilcbiAgICAgICAgICBpdC5sb2dnZXIud2Fybigka2V5d29yZHNNc2cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3Jkc01zZyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5pc1RvcCkge1xuICAgICAgb3V0ICs9IFwiIHZhciB2YWxpZGF0ZSA9IFwiO1xuICAgICAgaWYgKCRhc3luYykge1xuICAgICAgICBpdC5hc3luYyA9IHRydWU7XG4gICAgICAgIG91dCArPSBcImFzeW5jIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiZnVuY3Rpb24oZGF0YSwgZGF0YVBhdGgsIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eSwgcm9vdERhdGEpIHsgJ3VzZSBzdHJpY3QnOyBcIjtcbiAgICAgIGlmICgkaWQgJiYgKGl0Lm9wdHMuc291cmNlQ29kZSB8fCBpdC5vcHRzLnByb2Nlc3NDb2RlKSkge1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyAoXCIvKiMgc291cmNlVVJMPVwiICsgJGlkICsgXCIgKi9cIikgKyBcIiBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpdC5zY2hlbWEgPT0gXCJib29sZWFuXCIgfHwgISgkcmVmS2V5d29yZHMgfHwgaXQuc2NoZW1hLiRyZWYpKSB7XG4gICAgICB2YXIgJGtleXdvcmQgPSBcImZhbHNlIHNjaGVtYVwiO1xuICAgICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgICB2YXIgJGVycm9yS2V5d29yZDtcbiAgICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgICAgdmFyICR2YWxpZCA9IFwidmFsaWRcIiArICRsdmw7XG4gICAgICBpZiAoaXQuc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgICAgICAkYnJlYWtPbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTsgXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyAoJGVycm9yS2V5d29yZCB8fCBcImZhbHNlIHNjaGVtYVwiKSArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczoge30gXCI7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2UnIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpdC5pc1RvcCkge1xuICAgICAgICAgIGlmICgkYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiByZXR1cm4gZGF0YTsgXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsOyByZXR1cm4gdHJ1ZTsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkdmFsaWQgKyBcIiA9IHRydWU7IFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgICAgb3V0ICs9IFwiIH07IHJldHVybiB2YWxpZGF0ZTsgXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBpZiAoaXQuaXNUb3ApIHtcbiAgICAgIHZhciAkdG9wID0gaXQuaXNUb3AsICRsdmwgPSBpdC5sZXZlbCA9IDAsICRkYXRhTHZsID0gaXQuZGF0YUxldmVsID0gMCwgJGRhdGEgPSBcImRhdGFcIjtcbiAgICAgIGl0LnJvb3RJZCA9IGl0LnJlc29sdmUuZnVsbFBhdGgoaXQuc2VsZi5fZ2V0SWQoaXQucm9vdC5zY2hlbWEpKTtcbiAgICAgIGl0LmJhc2VJZCA9IGl0LmJhc2VJZCB8fCBpdC5yb290SWQ7XG4gICAgICBkZWxldGUgaXQuaXNUb3A7XG4gICAgICBpdC5kYXRhUGF0aEFyciA9IFtcIlwiXTtcbiAgICAgIGlmIChpdC5zY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgaXQub3B0cy5zdHJpY3REZWZhdWx0cykge1xuICAgICAgICB2YXIgJGRlZmF1bHRNc2cgPSBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIjtcbiAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0RGVmYXVsdHMgPT09IFwibG9nXCIpXG4gICAgICAgICAgaXQubG9nZ2VyLndhcm4oJGRlZmF1bHRNc2cpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCRkZWZhdWx0TXNnKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB2YXIgdkVycm9ycyA9IG51bGw7IFwiO1xuICAgICAgb3V0ICs9IFwiIHZhciBlcnJvcnMgPSAwOyAgICAgXCI7XG4gICAgICBvdXQgKz0gXCIgaWYgKHJvb3REYXRhID09PSB1bmRlZmluZWQpIHJvb3REYXRhID0gZGF0YTsgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB7IGxldmVsOiAkbHZsLCBkYXRhTGV2ZWw6ICRkYXRhTHZsIH0gPSBpdCwgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICAgIGlmICgkaWQpXG4gICAgICAgIGl0LmJhc2VJZCA9IGl0LnJlc29sdmUudXJsKGl0LmJhc2VJZCwgJGlkKTtcbiAgICAgIGlmICgkYXN5bmMgJiYgIWl0LmFzeW5jKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIik7XG4gICAgICBvdXQgKz0gXCIgdmFyIGVycnNfXCIgKyAkbHZsICsgXCIgPSBlcnJvcnM7XCI7XG4gICAgfVxuICAgIHZhciAkdmFsaWQgPSBcInZhbGlkXCIgKyAkbHZsLCAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzLCAkY2xvc2luZ0JyYWNlczEgPSBcIlwiLCAkY2xvc2luZ0JyYWNlczIgPSBcIlwiO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkO1xuICAgIHZhciAkdHlwZVNjaGVtYSA9IGl0LnNjaGVtYS50eXBlLCAkdHlwZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCR0eXBlU2NoZW1hKTtcbiAgICBpZiAoJHR5cGVTY2hlbWEgJiYgaXQub3B0cy5udWxsYWJsZSAmJiBpdC5zY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHtcbiAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgaWYgKCR0eXBlU2NoZW1hLmluZGV4T2YoXCJudWxsXCIpID09IC0xKVxuICAgICAgICAgICR0eXBlU2NoZW1hID0gJHR5cGVTY2hlbWEuY29uY2F0KFwibnVsbFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoJHR5cGVTY2hlbWEgIT0gXCJudWxsXCIpIHtcbiAgICAgICAgJHR5cGVTY2hlbWEgPSBbJHR5cGVTY2hlbWEsIFwibnVsbFwiXTtcbiAgICAgICAgJHR5cGVJc0FycmF5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCR0eXBlSXNBcnJheSAmJiAkdHlwZVNjaGVtYS5sZW5ndGggPT0gMSkge1xuICAgICAgJHR5cGVTY2hlbWEgPSAkdHlwZVNjaGVtYVswXTtcbiAgICAgICR0eXBlSXNBcnJheSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXQuc2NoZW1hLiRyZWYgJiYgJHJlZktleXdvcmRzKSB7XG4gICAgICBpZiAoaXQub3B0cy5leHRlbmRSZWZzID09IFwiZmFpbFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignJHJlZjogdmFsaWRhdGlvbiBrZXl3b3JkcyB1c2VkIGluIHNjaGVtYSBhdCBwYXRoIFwiJyArIGl0LmVyclNjaGVtYVBhdGggKyAnXCIgKHNlZSBvcHRpb24gZXh0ZW5kUmVmcyknKTtcbiAgICAgIH0gZWxzZSBpZiAoaXQub3B0cy5leHRlbmRSZWZzICE9PSB0cnVlKSB7XG4gICAgICAgICRyZWZLZXl3b3JkcyA9IGZhbHNlO1xuICAgICAgICBpdC5sb2dnZXIud2FybignJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIicgKyBpdC5lcnJTY2hlbWFQYXRoICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5zY2hlbWEuJGNvbW1lbnQgJiYgaXQub3B0cy4kY29tbWVudCkge1xuICAgICAgb3V0ICs9IFwiIFwiICsgaXQuUlVMRVMuYWxsLiRjb21tZW50LmNvZGUoaXQsIFwiJGNvbW1lbnRcIik7XG4gICAgfVxuICAgIGlmICgkdHlwZVNjaGVtYSkge1xuICAgICAgaWYgKGl0Lm9wdHMuY29lcmNlVHlwZXMpIHtcbiAgICAgICAgdmFyICRjb2VyY2VUb1R5cGVzID0gaXQudXRpbC5jb2VyY2VUb1R5cGVzKGl0Lm9wdHMuY29lcmNlVHlwZXMsICR0eXBlU2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIHZhciAkcnVsZXNHcm91cCA9IGl0LlJVTEVTLnR5cGVzWyR0eXBlU2NoZW1hXTtcbiAgICAgIGlmICgkY29lcmNlVG9UeXBlcyB8fCAkdHlwZUlzQXJyYXkgfHwgJHJ1bGVzR3JvdXAgPT09IHRydWUgfHwgJHJ1bGVzR3JvdXAgJiYgISRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkpIHtcbiAgICAgICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIFwiLnR5cGVcIiwgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvdHlwZVwiO1xuICAgICAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgXCIudHlwZVwiLCAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi90eXBlXCIsICRtZXRob2QgPSAkdHlwZUlzQXJyYXkgPyBcImNoZWNrRGF0YVR5cGVzXCIgOiBcImNoZWNrRGF0YVR5cGVcIjtcbiAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArIGl0LnV0aWxbJG1ldGhvZF0oJHR5cGVTY2hlbWEsICRkYXRhLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIHRydWUpICsgXCIpIHsgXCI7XG4gICAgICAgIGlmICgkY29lcmNlVG9UeXBlcykge1xuICAgICAgICAgIHZhciAkZGF0YVR5cGUgPSBcImRhdGFUeXBlXCIgKyAkbHZsLCAkY29lcmNlZCA9IFwiY29lcmNlZFwiICsgJGx2bDtcbiAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJGRhdGFUeXBlICsgXCIgPSB0eXBlb2YgXCIgKyAkZGF0YSArIFwiOyB2YXIgXCIgKyAkY29lcmNlZCArIFwiID0gdW5kZWZpbmVkOyBcIjtcbiAgICAgICAgICBpZiAoaXQub3B0cy5jb2VyY2VUeXBlcyA9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkZGF0YVR5cGUgKyBcIiA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KFwiICsgJGRhdGEgKyBcIikgJiYgXCIgKyAkZGF0YSArIFwiLmxlbmd0aCA9PSAxKSB7IFwiICsgJGRhdGEgKyBcIiA9IFwiICsgJGRhdGEgKyBcIlswXTsgXCIgKyAkZGF0YVR5cGUgKyBcIiA9IHR5cGVvZiBcIiArICRkYXRhICsgXCI7IGlmIChcIiArIGl0LnV0aWwuY2hlY2tEYXRhVHlwZShpdC5zY2hlbWEudHlwZSwgJGRhdGEsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycykgKyBcIikgXCIgKyAkY29lcmNlZCArIFwiID0gXCIgKyAkZGF0YSArIFwiOyB9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJGNvZXJjZWQgKyBcIiAhPT0gdW5kZWZpbmVkKSA7IFwiO1xuICAgICAgICAgIHZhciBhcnIxID0gJGNvZXJjZVRvVHlwZXM7XG4gICAgICAgICAgaWYgKGFycjEpIHtcbiAgICAgICAgICAgIHZhciAkdHlwZSwgJGkgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAgICAgICAkdHlwZSA9IGFycjFbJGkgKz0gMV07XG4gICAgICAgICAgICAgIGlmICgkdHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiIGVsc2UgaWYgKFwiICsgJGRhdGFUeXBlICsgXCIgPT0gJ251bWJlcicgfHwgXCIgKyAkZGF0YVR5cGUgKyBcIiA9PSAnYm9vbGVhbicpIFwiICsgJGNvZXJjZWQgKyBcIiA9ICcnICsgXCIgKyAkZGF0YSArIFwiOyBlbHNlIGlmIChcIiArICRkYXRhICsgXCIgPT09IG51bGwpIFwiICsgJGNvZXJjZWQgKyBcIiA9ICcnOyBcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSBcIm51bWJlclwiIHx8ICR0eXBlID09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiIGVsc2UgaWYgKFwiICsgJGRhdGFUeXBlICsgXCIgPT0gJ2Jvb2xlYW4nIHx8IFwiICsgJGRhdGEgKyBcIiA9PT0gbnVsbCB8fCAoXCIgKyAkZGF0YVR5cGUgKyBcIiA9PSAnc3RyaW5nJyAmJiBcIiArICRkYXRhICsgXCIgJiYgXCIgKyAkZGF0YSArIFwiID09ICtcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlID09IFwiaW50ZWdlclwiKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgJiYgIShcIiArICRkYXRhICsgXCIgJSAxKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIpKSBcIiArICRjb2VyY2VkICsgXCIgPSArXCIgKyAkZGF0YSArIFwiOyBcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiBlbHNlIGlmIChcIiArICRkYXRhICsgXCIgPT09ICdmYWxzZScgfHwgXCIgKyAkZGF0YSArIFwiID09PSAwIHx8IFwiICsgJGRhdGEgKyBcIiA9PT0gbnVsbCkgXCIgKyAkY29lcmNlZCArIFwiID0gZmFsc2U7IGVsc2UgaWYgKFwiICsgJGRhdGEgKyBcIiA9PT0gJ3RydWUnIHx8IFwiICsgJGRhdGEgKyBcIiA9PT0gMSkgXCIgKyAkY29lcmNlZCArIFwiID0gdHJ1ZTsgXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgZWxzZSBpZiAoXCIgKyAkZGF0YSArIFwiID09PSAnJyB8fCBcIiArICRkYXRhICsgXCIgPT09IDAgfHwgXCIgKyAkZGF0YSArIFwiID09PSBmYWxzZSkgXCIgKyAkY29lcmNlZCArIFwiID0gbnVsbDsgXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXQub3B0cy5jb2VyY2VUeXBlcyA9PSBcImFycmF5XCIgJiYgJHR5cGUgPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiIGVsc2UgaWYgKFwiICsgJGRhdGFUeXBlICsgXCIgPT0gJ3N0cmluZycgfHwgXCIgKyAkZGF0YVR5cGUgKyBcIiA9PSAnbnVtYmVyJyB8fCBcIiArICRkYXRhVHlwZSArIFwiID09ICdib29sZWFuJyB8fCBcIiArICRkYXRhICsgXCIgPT0gbnVsbCkgXCIgKyAkY29lcmNlZCArIFwiID0gW1wiICsgJGRhdGEgKyBcIl07IFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSBcIiBlbHNlIHsgICBcIjtcbiAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJ0eXBlXCIpICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IHR5cGU6ICdcIjtcbiAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBiZSBcIjtcbiAgICAgICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWEuam9pbihcIixcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgfSBpZiAoXCIgKyAkY29lcmNlZCArIFwiICE9PSB1bmRlZmluZWQpIHsgIFwiO1xuICAgICAgICAgIHZhciAkcGFyZW50RGF0YSA9ICRkYXRhTHZsID8gXCJkYXRhXCIgKyAoJGRhdGFMdmwgLSAxIHx8IFwiXCIpIDogXCJwYXJlbnREYXRhXCIsICRwYXJlbnREYXRhUHJvcGVydHkgPSAkZGF0YUx2bCA/IGl0LmRhdGFQYXRoQXJyWyRkYXRhTHZsXSA6IFwicGFyZW50RGF0YVByb3BlcnR5XCI7XG4gICAgICAgICAgb3V0ICs9IFwiIFwiICsgJGRhdGEgKyBcIiA9IFwiICsgJGNvZXJjZWQgKyBcIjsgXCI7XG4gICAgICAgICAgaWYgKCEkZGF0YUx2bCkge1xuICAgICAgICAgICAgb3V0ICs9IFwiaWYgKFwiICsgJHBhcmVudERhdGEgKyBcIiAhPT0gdW5kZWZpbmVkKVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgXCIgKyAkcGFyZW50RGF0YSArIFwiW1wiICsgJHBhcmVudERhdGFQcm9wZXJ0eSArIFwiXSA9IFwiICsgJGNvZXJjZWQgKyBcIjsgfSBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJ0eXBlXCIpICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IHR5cGU6ICdcIjtcbiAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBiZSBcIjtcbiAgICAgICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWEuam9pbihcIixcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0LnNjaGVtYS4kcmVmICYmICEkcmVmS2V5d29yZHMpIHtcbiAgICAgIG91dCArPSBcIiBcIiArIGl0LlJVTEVTLmFsbC4kcmVmLmNvZGUoaXQsIFwiJHJlZlwiKSArIFwiIFwiO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIH0gaWYgKGVycm9ycyA9PT0gXCI7XG4gICAgICAgIGlmICgkdG9wKSB7XG4gICAgICAgICAgb3V0ICs9IFwiMFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcImVycnNfXCIgKyAkbHZsO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIikgeyBcIjtcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMyICs9IFwifVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJyMiA9IGl0LlJVTEVTO1xuICAgICAgaWYgKGFycjIpIHtcbiAgICAgICAgdmFyICRydWxlc0dyb3VwLCBpMiA9IC0xLCBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGkyIDwgbDIpIHtcbiAgICAgICAgICAkcnVsZXNHcm91cCA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgICAgaWYgKCRzaG91bGRVc2VHcm91cCgkcnVsZXNHcm91cCkpIHtcbiAgICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyBpdC51dGlsLmNoZWNrRGF0YVR5cGUoJHJ1bGVzR3JvdXAudHlwZSwgJGRhdGEsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycykgKyBcIikgeyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnVzZURlZmF1bHRzKSB7XG4gICAgICAgICAgICAgIGlmICgkcnVsZXNHcm91cC50eXBlID09IFwib2JqZWN0XCIgJiYgaXQuc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYS5wcm9wZXJ0aWVzLCAkc2NoZW1hS2V5cyA9IE9iamVjdC5rZXlzKCRzY2hlbWEpO1xuICAgICAgICAgICAgICAgIHZhciBhcnIzID0gJHNjaGVtYUtleXM7XG4gICAgICAgICAgICAgICAgaWYgKGFycjMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciAkcHJvcGVydHlLZXksIGkzID0gLTEsIGwzID0gYXJyMy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKGkzIDwgbDMpIHtcbiAgICAgICAgICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyM1tpMyArPSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eUtleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgkc2NoLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQuY29tcG9zaXRlUnVsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0RGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRkZWZhdWx0TXNnID0gXCJkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiBcIiArICRwYXNzRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0RGVmYXVsdHMgPT09IFwibG9nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQubG9nZ2VyLndhcm4oJGRlZmF1bHRNc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRwYXNzRGF0YSArIFwiID09PSB1bmRlZmluZWQgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51c2VEZWZhdWx0cyA9PSBcImVtcHR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIHx8IFwiICsgJHBhc3NEYXRhICsgXCIgPT09IG51bGwgfHwgXCIgKyAkcGFzc0RhdGEgKyBcIiA9PT0gJycgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgKSBcIiArICRwYXNzRGF0YSArIFwiID0gXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy51c2VEZWZhdWx0cyA9PSBcInNoYXJlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIGl0LnVzZURlZmF1bHQoJHNjaC5kZWZhdWx0KSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgSlNPTi5zdHJpbmdpZnkoJHNjaC5kZWZhdWx0KSArIFwiIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiOyBcIjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHJ1bGVzR3JvdXAudHlwZSA9PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdC5zY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycjQgPSBpdC5zY2hlbWEuaXRlbXM7XG4gICAgICAgICAgICAgICAgaWYgKGFycjQpIHtcbiAgICAgICAgICAgICAgICAgIHZhciAkc2NoLCAkaSA9IC0xLCBsNCA9IGFycjQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgkaSA8IGw0KSB7XG4gICAgICAgICAgICAgICAgICAgICRzY2ggPSBhcnI0WyRpICs9IDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJHNjaC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGl0LmNvbXBvc2l0ZVJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZGVmYXVsdE1zZyA9IFwiZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogXCIgKyAkcGFzc0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLnN0cmljdERlZmF1bHRzID09PSBcImxvZ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LmxvZ2dlci53YXJuKCRkZWZhdWx0TXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigkZGVmYXVsdE1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkcGFzc0RhdGEgKyBcIiA9PT0gdW5kZWZpbmVkIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCBcIiArICRwYXNzRGF0YSArIFwiID09PSBudWxsIHx8IFwiICsgJHBhc3NEYXRhICsgXCIgPT09ICcnIFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiICkgXCIgKyAkcGFzc0RhdGEgKyBcIiA9IFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudXNlRGVmYXVsdHMgPT0gXCJzaGFyZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBpdC51c2VEZWZhdWx0KCRzY2guZGVmYXVsdCkgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIEpTT04uc3RyaW5naWZ5KCRzY2guZGVmYXVsdCkgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIjsgXCI7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJyNSA9ICRydWxlc0dyb3VwLnJ1bGVzO1xuICAgICAgICAgICAgaWYgKGFycjUpIHtcbiAgICAgICAgICAgICAgdmFyICRydWxlLCBpNSA9IC0xLCBsNSA9IGFycjUubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgd2hpbGUgKGk1IDwgbDUpIHtcbiAgICAgICAgICAgICAgICAkcnVsZSA9IGFycjVbaTUgKz0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCRzaG91bGRVc2VSdWxlKCRydWxlKSkge1xuICAgICAgICAgICAgICAgICAgdmFyICRjb2RlID0gJHJ1bGUuY29kZShpdCwgJHJ1bGUua2V5d29yZCwgJHJ1bGVzR3JvdXAudHlwZSk7XG4gICAgICAgICAgICAgICAgICBpZiAoJGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgJGNvZGUgKyBcIiBcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkY2xvc2luZ0JyYWNlczEgKz0gXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBcIiArICRjbG9zaW5nQnJhY2VzMSArIFwiIFwiO1xuICAgICAgICAgICAgICAkY2xvc2luZ0JyYWNlczEgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRydWxlc0dyb3VwLnR5cGUpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgICAgICAgIGlmICgkdHlwZVNjaGVtYSAmJiAkdHlwZVNjaGVtYSA9PT0gJHJ1bGVzR3JvdXAudHlwZSAmJiAhJGNvZXJjZVRvVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgZWxzZSB7IFwiO1xuICAgICAgICAgICAgICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBcIi50eXBlXCIsICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL3R5cGVcIjtcbiAgICAgICAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJ0eXBlXCIpICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IHR5cGU6ICdcIjtcbiAgICAgICAgICAgICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYS5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCInIH0gXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBiZSBcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCR0eXBlSXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHR5cGVTY2hlbWEuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiXCIgKyAkdHlwZVNjaGVtYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChlcnJvcnMgPT09IFwiO1xuICAgICAgICAgICAgICBpZiAoJHRvcCkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIjBcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCJlcnJzX1wiICsgJGx2bDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCIpIHsgXCI7XG4gICAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzMiArPSBcIn1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSBcIiBcIiArICRjbG9zaW5nQnJhY2VzMiArIFwiIFwiO1xuICAgIH1cbiAgICBpZiAoJHRvcCkge1xuICAgICAgaWYgKCRhc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKGVycm9ycyA9PT0gMCkgcmV0dXJuIGRhdGE7ICAgICAgICAgICBcIjtcbiAgICAgICAgb3V0ICs9IFwiIGVsc2UgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgXCI7XG4gICAgICAgIG91dCArPSBcIiByZXR1cm4gZXJyb3JzID09PSAwOyAgICAgICBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9OyByZXR1cm4gdmFsaWRhdGU7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkdmFsaWQgKyBcIiA9IGVycm9ycyA9PT0gZXJyc19cIiArICRsdmwgKyBcIjtcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gJHNob3VsZFVzZUdyb3VwKCRydWxlc0dyb3VwMikge1xuICAgICAgdmFyIHJ1bGVzID0gJHJ1bGVzR3JvdXAyLnJ1bGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IHJ1bGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoJHNob3VsZFVzZVJ1bGUocnVsZXNbaV0pKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkc2hvdWxkVXNlUnVsZSgkcnVsZTIpIHtcbiAgICAgIHJldHVybiBpdC5zY2hlbWFbJHJ1bGUyLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHwgJHJ1bGUyLmltcGxlbWVudHMgJiYgJHJ1bGVJbXBsZW1lbnRzU29tZUtleXdvcmQoJHJ1bGUyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJHJ1bGVJbXBsZW1lbnRzU29tZUtleXdvcmQoJHJ1bGUyKSB7XG4gICAgICB2YXIgaW1wbCA9ICRydWxlMi5pbXBsZW1lbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7aSA8IGltcGwubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChpdC5zY2hlbWFbaW1wbFtpXV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2luZGV4LmpzXG52YXIgcmVxdWlyZV9jb21waWxlID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciByZXNvbHZlID0gcmVxdWlyZV9yZXNvbHZlKCk7XG4gIHZhciB1dGlsMyA9IHJlcXVpcmVfdXRpbCgpO1xuICB2YXIgZXJyb3JDbGFzc2VzID0gcmVxdWlyZV9lcnJvcl9jbGFzc2VzKCk7XG4gIHZhciBzdGFibGVTdHJpbmdpZnkgPSByZXF1aXJlX2Zhc3RfanNvbl9zdGFibGVfc3RyaW5naWZ5KCk7XG4gIHZhciB2YWxpZGF0ZUdlbmVyYXRvciA9IHJlcXVpcmVfdmFsaWRhdGUoKTtcbiAgdmFyIHVjczJsZW5ndGggPSB1dGlsMy51Y3MybGVuZ3RoO1xuICB2YXIgZXF1YWwgPSByZXF1aXJlX2Zhc3RfZGVlcF9lcXVhbCgpO1xuICB2YXIgVmFsaWRhdGlvbkVycm9yID0gZXJyb3JDbGFzc2VzLlZhbGlkYXRpb247XG4gIG1vZHVsZS5leHBvcnRzID0gY29tcGlsZTtcbiAgZnVuY3Rpb24gY29tcGlsZShzY2hlbWEsIHJvb3QyLCBsb2NhbFJlZnMsIGJhc2VJZCkge1xuICAgIHZhciBzZWxmMiA9IHRoaXMsIG9wdHMgPSB0aGlzLl9vcHRzLCByZWZWYWwgPSBbdW5kZWZpbmVkXSwgcmVmcyA9IHt9LCBwYXR0ZXJucyA9IFtdLCBwYXR0ZXJuc0hhc2ggPSB7fSwgZGVmYXVsdHMgPSBbXSwgZGVmYXVsdHNIYXNoID0ge30sIGN1c3RvbVJ1bGVzID0gW107XG4gICAgcm9vdDIgPSByb290MiB8fCB7IHNjaGVtYSwgcmVmVmFsLCByZWZzIH07XG4gICAgdmFyIGMgPSBjaGVja0NvbXBpbGluZy5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdDIsIGJhc2VJZCk7XG4gICAgdmFyIGNvbXBpbGF0aW9uID0gdGhpcy5fY29tcGlsYXRpb25zW2MuaW5kZXhdO1xuICAgIGlmIChjLmNvbXBpbGluZylcbiAgICAgIHJldHVybiBjb21waWxhdGlvbi5jYWxsVmFsaWRhdGUgPSBjYWxsVmFsaWRhdGU7XG4gICAgdmFyIGZvcm1hdHMgPSB0aGlzLl9mb3JtYXRzO1xuICAgIHZhciBSVUxFUyA9IHRoaXMuUlVMRVM7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB2ID0gbG9jYWxDb21waWxlKHNjaGVtYSwgcm9vdDIsIGxvY2FsUmVmcywgYmFzZUlkKTtcbiAgICAgIGNvbXBpbGF0aW9uLnZhbGlkYXRlID0gdjtcbiAgICAgIHZhciBjdiA9IGNvbXBpbGF0aW9uLmNhbGxWYWxpZGF0ZTtcbiAgICAgIGlmIChjdikge1xuICAgICAgICBjdi5zY2hlbWEgPSB2LnNjaGVtYTtcbiAgICAgICAgY3YuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgY3YucmVmcyA9IHYucmVmcztcbiAgICAgICAgY3YucmVmVmFsID0gdi5yZWZWYWw7XG4gICAgICAgIGN2LnJvb3QgPSB2LnJvb3Q7XG4gICAgICAgIGN2LiRhc3luYyA9IHYuJGFzeW5jO1xuICAgICAgICBpZiAob3B0cy5zb3VyY2VDb2RlKVxuICAgICAgICAgIGN2LnNvdXJjZSA9IHYuc291cmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVuZENvbXBpbGluZy5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdDIsIGJhc2VJZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZSgpIHtcbiAgICAgIHZhciB2YWxpZGF0ZSA9IGNvbXBpbGF0aW9uLnZhbGlkYXRlO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBjYWxsVmFsaWRhdGUuZXJyb3JzID0gdmFsaWRhdGUuZXJyb3JzO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9jYWxDb21waWxlKF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMyLCBiYXNlSWQyKSB7XG4gICAgICB2YXIgaXNSb290ID0gIV9yb290IHx8IF9yb290ICYmIF9yb290LnNjaGVtYSA9PSBfc2NoZW1hO1xuICAgICAgaWYgKF9yb290LnNjaGVtYSAhPSByb290Mi5zY2hlbWEpXG4gICAgICAgIHJldHVybiBjb21waWxlLmNhbGwoc2VsZjIsIF9zY2hlbWEsIF9yb290LCBsb2NhbFJlZnMyLCBiYXNlSWQyKTtcbiAgICAgIHZhciAkYXN5bmMgPSBfc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZTtcbiAgICAgIHZhciBzb3VyY2VDb2RlID0gdmFsaWRhdGVHZW5lcmF0b3Ioe1xuICAgICAgICBpc1RvcDogdHJ1ZSxcbiAgICAgICAgc2NoZW1hOiBfc2NoZW1hLFxuICAgICAgICBpc1Jvb3QsXG4gICAgICAgIGJhc2VJZDogYmFzZUlkMixcbiAgICAgICAgcm9vdDogX3Jvb3QsXG4gICAgICAgIHNjaGVtYVBhdGg6IFwiXCIsXG4gICAgICAgIGVyclNjaGVtYVBhdGg6IFwiI1wiLFxuICAgICAgICBlcnJvclBhdGg6ICdcIlwiJyxcbiAgICAgICAgTWlzc2luZ1JlZkVycm9yOiBlcnJvckNsYXNzZXMuTWlzc2luZ1JlZixcbiAgICAgICAgUlVMRVMsXG4gICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUdlbmVyYXRvcixcbiAgICAgICAgdXRpbDogdXRpbDMsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlc29sdmVSZWYsXG4gICAgICAgIHVzZVBhdHRlcm4sXG4gICAgICAgIHVzZURlZmF1bHQsXG4gICAgICAgIHVzZUN1c3RvbVJ1bGUsXG4gICAgICAgIG9wdHMsXG4gICAgICAgIGZvcm1hdHMsXG4gICAgICAgIGxvZ2dlcjogc2VsZjIubG9nZ2VyLFxuICAgICAgICBzZWxmOiBzZWxmMlxuICAgICAgfSk7XG4gICAgICBzb3VyY2VDb2RlID0gdmFycyhyZWZWYWwsIHJlZlZhbENvZGUpICsgdmFycyhwYXR0ZXJucywgcGF0dGVybkNvZGUpICsgdmFycyhkZWZhdWx0cywgZGVmYXVsdENvZGUpICsgdmFycyhjdXN0b21SdWxlcywgY3VzdG9tUnVsZUNvZGUpICsgc291cmNlQ29kZTtcbiAgICAgIGlmIChvcHRzLnByb2Nlc3NDb2RlKVxuICAgICAgICBzb3VyY2VDb2RlID0gb3B0cy5wcm9jZXNzQ29kZShzb3VyY2VDb2RlLCBfc2NoZW1hKTtcbiAgICAgIHZhciB2YWxpZGF0ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oXCJzZWxmXCIsIFwiUlVMRVNcIiwgXCJmb3JtYXRzXCIsIFwicm9vdFwiLCBcInJlZlZhbFwiLCBcImRlZmF1bHRzXCIsIFwiY3VzdG9tUnVsZXNcIiwgXCJlcXVhbFwiLCBcInVjczJsZW5ndGhcIiwgXCJWYWxpZGF0aW9uRXJyb3JcIiwgc291cmNlQ29kZSk7XG4gICAgICAgIHZhbGlkYXRlID0gbWFrZVZhbGlkYXRlKHNlbGYyLCBSVUxFUywgZm9ybWF0cywgcm9vdDIsIHJlZlZhbCwgZGVmYXVsdHMsIGN1c3RvbVJ1bGVzLCBlcXVhbCwgdWNzMmxlbmd0aCwgVmFsaWRhdGlvbkVycm9yKTtcbiAgICAgICAgcmVmVmFsWzBdID0gdmFsaWRhdGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYyLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGUuc2NoZW1hID0gX3NjaGVtYTtcbiAgICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGw7XG4gICAgICB2YWxpZGF0ZS5yZWZzID0gcmVmcztcbiAgICAgIHZhbGlkYXRlLnJlZlZhbCA9IHJlZlZhbDtcbiAgICAgIHZhbGlkYXRlLnJvb3QgPSBpc1Jvb3QgPyB2YWxpZGF0ZSA6IF9yb290O1xuICAgICAgaWYgKCRhc3luYylcbiAgICAgICAgdmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRzLnNvdXJjZUNvZGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsaWRhdGUuc291cmNlID0ge1xuICAgICAgICAgIGNvZGU6IHNvdXJjZUNvZGUsXG4gICAgICAgICAgcGF0dGVybnMsXG4gICAgICAgICAgZGVmYXVsdHNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzb2x2ZVJlZihiYXNlSWQyLCByZWYsIGlzUm9vdCkge1xuICAgICAgcmVmID0gcmVzb2x2ZS51cmwoYmFzZUlkMiwgcmVmKTtcbiAgICAgIHZhciByZWZJbmRleCA9IHJlZnNbcmVmXTtcbiAgICAgIHZhciBfcmVmVmFsLCByZWZDb2RlO1xuICAgICAgaWYgKHJlZkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3JlZlZhbCA9IHJlZlZhbFtyZWZJbmRleF07XG4gICAgICAgIHJlZkNvZGUgPSBcInJlZlZhbFtcIiArIHJlZkluZGV4ICsgXCJdXCI7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFJlZihfcmVmVmFsLCByZWZDb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNSb290ICYmIHJvb3QyLnJlZnMpIHtcbiAgICAgICAgdmFyIHJvb3RSZWZJZCA9IHJvb3QyLnJlZnNbcmVmXTtcbiAgICAgICAgaWYgKHJvb3RSZWZJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgX3JlZlZhbCA9IHJvb3QyLnJlZlZhbFtyb290UmVmSWRdO1xuICAgICAgICAgIHJlZkNvZGUgPSBhZGRMb2NhbFJlZihyZWYsIF9yZWZWYWwpO1xuICAgICAgICAgIHJldHVybiByZXNvbHZlZFJlZihfcmVmVmFsLCByZWZDb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVmQ29kZSA9IGFkZExvY2FsUmVmKHJlZik7XG4gICAgICB2YXIgdjIgPSByZXNvbHZlLmNhbGwoc2VsZjIsIGxvY2FsQ29tcGlsZSwgcm9vdDIsIHJlZik7XG4gICAgICBpZiAodjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbG9jYWxTY2hlbWEgPSBsb2NhbFJlZnMgJiYgbG9jYWxSZWZzW3JlZl07XG4gICAgICAgIGlmIChsb2NhbFNjaGVtYSkge1xuICAgICAgICAgIHYyID0gcmVzb2x2ZS5pbmxpbmVSZWYobG9jYWxTY2hlbWEsIG9wdHMuaW5saW5lUmVmcykgPyBsb2NhbFNjaGVtYSA6IGNvbXBpbGUuY2FsbChzZWxmMiwgbG9jYWxTY2hlbWEsIHJvb3QyLCBsb2NhbFJlZnMsIGJhc2VJZDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW1vdmVMb2NhbFJlZihyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwbGFjZUxvY2FsUmVmKHJlZiwgdjIpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWRSZWYodjIsIHJlZkNvZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRMb2NhbFJlZihyZWYsIHYyKSB7XG4gICAgICB2YXIgcmVmSWQgPSByZWZWYWwubGVuZ3RoO1xuICAgICAgcmVmVmFsW3JlZklkXSA9IHYyO1xuICAgICAgcmVmc1tyZWZdID0gcmVmSWQ7XG4gICAgICByZXR1cm4gXCJyZWZWYWxcIiArIHJlZklkO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVMb2NhbFJlZihyZWYpIHtcbiAgICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2NhbFJlZihyZWYsIHYyKSB7XG4gICAgICB2YXIgcmVmSWQgPSByZWZzW3JlZl07XG4gICAgICByZWZWYWxbcmVmSWRdID0gdjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc29sdmVkUmVmKHJlZlZhbDIsIGNvZGUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgcmVmVmFsMiA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiByZWZWYWwyID09IFwiYm9vbGVhblwiID8geyBjb2RlLCBzY2hlbWE6IHJlZlZhbDIsIGlubGluZTogdHJ1ZSB9IDogeyBjb2RlLCAkYXN5bmM6IHJlZlZhbDIgJiYgISFyZWZWYWwyLiRhc3luYyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VQYXR0ZXJuKHJlZ2V4U3RyKSB7XG4gICAgICB2YXIgaW5kZXggPSBwYXR0ZXJuc0hhc2hbcmVnZXhTdHJdO1xuICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBwYXR0ZXJuc0hhc2hbcmVnZXhTdHJdID0gcGF0dGVybnMubGVuZ3RoO1xuICAgICAgICBwYXR0ZXJuc1tpbmRleF0gPSByZWdleFN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcInBhdHRlcm5cIiArIGluZGV4O1xuICAgIH1cbiAgICBmdW5jdGlvbiB1c2VEZWZhdWx0KHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiB1dGlsMy50b1F1b3RlZFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgdmFyIHZhbHVlU3RyID0gc3RhYmxlU3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBkZWZhdWx0c0hhc2hbdmFsdWVTdHJdO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmRleCA9IGRlZmF1bHRzSGFzaFt2YWx1ZVN0cl0gPSBkZWZhdWx0cy5sZW5ndGg7XG4gICAgICAgICAgICBkZWZhdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiZGVmYXVsdFwiICsgaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVzZUN1c3RvbVJ1bGUocnVsZSwgc2NoZW1hMiwgcGFyZW50U2NoZW1hLCBpdCkge1xuICAgICAgaWYgKHNlbGYyLl9vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSkge1xuICAgICAgICB2YXIgZGVwcyA9IHJ1bGUuZGVmaW5pdGlvbi5kZXBlbmRlbmNpZXM7XG4gICAgICAgIGlmIChkZXBzICYmICFkZXBzLmV2ZXJ5KGZ1bmN0aW9uKGtleXdvcmQpIHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmVudFNjaGVtYSwga2V5d29yZCk7XG4gICAgICAgIH0pKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGFsbCByZXF1aXJlZCBrZXl3b3JkczogXCIgKyBkZXBzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgdmFyIHZhbGlkYXRlU2NoZW1hID0gcnVsZS5kZWZpbml0aW9uLnZhbGlkYXRlU2NoZW1hO1xuICAgICAgICBpZiAodmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZVNjaGVtYShzY2hlbWEyKTtcbiAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwia2V5d29yZCBzY2hlbWEgaXMgaW52YWxpZDogXCIgKyBzZWxmMi5lcnJvcnNUZXh0KHZhbGlkYXRlU2NoZW1hLmVycm9ycyk7XG4gICAgICAgICAgICBpZiAoc2VsZjIuX29wdHMudmFsaWRhdGVTY2hlbWEgPT0gXCJsb2dcIilcbiAgICAgICAgICAgICAgc2VsZjIubG9nZ2VyLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY29tcGlsZTIgPSBydWxlLmRlZmluaXRpb24uY29tcGlsZSwgaW5saW5lID0gcnVsZS5kZWZpbml0aW9uLmlubGluZSwgbWFjcm8gPSBydWxlLmRlZmluaXRpb24ubWFjcm87XG4gICAgICB2YXIgdmFsaWRhdGU7XG4gICAgICBpZiAoY29tcGlsZTIpIHtcbiAgICAgICAgdmFsaWRhdGUgPSBjb21waWxlMi5jYWxsKHNlbGYyLCBzY2hlbWEyLCBwYXJlbnRTY2hlbWEsIGl0KTtcbiAgICAgIH0gZWxzZSBpZiAobWFjcm8pIHtcbiAgICAgICAgdmFsaWRhdGUgPSBtYWNyby5jYWxsKHNlbGYyLCBzY2hlbWEyLCBwYXJlbnRTY2hlbWEsIGl0KTtcbiAgICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKVxuICAgICAgICAgIHNlbGYyLnZhbGlkYXRlU2NoZW1hKHZhbGlkYXRlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5saW5lKSB7XG4gICAgICAgIHZhbGlkYXRlID0gaW5saW5lLmNhbGwoc2VsZjIsIGl0LCBydWxlLmtleXdvcmQsIHNjaGVtYTIsIHBhcmVudFNjaGVtYSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZGF0ZSA9IHJ1bGUuZGVmaW5pdGlvbi52YWxpZGF0ZTtcbiAgICAgICAgaWYgKCF2YWxpZGF0ZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjdXN0b20ga2V5d29yZCBcIicgKyBydWxlLmtleXdvcmQgKyAnXCJmYWlsZWQgdG8gY29tcGlsZScpO1xuICAgICAgdmFyIGluZGV4ID0gY3VzdG9tUnVsZXMubGVuZ3RoO1xuICAgICAgY3VzdG9tUnVsZXNbaW5kZXhdID0gdmFsaWRhdGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBcImN1c3RvbVJ1bGVcIiArIGluZGV4LFxuICAgICAgICB2YWxpZGF0ZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tDb21waWxpbmcoc2NoZW1hLCByb290MiwgYmFzZUlkKSB7XG4gICAgdmFyIGluZGV4ID0gY29tcEluZGV4LmNhbGwodGhpcywgc2NoZW1hLCByb290MiwgYmFzZUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMClcbiAgICAgIHJldHVybiB7IGluZGV4LCBjb21waWxpbmc6IHRydWUgfTtcbiAgICBpbmRleCA9IHRoaXMuX2NvbXBpbGF0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5fY29tcGlsYXRpb25zW2luZGV4XSA9IHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIHJvb3Q6IHJvb3QyLFxuICAgICAgYmFzZUlkXG4gICAgfTtcbiAgICByZXR1cm4geyBpbmRleCwgY29tcGlsaW5nOiBmYWxzZSB9O1xuICB9XG4gIGZ1bmN0aW9uIGVuZENvbXBpbGluZyhzY2hlbWEsIHJvb3QyLCBiYXNlSWQpIHtcbiAgICB2YXIgaSA9IGNvbXBJbmRleC5jYWxsKHRoaXMsIHNjaGVtYSwgcm9vdDIsIGJhc2VJZCk7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5zcGxpY2UoaSwgMSk7XG4gIH1cbiAgZnVuY3Rpb24gY29tcEluZGV4KHNjaGVtYSwgcm9vdDIsIGJhc2VJZCkge1xuICAgIGZvciAodmFyIGkgPSAwO2kgPCB0aGlzLl9jb21waWxhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gdGhpcy5fY29tcGlsYXRpb25zW2ldO1xuICAgICAgaWYgKGMuc2NoZW1hID09IHNjaGVtYSAmJiBjLnJvb3QgPT0gcm9vdDIgJiYgYy5iYXNlSWQgPT0gYmFzZUlkKVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZ1bmN0aW9uIHBhdHRlcm5Db2RlKGksIHBhdHRlcm5zKSB7XG4gICAgcmV0dXJuIFwidmFyIHBhdHRlcm5cIiArIGkgKyBcIiA9IG5ldyBSZWdFeHAoXCIgKyB1dGlsMy50b1F1b3RlZFN0cmluZyhwYXR0ZXJuc1tpXSkgKyBcIik7XCI7XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdENvZGUoaSkge1xuICAgIHJldHVybiBcInZhciBkZWZhdWx0XCIgKyBpICsgXCIgPSBkZWZhdWx0c1tcIiArIGkgKyBcIl07XCI7XG4gIH1cbiAgZnVuY3Rpb24gcmVmVmFsQ29kZShpLCByZWZWYWwpIHtcbiAgICByZXR1cm4gcmVmVmFsW2ldID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCJ2YXIgcmVmVmFsXCIgKyBpICsgXCIgPSByZWZWYWxbXCIgKyBpICsgXCJdO1wiO1xuICB9XG4gIGZ1bmN0aW9uIGN1c3RvbVJ1bGVDb2RlKGkpIHtcbiAgICByZXR1cm4gXCJ2YXIgY3VzdG9tUnVsZVwiICsgaSArIFwiID0gY3VzdG9tUnVsZXNbXCIgKyBpICsgXCJdO1wiO1xuICB9XG4gIGZ1bmN0aW9uIHZhcnMoYXJyLCBzdGF0ZW1lbnQpIHtcbiAgICBpZiAoIWFyci5sZW5ndGgpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgZm9yICh2YXIgaSA9IDA7aSA8IGFyci5sZW5ndGg7IGkrKylcbiAgICAgIGNvZGUgKz0gc3RhdGVtZW50KGksIGFycik7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jYWNoZS5qc1xudmFyIHJlcXVpcmVfY2FjaGUgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgdmFyIENhY2hlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDYWNoZSgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICB9O1xuICBDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gQ2FjaGVfcHV0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLl9jYWNoZVtrZXldID0gdmFsdWU7XG4gIH07XG4gIENhY2hlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBDYWNoZV9nZXQoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlW2tleV07XG4gIH07XG4gIENhY2hlLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiBDYWNoZV9kZWwoa2V5KSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlW2tleV07XG4gIH07XG4gIENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIENhY2hlX2NsZWFyKCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9mb3JtYXRzLmpzXG52YXIgcmVxdWlyZV9mb3JtYXRzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciB1dGlsMyA9IHJlcXVpcmVfdXRpbCgpO1xuICB2YXIgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkLztcbiAgdmFyIERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG4gIHZhciBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuICB2YXIgSE9TVE5BTUUgPSAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pO1xuICB2YXIgVVJJID0gL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaTtcbiAgdmFyIFVSSVJFRiA9IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2k7XG4gIHZhciBVUklURU1QTEFURSA9IC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pO1xuICB2YXIgVVJMMiA9IC9eKD86KD86aHR0cFtzXFx1MDE3Rl0/fGZ0cCk6XFwvXFwvKSg/Oig/OltcXDAtXFx4MDhcXHgwRS1cXHgxRiEtXFx4OUZcXHhBMS1cXHUxNjdGXFx1MTY4MS1cXHUxRkZGXFx1MjAwQi1cXHUyMDI3XFx1MjAyQS1cXHUyMDJFXFx1MjAzMC1cXHUyMDVFXFx1MjA2MC1cXHUyRkZGXFx1MzAwMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRUZFXFx1RkYwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSsoPzo6KD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKik/QCk/KD86KD8hMTAoPzpcXC5bMC05XXsxLDN9KXszfSkoPyExMjcoPzpcXC5bMC05XXsxLDN9KXszfSkoPyExNjlcXC4yNTQoPzpcXC5bMC05XXsxLDN9KXsyfSkoPyExOTJcXC4xNjgoPzpcXC5bMC05XXsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlswLTldfDNbMDFdKSg/OlxcLlswLTldezEsM30pezJ9KSg/OlsxLTldWzAtOV0/fDFbMC05XVswLTldfDJbMDFdWzAtOV18MjJbMC0zXSkoPzpcXC4oPzoxP1swLTldezEsMn18MlswLTRdWzAtOV18MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1bMC05XT98MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC00XSkpfCg/Oig/Oig/OlswLTlhLXpcXHhBMS1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXSkrLSkqKD86WzAtOWEtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSspKD86XFwuKD86KD86WzAtOWEtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKSstKSooPzpbMC05YS16XFx4QTEtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKykqKD86XFwuKD86KD86W2EtelxceEExLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdKD8hW1xcdURDMDAtXFx1REZGRl0pfCg/OlteXFx1RDgwMC1cXHVEQkZGXXxeKVtcXHVEQzAwLVxcdURGRkZdKXsyLH0pKSkoPzo6WzAtOV17Miw1fSk/KD86XFwvKD86W1xcMC1cXHgwOFxceDBFLVxceDFGIS1cXHg5RlxceEExLVxcdTE2N0ZcXHUxNjgxLVxcdTFGRkZcXHUyMDBCLVxcdTIwMjdcXHUyMDJBLVxcdTIwMkVcXHUyMDMwLVxcdTIwNUVcXHUyMDYwLVxcdTJGRkZcXHUzMDAxLVxcdUQ3RkZcXHVFMDAwLVxcdUZFRkVcXHVGRjAwLVxcdUZGRkZdfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W1xcdUQ4MDAtXFx1REJGRl0oPyFbXFx1REMwMC1cXHVERkZGXSl8KD86W15cXHVEODAwLVxcdURCRkZdfF4pW1xcdURDMDAtXFx1REZGRl0pKik/JC9pO1xuICB2YXIgVVVJRCA9IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pO1xuICB2YXIgSlNPTl9QT0lOVEVSID0gL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLztcbiAgdmFyIEpTT05fUE9JTlRFUl9VUklfRlJBR01FTlQgPSAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pO1xuICB2YXIgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvO1xuICBtb2R1bGUuZXhwb3J0cyA9IGZvcm1hdHM7XG4gIGZ1bmN0aW9uIGZvcm1hdHMobW9kZSkge1xuICAgIG1vZGUgPSBtb2RlID09IFwiZnVsbFwiID8gXCJmdWxsXCIgOiBcImZhc3RcIjtcbiAgICByZXR1cm4gdXRpbDMuY29weShmb3JtYXRzW21vZGVdKTtcbiAgfVxuICBmb3JtYXRzLmZhc3QgPSB7XG4gICAgZGF0ZTogL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLyxcbiAgICB0aW1lOiAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSxcbiAgICBcImRhdGUtdGltZVwiOiAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLFxuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiBVUklURU1QTEFURSxcbiAgICB1cmw6IFVSTDIsXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG4gICAgaG9zdG5hbWU6IEhPU1ROQU1FLFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaSxcbiAgICByZWdleCxcbiAgICB1dWlkOiBVVUlELFxuICAgIFwianNvbi1wb2ludGVyXCI6IEpTT05fUE9JTlRFUixcbiAgICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogSlNPTl9QT0lOVEVSX1VSSV9GUkFHTUVOVCxcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiBSRUxBVElWRV9KU09OX1BPSU5URVJcbiAgfTtcbiAgZm9ybWF0cy5mdWxsID0ge1xuICAgIGRhdGUsXG4gICAgdGltZSxcbiAgICBcImRhdGUtdGltZVwiOiBkYXRlX3RpbWUsXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiBVUklSRUYsXG4gICAgXCJ1cmktdGVtcGxhdGVcIjogVVJJVEVNUExBVEUsXG4gICAgdXJsOiBVUkwyLFxuICAgIGVtYWlsOiAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgICBob3N0bmFtZTogSE9TVE5BTUUsXG4gICAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykkLyxcbiAgICBpcHY2OiAvXlxccyooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7N30oPzpbMC05YS1mXXsxLDR9fDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Nn0oPzo6WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezV9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsMn0pfDooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezR9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsM30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KT86KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7M30oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw0fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsMn06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7Mn0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw1fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsM306KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MX0oPzooPzooPzo6WzAtOWEtZl17MSw0fSl7MSw2fSl8KD86KD86OlswLTlhLWZdezEsNH0pezAsNH06KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoPzo6KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsN30pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDV9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpKD86JS4rKT9cXHMqJC9pLFxuICAgIHJlZ2V4LFxuICAgIHV1aWQ6IFVVSUQsXG4gICAgXCJqc29uLXBvaW50ZXJcIjogSlNPTl9QT0lOVEVSLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiBKU09OX1BPSU5URVJfVVJJX0ZSQUdNRU5ULFxuICAgIFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCI6IFJFTEFUSVZFX0pTT05fUE9JTlRFUlxuICB9O1xuICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IHN0ci5tYXRjaChEQVRFKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICB2YXIgbW9udGggPSArbWF0Y2hlc1syXTtcbiAgICB2YXIgZGF5ID0gK21hdGNoZXNbM107XG4gICAgcmV0dXJuIG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgJiYgZGF5ID49IDEgJiYgZGF5IDw9IChtb250aCA9PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKTtcbiAgfVxuICBmdW5jdGlvbiB0aW1lKHN0ciwgZnVsbCkge1xuICAgIHZhciBtYXRjaGVzID0gc3RyLm1hdGNoKFRJTUUpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaG91ciA9IG1hdGNoZXNbMV07XG4gICAgdmFyIG1pbnV0ZSA9IG1hdGNoZXNbMl07XG4gICAgdmFyIHNlY29uZCA9IG1hdGNoZXNbM107XG4gICAgdmFyIHRpbWVab25lID0gbWF0Y2hlc1s1XTtcbiAgICByZXR1cm4gKGhvdXIgPD0gMjMgJiYgbWludXRlIDw9IDU5ICYmIHNlY29uZCA8PSA1OSB8fCBob3VyID09IDIzICYmIG1pbnV0ZSA9PSA1OSAmJiBzZWNvbmQgPT0gNjApICYmICghZnVsbCB8fCB0aW1lWm9uZSk7XG4gIH1cbiAgdmFyIERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaTtcbiAgZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIHZhciBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSwgdHJ1ZSk7XG4gIH1cbiAgdmFyIE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovO1xuICBmdW5jdGlvbiB1cmkoc3RyKSB7XG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG4gIH1cbiAgdmFyIFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG4gIGZ1bmN0aW9uIHJlZ2V4KHN0cikge1xuICAgIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBSZWdFeHAoc3RyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9yZWYuanNcbnZhciByZXF1aXJlX3JlZiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3JlZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICR2YWxpZCA9IFwidmFsaWRcIiArICRsdmw7XG4gICAgdmFyICRhc3luYywgJHJlZkNvZGU7XG4gICAgaWYgKCRzY2hlbWEgPT0gXCIjXCIgfHwgJHNjaGVtYSA9PSBcIiMvXCIpIHtcbiAgICAgIGlmIChpdC5pc1Jvb3QpIHtcbiAgICAgICAgJGFzeW5jID0gaXQuYXN5bmM7XG4gICAgICAgICRyZWZDb2RlID0gXCJ2YWxpZGF0ZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFzeW5jID0gaXQucm9vdC5zY2hlbWEuJGFzeW5jID09PSB0cnVlO1xuICAgICAgICAkcmVmQ29kZSA9IFwicm9vdC5yZWZWYWxbMF1cIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRyZWZWYWwgPSBpdC5yZXNvbHZlUmVmKGl0LmJhc2VJZCwgJHNjaGVtYSwgaXQuaXNSb290KTtcbiAgICAgIGlmICgkcmVmVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyICRtZXNzYWdlID0gaXQuTWlzc2luZ1JlZkVycm9yLm1lc3NhZ2UoaXQuYmFzZUlkLCAkc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0Lm9wdHMubWlzc2luZ1JlZnMgPT0gXCJmYWlsXCIpIHtcbiAgICAgICAgICBpdC5sb2dnZXIuZXJyb3IoJG1lc3NhZ2UpO1xuICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICBvdXQgPSBcIlwiO1xuICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcIiRyZWZcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyByZWY6ICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpICsgXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ2NhblxcXFwndCByZXNvbHZlIHJlZmVyZW5jZSBcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRzY2hlbWEpICsgXCInIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKSArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgaWYgKGZhbHNlKSB7IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpdC5vcHRzLm1pc3NpbmdSZWZzID09IFwiaWdub3JlXCIpIHtcbiAgICAgICAgICBpdC5sb2dnZXIud2FybigkbWVzc2FnZSk7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiBpZiAodHJ1ZSkgeyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IGl0Lk1pc3NpbmdSZWZFcnJvcihpdC5iYXNlSWQsICRzY2hlbWEsICRtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkcmVmVmFsLmlubGluZSkge1xuICAgICAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICAgICAgJGl0LmxldmVsKys7XG4gICAgICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgICAgICAkaXQuc2NoZW1hID0gJHJlZlZhbC5zY2hlbWE7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gXCJcIjtcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkc2NoZW1hO1xuICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpLnJlcGxhY2UoL3ZhbGlkYXRlXFwuc2NoZW1hL2csICRyZWZWYWwuY29kZSk7XG4gICAgICAgIG91dCArPSBcIiBcIiArICRjb2RlICsgXCIgXCI7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRuZXh0VmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGFzeW5jID0gJHJlZlZhbC4kYXN5bmMgPT09IHRydWUgfHwgaXQuYXN5bmMgJiYgJHJlZlZhbC4kYXN5bmMgIT09IGZhbHNlO1xuICAgICAgICAkcmVmQ29kZSA9ICRyZWZWYWwuY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRyZWZDb2RlKSB7XG4gICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgIG91dCA9IFwiXCI7XG4gICAgICBpZiAoaXQub3B0cy5wYXNzQ29udGV4dCkge1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyAkcmVmQ29kZSArIFwiLmNhbGwodGhpcywgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyAkcmVmQ29kZSArIFwiKCBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiBcIiArICRkYXRhICsgXCIsIChkYXRhUGF0aCB8fCAnJylcIjtcbiAgICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICAgIG91dCArPSBcIiArIFwiICsgaXQuZXJyb3JQYXRoO1xuICAgICAgfVxuICAgICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyBcImRhdGFcIiArICgkZGF0YUx2bCAtIDEgfHwgXCJcIikgOiBcInBhcmVudERhdGFcIiwgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogXCJwYXJlbnREYXRhUHJvcGVydHlcIjtcbiAgICAgIG91dCArPSBcIiAsIFwiICsgJHBhcmVudERhdGEgKyBcIiAsIFwiICsgJHBhcmVudERhdGFQcm9wZXJ0eSArIFwiLCByb290RGF0YSkgIFwiO1xuICAgICAgdmFyIF9fY2FsbFZhbGlkYXRlID0gb3V0O1xuICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgIGlmICgkYXN5bmMpIHtcbiAgICAgICAgaWYgKCFpdC5hc3luYylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJHZhbGlkICsgXCI7IFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB0cnkgeyBhd2FpdCBcIiArIF9fY2FsbFZhbGlkYXRlICsgXCI7IFwiO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gdHJ1ZTsgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gY2F0Y2ggKGUpIHsgaWYgKCEoZSBpbnN0YW5jZW9mIFZhbGlkYXRpb25FcnJvcikpIHRocm93IGU7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gZS5lcnJvcnM7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KGUuZXJyb3JzKTsgZXJyb3JzID0gdkVycm9ycy5sZW5ndGg7IFwiO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gZmFsc2U7IFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkdmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICghXCIgKyBfX2NhbGxWYWxpZGF0ZSArIFwiKSB7IGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gXCIgKyAkcmVmQ29kZSArIFwiLmVycm9yczsgZWxzZSB2RXJyb3JzID0gdkVycm9ycy5jb25jYXQoXCIgKyAkcmVmQ29kZSArIFwiLmVycm9ycyk7IGVycm9ycyA9IHZFcnJvcnMubGVuZ3RoOyB9IFwiO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBlbHNlIHsgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9hbGxPZi5qc1xudmFyIHJlcXVpcmVfYWxsT2YgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9hbGxPZihpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgIHZhciAkY2xvc2luZ0JyYWNlcyA9IFwiXCI7XG4gICAgJGl0LmxldmVsKys7XG4gICAgdmFyICRuZXh0VmFsaWQgPSBcInZhbGlkXCIgKyAkaXQubGV2ZWw7XG4gICAgdmFyICRjdXJyZW50QmFzZUlkID0gJGl0LmJhc2VJZCwgJGFsbFNjaGVtYXNFbXB0eSA9IHRydWU7XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyB0eXBlb2YgJHNjaCA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDAgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICAkYWxsU2NoZW1hc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgJGl0LnNjaGVtYSA9ICRzY2g7XG4gICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArIFwiW1wiICsgJGkgKyBcIl1cIjtcbiAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAkaTtcbiAgICAgICAgICBvdXQgKz0gXCIgIFwiICsgaXQudmFsaWRhdGUoJGl0KSArIFwiIFwiO1xuICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRuZXh0VmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9IFwifVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgaWYgKCRhbGxTY2hlbWFzRW1wdHkpIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICh0cnVlKSB7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJGNsb3NpbmdCcmFjZXMuc2xpY2UoMCwgLTEpICsgXCIgXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvYW55T2YuanNcbnZhciByZXF1aXJlX2FueU9mID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfYW55T2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJHZhbGlkID0gXCJ2YWxpZFwiICsgJGx2bDtcbiAgICB2YXIgJGVycnMgPSBcImVycnNfX1wiICsgJGx2bDtcbiAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICB2YXIgJGNsb3NpbmdCcmFjZXMgPSBcIlwiO1xuICAgICRpdC5sZXZlbCsrO1xuICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgIHZhciAkbm9FbXB0eVNjaGVtYSA9ICRzY2hlbWEuZXZlcnkoZnVuY3Rpb24oJHNjaDIpIHtcbiAgICAgIHJldHVybiBpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gdHlwZW9mICRzY2gyID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJHNjaDIpLmxlbmd0aCA+IDAgfHwgJHNjaDIgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoMiwgaXQuUlVMRVMuYWxsKTtcbiAgICB9KTtcbiAgICBpZiAoJG5vRW1wdHlTY2hlbWEpIHtcbiAgICAgIHZhciAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQ7XG4gICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJGVycnMgKyBcIiA9IGVycm9yczsgdmFyIFwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTsgIFwiO1xuICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgIHZhciAkc2NoLCAkaSA9IC0xLCBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgXCJbXCIgKyAkaSArIFwiXVwiO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGggKyBcIi9cIiArICRpO1xuICAgICAgICAgIG91dCArPSBcIiAgXCIgKyBpdC52YWxpZGF0ZSgkaXQpICsgXCIgXCI7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gXCIgKyAkdmFsaWQgKyBcIiB8fCBcIiArICRuZXh0VmFsaWQgKyBcIjsgaWYgKCFcIiArICR2YWxpZCArIFwiKSB7IFwiO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgb3V0ICs9IFwiIFwiICsgJGNsb3NpbmdCcmFjZXMgKyBcIiBpZiAoIVwiICsgJHZhbGlkICsgXCIpIHsgICB2YXIgZXJyID0gICBcIjtcbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArIFwiYW55T2ZcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczoge30gXCI7XG4gICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdzaG91bGQgbWF0Y2ggc29tZSBzY2hlbWEgaW4gYW55T2YnIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IGVsc2UgeyAgZXJyb3JzID0gXCIgKyAkZXJycyArIFwiOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoXCIgKyAkZXJycyArIFwiKSB2RXJyb3JzLmxlbmd0aCA9IFwiICsgJGVycnMgKyBcIjsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLmFsbEVycm9ycykge1xuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICh0cnVlKSB7IFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2NvbW1lbnQuanNcbnZhciByZXF1aXJlX2NvbW1lbnQgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb21tZW50KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGNvbW1lbnQgPSBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpO1xuICAgIGlmIChpdC5vcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgICBvdXQgKz0gXCIgY29uc29sZS5sb2coXCIgKyAkY29tbWVudCArIFwiKTtcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdC5vcHRzLiRjb21tZW50ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb3V0ICs9IFwiIHNlbGYuX29wdHMuJGNvbW1lbnQoXCIgKyAkY29tbWVudCArIFwiLCBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIsIHZhbGlkYXRlLnJvb3Quc2NoZW1hKTtcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9jb25zdC5qc1xudmFyIHJlcXVpcmVfY29uc3QgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb25zdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkdmFsaWQgPSBcInZhbGlkXCIgKyAkbHZsO1xuICAgIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsICRzY2hlbWFWYWx1ZTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWUgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgICB9XG4gICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIHNjaGVtYVwiICsgJGx2bCArIFwiID0gdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiO1wiO1xuICAgIH1cbiAgICBvdXQgKz0gXCJ2YXIgXCIgKyAkdmFsaWQgKyBcIiA9IGVxdWFsKFwiICsgJGRhdGEgKyBcIiwgc2NoZW1hXCIgKyAkbHZsICsgXCIpOyBpZiAoIVwiICsgJHZhbGlkICsgXCIpIHsgICBcIjtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gXCJcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJjb25zdFwiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IGFsbG93ZWRWYWx1ZTogc2NoZW1hXCIgKyAkbHZsICsgXCIgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIGJlIGVxdWFsIHRvIGNvbnN0YW50JyBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCIgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwiIH1cIjtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9jb250YWlucy5qc1xudmFyIHJlcXVpcmVfY29udGFpbnMgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9jb250YWlucyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkdmFsaWQgPSBcInZhbGlkXCIgKyAkbHZsO1xuICAgIHZhciAkZXJycyA9IFwiZXJyc19fXCIgKyAkbHZsO1xuICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgIHZhciAkY2xvc2luZ0JyYWNlcyA9IFwiXCI7XG4gICAgJGl0LmxldmVsKys7XG4gICAgdmFyICRuZXh0VmFsaWQgPSBcInZhbGlkXCIgKyAkaXQubGV2ZWw7XG4gICAgdmFyICRpZHggPSBcImlcIiArICRsdmwsICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsICRuZXh0RGF0YSA9IFwiZGF0YVwiICsgJGRhdGFOeHQsICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkLCAkbm9uRW1wdHlTY2hlbWEgPSBpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gdHlwZW9mICRzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkc2NoZW1hKS5sZW5ndGggPiAwIHx8ICRzY2hlbWEgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpO1xuICAgIG91dCArPSBcInZhciBcIiArICRlcnJzICsgXCIgPSBlcnJvcnM7dmFyIFwiICsgJHZhbGlkICsgXCI7XCI7XG4gICAgaWYgKCRub25FbXB0eVNjaGVtYSkge1xuICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgICRpdC5zY2hlbWEgPSAkc2NoZW1hO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJG5leHRWYWxpZCArIFwiID0gZmFsc2U7IGZvciAodmFyIFwiICsgJGlkeCArIFwiID0gMDsgXCIgKyAkaWR4ICsgXCIgPCBcIiArICRkYXRhICsgXCIubGVuZ3RoOyBcIiArICRpZHggKyBcIisrKSB7IFwiO1xuICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaWR4LCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRpZHggKyBcIl1cIjtcbiAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgIG91dCArPSBcIiBcIiArIGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpICsgXCIgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJG5leHREYXRhICsgXCIgPSBcIiArICRwYXNzRGF0YSArIFwiOyBcIiArICRjb2RlICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiKSBicmVhazsgfSAgXCI7XG4gICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgb3V0ICs9IFwiIFwiICsgJGNsb3NpbmdCcmFjZXMgKyBcIiBpZiAoIVwiICsgJG5leHRWYWxpZCArIFwiKSB7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkZGF0YSArIFwiLmxlbmd0aCA9PSAwKSB7XCI7XG4gICAgfVxuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSBcIlwiO1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcImNvbnRhaW5zXCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHt9IFwiO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdzaG91bGQgY29udGFpbiBhIHZhbGlkIGl0ZW0nIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCIgfSBlbHNlIHsgXCI7XG4gICAgaWYgKCRub25FbXB0eVNjaGVtYSkge1xuICAgICAgb3V0ICs9IFwiICBlcnJvcnMgPSBcIiArICRlcnJzICsgXCI7IGlmICh2RXJyb3JzICE9PSBudWxsKSB7IGlmIChcIiArICRlcnJzICsgXCIpIHZFcnJvcnMubGVuZ3RoID0gXCIgKyAkZXJycyArIFwiOyBlbHNlIHZFcnJvcnMgPSBudWxsOyB9IFwiO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2RlcGVuZGVuY2llcy5qc1xudmFyIHJlcXVpcmVfZGVwZW5kZW5jaWVzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZGVwZW5kZW5jaWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICRlcnJzID0gXCJlcnJzX19cIiArICRsdmw7XG4gICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICAgdmFyICRjbG9zaW5nQnJhY2VzID0gXCJcIjtcbiAgICAkaXQubGV2ZWwrKztcbiAgICB2YXIgJG5leHRWYWxpZCA9IFwidmFsaWRcIiArICRpdC5sZXZlbDtcbiAgICB2YXIgJHNjaGVtYURlcHMgPSB7fSwgJHByb3BlcnR5RGVwcyA9IHt9LCAkb3duUHJvcGVydGllcyA9IGl0Lm9wdHMub3duUHJvcGVydGllcztcbiAgICBmb3IgKCRwcm9wZXJ0eSBpbiAkc2NoZW1hKSB7XG4gICAgICBpZiAoJHByb3BlcnR5ID09IFwiX19wcm90b19fXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyICRzY2ggPSAkc2NoZW1hWyRwcm9wZXJ0eV07XG4gICAgICB2YXIgJGRlcHMgPSBBcnJheS5pc0FycmF5KCRzY2gpID8gJHByb3BlcnR5RGVwcyA6ICRzY2hlbWFEZXBzO1xuICAgICAgJGRlcHNbJHByb3BlcnR5XSA9ICRzY2g7XG4gICAgfVxuICAgIG91dCArPSBcInZhciBcIiArICRlcnJzICsgXCIgPSBlcnJvcnM7XCI7XG4gICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoO1xuICAgIG91dCArPSBcInZhciBtaXNzaW5nXCIgKyAkbHZsICsgXCI7XCI7XG4gICAgZm9yICh2YXIgJHByb3BlcnR5IGluICRwcm9wZXJ0eURlcHMpIHtcbiAgICAgICRkZXBzID0gJHByb3BlcnR5RGVwc1skcHJvcGVydHldO1xuICAgICAgaWYgKCRkZXBzLmxlbmd0aCkge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKCBcIiArICRkYXRhICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHkpICsgXCIgIT09IHVuZGVmaW5lZCBcIjtcbiAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkgKyBcIicpIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICYmICggXCI7XG4gICAgICAgICAgdmFyIGFycjEgPSAkZGVwcztcbiAgICAgICAgICBpZiAoYXJyMSkge1xuICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgJGkgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIxWyRpICs9IDFdO1xuICAgICAgICAgICAgICBpZiAoJGkpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfHwgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLCAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICAgIG91dCArPSBcIiAoICggXCIgKyAkdXNlRGF0YSArIFwiID09PSB1bmRlZmluZWQgXCI7XG4gICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkgKyBcIicpIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIikgJiYgKG1pc3NpbmdcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eUtleSA6ICRwcm9wKSArIFwiKSApIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIpKSB7ICBcIjtcbiAgICAgICAgICB2YXIgJHByb3BlcnR5UGF0aCA9IFwibWlzc2luZ1wiICsgJGx2bCwgJG1pc3NpbmdQcm9wZXJ0eSA9IFwiJyArIFwiICsgJHByb3BlcnR5UGF0aCArIFwiICsgJ1wiO1xuICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0Lm9wdHMuanNvblBvaW50ZXJzID8gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgdHJ1ZSkgOiAkY3VycmVudEVycm9yUGF0aCArIFwiICsgXCIgKyAkcHJvcGVydHlQYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJkZXBlbmRlbmNpZXNcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBwcm9wZXJ0eTogJ1wiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSArIFwiJywgbWlzc2luZ1Byb3BlcnR5OiAnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCInLCBkZXBzQ291bnQ6IFwiICsgJGRlcHMubGVuZ3RoICsgXCIsIGRlcHM6ICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmxlbmd0aCA9PSAxID8gJGRlcHNbMF0gOiAkZGVwcy5qb2luKFwiLCBcIikpICsgXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBoYXZlIFwiO1xuICAgICAgICAgICAgICBpZiAoJGRlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCJwcm9wZXJ0eSBcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzWzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCJwcm9wZXJ0aWVzIFwiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCIgd2hlbiBwcm9wZXJ0eSBcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eSkgKyBcIiBpcyBwcmVzZW50JyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCIgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiICkgeyBcIjtcbiAgICAgICAgICB2YXIgYXJyMiA9ICRkZXBzO1xuICAgICAgICAgIGlmIChhcnIyKSB7XG4gICAgICAgICAgICB2YXIgJHByb3BlcnR5S2V5LCBpMiA9IC0xLCBsMiA9IGFycjIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHdoaWxlIChpMiA8IGwyKSB7XG4gICAgICAgICAgICAgICRwcm9wZXJ0eUtleSA9IGFycjJbaTIgKz0gMV07XG4gICAgICAgICAgICAgIHZhciAkcHJvcCA9IGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5S2V5KSwgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSksICR1c2VEYXRhID0gJGRhdGEgKyAkcHJvcDtcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aCgkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5S2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9IFwiIGlmICggXCIgKyAkdXNlRGF0YSArIFwiID09PSB1bmRlZmluZWQgXCI7XG4gICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkgKyBcIicpIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIikgeyAgdmFyIGVyciA9ICAgXCI7XG4gICAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJkZXBlbmRlbmNpZXNcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBwcm9wZXJ0eTogJ1wiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSArIFwiJywgbWlzc2luZ1Byb3BlcnR5OiAnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCInLCBkZXBzQ291bnQ6IFwiICsgJGRlcHMubGVuZ3RoICsgXCIsIGRlcHM6ICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRkZXBzLmxlbmd0aCA9PSAxID8gJGRlcHNbMF0gOiAkZGVwcy5qb2luKFwiLCBcIikpICsgXCInIH0gXCI7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIGhhdmUgXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoJGRlcHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwicHJvcGVydHkgXCIgKyBpdC51dGlsLmVzY2FwZVF1b3RlcygkZGVwc1swXSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJwcm9wZXJ0aWVzIFwiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJGRlcHMuam9pbihcIiwgXCIpKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB3aGVuIHByb3BlcnR5IFwiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSArIFwiIGlzIHByZXNlbnQnIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gICBcIjtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSBcIn1cIjtcbiAgICAgICAgICBvdXQgKz0gXCIgZWxzZSB7IFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgIHZhciAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQ7XG4gICAgZm9yICh2YXIgJHByb3BlcnR5IGluICRzY2hlbWFEZXBzKSB7XG4gICAgICB2YXIgJHNjaCA9ICRzY2hlbWFEZXBzWyRwcm9wZXJ0eV07XG4gICAgICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkc2NoID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyAkbmV4dFZhbGlkICsgXCIgPSB0cnVlOyBpZiAoIFwiICsgJGRhdGEgKyBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eSkgKyBcIiAhPT0gdW5kZWZpbmVkIFwiO1xuICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFwiICsgJGRhdGEgKyBcIiwgJ1wiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5KSArIFwiJykgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiKSB7IFwiO1xuICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHByb3BlcnR5KTtcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgaXQudXRpbC5lc2NhcGVGcmFnbWVudCgkcHJvcGVydHkpO1xuICAgICAgICBvdXQgKz0gXCIgIFwiICsgaXQudmFsaWRhdGUoJGl0KSArIFwiIFwiO1xuICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgIG91dCArPSBcIiB9ICBcIjtcbiAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiKSB7IFwiO1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9IFwifVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gXCIgICBcIiArICRjbG9zaW5nQnJhY2VzICsgXCIgaWYgKFwiICsgJGVycnMgKyBcIiA9PSBlcnJvcnMpIHtcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9lbnVtLmpzXG52YXIgcmVxdWlyZV9lbnVtID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZW51bShpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkdmFsaWQgPSBcInZhbGlkXCIgKyAkbHZsO1xuICAgIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsICRzY2hlbWFWYWx1ZTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWUgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgICB9XG4gICAgdmFyICRpID0gXCJpXCIgKyAkbHZsLCAkdlNjaGVtYSA9IFwic2NoZW1hXCIgKyAkbHZsO1xuICAgIGlmICghJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBcIiArICR2U2NoZW1hICsgXCIgPSB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCI7XCI7XG4gICAgfVxuICAgIG91dCArPSBcInZhciBcIiArICR2YWxpZCArIFwiO1wiO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgaWYgKHNjaGVtYVwiICsgJGx2bCArIFwiID09PSB1bmRlZmluZWQpIFwiICsgJHZhbGlkICsgXCIgPSB0cnVlOyBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFcIiArICRsdmwgKyBcIikpIFwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTsgZWxzZSB7XCI7XG4gICAgfVxuICAgIG91dCArPSBcIlwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTtmb3IgKHZhciBcIiArICRpICsgXCI9MDsgXCIgKyAkaSArIFwiPFwiICsgJHZTY2hlbWEgKyBcIi5sZW5ndGg7IFwiICsgJGkgKyBcIisrKSBpZiAoZXF1YWwoXCIgKyAkZGF0YSArIFwiLCBcIiArICR2U2NoZW1hICsgXCJbXCIgKyAkaSArIFwiXSkpIHsgXCIgKyAkdmFsaWQgKyBcIiA9IHRydWU7IGJyZWFrOyB9XCI7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiAgfSAgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIiBpZiAoIVwiICsgJHZhbGlkICsgXCIpIHsgICBcIjtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gXCJcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJlbnVtXCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgYWxsb3dlZFZhbHVlczogc2NoZW1hXCIgKyAkbHZsICsgXCIgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXMnIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCIgfVwiO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gXCIgZWxzZSB7IFwiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2Zvcm1hdC5qc1xudmFyIHJlcXVpcmVfZm9ybWF0ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfZm9ybWF0KGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgaWYgKGl0Lm9wdHMuZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICh0cnVlKSB7IFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSwgJHNjaGVtYVZhbHVlO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIHNjaGVtYVwiICsgJGx2bCArIFwiID0gXCIgKyBpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSArIFwiOyBcIjtcbiAgICAgICRzY2hlbWFWYWx1ZSA9IFwic2NoZW1hXCIgKyAkbHZsO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICAgIH1cbiAgICB2YXIgJHVua25vd25Gb3JtYXRzID0gaXQub3B0cy51bmtub3duRm9ybWF0cywgJGFsbG93VW5rbm93biA9IEFycmF5LmlzQXJyYXkoJHVua25vd25Gb3JtYXRzKTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgdmFyICRmb3JtYXQgPSBcImZvcm1hdFwiICsgJGx2bCwgJGlzT2JqZWN0ID0gXCJpc09iamVjdFwiICsgJGx2bCwgJGZvcm1hdFR5cGUgPSBcImZvcm1hdFR5cGVcIiArICRsdmw7XG4gICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJGZvcm1hdCArIFwiID0gZm9ybWF0c1tcIiArICRzY2hlbWFWYWx1ZSArIFwiXTsgdmFyIFwiICsgJGlzT2JqZWN0ICsgXCIgPSB0eXBlb2YgXCIgKyAkZm9ybWF0ICsgXCIgPT0gJ29iamVjdCcgJiYgIShcIiArICRmb3JtYXQgKyBcIiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgXCIgKyAkZm9ybWF0ICsgXCIudmFsaWRhdGU7IHZhciBcIiArICRmb3JtYXRUeXBlICsgXCIgPSBcIiArICRpc09iamVjdCArIFwiICYmIFwiICsgJGZvcm1hdCArIFwiLnR5cGUgfHwgJ3N0cmluZyc7IGlmIChcIiArICRpc09iamVjdCArIFwiKSB7IFwiO1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSBcIiB2YXIgYXN5bmNcIiArICRsdmwgKyBcIiA9IFwiICsgJGZvcm1hdCArIFwiLmFzeW5jOyBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiBcIiArICRmb3JtYXQgKyBcIiA9IFwiICsgJGZvcm1hdCArIFwiLnZhbGlkYXRlOyB9IGlmICggIFwiO1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9IFwiIChcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT0gJ3N0cmluZycpIHx8IFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIChcIjtcbiAgICAgIGlmICgkdW5rbm93bkZvcm1hdHMgIT0gXCJpZ25vcmVcIikge1xuICAgICAgICBvdXQgKz0gXCIgKFwiICsgJHNjaGVtYVZhbHVlICsgXCIgJiYgIVwiICsgJGZvcm1hdCArIFwiIFwiO1xuICAgICAgICBpZiAoJGFsbG93VW5rbm93bikge1xuICAgICAgICAgIG91dCArPSBcIiAmJiBzZWxmLl9vcHRzLnVua25vd25Gb3JtYXRzLmluZGV4T2YoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIikgPT0gLTEgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiKSB8fCBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiAoXCIgKyAkZm9ybWF0ICsgXCIgJiYgXCIgKyAkZm9ybWF0VHlwZSArIFwiID09ICdcIiArICRydWxlVHlwZSArIFwiJyAmJiAhKHR5cGVvZiBcIiArICRmb3JtYXQgKyBcIiA9PSAnZnVuY3Rpb24nID8gXCI7XG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9IFwiIChhc3luY1wiICsgJGx2bCArIFwiID8gYXdhaXQgXCIgKyAkZm9ybWF0ICsgXCIoXCIgKyAkZGF0YSArIFwiKSA6IFwiICsgJGZvcm1hdCArIFwiKFwiICsgJGRhdGEgKyBcIikpIFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJGZvcm1hdCArIFwiKFwiICsgJGRhdGEgKyBcIikgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgOiBcIiArICRmb3JtYXQgKyBcIi50ZXN0KFwiICsgJGRhdGEgKyBcIikpKSkpIHtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICRmb3JtYXQgPSBpdC5mb3JtYXRzWyRzY2hlbWFdO1xuICAgICAgaWYgKCEkZm9ybWF0KSB7XG4gICAgICAgIGlmICgkdW5rbm93bkZvcm1hdHMgPT0gXCJpZ25vcmVcIikge1xuICAgICAgICAgIGl0LmxvZ2dlci53YXJuKCd1bmtub3duIGZvcm1hdCBcIicgKyAkc2NoZW1hICsgJ1wiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCInICsgaXQuZXJyU2NoZW1hUGF0aCArICdcIicpO1xuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgaWYgKHRydWUpIHsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoJGFsbG93VW5rbm93biAmJiAkdW5rbm93bkZvcm1hdHMuaW5kZXhPZigkc2NoZW1hKSA+PSAwKSB7XG4gICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiBpZiAodHJ1ZSkgeyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gZm9ybWF0IFwiJyArICRzY2hlbWEgKyAnXCIgaXMgdXNlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIicgKyBpdC5lcnJTY2hlbWFQYXRoICsgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciAkaXNPYmplY3QgPSB0eXBlb2YgJGZvcm1hdCA9PSBcIm9iamVjdFwiICYmICEoJGZvcm1hdCBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgJGZvcm1hdC52YWxpZGF0ZTtcbiAgICAgIHZhciAkZm9ybWF0VHlwZSA9ICRpc09iamVjdCAmJiAkZm9ybWF0LnR5cGUgfHwgXCJzdHJpbmdcIjtcbiAgICAgIGlmICgkaXNPYmplY3QpIHtcbiAgICAgICAgdmFyICRhc3luYyA9ICRmb3JtYXQuYXN5bmMgPT09IHRydWU7XG4gICAgICAgICRmb3JtYXQgPSAkZm9ybWF0LnZhbGlkYXRlO1xuICAgICAgfVxuICAgICAgaWYgKCRmb3JtYXRUeXBlICE9ICRydWxlVHlwZSkge1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBpZiAodHJ1ZSkgeyBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgaWYgKCRhc3luYykge1xuICAgICAgICBpZiAoIWl0LmFzeW5jKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICAgICAgdmFyICRmb3JtYXRSZWYgPSBcImZvcm1hdHNcIiArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHNjaGVtYSkgKyBcIi52YWxpZGF0ZVwiO1xuICAgICAgICBvdXQgKz0gXCIgaWYgKCEoYXdhaXQgXCIgKyAkZm9ybWF0UmVmICsgXCIoXCIgKyAkZGF0YSArIFwiKSkpIHsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKCEgXCI7XG4gICAgICAgIHZhciAkZm9ybWF0UmVmID0gXCJmb3JtYXRzXCIgKyBpdC51dGlsLmdldFByb3BlcnR5KCRzY2hlbWEpO1xuICAgICAgICBpZiAoJGlzT2JqZWN0KVxuICAgICAgICAgICRmb3JtYXRSZWYgKz0gXCIudmFsaWRhdGVcIjtcbiAgICAgICAgaWYgKHR5cGVvZiAkZm9ybWF0ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICRmb3JtYXRSZWYgKyBcIihcIiArICRkYXRhICsgXCIpIFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICRmb3JtYXRSZWYgKyBcIi50ZXN0KFwiICsgJGRhdGEgKyBcIikgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiKSB7IFwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gXCJcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJmb3JtYXRcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBmb3JtYXQ6ICBcIjtcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSBcIlwiICsgJHNjaGVtYVZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRzY2hlbWEpO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiICB9IFwiO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBgICwgbWVzc2FnZTogJ3Nob3VsZCBtYXRjaCBmb3JtYXQgXCJgO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSBcIicgKyBcIiArICRzY2hlbWFWYWx1ZSArIFwiICsgJ1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IGBcIicgYDtcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiAgXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwidmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSBcIiBlbHNlIHsgXCI7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaWYuanNcbnZhciByZXF1aXJlX2lmID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfaWYoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJHZhbGlkID0gXCJ2YWxpZFwiICsgJGx2bDtcbiAgICB2YXIgJGVycnMgPSBcImVycnNfX1wiICsgJGx2bDtcbiAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICAkaXQubGV2ZWwrKztcbiAgICB2YXIgJG5leHRWYWxpZCA9IFwidmFsaWRcIiArICRpdC5sZXZlbDtcbiAgICB2YXIgJHRoZW5TY2ggPSBpdC5zY2hlbWFbXCJ0aGVuXCJdLCAkZWxzZVNjaCA9IGl0LnNjaGVtYVtcImVsc2VcIl0sICR0aGVuUHJlc2VudCA9ICR0aGVuU2NoICE9PSB1bmRlZmluZWQgJiYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyB0eXBlb2YgJHRoZW5TY2ggPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkdGhlblNjaCkubGVuZ3RoID4gMCB8fCAkdGhlblNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCR0aGVuU2NoLCBpdC5SVUxFUy5hbGwpKSwgJGVsc2VQcmVzZW50ID0gJGVsc2VTY2ggIT09IHVuZGVmaW5lZCAmJiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkZWxzZVNjaCA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKCRlbHNlU2NoKS5sZW5ndGggPiAwIHx8ICRlbHNlU2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJGVsc2VTY2gsIGl0LlJVTEVTLmFsbCkpLCAkY3VycmVudEJhc2VJZCA9ICRpdC5iYXNlSWQ7XG4gICAgaWYgKCR0aGVuUHJlc2VudCB8fCAkZWxzZVByZXNlbnQpIHtcbiAgICAgIHZhciAkaWZDbGF1c2U7XG4gICAgICAkaXQuY3JlYXRlRXJyb3JzID0gZmFsc2U7XG4gICAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGg7XG4gICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRlcnJzICsgXCIgPSBlcnJvcnM7IHZhciBcIiArICR2YWxpZCArIFwiID0gdHJ1ZTsgIFwiO1xuICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgIG91dCArPSBcIiAgXCIgKyBpdC52YWxpZGF0ZSgkaXQpICsgXCIgXCI7XG4gICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAkaXQuY3JlYXRlRXJyb3JzID0gdHJ1ZTtcbiAgICAgIG91dCArPSBcIiAgZXJyb3JzID0gXCIgKyAkZXJycyArIFwiOyBpZiAodkVycm9ycyAhPT0gbnVsbCkgeyBpZiAoXCIgKyAkZXJycyArIFwiKSB2RXJyb3JzLmxlbmd0aCA9IFwiICsgJGVycnMgKyBcIjsgZWxzZSB2RXJyb3JzID0gbnVsbDsgfSAgXCI7XG4gICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgaWYgKCR0aGVuUHJlc2VudCkge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiKSB7ICBcIjtcbiAgICAgICAgJGl0LnNjaGVtYSA9IGl0LnNjaGVtYVtcInRoZW5cIl07XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIFwiLnRoZW5cIjtcbiAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvdGhlblwiO1xuICAgICAgICBvdXQgKz0gXCIgIFwiICsgaXQudmFsaWRhdGUoJGl0KSArIFwiIFwiO1xuICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gXCIgKyAkbmV4dFZhbGlkICsgXCI7IFwiO1xuICAgICAgICBpZiAoJHRoZW5QcmVzZW50ICYmICRlbHNlUHJlc2VudCkge1xuICAgICAgICAgICRpZkNsYXVzZSA9IFwiaWZDbGF1c2VcIiArICRsdmw7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRpZkNsYXVzZSArIFwiID0gJ3RoZW4nOyBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaWZDbGF1c2UgPSBcIid0aGVuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICBpZiAoJGVsc2VQcmVzZW50KSB7XG4gICAgICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICghXCIgKyAkbmV4dFZhbGlkICsgXCIpIHsgXCI7XG4gICAgICB9XG4gICAgICBpZiAoJGVsc2VQcmVzZW50KSB7XG4gICAgICAgICRpdC5zY2hlbWEgPSBpdC5zY2hlbWFbXCJlbHNlXCJdO1xuICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBcIi5lbHNlXCI7XG4gICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL2Vsc2VcIjtcbiAgICAgICAgb3V0ICs9IFwiICBcIiArIGl0LnZhbGlkYXRlKCRpdCkgKyBcIiBcIjtcbiAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyAkdmFsaWQgKyBcIiA9IFwiICsgJG5leHRWYWxpZCArIFwiOyBcIjtcbiAgICAgICAgaWYgKCR0aGVuUHJlc2VudCAmJiAkZWxzZVByZXNlbnQpIHtcbiAgICAgICAgICAkaWZDbGF1c2UgPSBcImlmQ2xhdXNlXCIgKyAkbHZsO1xuICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkaWZDbGF1c2UgKyBcIiA9ICdlbHNlJzsgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGlmQ2xhdXNlID0gXCInZWxzZSdcIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiBpZiAoIVwiICsgJHZhbGlkICsgXCIpIHsgICB2YXIgZXJyID0gICBcIjtcbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArIFwiaWZcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBmYWlsaW5nS2V5d29yZDogXCIgKyAkaWZDbGF1c2UgKyBcIiB9IFwiO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gYCAsIG1lc3NhZ2U6ICdzaG91bGQgbWF0Y2ggXCInICsgYCArICRpZkNsYXVzZSArIGAgKyAnXCIgc2NoZW1hJyBgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9ICAgXCI7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgZWxzZSB7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKHRydWUpIHsgXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvaXRlbXMuanNcbnZhciByZXF1aXJlX2l0ZW1zID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfaXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJHZhbGlkID0gXCJ2YWxpZFwiICsgJGx2bDtcbiAgICB2YXIgJGVycnMgPSBcImVycnNfX1wiICsgJGx2bDtcbiAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICB2YXIgJGNsb3NpbmdCcmFjZXMgPSBcIlwiO1xuICAgICRpdC5sZXZlbCsrO1xuICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgIHZhciAkaWR4ID0gXCJpXCIgKyAkbHZsLCAkZGF0YU54dCA9ICRpdC5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxLCAkbmV4dERhdGEgPSBcImRhdGFcIiArICRkYXRhTnh0LCAkY3VycmVudEJhc2VJZCA9IGl0LmJhc2VJZDtcbiAgICBvdXQgKz0gXCJ2YXIgXCIgKyAkZXJycyArIFwiID0gZXJyb3JzO3ZhciBcIiArICR2YWxpZCArIFwiO1wiO1xuICAgIGlmIChBcnJheS5pc0FycmF5KCRzY2hlbWEpKSB7XG4gICAgICB2YXIgJGFkZGl0aW9uYWxJdGVtcyA9IGl0LnNjaGVtYS5hZGRpdGlvbmFsSXRlbXM7XG4gICAgICBpZiAoJGFkZGl0aW9uYWxJdGVtcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJHZhbGlkICsgXCIgPSBcIiArICRkYXRhICsgXCIubGVuZ3RoIDw9IFwiICsgJHNjaGVtYS5sZW5ndGggKyBcIjsgXCI7XG4gICAgICAgIHZhciAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvYWRkaXRpb25hbEl0ZW1zXCI7XG4gICAgICAgIG91dCArPSBcIiAgaWYgKCFcIiArICR2YWxpZCArIFwiKSB7ICAgXCI7XG4gICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgIG91dCA9IFwiXCI7XG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJhZGRpdGlvbmFsSXRlbXNcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBsaW1pdDogXCIgKyAkc2NoZW1hLmxlbmd0aCArIFwiIH0gXCI7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIE5PVCBoYXZlIG1vcmUgdGhhbiBcIiArICRzY2hlbWEubGVuZ3RoICsgXCIgaXRlbXMnIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IGZhbHNlICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgICRlcnJTY2hlbWFQYXRoID0gJGN1cnJFcnJTY2hlbWFQYXRoO1xuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICRjbG9zaW5nQnJhY2VzICs9IFwifVwiO1xuICAgICAgICAgIG91dCArPSBcIiBlbHNlIHsgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBhcnIxID0gJHNjaGVtYTtcbiAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgIHZhciAkc2NoLCAkaSA9IC0xLCBsMSA9IGFycjEubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKCRpIDwgbDEpIHtcbiAgICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkc2NoID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgJG5leHRWYWxpZCArIFwiID0gdHJ1ZTsgaWYgKFwiICsgJGRhdGEgKyBcIi5sZW5ndGggPiBcIiArICRpICsgXCIpIHsgXCI7XG4gICAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRpICsgXCJdXCI7XG4gICAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGggKyBcIltcIiArICRpICsgXCJdXCI7XG4gICAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAkaTtcbiAgICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGksIGl0Lm9wdHMuanNvblBvaW50ZXJzLCB0cnVlKTtcbiAgICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaTtcbiAgICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSArIFwiIFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRuZXh0RGF0YSArIFwiID0gXCIgKyAkcGFzc0RhdGEgKyBcIjsgXCIgKyAkY29kZSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IFwiIH0gIFwiO1xuICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRuZXh0VmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mICRhZGRpdGlvbmFsSXRlbXMgPT0gXCJvYmplY3RcIiAmJiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkYWRkaXRpb25hbEl0ZW1zID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJGFkZGl0aW9uYWxJdGVtcykubGVuZ3RoID4gMCB8fCAkYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJGFkZGl0aW9uYWxJdGVtcywgaXQuUlVMRVMuYWxsKSkpIHtcbiAgICAgICAgJGl0LnNjaGVtYSA9ICRhZGRpdGlvbmFsSXRlbXM7XG4gICAgICAgICRpdC5zY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIFwiLmFkZGl0aW9uYWxJdGVtc1wiO1xuICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9hZGRpdGlvbmFsSXRlbXNcIjtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJG5leHRWYWxpZCArIFwiID0gdHJ1ZTsgaWYgKFwiICsgJGRhdGEgKyBcIi5sZW5ndGggPiBcIiArICRzY2hlbWEubGVuZ3RoICsgXCIpIHsgIGZvciAodmFyIFwiICsgJGlkeCArIFwiID0gXCIgKyAkc2NoZW1hLmxlbmd0aCArIFwiOyBcIiArICRpZHggKyBcIiA8IFwiICsgJGRhdGEgKyBcIi5sZW5ndGg7IFwiICsgJGlkeCArIFwiKyspIHsgXCI7XG4gICAgICAgICRpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGlkeCwgaXQub3B0cy5qc29uUG9pbnRlcnMsIHRydWUpO1xuICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRpZHggKyBcIl1cIjtcbiAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRpZHg7XG4gICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSArIFwiIFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkbmV4dERhdGEgKyBcIiA9IFwiICsgJHBhc3NEYXRhICsgXCI7IFwiICsgJGNvZGUgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgIG91dCArPSBcIiBpZiAoIVwiICsgJG5leHRWYWxpZCArIFwiKSBicmVhazsgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gfSAgXCI7XG4gICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRuZXh0VmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkc2NoZW1hID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJHNjaGVtYSkubGVuZ3RoID4gMCB8fCAkc2NoZW1hID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaGVtYSwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgJGl0LnNjaGVtYSA9ICRzY2hlbWE7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoO1xuICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aDtcbiAgICAgIG91dCArPSBcIiAgZm9yICh2YXIgXCIgKyAkaWR4ICsgXCIgPSBcIiArIDAgKyBcIjsgXCIgKyAkaWR4ICsgXCIgPCBcIiArICRkYXRhICsgXCIubGVuZ3RoOyBcIiArICRpZHggKyBcIisrKSB7IFwiO1xuICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAkaWR4LCBpdC5vcHRzLmpzb25Qb2ludGVycywgdHJ1ZSk7XG4gICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRpZHggKyBcIl1cIjtcbiAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAkaWR4O1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgIG91dCArPSBcIiBcIiArIGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpICsgXCIgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJG5leHREYXRhICsgXCIgPSBcIiArICRwYXNzRGF0YSArIFwiOyBcIiArICRjb2RlICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKCFcIiArICRuZXh0VmFsaWQgKyBcIikgYnJlYWs7IFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH1cIjtcbiAgICB9XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSBcIiBcIiArICRjbG9zaW5nQnJhY2VzICsgXCIgaWYgKFwiICsgJGVycnMgKyBcIiA9PSBlcnJvcnMpIHtcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXQuanNcbnZhciByZXF1aXJlX19saW1pdCA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX19saW1pdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsICRzY2hlbWFWYWx1ZTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWUgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgICB9XG4gICAgdmFyICRpc01heCA9ICRrZXl3b3JkID09IFwibWF4aW11bVwiLCAkZXhjbHVzaXZlS2V5d29yZCA9ICRpc01heCA/IFwiZXhjbHVzaXZlTWF4aW11bVwiIDogXCJleGNsdXNpdmVNaW5pbXVtXCIsICRzY2hlbWFFeGNsID0gaXQuc2NoZW1hWyRleGNsdXNpdmVLZXl3b3JkXSwgJGlzRGF0YUV4Y2wgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWFFeGNsICYmICRzY2hlbWFFeGNsLiRkYXRhLCAkb3AgPSAkaXNNYXggPyBcIjxcIiA6IFwiPlwiLCAkbm90T3AgPSAkaXNNYXggPyBcIj5cIiA6IFwiPFwiLCAkZXJyb3JLZXl3b3JkID0gdW5kZWZpbmVkO1xuICAgIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCAkc2NoZW1hID09PSB1bmRlZmluZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJGtleXdvcmQgKyBcIiBtdXN0IGJlIG51bWJlclwiKTtcbiAgICB9XG4gICAgaWYgKCEoJGlzRGF0YUV4Y2wgfHwgJHNjaGVtYUV4Y2wgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgJHNjaGVtYUV4Y2wgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgJHNjaGVtYUV4Y2wgPT0gXCJib29sZWFuXCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJGV4Y2x1c2l2ZUtleXdvcmQgKyBcIiBtdXN0IGJlIG51bWJlciBvciBib29sZWFuXCIpO1xuICAgIH1cbiAgICBpZiAoJGlzRGF0YUV4Y2wpIHtcbiAgICAgIHZhciAkc2NoZW1hVmFsdWVFeGNsID0gaXQudXRpbC5nZXREYXRhKCRzY2hlbWFFeGNsLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpLCAkZXhjbHVzaXZlID0gXCJleGNsdXNpdmVcIiArICRsdmwsICRleGNsVHlwZSA9IFwiZXhjbFR5cGVcIiArICRsdmwsICRleGNsSXNOdW1iZXIgPSBcImV4Y2xJc051bWJlclwiICsgJGx2bCwgJG9wRXhwciA9IFwib3BcIiArICRsdmwsICRvcFN0ciA9IFwiJyArIFwiICsgJG9wRXhwciArIFwiICsgJ1wiO1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFFeGNsXCIgKyAkbHZsICsgXCIgPSBcIiArICRzY2hlbWFWYWx1ZUV4Y2wgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWVFeGNsID0gXCJzY2hlbWFFeGNsXCIgKyAkbHZsO1xuICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRleGNsdXNpdmUgKyBcIjsgdmFyIFwiICsgJGV4Y2xUeXBlICsgXCIgPSB0eXBlb2YgXCIgKyAkc2NoZW1hVmFsdWVFeGNsICsgXCI7IGlmIChcIiArICRleGNsVHlwZSArIFwiICE9ICdib29sZWFuJyAmJiBcIiArICRleGNsVHlwZSArIFwiICE9ICd1bmRlZmluZWQnICYmIFwiICsgJGV4Y2xUeXBlICsgXCIgIT0gJ251bWJlcicpIHsgXCI7XG4gICAgICB2YXIgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSBcIlwiO1xuICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJfZXhjbHVzaXZlTGltaXRcIikgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHt9IFwiO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnXCIgKyAkZXhjbHVzaXZlS2V5d29yZCArIFwiIHNob3VsZCBiZSBib29sZWFuJyBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCIgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgfVxuICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IGVsc2UgaWYgKCBcIjtcbiAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgIG91dCArPSBcIiAoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9ICdudW1iZXInKSB8fCBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiBcIiArICRleGNsVHlwZSArIFwiID09ICdudW1iZXInID8gKCAoXCIgKyAkZXhjbHVzaXZlICsgXCIgPSBcIiArICRzY2hlbWFWYWx1ZSArIFwiID09PSB1bmRlZmluZWQgfHwgXCIgKyAkc2NoZW1hVmFsdWVFeGNsICsgXCIgXCIgKyAkb3AgKyBcIj0gXCIgKyAkc2NoZW1hVmFsdWUgKyBcIikgPyBcIiArICRkYXRhICsgXCIgXCIgKyAkbm90T3AgKyBcIj0gXCIgKyAkc2NoZW1hVmFsdWVFeGNsICsgXCIgOiBcIiArICRkYXRhICsgXCIgXCIgKyAkbm90T3AgKyBcIiBcIiArICRzY2hlbWFWYWx1ZSArIFwiICkgOiAoIChcIiArICRleGNsdXNpdmUgKyBcIiA9IFwiICsgJHNjaGVtYVZhbHVlRXhjbCArIFwiID09PSB0cnVlKSA/IFwiICsgJGRhdGEgKyBcIiBcIiArICRub3RPcCArIFwiPSBcIiArICRzY2hlbWFWYWx1ZSArIFwiIDogXCIgKyAkZGF0YSArIFwiIFwiICsgJG5vdE9wICsgXCIgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiApIHx8IFwiICsgJGRhdGEgKyBcIiAhPT0gXCIgKyAkZGF0YSArIFwiKSB7IHZhciBvcFwiICsgJGx2bCArIFwiID0gXCIgKyAkZXhjbHVzaXZlICsgXCIgPyAnXCIgKyAkb3AgKyBcIicgOiAnXCIgKyAkb3AgKyBcIj0nOyBcIjtcbiAgICAgIGlmICgkc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hVmFsdWVFeGNsO1xuICAgICAgICAkaXNEYXRhID0gJGlzRGF0YUV4Y2w7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciAkZXhjbElzTnVtYmVyID0gdHlwZW9mICRzY2hlbWFFeGNsID09IFwibnVtYmVyXCIsICRvcFN0ciA9ICRvcDtcbiAgICAgIGlmICgkZXhjbElzTnVtYmVyICYmICRpc0RhdGEpIHtcbiAgICAgICAgdmFyICRvcEV4cHIgPSBcIidcIiArICRvcFN0ciArIFwiJ1wiO1xuICAgICAgICBvdXQgKz0gXCIgaWYgKCBcIjtcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgKFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPSAnbnVtYmVyJykgfHwgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiICggXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiA9PT0gdW5kZWZpbmVkIHx8IFwiICsgJHNjaGVtYUV4Y2wgKyBcIiBcIiArICRvcCArIFwiPSBcIiArICRzY2hlbWFWYWx1ZSArIFwiID8gXCIgKyAkZGF0YSArIFwiIFwiICsgJG5vdE9wICsgXCI9IFwiICsgJHNjaGVtYUV4Y2wgKyBcIiA6IFwiICsgJGRhdGEgKyBcIiBcIiArICRub3RPcCArIFwiIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgKSB8fCBcIiArICRkYXRhICsgXCIgIT09IFwiICsgJGRhdGEgKyBcIikgeyBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgkZXhjbElzTnVtYmVyICYmICRzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRleGNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICRlcnJvcktleXdvcmQgPSAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWFFeGNsO1xuICAgICAgICAgICRub3RPcCArPSBcIj1cIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoJGV4Y2xJc051bWJlcilcbiAgICAgICAgICAgICRzY2hlbWFWYWx1ZSA9IE1hdGhbJGlzTWF4ID8gXCJtaW5cIiA6IFwibWF4XCJdKCRzY2hlbWFFeGNsLCAkc2NoZW1hKTtcbiAgICAgICAgICBpZiAoJHNjaGVtYUV4Y2wgPT09ICgkZXhjbElzTnVtYmVyID8gJHNjaGVtYVZhbHVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgICRleGNsdXNpdmUgPSB0cnVlO1xuICAgICAgICAgICAgJGVycm9yS2V5d29yZCA9ICRleGNsdXNpdmVLZXl3b3JkO1xuICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAkZXhjbHVzaXZlS2V5d29yZDtcbiAgICAgICAgICAgICRub3RPcCArPSBcIj1cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGV4Y2x1c2l2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJG9wU3RyICs9IFwiPVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgJG9wRXhwciA9IFwiJ1wiICsgJG9wU3RyICsgXCInXCI7XG4gICAgICAgIG91dCArPSBcIiBpZiAoIFwiO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSBcIiAoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9ICdudW1iZXInKSB8fCBcIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgXCIgKyAkZGF0YSArIFwiIFwiICsgJG5vdE9wICsgXCIgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiB8fCBcIiArICRkYXRhICsgXCIgIT09IFwiICsgJGRhdGEgKyBcIikgeyBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgJGVycm9yS2V5d29yZCA9ICRlcnJvcktleXdvcmQgfHwgJGtleXdvcmQ7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9IFwiXCI7XG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArICgkZXJyb3JLZXl3b3JkIHx8IFwiX2xpbWl0XCIpICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IGNvbXBhcmlzb246IFwiICsgJG9wRXhwciArIFwiLCBsaW1pdDogXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiwgZXhjbHVzaXZlOiBcIiArICRleGNsdXNpdmUgKyBcIiB9IFwiO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdzaG91bGQgYmUgXCIgKyAkb3BTdHIgKyBcIiBcIjtcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gXCInICsgXCIgKyAkc2NoZW1hVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyAkc2NoZW1hVmFsdWUgKyBcIidcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6ICBcIjtcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gXCJ2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgJHNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRJdGVtcy5qc1xudmFyIHJlcXVpcmVfX2xpbWl0SXRlbXMgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9fbGltaXRJdGVtcyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsICRzY2hlbWFWYWx1ZTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWUgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgICB9XG4gICAgaWYgKCEoJGlzRGF0YSB8fCB0eXBlb2YgJHNjaGVtYSA9PSBcIm51bWJlclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgXCIgbXVzdCBiZSBudW1iZXJcIik7XG4gICAgfVxuICAgIHZhciAkb3AgPSAka2V5d29yZCA9PSBcIm1heEl0ZW1zXCIgPyBcIj5cIiA6IFwiPFwiO1xuICAgIG91dCArPSBcImlmICggXCI7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiAoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9ICdudW1iZXInKSB8fCBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwiIFwiICsgJGRhdGEgKyBcIi5sZW5ndGggXCIgKyAkb3AgKyBcIiBcIiArICRzY2hlbWFWYWx1ZSArIFwiKSB7IFwiO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9IFwiXCI7XG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArICgkZXJyb3JLZXl3b3JkIHx8IFwiX2xpbWl0SXRlbXNcIikgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgbGltaXQ6IFwiICsgJHNjaGVtYVZhbHVlICsgXCIgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIE5PVCBoYXZlIFwiO1xuICAgICAgICBpZiAoJGtleXdvcmQgPT0gXCJtYXhJdGVtc1wiKSB7XG4gICAgICAgICAgb3V0ICs9IFwibW9yZVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcImZld2VyXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIHRoYW4gXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwiJyArIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgKyAnXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyAkc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiBpdGVtcycgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogIFwiO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSBcInZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyAkc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIn0gXCI7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSBcIiBlbHNlIHsgXCI7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvX2xpbWl0TGVuZ3RoLmpzXG52YXIgcmVxdWlyZV9fbGltaXRMZW5ndGggPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9fbGltaXRMZW5ndGgoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGVycm9yS2V5d29yZDtcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLCAkc2NoZW1hVmFsdWU7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiB2YXIgc2NoZW1hXCIgKyAkbHZsICsgXCIgPSBcIiArIGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpICsgXCI7IFwiO1xuICAgICAgJHNjaGVtYVZhbHVlID0gXCJzY2hlbWFcIiArICRsdmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gICAgfVxuICAgIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gXCJudW1iZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArIFwiIG11c3QgYmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgICB2YXIgJG9wID0gJGtleXdvcmQgPT0gXCJtYXhMZW5ndGhcIiA/IFwiPlwiIDogXCI8XCI7XG4gICAgb3V0ICs9IFwiaWYgKCBcIjtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIChcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT0gJ251bWJlcicpIHx8IFwiO1xuICAgIH1cbiAgICBpZiAoaXQub3B0cy51bmljb2RlID09PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIFwiICsgJGRhdGEgKyBcIi5sZW5ndGggXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB1Y3MybGVuZ3RoKFwiICsgJGRhdGEgKyBcIikgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIiBcIiArICRvcCArIFwiIFwiICsgJHNjaGVtYVZhbHVlICsgXCIpIHsgXCI7XG4gICAgdmFyICRlcnJvcktleXdvcmQgPSAka2V5d29yZDtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gXCJcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJfbGltaXRMZW5ndGhcIikgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgbGltaXQ6IFwiICsgJHNjaGVtYVZhbHVlICsgXCIgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIE5PVCBiZSBcIjtcbiAgICAgICAgaWYgKCRrZXl3b3JkID09IFwibWF4TGVuZ3RoXCIpIHtcbiAgICAgICAgICBvdXQgKz0gXCJsb25nZXJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJzaG9ydGVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIHRoYW4gXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwiJyArIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgKyAnXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyAkc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiBjaGFyYWN0ZXJzJyBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiAgXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwidmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJcIiArICRzY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwifSBcIjtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9fbGltaXRQcm9wZXJ0aWVzLmpzXG52YXIgcmVxdWlyZV9fbGltaXRQcm9wZXJ0aWVzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfX2xpbWl0UHJvcGVydGllcyhpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkaXNEYXRhID0gaXQub3B0cy4kZGF0YSAmJiAkc2NoZW1hICYmICRzY2hlbWEuJGRhdGEsICRzY2hlbWFWYWx1ZTtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIHZhciBzY2hlbWFcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC5nZXREYXRhKCRzY2hlbWEuJGRhdGEsICRkYXRhTHZsLCBpdC5kYXRhUGF0aEFycikgKyBcIjsgXCI7XG4gICAgICAkc2NoZW1hVmFsdWUgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjaGVtYVZhbHVlID0gJHNjaGVtYTtcbiAgICB9XG4gICAgaWYgKCEoJGlzRGF0YSB8fCB0eXBlb2YgJHNjaGVtYSA9PSBcIm51bWJlclwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCRrZXl3b3JkICsgXCIgbXVzdCBiZSBudW1iZXJcIik7XG4gICAgfVxuICAgIHZhciAkb3AgPSAka2V5d29yZCA9PSBcIm1heFByb3BlcnRpZXNcIiA/IFwiPlwiIDogXCI8XCI7XG4gICAgb3V0ICs9IFwiaWYgKCBcIjtcbiAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgb3V0ICs9IFwiIChcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT0gJ251bWJlcicpIHx8IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCIgT2JqZWN0LmtleXMoXCIgKyAkZGF0YSArIFwiKS5sZW5ndGggXCIgKyAkb3AgKyBcIiBcIiArICRzY2hlbWFWYWx1ZSArIFwiKSB7IFwiO1xuICAgIHZhciAkZXJyb3JLZXl3b3JkID0gJGtleXdvcmQ7XG4gICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgIG91dCA9IFwiXCI7XG4gICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArICgkZXJyb3JLZXl3b3JkIHx8IFwiX2xpbWl0UHJvcGVydGllc1wiKSArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBsaW1pdDogXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiB9IFwiO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdzaG91bGQgTk9UIGhhdmUgXCI7XG4gICAgICAgIGlmICgka2V5d29yZCA9PSBcIm1heFByb3BlcnRpZXNcIikge1xuICAgICAgICAgIG91dCArPSBcIm1vcmVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJmZXdlclwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB0aGFuIFwiO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSBcIicgKyBcIiArICRzY2hlbWFWYWx1ZSArIFwiICsgJ1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgJHNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgcHJvcGVydGllcycgXCI7XG4gICAgICB9XG4gICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogIFwiO1xuICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgIG91dCArPSBcInZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyAkc2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiAgICAgICAgICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgfVxuICAgIHZhciBfX2VyciA9IG91dDtcbiAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIn0gXCI7XG4gICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgIG91dCArPSBcIiBlbHNlIHsgXCI7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvbXVsdGlwbGVPZi5qc1xudmFyIHJlcXVpcmVfbXVsdGlwbGVPZiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX211bHRpcGxlT2YoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLCAkc2NoZW1hVmFsdWU7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiB2YXIgc2NoZW1hXCIgKyAkbHZsICsgXCIgPSBcIiArIGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpICsgXCI7IFwiO1xuICAgICAgJHNjaGVtYVZhbHVlID0gXCJzY2hlbWFcIiArICRsdmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gICAgfVxuICAgIGlmICghKCRpc0RhdGEgfHwgdHlwZW9mICRzY2hlbWEgPT0gXCJudW1iZXJcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigka2V5d29yZCArIFwiIG11c3QgYmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgICBvdXQgKz0gXCJ2YXIgZGl2aXNpb25cIiArICRsdmwgKyBcIjtpZiAoXCI7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiBcIiArICRzY2hlbWFWYWx1ZSArIFwiICE9PSB1bmRlZmluZWQgJiYgKCB0eXBlb2YgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPSAnbnVtYmVyJyB8fCBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwiIChkaXZpc2lvblwiICsgJGx2bCArIFwiID0gXCIgKyAkZGF0YSArIFwiIC8gXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiwgXCI7XG4gICAgaWYgKGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvbikge1xuICAgICAgb3V0ICs9IFwiIE1hdGguYWJzKE1hdGgucm91bmQoZGl2aXNpb25cIiArICRsdmwgKyBcIikgLSBkaXZpc2lvblwiICsgJGx2bCArIFwiKSA+IDFlLVwiICsgaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uICsgXCIgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiBkaXZpc2lvblwiICsgJGx2bCArIFwiICE9PSBwYXJzZUludChkaXZpc2lvblwiICsgJGx2bCArIFwiKSBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwiICkgXCI7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiAgKSAgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIiApIHsgICBcIjtcbiAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgb3V0ID0gXCJcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJtdWx0aXBsZU9mXCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgbXVsdGlwbGVPZjogXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiB9IFwiO1xuICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdzaG91bGQgYmUgbXVsdGlwbGUgb2YgXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwiJyArIFwiICsgJHNjaGVtYVZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgJHNjaGVtYVZhbHVlICsgXCInXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiAgXCI7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwidmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJcIiArICRzY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICB9XG4gICAgdmFyIF9fZXJyID0gb3V0O1xuICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICB9XG4gICAgb3V0ICs9IFwifSBcIjtcbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9kb3Rqcy9ub3QuanNcbnZhciByZXF1aXJlX25vdCA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX25vdChpdCwgJGtleXdvcmQsICRydWxlVHlwZSkge1xuICAgIHZhciBvdXQgPSBcIiBcIjtcbiAgICB2YXIgJGx2bCA9IGl0LmxldmVsO1xuICAgIHZhciAkZGF0YUx2bCA9IGl0LmRhdGFMZXZlbDtcbiAgICB2YXIgJHNjaGVtYSA9IGl0LnNjaGVtYVska2V5d29yZF07XG4gICAgdmFyICRzY2hlbWFQYXRoID0gaXQuc2NoZW1hUGF0aCArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJGtleXdvcmQpO1xuICAgIHZhciAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9cIiArICRrZXl3b3JkO1xuICAgIHZhciAkYnJlYWtPbkVycm9yID0gIWl0Lm9wdHMuYWxsRXJyb3JzO1xuICAgIHZhciAkZGF0YSA9IFwiZGF0YVwiICsgKCRkYXRhTHZsIHx8IFwiXCIpO1xuICAgIHZhciAkZXJycyA9IFwiZXJyc19fXCIgKyAkbHZsO1xuICAgIHZhciAkaXQgPSBpdC51dGlsLmNvcHkoaXQpO1xuICAgICRpdC5sZXZlbCsrO1xuICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgIGlmIChpdC5vcHRzLnN0cmljdEtleXdvcmRzID8gdHlwZW9mICRzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkc2NoZW1hKS5sZW5ndGggPiAwIHx8ICRzY2hlbWEgPT09IGZhbHNlIDogaXQudXRpbC5zY2hlbWFIYXNSdWxlcygkc2NoZW1hLCBpdC5SVUxFUy5hbGwpKSB7XG4gICAgICAkaXQuc2NoZW1hID0gJHNjaGVtYTtcbiAgICAgICRpdC5zY2hlbWFQYXRoID0gJHNjaGVtYVBhdGg7XG4gICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9ICRlcnJTY2hlbWFQYXRoO1xuICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRlcnJzICsgXCIgPSBlcnJvcnM7ICBcIjtcbiAgICAgIHZhciAkd2FzQ29tcG9zaXRlID0gaXQuY29tcG9zaXRlUnVsZTtcbiAgICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgICAkaXQuY3JlYXRlRXJyb3JzID0gZmFsc2U7XG4gICAgICB2YXIgJGFsbEVycm9yc09wdGlvbjtcbiAgICAgIGlmICgkaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgICAgJGFsbEVycm9yc09wdGlvbiA9ICRpdC5vcHRzLmFsbEVycm9ycztcbiAgICAgICAgJGl0Lm9wdHMuYWxsRXJyb3JzID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgXCIgKyBpdC52YWxpZGF0ZSgkaXQpICsgXCIgXCI7XG4gICAgICAkaXQuY3JlYXRlRXJyb3JzID0gdHJ1ZTtcbiAgICAgIGlmICgkYWxsRXJyb3JzT3B0aW9uKVxuICAgICAgICAkaXQub3B0cy5hbGxFcnJvcnMgPSAkYWxsRXJyb3JzT3B0aW9uO1xuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkbmV4dFZhbGlkICsgXCIpIHsgICBcIjtcbiAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgb3V0ID0gXCJcIjtcbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArIFwibm90XCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHt9IFwiO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnc2hvdWxkIE5PVCBiZSB2YWxpZCcgXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgIH1cbiAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBlbHNlIHsgIGVycm9ycyA9IFwiICsgJGVycnMgKyBcIjsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKFwiICsgJGVycnMgKyBcIikgdkVycm9ycy5sZW5ndGggPSBcIiArICRlcnJzICsgXCI7IGVsc2UgdkVycm9ycyA9IG51bGw7IH0gXCI7XG4gICAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiAgdmFyIGVyciA9ICAgXCI7XG4gICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcIm5vdFwiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7fSBcIjtcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBOT1QgYmUgdmFsaWQnIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKGZhbHNlKSB7IFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL29uZU9mLmpzXG52YXIgcmVxdWlyZV9vbmVPZiA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX29uZU9mKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICR2YWxpZCA9IFwidmFsaWRcIiArICRsdmw7XG4gICAgdmFyICRlcnJzID0gXCJlcnJzX19cIiArICRsdmw7XG4gICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICAgdmFyICRjbG9zaW5nQnJhY2VzID0gXCJcIjtcbiAgICAkaXQubGV2ZWwrKztcbiAgICB2YXIgJG5leHRWYWxpZCA9IFwidmFsaWRcIiArICRpdC5sZXZlbDtcbiAgICB2YXIgJGN1cnJlbnRCYXNlSWQgPSAkaXQuYmFzZUlkLCAkcHJldlZhbGlkID0gXCJwcmV2VmFsaWRcIiArICRsdmwsICRwYXNzaW5nU2NoZW1hcyA9IFwicGFzc2luZ1NjaGVtYXNcIiArICRsdmw7XG4gICAgb3V0ICs9IFwidmFyIFwiICsgJGVycnMgKyBcIiA9IGVycm9ycyAsIFwiICsgJHByZXZWYWxpZCArIFwiID0gZmFsc2UgLCBcIiArICR2YWxpZCArIFwiID0gZmFsc2UgLCBcIiArICRwYXNzaW5nU2NoZW1hcyArIFwiID0gbnVsbDsgXCI7XG4gICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9IHRydWU7XG4gICAgdmFyIGFycjEgPSAkc2NoZW1hO1xuICAgIGlmIChhcnIxKSB7XG4gICAgICB2YXIgJHNjaCwgJGkgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoJGkgPCBsMSkge1xuICAgICAgICAkc2NoID0gYXJyMVskaSArPSAxXTtcbiAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyB0eXBlb2YgJHNjaCA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDAgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICAkaXQuc2NoZW1hID0gJHNjaDtcbiAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9ICRzY2hlbWFQYXRoICsgXCJbXCIgKyAkaSArIFwiXVwiO1xuICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGggKyBcIi9cIiArICRpO1xuICAgICAgICAgIG91dCArPSBcIiAgXCIgKyBpdC52YWxpZGF0ZSgkaXQpICsgXCIgXCI7XG4gICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkbmV4dFZhbGlkICsgXCIgPSB0cnVlOyBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGkpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiICYmIFwiICsgJHByZXZWYWxpZCArIFwiKSB7IFwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTsgXCIgKyAkcGFzc2luZ1NjaGVtYXMgKyBcIiA9IFtcIiArICRwYXNzaW5nU2NoZW1hcyArIFwiLCBcIiArICRpICsgXCJdOyB9IGVsc2UgeyBcIjtcbiAgICAgICAgICAkY2xvc2luZ0JyYWNlcyArPSBcIn1cIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiKSB7IFwiICsgJHZhbGlkICsgXCIgPSBcIiArICRwcmV2VmFsaWQgKyBcIiA9IHRydWU7IFwiICsgJHBhc3NpbmdTY2hlbWFzICsgXCIgPSBcIiArICRpICsgXCI7IH1cIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICBvdXQgKz0gXCJcIiArICRjbG9zaW5nQnJhY2VzICsgXCJpZiAoIVwiICsgJHZhbGlkICsgXCIpIHsgICB2YXIgZXJyID0gICBcIjtcbiAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJvbmVPZlwiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IHBhc3NpbmdTY2hlbWFzOiBcIiArICRwYXNzaW5nU2NoZW1hcyArIFwiIH0gXCI7XG4gICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2YnIFwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcih2RXJyb3JzKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gdkVycm9yczsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IFwifSBlbHNlIHsgIGVycm9ycyA9IFwiICsgJGVycnMgKyBcIjsgaWYgKHZFcnJvcnMgIT09IG51bGwpIHsgaWYgKFwiICsgJGVycnMgKyBcIikgdkVycm9ycy5sZW5ndGggPSBcIiArICRlcnJzICsgXCI7IGVsc2UgdkVycm9ycyA9IG51bGw7IH1cIjtcbiAgICBpZiAoaXQub3B0cy5hbGxFcnJvcnMpIHtcbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3BhdHRlcm4uanNcbnZhciByZXF1aXJlX3BhdHRlcm4gPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9wYXR0ZXJuKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSwgJHNjaGVtYVZhbHVlO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIHNjaGVtYVwiICsgJGx2bCArIFwiID0gXCIgKyBpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSArIFwiOyBcIjtcbiAgICAgICRzY2hlbWFWYWx1ZSA9IFwic2NoZW1hXCIgKyAkbHZsO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICAgIH1cbiAgICB2YXIgJHJlZ2V4cCA9ICRpc0RhdGEgPyBcIihuZXcgUmVnRXhwKFwiICsgJHNjaGVtYVZhbHVlICsgXCIpKVwiIDogaXQudXNlUGF0dGVybigkc2NoZW1hKTtcbiAgICBvdXQgKz0gXCJpZiAoIFwiO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgKFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiAhPSAnc3RyaW5nJykgfHwgXCI7XG4gICAgfVxuICAgIG91dCArPSBcIiAhXCIgKyAkcmVnZXhwICsgXCIudGVzdChcIiArICRkYXRhICsgXCIpICkgeyAgIFwiO1xuICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICBvdXQgPSBcIlwiO1xuICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcInBhdHRlcm5cIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBwYXR0ZXJuOiAgXCI7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gXCJcIiArICRzY2hlbWFWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIlwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKTtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiAgfSBcIjtcbiAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gYCAsIG1lc3NhZ2U6ICdzaG91bGQgbWF0Y2ggcGF0dGVybiBcImA7XG4gICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgb3V0ICs9IFwiJyArIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgKyAnXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiXCIgKyBpdC51dGlsLmVzY2FwZVF1b3Rlcygkc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gYFwiJyBgO1xuICAgICAgfVxuICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6ICBcIjtcbiAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICBvdXQgKz0gXCJ2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgICAgICAgICAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgIH1cbiAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgIH1cbiAgICBvdXQgKz0gXCJ9IFwiO1xuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gXCIgZWxzZSB7IFwiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3Byb3BlcnRpZXMuanNcbnZhciByZXF1aXJlX3Byb3BlcnRpZXMgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZW5lcmF0ZV9wcm9wZXJ0aWVzKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICRlcnJzID0gXCJlcnJzX19cIiArICRsdmw7XG4gICAgdmFyICRpdCA9IGl0LnV0aWwuY29weShpdCk7XG4gICAgdmFyICRjbG9zaW5nQnJhY2VzID0gXCJcIjtcbiAgICAkaXQubGV2ZWwrKztcbiAgICB2YXIgJG5leHRWYWxpZCA9IFwidmFsaWRcIiArICRpdC5sZXZlbDtcbiAgICB2YXIgJGtleSA9IFwia2V5XCIgKyAkbHZsLCAkaWR4ID0gXCJpZHhcIiArICRsdmwsICRkYXRhTnh0ID0gJGl0LmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDEsICRuZXh0RGF0YSA9IFwiZGF0YVwiICsgJGRhdGFOeHQsICRkYXRhUHJvcGVydGllcyA9IFwiZGF0YVByb3BlcnRpZXNcIiArICRsdmw7XG4gICAgdmFyICRzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoJHNjaGVtYSB8fCB7fSkuZmlsdGVyKG5vdFByb3RvKSwgJHBQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzIHx8IHt9LCAkcFByb3BlcnR5S2V5cyA9IE9iamVjdC5rZXlzKCRwUHJvcGVydGllcykuZmlsdGVyKG5vdFByb3RvKSwgJGFQcm9wZXJ0aWVzID0gaXQuc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCAkc29tZVByb3BlcnRpZXMgPSAkc2NoZW1hS2V5cy5sZW5ndGggfHwgJHBQcm9wZXJ0eUtleXMubGVuZ3RoLCAkbm9BZGRpdGlvbmFsID0gJGFQcm9wZXJ0aWVzID09PSBmYWxzZSwgJGFkZGl0aW9uYWxJc1NjaGVtYSA9IHR5cGVvZiAkYVByb3BlcnRpZXMgPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkYVByb3BlcnRpZXMpLmxlbmd0aCwgJHJlbW92ZUFkZGl0aW9uYWwgPSBpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwsICRjaGVja0FkZGl0aW9uYWwgPSAkbm9BZGRpdGlvbmFsIHx8ICRhZGRpdGlvbmFsSXNTY2hlbWEgfHwgJHJlbW92ZUFkZGl0aW9uYWwsICRvd25Qcm9wZXJ0aWVzID0gaXQub3B0cy5vd25Qcm9wZXJ0aWVzLCAkY3VycmVudEJhc2VJZCA9IGl0LmJhc2VJZDtcbiAgICB2YXIgJHJlcXVpcmVkID0gaXQuc2NoZW1hLnJlcXVpcmVkO1xuICAgIGlmICgkcmVxdWlyZWQgJiYgIShpdC5vcHRzLiRkYXRhICYmICRyZXF1aXJlZC4kZGF0YSkgJiYgJHJlcXVpcmVkLmxlbmd0aCA8IGl0Lm9wdHMubG9vcFJlcXVpcmVkKSB7XG4gICAgICB2YXIgJHJlcXVpcmVkSGFzaCA9IGl0LnV0aWwudG9IYXNoKCRyZXF1aXJlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vdFByb3RvKHApIHtcbiAgICAgIHJldHVybiBwICE9PSBcIl9fcHJvdG9fX1wiO1xuICAgIH1cbiAgICBvdXQgKz0gXCJ2YXIgXCIgKyAkZXJycyArIFwiID0gZXJyb3JzO3ZhciBcIiArICRuZXh0VmFsaWQgKyBcIiA9IHRydWU7XCI7XG4gICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIgPSB1bmRlZmluZWQ7XCI7XG4gICAgfVxuICAgIGlmICgkY2hlY2tBZGRpdGlvbmFsKSB7XG4gICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIgPSBcIiArICRkYXRhUHJvcGVydGllcyArIFwiIHx8IE9iamVjdC5rZXlzKFwiICsgJGRhdGEgKyBcIik7IGZvciAodmFyIFwiICsgJGlkeCArIFwiPTA7IFwiICsgJGlkeCArIFwiPFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIubGVuZ3RoOyBcIiArICRpZHggKyBcIisrKSB7IHZhciBcIiArICRrZXkgKyBcIiA9IFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCJbXCIgKyAkaWR4ICsgXCJdOyBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiBmb3IgKHZhciBcIiArICRrZXkgKyBcIiBpbiBcIiArICRkYXRhICsgXCIpIHsgXCI7XG4gICAgICB9XG4gICAgICBpZiAoJHNvbWVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIG91dCArPSBcIiB2YXIgaXNBZGRpdGlvbmFsXCIgKyAkbHZsICsgXCIgPSAhKGZhbHNlIFwiO1xuICAgICAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCRzY2hlbWFLZXlzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB8fCB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCIuaGFzT3duUHJvcGVydHkoXCIgKyAka2V5ICsgXCIpIFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXJyMSA9ICRzY2hlbWFLZXlzO1xuICAgICAgICAgICAgaWYgKGFycjEpIHtcbiAgICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTEgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIHdoaWxlIChpMSA8IGwxKSB7XG4gICAgICAgICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyMVtpMSArPSAxXTtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfHwgXCIgKyAka2V5ICsgXCIgPT0gXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRwcm9wZXJ0eUtleSkgKyBcIiBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJHBQcm9wZXJ0eUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGFycjIgPSAkcFByb3BlcnR5S2V5cztcbiAgICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgICAgdmFyICRwUHJvcGVydHksICRpID0gLTEsIGwyID0gYXJyMi5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKCRpIDwgbDIpIHtcbiAgICAgICAgICAgICAgJHBQcm9wZXJ0eSA9IGFycjJbJGkgKz0gMV07XG4gICAgICAgICAgICAgIG91dCArPSBcIiB8fCBcIiArIGl0LnVzZVBhdHRlcm4oJHBQcm9wZXJ0eSkgKyBcIi50ZXN0KFwiICsgJGtleSArIFwiKSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9IFwiICk7IGlmIChpc0FkZGl0aW9uYWxcIiArICRsdmwgKyBcIikgeyBcIjtcbiAgICAgIH1cbiAgICAgIGlmICgkcmVtb3ZlQWRkaXRpb25hbCA9PSBcImFsbFwiKSB7XG4gICAgICAgIG91dCArPSBcIiBkZWxldGUgXCIgKyAkZGF0YSArIFwiW1wiICsgJGtleSArIFwiXTsgXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgJGN1cnJlbnRFcnJvclBhdGggPSBpdC5lcnJvclBhdGg7XG4gICAgICAgIHZhciAkYWRkaXRpb25hbFByb3BlcnR5ID0gXCInICsgXCIgKyAka2V5ICsgXCIgKyAnXCI7XG4gICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkbm9BZGRpdGlvbmFsKSB7XG4gICAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgZGVsZXRlIFwiICsgJGRhdGEgKyBcIltcIiArICRrZXkgKyBcIl07IFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyAkbmV4dFZhbGlkICsgXCIgPSBmYWxzZTsgXCI7XG4gICAgICAgICAgICB2YXIgJGN1cnJFcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9hZGRpdGlvbmFsUHJvcGVydGllc1wiO1xuICAgICAgICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgICBvdXQgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IGFkZGl0aW9uYWxQcm9wZXJ0eTogJ1wiICsgJGFkZGl0aW9uYWxQcm9wZXJ0eSArIFwiJyB9IFwiO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAnXCI7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiaXMgYW4gaW52YWxpZCBhZGRpdGlvbmFsIHByb3BlcnR5XCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcInNob3VsZCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiJyBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiBmYWxzZSAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSAkY3VyckVyclNjaGVtYVBhdGg7XG4gICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgYnJlYWs7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgkYWRkaXRpb25hbElzU2NoZW1hKSB7XG4gICAgICAgICAgaWYgKCRyZW1vdmVBZGRpdGlvbmFsID09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJGVycnMgKyBcIiA9IGVycm9yczsgIFwiO1xuICAgICAgICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICRpdC5zY2hlbWEgPSAkYVByb3BlcnRpZXM7XG4gICAgICAgICAgICAkaXQuc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBcIi5hZGRpdGlvbmFsUHJvcGVydGllc1wiO1xuICAgICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvYWRkaXRpb25hbFByb3BlcnRpZXNcIjtcbiAgICAgICAgICAgICRpdC5lcnJvclBhdGggPSBpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkgPyBpdC5lcnJvclBhdGggOiBpdC51dGlsLmdldFBhdGhFeHByKGl0LmVycm9yUGF0aCwgJGtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgdmFyICRwYXNzRGF0YSA9ICRkYXRhICsgXCJbXCIgKyAka2V5ICsgXCJdXCI7XG4gICAgICAgICAgICAkaXQuZGF0YVBhdGhBcnJbJGRhdGFOeHRdID0gJGtleTtcbiAgICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSArIFwiIFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRuZXh0RGF0YSArIFwiID0gXCIgKyAkcGFzc0RhdGEgKyBcIjsgXCIgKyAkY29kZSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IFwiIGlmICghXCIgKyAkbmV4dFZhbGlkICsgXCIpIHsgZXJyb3JzID0gXCIgKyAkZXJycyArIFwiOyBpZiAodmFsaWRhdGUuZXJyb3JzICE9PSBudWxsKSB7IGlmIChlcnJvcnMpIHZhbGlkYXRlLmVycm9ycy5sZW5ndGggPSBlcnJvcnM7IGVsc2UgdmFsaWRhdGUuZXJyb3JzID0gbnVsbDsgfSBkZWxldGUgXCIgKyAkZGF0YSArIFwiW1wiICsgJGtleSArIFwiXTsgfSAgXCI7XG4gICAgICAgICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSAkd2FzQ29tcG9zaXRlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkaXQuc2NoZW1hID0gJGFQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgXCIuYWRkaXRpb25hbFByb3BlcnRpZXNcIjtcbiAgICAgICAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCI7XG4gICAgICAgICAgICAkaXQuZXJyb3JQYXRoID0gaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5ID8gaXQuZXJyb3JQYXRoIDogaXQudXRpbC5nZXRQYXRoRXhwcihpdC5lcnJvclBhdGgsICRrZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgIHZhciAkcGFzc0RhdGEgPSAkZGF0YSArIFwiW1wiICsgJGtleSArIFwiXVwiO1xuICAgICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9ICRrZXk7XG4gICAgICAgICAgICB2YXIgJGNvZGUgPSBpdC52YWxpZGF0ZSgkaXQpO1xuICAgICAgICAgICAgJGl0LmJhc2VJZCA9ICRjdXJyZW50QmFzZUlkO1xuICAgICAgICAgICAgaWYgKGl0LnV0aWwudmFyT2NjdXJlbmNlcygkY29kZSwgJG5leHREYXRhKSA8IDIpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgaXQudXRpbC52YXJSZXBsYWNlKCRjb2RlLCAkbmV4dERhdGEsICRwYXNzRGF0YSkgKyBcIiBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkbmV4dERhdGEgKyBcIiA9IFwiICsgJHBhc3NEYXRhICsgXCI7IFwiICsgJGNvZGUgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoIVwiICsgJG5leHRWYWxpZCArIFwiKSBicmVhazsgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgICAgfVxuICAgICAgaWYgKCRzb21lUHJvcGVydGllcykge1xuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9ICBcIjtcbiAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkbmV4dFZhbGlkICsgXCIpIHsgXCI7XG4gICAgICAgICRjbG9zaW5nQnJhY2VzICs9IFwifVwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgJHVzZURlZmF1bHRzID0gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZTtcbiAgICBpZiAoJHNjaGVtYUtleXMubGVuZ3RoKSB7XG4gICAgICB2YXIgYXJyMyA9ICRzY2hlbWFLZXlzO1xuICAgICAgaWYgKGFycjMpIHtcbiAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSwgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpMyA8IGwzKSB7XG4gICAgICAgICAgJHByb3BlcnR5S2V5ID0gYXJyM1tpMyArPSAxXTtcbiAgICAgICAgICB2YXIgJHNjaCA9ICRzY2hlbWFbJHByb3BlcnR5S2V5XTtcbiAgICAgICAgICBpZiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkc2NoID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoJHNjaCkubGVuZ3RoID4gMCB8fCAkc2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHNjaCwgaXQuUlVMRVMuYWxsKSkge1xuICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLCAkcGFzc0RhdGEgPSAkZGF0YSArICRwcm9wLCAkaGFzRGVmYXVsdCA9ICR1c2VEZWZhdWx0cyAmJiAkc2NoLmRlZmF1bHQgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aCArICRwcm9wO1xuICAgICAgICAgICAgJGl0LmVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgaXQudXRpbC5lc2NhcGVGcmFnbWVudCgkcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aChpdC5lcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgJGl0LmRhdGFQYXRoQXJyWyRkYXRhTnh0XSA9IGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAgICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICAgICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICAgICAgICAkY29kZSA9IGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpO1xuICAgICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkcGFzc0RhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgJHVzZURhdGEgPSAkbmV4dERhdGE7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkbmV4dERhdGEgKyBcIiA9IFwiICsgJHBhc3NEYXRhICsgXCI7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCRoYXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBcIiArICRjb2RlICsgXCIgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoJHJlcXVpcmVkSGFzaCAmJiAkcmVxdWlyZWRIYXNoWyRwcm9wZXJ0eUtleV0pIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgaWYgKCBcIiArICR1c2VEYXRhICsgXCIgPT09IHVuZGVmaW5lZCBcIjtcbiAgICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkgKyBcIicpIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIpIHsgXCIgKyAkbmV4dFZhbGlkICsgXCIgPSBmYWxzZTsgXCI7XG4gICAgICAgICAgICAgICAgdmFyICRjdXJyZW50RXJyb3JQYXRoID0gaXQuZXJyb3JQYXRoLCAkY3VyckVyclNjaGVtYVBhdGggPSAkZXJyU2NoZW1hUGF0aCwgJG1pc3NpbmdQcm9wZXJ0eSA9IGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlLZXksIGl0Lm9wdHMuanNvblBvaW50ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvcmVxdWlyZWRcIjtcbiAgICAgICAgICAgICAgICB2YXIgJCRvdXRTdGFjayA9ICQkb3V0U3RhY2sgfHwgW107XG4gICAgICAgICAgICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICAgICAgICAgICAgb3V0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJyZXF1aXJlZFwiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogJ1wiICsgJG1pc3NpbmdQcm9wZXJ0eSArIFwiJyB9IFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBcImlzIGEgcmVxdWlyZWQgcHJvcGVydHlcIjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCJzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcJ1wiICsgJG1pc3NpbmdQcm9wZXJ0eSArIFwiXFxcXCdcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX19lcnIgPSBvdXQ7XG4gICAgICAgICAgICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFsaWRhdGUuZXJyb3JzID0gW1wiICsgX19lcnIgKyBcIl07IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB2YXIgZXJyID0gXCIgKyBfX2VyciArIFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkZXJyU2NoZW1hUGF0aCA9ICRjdXJyRXJyU2NoZW1hUGF0aDtcbiAgICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSAkY3VycmVudEVycm9yUGF0aDtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfSBlbHNlIHsgXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoIFwiICsgJHVzZURhdGEgKyBcIiA9PT0gdW5kZWZpbmVkIFwiO1xuICAgICAgICAgICAgICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkgKyBcIicpIFwiO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiKSB7IFwiICsgJG5leHRWYWxpZCArIFwiID0gdHJ1ZTsgfSBlbHNlIHsgXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkdXNlRGF0YSArIFwiICE9PSB1bmRlZmluZWQgXCI7XG4gICAgICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiICYmICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFwiICsgJGRhdGEgKyBcIiwgJ1wiICsgaXQudXRpbC5lc2NhcGVRdW90ZXMoJHByb3BlcnR5S2V5KSArIFwiJykgXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgKSB7IFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyAkY29kZSArIFwiIH0gXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJG5leHRWYWxpZCArIFwiKSB7IFwiO1xuICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gXCJ9XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkcFByb3BlcnR5S2V5cy5sZW5ndGgpIHtcbiAgICAgIHZhciBhcnI0ID0gJHBQcm9wZXJ0eUtleXM7XG4gICAgICBpZiAoYXJyNCkge1xuICAgICAgICB2YXIgJHBQcm9wZXJ0eSwgaTQgPSAtMSwgbDQgPSBhcnI0Lmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpNCA8IGw0KSB7XG4gICAgICAgICAgJHBQcm9wZXJ0eSA9IGFycjRbaTQgKz0gMV07XG4gICAgICAgICAgdmFyICRzY2ggPSAkcFByb3BlcnRpZXNbJHBQcm9wZXJ0eV07XG4gICAgICAgICAgaWYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyB0eXBlb2YgJHNjaCA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKCRzY2gpLmxlbmd0aCA+IDAgfHwgJHNjaCA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2gsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICAgICAgICRpdC5zY2hlbWEgPSAkc2NoO1xuICAgICAgICAgICAgJGl0LnNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgXCIucGF0dGVyblByb3BlcnRpZXNcIiArIGl0LnV0aWwuZ2V0UHJvcGVydHkoJHBQcm9wZXJ0eSk7XG4gICAgICAgICAgICAkaXQuZXJyU2NoZW1hUGF0aCA9IGl0LmVyclNjaGVtYVBhdGggKyBcIi9wYXR0ZXJuUHJvcGVydGllcy9cIiArIGl0LnV0aWwuZXNjYXBlRnJhZ21lbnQoJHBQcm9wZXJ0eSk7XG4gICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIgPSBcIiArICRkYXRhUHJvcGVydGllcyArIFwiIHx8IE9iamVjdC5rZXlzKFwiICsgJGRhdGEgKyBcIik7IGZvciAodmFyIFwiICsgJGlkeCArIFwiPTA7IFwiICsgJGlkeCArIFwiPFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIubGVuZ3RoOyBcIiArICRpZHggKyBcIisrKSB7IHZhciBcIiArICRrZXkgKyBcIiA9IFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCJbXCIgKyAkaWR4ICsgXCJdOyBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBmb3IgKHZhciBcIiArICRrZXkgKyBcIiBpbiBcIiArICRkYXRhICsgXCIpIHsgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgaXQudXNlUGF0dGVybigkcFByb3BlcnR5KSArIFwiLnRlc3QoXCIgKyAka2V5ICsgXCIpKSB7IFwiO1xuICAgICAgICAgICAgJGl0LmVycm9yUGF0aCA9IGl0LnV0aWwuZ2V0UGF0aEV4cHIoaXQuZXJyb3JQYXRoLCAka2V5LCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgICB2YXIgJHBhc3NEYXRhID0gJGRhdGEgKyBcIltcIiArICRrZXkgKyBcIl1cIjtcbiAgICAgICAgICAgICRpdC5kYXRhUGF0aEFyclskZGF0YU54dF0gPSAka2V5O1xuICAgICAgICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KTtcbiAgICAgICAgICAgICRpdC5iYXNlSWQgPSAkY3VycmVudEJhc2VJZDtcbiAgICAgICAgICAgIGlmIChpdC51dGlsLnZhck9jY3VyZW5jZXMoJGNvZGUsICRuZXh0RGF0YSkgPCAyKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiBcIiArIGl0LnV0aWwudmFyUmVwbGFjZSgkY29kZSwgJG5leHREYXRhLCAkcGFzc0RhdGEpICsgXCIgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJG5leHREYXRhICsgXCIgPSBcIiArICRwYXNzRGF0YSArIFwiOyBcIiArICRjb2RlICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgaWYgKCFcIiArICRuZXh0VmFsaWQgKyBcIikgYnJlYWs7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgZWxzZSBcIiArICRuZXh0VmFsaWQgKyBcIiA9IHRydWU7IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0ICs9IFwiIH0gIFwiO1xuICAgICAgICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRuZXh0VmFsaWQgKyBcIikgeyBcIjtcbiAgICAgICAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkYnJlYWtPbkVycm9yKSB7XG4gICAgICBvdXQgKz0gXCIgXCIgKyAkY2xvc2luZ0JyYWNlcyArIFwiIGlmIChcIiArICRlcnJzICsgXCIgPT0gZXJyb3JzKSB7XCI7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvcHJvcGVydHlOYW1lcy5qc1xudmFyIHJlcXVpcmVfcHJvcGVydHlOYW1lcyA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3Byb3BlcnR5TmFtZXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJGVycnMgPSBcImVycnNfX1wiICsgJGx2bDtcbiAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICB2YXIgJGNsb3NpbmdCcmFjZXMgPSBcIlwiO1xuICAgICRpdC5sZXZlbCsrO1xuICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgIG91dCArPSBcInZhciBcIiArICRlcnJzICsgXCIgPSBlcnJvcnM7XCI7XG4gICAgaWYgKGl0Lm9wdHMuc3RyaWN0S2V5d29yZHMgPyB0eXBlb2YgJHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKCRzY2hlbWEpLmxlbmd0aCA+IDAgfHwgJHNjaGVtYSA9PT0gZmFsc2UgOiBpdC51dGlsLnNjaGVtYUhhc1J1bGVzKCRzY2hlbWEsIGl0LlJVTEVTLmFsbCkpIHtcbiAgICAgICRpdC5zY2hlbWEgPSAkc2NoZW1hO1xuICAgICAgJGl0LnNjaGVtYVBhdGggPSAkc2NoZW1hUGF0aDtcbiAgICAgICRpdC5lcnJTY2hlbWFQYXRoID0gJGVyclNjaGVtYVBhdGg7XG4gICAgICB2YXIgJGtleSA9IFwia2V5XCIgKyAkbHZsLCAkaWR4ID0gXCJpZHhcIiArICRsdmwsICRpID0gXCJpXCIgKyAkbHZsLCAkaW52YWxpZE5hbWUgPSBcIicgKyBcIiArICRrZXkgKyBcIiArICdcIiwgJGRhdGFOeHQgPSAkaXQuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMSwgJG5leHREYXRhID0gXCJkYXRhXCIgKyAkZGF0YU54dCwgJGRhdGFQcm9wZXJ0aWVzID0gXCJkYXRhUHJvcGVydGllc1wiICsgJGx2bCwgJG93blByb3BlcnRpZXMgPSBpdC5vcHRzLm93blByb3BlcnRpZXMsICRjdXJyZW50QmFzZUlkID0gaXQuYmFzZUlkO1xuICAgICAgaWYgKCRvd25Qcm9wZXJ0aWVzKSB7XG4gICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkZGF0YVByb3BlcnRpZXMgKyBcIiA9IHVuZGVmaW5lZDsgXCI7XG4gICAgICB9XG4gICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIgPSBcIiArICRkYXRhUHJvcGVydGllcyArIFwiIHx8IE9iamVjdC5rZXlzKFwiICsgJGRhdGEgKyBcIik7IGZvciAodmFyIFwiICsgJGlkeCArIFwiPTA7IFwiICsgJGlkeCArIFwiPFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCIubGVuZ3RoOyBcIiArICRpZHggKyBcIisrKSB7IHZhciBcIiArICRrZXkgKyBcIiA9IFwiICsgJGRhdGFQcm9wZXJ0aWVzICsgXCJbXCIgKyAkaWR4ICsgXCJdOyBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiBmb3IgKHZhciBcIiArICRrZXkgKyBcIiBpbiBcIiArICRkYXRhICsgXCIpIHsgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIgdmFyIHN0YXJ0RXJyc1wiICsgJGx2bCArIFwiID0gZXJyb3JzOyBcIjtcbiAgICAgIHZhciAkcGFzc0RhdGEgPSAka2V5O1xuICAgICAgdmFyICR3YXNDb21wb3NpdGUgPSBpdC5jb21wb3NpdGVSdWxlO1xuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gdHJ1ZTtcbiAgICAgIHZhciAkY29kZSA9IGl0LnZhbGlkYXRlKCRpdCk7XG4gICAgICAkaXQuYmFzZUlkID0gJGN1cnJlbnRCYXNlSWQ7XG4gICAgICBpZiAoaXQudXRpbC52YXJPY2N1cmVuY2VzKCRjb2RlLCAkbmV4dERhdGEpIDwgMikge1xuICAgICAgICBvdXQgKz0gXCIgXCIgKyBpdC51dGlsLnZhclJlcGxhY2UoJGNvZGUsICRuZXh0RGF0YSwgJHBhc3NEYXRhKSArIFwiIFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhciBcIiArICRuZXh0RGF0YSArIFwiID0gXCIgKyAkcGFzc0RhdGEgKyBcIjsgXCIgKyAkY29kZSArIFwiIFwiO1xuICAgICAgfVxuICAgICAgaXQuY29tcG9zaXRlUnVsZSA9ICRpdC5jb21wb3NpdGVSdWxlID0gJHdhc0NvbXBvc2l0ZTtcbiAgICAgIG91dCArPSBcIiBpZiAoIVwiICsgJG5leHRWYWxpZCArIFwiKSB7IGZvciAodmFyIFwiICsgJGkgKyBcIj1zdGFydEVycnNcIiArICRsdmwgKyBcIjsgXCIgKyAkaSArIFwiPGVycm9yczsgXCIgKyAkaSArIFwiKyspIHsgdkVycm9yc1tcIiArICRpICsgXCJdLnByb3BlcnR5TmFtZSA9IFwiICsgJGtleSArIFwiOyB9ICAgdmFyIGVyciA9ICAgXCI7XG4gICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcInByb3BlcnR5TmFtZXNcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBwcm9wZXJ0eU5hbWU6ICdcIiArICRpbnZhbGlkTmFtZSArIFwiJyB9IFwiO1xuICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgLCBtZXNzYWdlOiAncHJvcGVydHkgbmFtZSBcXFxcJ1wiICsgJGludmFsaWROYW1lICsgXCJcXFxcJyBpcyBpbnZhbGlkJyBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoICsgXCIgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiOyAgaWYgKHZFcnJvcnMgPT09IG51bGwpIHZFcnJvcnMgPSBbZXJyXTsgZWxzZSB2RXJyb3JzLnB1c2goZXJyKTsgZXJyb3JzKys7IFwiO1xuICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgaWYgKGl0LmFzeW5jKSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IodkVycm9ycyk7IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSB2RXJyb3JzOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgYnJlYWs7IFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gfVwiO1xuICAgIH1cbiAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIFwiICsgJGNsb3NpbmdCcmFjZXMgKyBcIiBpZiAoXCIgKyAkZXJycyArIFwiID09IGVycm9ycykge1wiO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL3JlcXVpcmVkLmpzXG52YXIgcmVxdWlyZV9yZXF1aXJlZCA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdlbmVyYXRlX3JlcXVpcmVkKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICR2YWxpZCA9IFwidmFsaWRcIiArICRsdmw7XG4gICAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSwgJHNjaGVtYVZhbHVlO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIHNjaGVtYVwiICsgJGx2bCArIFwiID0gXCIgKyBpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSArIFwiOyBcIjtcbiAgICAgICRzY2hlbWFWYWx1ZSA9IFwic2NoZW1hXCIgKyAkbHZsO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICAgIH1cbiAgICB2YXIgJHZTY2hlbWEgPSBcInNjaGVtYVwiICsgJGx2bDtcbiAgICBpZiAoISRpc0RhdGEpIHtcbiAgICAgIGlmICgkc2NoZW1hLmxlbmd0aCA8IGl0Lm9wdHMubG9vcFJlcXVpcmVkICYmIGl0LnNjaGVtYS5wcm9wZXJ0aWVzICYmIE9iamVjdC5rZXlzKGl0LnNjaGVtYS5wcm9wZXJ0aWVzKS5sZW5ndGgpIHtcbiAgICAgICAgdmFyICRyZXF1aXJlZCA9IFtdO1xuICAgICAgICB2YXIgYXJyMSA9ICRzY2hlbWE7XG4gICAgICAgIGlmIChhcnIxKSB7XG4gICAgICAgICAgdmFyICRwcm9wZXJ0eSwgaTEgPSAtMSwgbDEgPSBhcnIxLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGkxIDwgbDEpIHtcbiAgICAgICAgICAgICRwcm9wZXJ0eSA9IGFycjFbaTEgKz0gMV07XG4gICAgICAgICAgICB2YXIgJHByb3BlcnR5U2NoID0gaXQuc2NoZW1hLnByb3BlcnRpZXNbJHByb3BlcnR5XTtcbiAgICAgICAgICAgIGlmICghKCRwcm9wZXJ0eVNjaCAmJiAoaXQub3B0cy5zdHJpY3RLZXl3b3JkcyA/IHR5cGVvZiAkcHJvcGVydHlTY2ggPT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cygkcHJvcGVydHlTY2gpLmxlbmd0aCA+IDAgfHwgJHByb3BlcnR5U2NoID09PSBmYWxzZSA6IGl0LnV0aWwuc2NoZW1hSGFzUnVsZXMoJHByb3BlcnR5U2NoLCBpdC5SVUxFUy5hbGwpKSkpIHtcbiAgICAgICAgICAgICAgJHJlcXVpcmVkWyRyZXF1aXJlZC5sZW5ndGhdID0gJHByb3BlcnR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyICRyZXF1aXJlZCA9ICRzY2hlbWE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNEYXRhIHx8ICRyZXF1aXJlZC5sZW5ndGgpIHtcbiAgICAgIHZhciAkY3VycmVudEVycm9yUGF0aCA9IGl0LmVycm9yUGF0aCwgJGxvb3BSZXF1aXJlZCA9ICRpc0RhdGEgfHwgJHJlcXVpcmVkLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BSZXF1aXJlZCwgJG93blByb3BlcnRpZXMgPSBpdC5vcHRzLm93blByb3BlcnRpZXM7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgdmFyIG1pc3NpbmdcIiArICRsdmwgKyBcIjsgXCI7XG4gICAgICAgIGlmICgkbG9vcFJlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKCEkaXNEYXRhKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJHZTY2hlbWEgKyBcIiA9IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIjsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciAkaSA9IFwiaVwiICsgJGx2bCwgJHByb3BlcnR5UGF0aCA9IFwic2NoZW1hXCIgKyAkbHZsICsgXCJbXCIgKyAkaSArIFwiXVwiLCAkbWlzc2luZ1Byb3BlcnR5ID0gXCInICsgXCIgKyAkcHJvcGVydHlQYXRoICsgXCIgKyAnXCI7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQudXRpbC5nZXRQYXRoRXhwcigkY3VycmVudEVycm9yUGF0aCwgJHByb3BlcnR5UGF0aCwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJHZhbGlkICsgXCIgPSB0cnVlOyBcIjtcbiAgICAgICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIGlmIChzY2hlbWFcIiArICRsdmwgKyBcIiA9PT0gdW5kZWZpbmVkKSBcIiArICR2YWxpZCArIFwiID0gdHJ1ZTsgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hXCIgKyAkbHZsICsgXCIpKSBcIiArICR2YWxpZCArIFwiID0gZmFsc2U7IGVsc2Uge1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgZm9yICh2YXIgXCIgKyAkaSArIFwiID0gMDsgXCIgKyAkaSArIFwiIDwgXCIgKyAkdlNjaGVtYSArIFwiLmxlbmd0aDsgXCIgKyAkaSArIFwiKyspIHsgXCIgKyAkdmFsaWQgKyBcIiA9IFwiICsgJGRhdGEgKyBcIltcIiArICR2U2NoZW1hICsgXCJbXCIgKyAkaSArIFwiXV0gIT09IHVuZGVmaW5lZCBcIjtcbiAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiAmJiAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsIFwiICsgJHZTY2hlbWEgKyBcIltcIiArICRpICsgXCJdKSBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiOyBpZiAoIVwiICsgJHZhbGlkICsgXCIpIGJyZWFrOyB9IFwiO1xuICAgICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgIH0gIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgIGlmICghXCIgKyAkdmFsaWQgKyBcIikgeyAgIFwiO1xuICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICBvdXQgPSBcIlwiO1xuICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcInJlcXVpcmVkXCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiAnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ1wiO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBcInNob3VsZCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFxcXFwnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCJcXFxcJ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIicgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSBcIiB9IGVsc2UgeyBcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCIgaWYgKCBcIjtcbiAgICAgICAgICB2YXIgYXJyMiA9ICRyZXF1aXJlZDtcbiAgICAgICAgICBpZiAoYXJyMikge1xuICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgJGkgPSAtMSwgbDIgPSBhcnIyLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoJGkgPCBsMikge1xuICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIyWyRpICs9IDFdO1xuICAgICAgICAgICAgICBpZiAoJGkpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfHwgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyICRwcm9wID0gaXQudXRpbC5nZXRQcm9wZXJ0eSgkcHJvcGVydHlLZXkpLCAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICAgIG91dCArPSBcIiAoICggXCIgKyAkdXNlRGF0YSArIFwiID09PSB1bmRlZmluZWQgXCI7XG4gICAgICAgICAgICAgIGlmICgkb3duUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsICdcIiArIGl0LnV0aWwuZXNjYXBlUXVvdGVzKCRwcm9wZXJ0eUtleSkgKyBcIicpIFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIikgJiYgKG1pc3NpbmdcIiArICRsdmwgKyBcIiA9IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZyhpdC5vcHRzLmpzb25Qb2ludGVycyA/ICRwcm9wZXJ0eUtleSA6ICRwcm9wKSArIFwiKSApIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIpIHsgIFwiO1xuICAgICAgICAgIHZhciAkcHJvcGVydHlQYXRoID0gXCJtaXNzaW5nXCIgKyAkbHZsLCAkbWlzc2luZ1Byb3BlcnR5ID0gXCInICsgXCIgKyAkcHJvcGVydHlQYXRoICsgXCIgKyAnXCI7XG4gICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaXQuZXJyb3JQYXRoID0gaXQub3B0cy5qc29uUG9pbnRlcnMgPyBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCB0cnVlKSA6ICRjdXJyZW50RXJyb3JQYXRoICsgXCIgKyBcIiArICRwcm9wZXJ0eVBhdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICAgICAkJG91dFN0YWNrLnB1c2gob3V0KTtcbiAgICAgICAgICBvdXQgPSBcIlwiO1xuICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgeyBrZXl3b3JkOiAnXCIgKyBcInJlcXVpcmVkXCIgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsgbWlzc2luZ1Byb3BlcnR5OiAnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCInIH0gXCI7XG4gICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ1wiO1xuICAgICAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBcInNob3VsZCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5IFxcXFwnXCIgKyAkbWlzc2luZ1Byb3BlcnR5ICsgXCJcXFxcJ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIicgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIge30gXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoW1wiICsgX19lcnIgKyBcIl0pOyBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSBcIiB9IGVsc2UgeyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRsb29wUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAoISRpc0RhdGEpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkdlNjaGVtYSArIFwiID0gdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiOyBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyICRpID0gXCJpXCIgKyAkbHZsLCAkcHJvcGVydHlQYXRoID0gXCJzY2hlbWFcIiArICRsdmwgKyBcIltcIiArICRpICsgXCJdXCIsICRtaXNzaW5nUHJvcGVydHkgPSBcIicgKyBcIiArICRwcm9wZXJ0eVBhdGggKyBcIiArICdcIjtcbiAgICAgICAgICBpZiAoaXQub3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5KSB7XG4gICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGhFeHByKCRjdXJyZW50RXJyb3JQYXRoLCAkcHJvcGVydHlQYXRoLCBpdC5vcHRzLmpzb25Qb2ludGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgaWYgKFwiICsgJHZTY2hlbWEgKyBcIiAmJiAhQXJyYXkuaXNBcnJheShcIiArICR2U2NoZW1hICsgXCIpKSB7ICB2YXIgZXJyID0gICBcIjtcbiAgICAgICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArIFwicmVxdWlyZWRcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6ICdcIiArICRtaXNzaW5nUHJvcGVydHkgKyBcIicgfSBcIjtcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ1wiO1xuICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcImlzIGEgcmVxdWlyZWQgcHJvcGVydHlcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0ICs9IFwic2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXCdcIiArICRtaXNzaW5nUHJvcGVydHkgKyBcIlxcXFwnXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSBcIicgXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyB9IGVsc2UgaWYgKFwiICsgJHZTY2hlbWEgKyBcIiAhPT0gdW5kZWZpbmVkKSB7IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgZm9yICh2YXIgXCIgKyAkaSArIFwiID0gMDsgXCIgKyAkaSArIFwiIDwgXCIgKyAkdlNjaGVtYSArIFwiLmxlbmd0aDsgXCIgKyAkaSArIFwiKyspIHsgaWYgKFwiICsgJGRhdGEgKyBcIltcIiArICR2U2NoZW1hICsgXCJbXCIgKyAkaSArIFwiXV0gPT09IHVuZGVmaW5lZCBcIjtcbiAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB8fCAhIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcIiArICRkYXRhICsgXCIsIFwiICsgJHZTY2hlbWEgKyBcIltcIiArICRpICsgXCJdKSBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiKSB7ICB2YXIgZXJyID0gICBcIjtcbiAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJyZXF1aXJlZFwiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IG1pc3NpbmdQcm9wZXJ0eTogJ1wiICsgJG1pc3NpbmdQcm9wZXJ0eSArIFwiJyB9IFwiO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdcIjtcbiAgICAgICAgICAgICAgaWYgKGl0Lm9wdHMuX2Vycm9yRGF0YVBhdGhQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcImlzIGEgcmVxdWlyZWQgcHJvcGVydHlcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCJzaG91bGQgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSBcXFxcJ1wiICsgJG1pc3NpbmdQcm9wZXJ0eSArIFwiXFxcXCdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSB9IFwiO1xuICAgICAgICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgIH0gIFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJyMyA9ICRyZXF1aXJlZDtcbiAgICAgICAgICBpZiAoYXJyMykge1xuICAgICAgICAgICAgdmFyICRwcm9wZXJ0eUtleSwgaTMgPSAtMSwgbDMgPSBhcnIzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAoaTMgPCBsMykge1xuICAgICAgICAgICAgICAkcHJvcGVydHlLZXkgPSBhcnIzW2kzICs9IDFdO1xuICAgICAgICAgICAgICB2YXIgJHByb3AgPSBpdC51dGlsLmdldFByb3BlcnR5KCRwcm9wZXJ0eUtleSksICRtaXNzaW5nUHJvcGVydHkgPSBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpLCAkdXNlRGF0YSA9ICRkYXRhICsgJHByb3A7XG4gICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBpdC5lcnJvclBhdGggPSBpdC51dGlsLmdldFBhdGgoJGN1cnJlbnRFcnJvclBhdGgsICRwcm9wZXJ0eUtleSwgaXQub3B0cy5qc29uUG9pbnRlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG91dCArPSBcIiBpZiAoIFwiICsgJHVzZURhdGEgKyBcIiA9PT0gdW5kZWZpbmVkIFwiO1xuICAgICAgICAgICAgICBpZiAoJG93blByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gXCIgfHwgISBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXCIgKyAkZGF0YSArIFwiLCAnXCIgKyBpdC51dGlsLmVzY2FwZVF1b3RlcygkcHJvcGVydHlLZXkpICsgXCInKSBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCIpIHsgIHZhciBlcnIgPSAgIFwiO1xuICAgICAgICAgICAgICBpZiAoaXQuY3JlYXRlRXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArIFwicmVxdWlyZWRcIiArIFwiJyAsIGRhdGFQYXRoOiAoZGF0YVBhdGggfHwgJycpICsgXCIgKyBpdC5lcnJvclBhdGggKyBcIiAsIHNjaGVtYVBhdGg6IFwiICsgaXQudXRpbC50b1F1b3RlZFN0cmluZygkZXJyU2NoZW1hUGF0aCkgKyBcIiAsIHBhcmFtczogeyBtaXNzaW5nUHJvcGVydHk6ICdcIiArICRtaXNzaW5nUHJvcGVydHkgKyBcIicgfSBcIjtcbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy5tZXNzYWdlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIG91dCArPSBcIiAsIG1lc3NhZ2U6ICdcIjtcbiAgICAgICAgICAgICAgICAgIGlmIChpdC5vcHRzLl9lcnJvckRhdGFQYXRoUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwiaXMgYSByZXF1aXJlZCBwcm9wZXJ0eVwiO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IFwic2hvdWxkIGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgXFxcXCdcIiArICRtaXNzaW5nUHJvcGVydHkgKyBcIlxcXFwnXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCInIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICBvdXQgKz0gXCIgLCBzY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGggKyBcIiAsIHBhcmVudFNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyBpdC5zY2hlbWFQYXRoICsgXCIgLCBkYXRhOiBcIiArICRkYXRhICsgXCIgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvdXQgKz0gXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgfSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0LmVycm9yUGF0aCA9ICRjdXJyZW50RXJyb3JQYXRoO1xuICAgIH0gZWxzZSBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgb3V0ICs9IFwiIGlmICh0cnVlKSB7XCI7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH07XG59KTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2Fqdi9saWIvZG90anMvdW5pcXVlSXRlbXMuanNcbnZhciByZXF1aXJlX3VuaXF1ZUl0ZW1zID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfdW5pcXVlSXRlbXMoaXQsICRrZXl3b3JkLCAkcnVsZVR5cGUpIHtcbiAgICB2YXIgb3V0ID0gXCIgXCI7XG4gICAgdmFyICRsdmwgPSBpdC5sZXZlbDtcbiAgICB2YXIgJGRhdGFMdmwgPSBpdC5kYXRhTGV2ZWw7XG4gICAgdmFyICRzY2hlbWEgPSBpdC5zY2hlbWFbJGtleXdvcmRdO1xuICAgIHZhciAkc2NoZW1hUGF0aCA9IGl0LnNjaGVtYVBhdGggKyBpdC51dGlsLmdldFByb3BlcnR5KCRrZXl3b3JkKTtcbiAgICB2YXIgJGVyclNjaGVtYVBhdGggPSBpdC5lcnJTY2hlbWFQYXRoICsgXCIvXCIgKyAka2V5d29yZDtcbiAgICB2YXIgJGJyZWFrT25FcnJvciA9ICFpdC5vcHRzLmFsbEVycm9ycztcbiAgICB2YXIgJGRhdGEgPSBcImRhdGFcIiArICgkZGF0YUx2bCB8fCBcIlwiKTtcbiAgICB2YXIgJHZhbGlkID0gXCJ2YWxpZFwiICsgJGx2bDtcbiAgICB2YXIgJGlzRGF0YSA9IGl0Lm9wdHMuJGRhdGEgJiYgJHNjaGVtYSAmJiAkc2NoZW1hLiRkYXRhLCAkc2NoZW1hVmFsdWU7XG4gICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgIG91dCArPSBcIiB2YXIgc2NoZW1hXCIgKyAkbHZsICsgXCIgPSBcIiArIGl0LnV0aWwuZ2V0RGF0YSgkc2NoZW1hLiRkYXRhLCAkZGF0YUx2bCwgaXQuZGF0YVBhdGhBcnIpICsgXCI7IFwiO1xuICAgICAgJHNjaGVtYVZhbHVlID0gXCJzY2hlbWFcIiArICRsdmw7XG4gICAgfSBlbHNlIHtcbiAgICAgICRzY2hlbWFWYWx1ZSA9ICRzY2hlbWE7XG4gICAgfVxuICAgIGlmICgoJHNjaGVtYSB8fCAkaXNEYXRhKSAmJiBpdC5vcHRzLnVuaXF1ZUl0ZW1zICE9PSBmYWxzZSkge1xuICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhciBcIiArICR2YWxpZCArIFwiOyBpZiAoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiA9PT0gZmFsc2UgfHwgXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiA9PT0gdW5kZWZpbmVkKSBcIiArICR2YWxpZCArIFwiID0gdHJ1ZTsgZWxzZSBpZiAodHlwZW9mIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgIT0gJ2Jvb2xlYW4nKSBcIiArICR2YWxpZCArIFwiID0gZmFsc2U7IGVsc2UgeyBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB2YXIgaSA9IFwiICsgJGRhdGEgKyBcIi5sZW5ndGggLCBcIiArICR2YWxpZCArIFwiID0gdHJ1ZSAsIGo7IGlmIChpID4gMSkgeyBcIjtcbiAgICAgIHZhciAkaXRlbVR5cGUgPSBpdC5zY2hlbWEuaXRlbXMgJiYgaXQuc2NoZW1hLml0ZW1zLnR5cGUsICR0eXBlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoJGl0ZW1UeXBlKTtcbiAgICAgIGlmICghJGl0ZW1UeXBlIHx8ICRpdGVtVHlwZSA9PSBcIm9iamVjdFwiIHx8ICRpdGVtVHlwZSA9PSBcImFycmF5XCIgfHwgJHR5cGVJc0FycmF5ICYmICgkaXRlbVR5cGUuaW5kZXhPZihcIm9iamVjdFwiKSA+PSAwIHx8ICRpdGVtVHlwZS5pbmRleE9mKFwiYXJyYXlcIikgPj0gMCkpIHtcbiAgICAgICAgb3V0ICs9IFwiIG91dGVyOiBmb3IgKDtpLS07KSB7IGZvciAoaiA9IGk7IGotLTspIHsgaWYgKGVxdWFsKFwiICsgJGRhdGEgKyBcIltpXSwgXCIgKyAkZGF0YSArIFwiW2pdKSkgeyBcIiArICR2YWxpZCArIFwiID0gZmFsc2U7IGJyZWFrIG91dGVyOyB9IH0gfSBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiB2YXIgaXRlbUluZGljZXMgPSB7fSwgaXRlbTsgZm9yICg7aS0tOykgeyB2YXIgaXRlbSA9IFwiICsgJGRhdGEgKyBcIltpXTsgXCI7XG4gICAgICAgIHZhciAkbWV0aG9kID0gXCJjaGVja0RhdGFUeXBlXCIgKyAoJHR5cGVJc0FycmF5ID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgICAgb3V0ICs9IFwiIGlmIChcIiArIGl0LnV0aWxbJG1ldGhvZF0oJGl0ZW1UeXBlLCBcIml0ZW1cIiwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCB0cnVlKSArIFwiKSBjb250aW51ZTsgXCI7XG4gICAgICAgIGlmICgkdHlwZUlzQXJyYXkpIHtcbiAgICAgICAgICBvdXQgKz0gYCBpZiAodHlwZW9mIGl0ZW0gPT0gJ3N0cmluZycpIGl0ZW0gPSAnXCInICsgaXRlbTsgYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgaWYgKHR5cGVvZiBpdGVtSW5kaWNlc1tpdGVtXSA9PSAnbnVtYmVyJykgeyBcIiArICR2YWxpZCArIFwiID0gZmFsc2U7IGogPSBpdGVtSW5kaWNlc1tpdGVtXTsgYnJlYWs7IH0gaXRlbUluZGljZXNbaXRlbV0gPSBpOyB9IFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICBpZiAoJGlzRGF0YSkge1xuICAgICAgICBvdXQgKz0gXCIgIH0gIFwiO1xuICAgICAgfVxuICAgICAgb3V0ICs9IFwiIGlmICghXCIgKyAkdmFsaWQgKyBcIikgeyAgIFwiO1xuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSBcIlwiO1xuICAgICAgaWYgKGl0LmNyZWF0ZUVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgXCJ1bmlxdWVJdGVtc1wiICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IGk6IGksIGo6IGogfSBcIjtcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICwgbWVzc2FnZTogJ3Nob3VsZCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICcgKyBqICsgJyBhbmQgJyArIGkgKyAnIGFyZSBpZGVudGljYWwpJyBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiICwgc2NoZW1hOiAgXCI7XG4gICAgICAgICAgaWYgKCRpc0RhdGEpIHtcbiAgICAgICAgICAgIG91dCArPSBcInZhbGlkYXRlLnNjaGVtYVwiICsgJHNjaGVtYVBhdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIlwiICsgJHNjaGVtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiICAgICAgICAgLCBwYXJlbnRTY2hlbWE6IHZhbGlkYXRlLnNjaGVtYVwiICsgaXQuc2NoZW1hUGF0aCArIFwiICwgZGF0YTogXCIgKyAkZGF0YSArIFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgfVxuICAgICAgdmFyIF9fZXJyID0gb3V0O1xuICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgIGlmICghaXQuY29tcG9zaXRlUnVsZSAmJiAkYnJlYWtPbkVycm9yKSB7XG4gICAgICAgIGlmIChpdC5hc3luYykge1xuICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKFtcIiArIF9fZXJyICsgXCJdKTsgXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IFtcIiArIF9fZXJyICsgXCJdOyByZXR1cm4gZmFsc2U7IFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gXCIgdmFyIGVyciA9IFwiICsgX19lcnIgKyBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIGlmICh0cnVlKSB7IFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2luZGV4LmpzXG52YXIgcmVxdWlyZV9kb3RqcyA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAkcmVmOiByZXF1aXJlX3JlZigpLFxuICAgIGFsbE9mOiByZXF1aXJlX2FsbE9mKCksXG4gICAgYW55T2Y6IHJlcXVpcmVfYW55T2YoKSxcbiAgICAkY29tbWVudDogcmVxdWlyZV9jb21tZW50KCksXG4gICAgY29uc3Q6IHJlcXVpcmVfY29uc3QoKSxcbiAgICBjb250YWluczogcmVxdWlyZV9jb250YWlucygpLFxuICAgIGRlcGVuZGVuY2llczogcmVxdWlyZV9kZXBlbmRlbmNpZXMoKSxcbiAgICBlbnVtOiByZXF1aXJlX2VudW0oKSxcbiAgICBmb3JtYXQ6IHJlcXVpcmVfZm9ybWF0KCksXG4gICAgaWY6IHJlcXVpcmVfaWYoKSxcbiAgICBpdGVtczogcmVxdWlyZV9pdGVtcygpLFxuICAgIG1heGltdW06IHJlcXVpcmVfX2xpbWl0KCksXG4gICAgbWluaW11bTogcmVxdWlyZV9fbGltaXQoKSxcbiAgICBtYXhJdGVtczogcmVxdWlyZV9fbGltaXRJdGVtcygpLFxuICAgIG1pbkl0ZW1zOiByZXF1aXJlX19saW1pdEl0ZW1zKCksXG4gICAgbWF4TGVuZ3RoOiByZXF1aXJlX19saW1pdExlbmd0aCgpLFxuICAgIG1pbkxlbmd0aDogcmVxdWlyZV9fbGltaXRMZW5ndGgoKSxcbiAgICBtYXhQcm9wZXJ0aWVzOiByZXF1aXJlX19saW1pdFByb3BlcnRpZXMoKSxcbiAgICBtaW5Qcm9wZXJ0aWVzOiByZXF1aXJlX19saW1pdFByb3BlcnRpZXMoKSxcbiAgICBtdWx0aXBsZU9mOiByZXF1aXJlX211bHRpcGxlT2YoKSxcbiAgICBub3Q6IHJlcXVpcmVfbm90KCksXG4gICAgb25lT2Y6IHJlcXVpcmVfb25lT2YoKSxcbiAgICBwYXR0ZXJuOiByZXF1aXJlX3BhdHRlcm4oKSxcbiAgICBwcm9wZXJ0aWVzOiByZXF1aXJlX3Byb3BlcnRpZXMoKSxcbiAgICBwcm9wZXJ0eU5hbWVzOiByZXF1aXJlX3Byb3BlcnR5TmFtZXMoKSxcbiAgICByZXF1aXJlZDogcmVxdWlyZV9yZXF1aXJlZCgpLFxuICAgIHVuaXF1ZUl0ZW1zOiByZXF1aXJlX3VuaXF1ZUl0ZW1zKCksXG4gICAgdmFsaWRhdGU6IHJlcXVpcmVfdmFsaWRhdGUoKVxuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcnVsZXMuanNcbnZhciByZXF1aXJlX3J1bGVzID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciBydWxlTW9kdWxlcyA9IHJlcXVpcmVfZG90anMoKTtcbiAgdmFyIHRvSGFzaCA9IHJlcXVpcmVfdXRpbCgpLnRvSGFzaDtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBydWxlcygpIHtcbiAgICB2YXIgUlVMRVMgPSBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHJ1bGVzOiBbXG4gICAgICAgICAgeyBtYXhpbXVtOiBbXCJleGNsdXNpdmVNYXhpbXVtXCJdIH0sXG4gICAgICAgICAgeyBtaW5pbXVtOiBbXCJleGNsdXNpdmVNaW5pbXVtXCJdIH0sXG4gICAgICAgICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgXCJmb3JtYXRcIlxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBydWxlczogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCIsIFwicGF0dGVyblwiLCBcImZvcm1hdFwiXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBydWxlczogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiLCBcIml0ZW1zXCIsIFwiY29udGFpbnNcIiwgXCJ1bmlxdWVJdGVtc1wiXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgcnVsZXM6IFtcbiAgICAgICAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICAgICAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICAgICAgICBcInJlcXVpcmVkXCIsXG4gICAgICAgICAgXCJkZXBlbmRlbmNpZXNcIixcbiAgICAgICAgICBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICB7IHByb3BlcnRpZXM6IFtcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsIFwicGF0dGVyblByb3BlcnRpZXNcIl0gfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgeyBydWxlczogW1wiJHJlZlwiLCBcImNvbnN0XCIsIFwiZW51bVwiLCBcIm5vdFwiLCBcImFueU9mXCIsIFwib25lT2ZcIiwgXCJhbGxPZlwiLCBcImlmXCJdIH1cbiAgICBdO1xuICAgIHZhciBBTEwgPSBbXCJ0eXBlXCIsIFwiJGNvbW1lbnRcIl07XG4gICAgdmFyIEtFWVdPUkRTID0gW1xuICAgICAgXCIkc2NoZW1hXCIsXG4gICAgICBcIiRpZFwiLFxuICAgICAgXCJpZFwiLFxuICAgICAgXCIkZGF0YVwiLFxuICAgICAgXCIkYXN5bmNcIixcbiAgICAgIFwidGl0bGVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICAgIFwiZGVmYXVsdFwiLFxuICAgICAgXCJkZWZpbml0aW9uc1wiLFxuICAgICAgXCJleGFtcGxlc1wiLFxuICAgICAgXCJyZWFkT25seVwiLFxuICAgICAgXCJ3cml0ZU9ubHlcIixcbiAgICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICAgIFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgICBcInRoZW5cIixcbiAgICAgIFwiZWxzZVwiXG4gICAgXTtcbiAgICB2YXIgVFlQRVMgPSBbXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwic3RyaW5nXCIsIFwiYXJyYXlcIiwgXCJvYmplY3RcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXTtcbiAgICBSVUxFUy5hbGwgPSB0b0hhc2goQUxMKTtcbiAgICBSVUxFUy50eXBlcyA9IHRvSGFzaChUWVBFUyk7XG4gICAgUlVMRVMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgZ3JvdXAucnVsZXMgPSBncm91cC5ydWxlcy5tYXAoZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgICB2YXIgaW1wbEtleXdvcmRzO1xuICAgICAgICBpZiAodHlwZW9mIGtleXdvcmQgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHZhciBrZXkgPSBPYmplY3Qua2V5cyhrZXl3b3JkKVswXTtcbiAgICAgICAgICBpbXBsS2V5d29yZHMgPSBrZXl3b3JkW2tleV07XG4gICAgICAgICAga2V5d29yZCA9IGtleTtcbiAgICAgICAgICBpbXBsS2V5d29yZHMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICBBTEwucHVzaChrKTtcbiAgICAgICAgICAgIFJVTEVTLmFsbFtrXSA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQUxMLnB1c2goa2V5d29yZCk7XG4gICAgICAgIHZhciBydWxlID0gUlVMRVMuYWxsW2tleXdvcmRdID0ge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgY29kZTogcnVsZU1vZHVsZXNba2V5d29yZF0sXG4gICAgICAgICAgaW1wbGVtZW50czogaW1wbEtleXdvcmRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgICAgfSk7XG4gICAgICBSVUxFUy5hbGwuJGNvbW1lbnQgPSB7XG4gICAgICAgIGtleXdvcmQ6IFwiJGNvbW1lbnRcIixcbiAgICAgICAgY29kZTogcnVsZU1vZHVsZXMuJGNvbW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAoZ3JvdXAudHlwZSlcbiAgICAgICAgUlVMRVMudHlwZXNbZ3JvdXAudHlwZV0gPSBncm91cDtcbiAgICB9KTtcbiAgICBSVUxFUy5rZXl3b3JkcyA9IHRvSGFzaChBTEwuY29uY2F0KEtFWVdPUkRTKSk7XG4gICAgUlVMRVMuY3VzdG9tID0ge307XG4gICAgcmV0dXJuIFJVTEVTO1xuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RhdGEuanNcbnZhciByZXF1aXJlX2RhdGEgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgdmFyIEtFWVdPUkRTID0gW1xuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiLFxuICAgIFwibWluaW11bVwiLFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICBcImNvbnN0XCJcbiAgXTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRhU2NoZW1hLCBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgIGZvciAodmFyIGkgPSAwO2kgPCBrZXl3b3Jkc0pzb25Qb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpO1xuICAgICAgdmFyIHNlZ21lbnRzID0ga2V5d29yZHNKc29uUG9pbnRlcnNbaV0uc3BsaXQoXCIvXCIpO1xuICAgICAgdmFyIGtleXdvcmRzID0gbWV0YVNjaGVtYTtcbiAgICAgIHZhciBqO1xuICAgICAgZm9yIChqID0gMTtqIDwgc2VnbWVudHMubGVuZ3RoOyBqKyspXG4gICAgICAgIGtleXdvcmRzID0ga2V5d29yZHNbc2VnbWVudHNbal1dO1xuICAgICAgZm9yIChqID0gMDtqIDwgS0VZV09SRFMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIGtleSA9IEtFWVdPUkRTW2pdO1xuICAgICAgICB2YXIgc2NoZW1hID0ga2V5d29yZHNba2V5XTtcbiAgICAgICAgaWYgKHNjaGVtYSkge1xuICAgICAgICAgIGtleXdvcmRzW2tleV0gPSB7XG4gICAgICAgICAgICBhbnlPZjogW1xuICAgICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICAgIHsgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIiB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0YVNjaGVtYTtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2FzeW5jLmpzXG52YXIgcmVxdWlyZV9hc3luYyA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICB2YXIgTWlzc2luZ1JlZkVycm9yID0gcmVxdWlyZV9lcnJvcl9jbGFzc2VzKCkuTWlzc2luZ1JlZjtcbiAgbW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQXN5bmM7XG4gIGZ1bmN0aW9uIGNvbXBpbGVBc3luYyhzY2hlbWEsIG1ldGEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRoaXMuX29wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIik7XG4gICAgaWYgKHR5cGVvZiBtZXRhID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY2FsbGJhY2sgPSBtZXRhO1xuICAgICAgbWV0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHAgPSBsb2FkTWV0YVNjaGVtYU9mKHNjaGVtYSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzY2hlbWFPYmogPSBzZWxmMi5fYWRkU2NoZW1hKHNjaGVtYSwgdW5kZWZpbmVkLCBtZXRhKTtcbiAgICAgIHJldHVybiBzY2hlbWFPYmoudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopO1xuICAgIH0pO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgcC50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdik7XG4gICAgICB9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICAgIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hT2Yoc2NoKSB7XG4gICAgICB2YXIgJHNjaGVtYSA9IHNjaC4kc2NoZW1hO1xuICAgICAgcmV0dXJuICRzY2hlbWEgJiYgIXNlbGYyLmdldFNjaGVtYSgkc2NoZW1hKSA/IGNvbXBpbGVBc3luYy5jYWxsKHNlbGYyLCB7ICRyZWY6ICRzY2hlbWEgfSwgdHJ1ZSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmMi5fY29tcGlsZShzY2hlbWFPYmopO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIE1pc3NpbmdSZWZFcnJvcilcbiAgICAgICAgICByZXR1cm4gbG9hZE1pc3NpbmdTY2hlbWEoZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYShlKSB7XG4gICAgICAgIHZhciByZWYgPSBlLm1pc3NpbmdTY2hlbWE7XG4gICAgICAgIGlmIChhZGRlZChyZWYpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBcIiArIHJlZiArIFwiIGlzIGxvYWRlZCBidXQgXCIgKyBlLm1pc3NpbmdSZWYgKyBcIiBjYW5ub3QgYmUgcmVzb2x2ZWRcIik7XG4gICAgICAgIHZhciBzY2hlbWFQcm9taXNlID0gc2VsZjIuX2xvYWRpbmdTY2hlbWFzW3JlZl07XG4gICAgICAgIGlmICghc2NoZW1hUHJvbWlzZSkge1xuICAgICAgICAgIHNjaGVtYVByb21pc2UgPSBzZWxmMi5fbG9hZGluZ1NjaGVtYXNbcmVmXSA9IHNlbGYyLl9vcHRzLmxvYWRTY2hlbWEocmVmKTtcbiAgICAgICAgICBzY2hlbWFQcm9taXNlLnRoZW4ocmVtb3ZlUHJvbWlzZSwgcmVtb3ZlUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYVByb21pc2UudGhlbihmdW5jdGlvbihzY2gpIHtcbiAgICAgICAgICBpZiAoIWFkZGVkKHJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkTWV0YVNjaGVtYU9mKHNjaCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCFhZGRlZChyZWYpKVxuICAgICAgICAgICAgICAgIHNlbGYyLmFkZFNjaGVtYShzY2gsIHJlZiwgdW5kZWZpbmVkLCBtZXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYyhzY2hlbWFPYmopO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlUHJvbWlzZSgpIHtcbiAgICAgICAgICBkZWxldGUgc2VsZjIuX2xvYWRpbmdTY2hlbWFzW3JlZl07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkZWQocmVmMikge1xuICAgICAgICAgIHJldHVybiBzZWxmMi5fcmVmc1tyZWYyXSB8fCBzZWxmMi5fc2NoZW1hc1tyZWYyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RvdGpzL2N1c3RvbS5qc1xudmFyIHJlcXVpcmVfY3VzdG9tID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2VuZXJhdGVfY3VzdG9tKGl0LCAka2V5d29yZCwgJHJ1bGVUeXBlKSB7XG4gICAgdmFyIG91dCA9IFwiIFwiO1xuICAgIHZhciAkbHZsID0gaXQubGV2ZWw7XG4gICAgdmFyICRkYXRhTHZsID0gaXQuZGF0YUxldmVsO1xuICAgIHZhciAkc2NoZW1hID0gaXQuc2NoZW1hWyRrZXl3b3JkXTtcbiAgICB2YXIgJHNjaGVtYVBhdGggPSBpdC5zY2hlbWFQYXRoICsgaXQudXRpbC5nZXRQcm9wZXJ0eSgka2V5d29yZCk7XG4gICAgdmFyICRlcnJTY2hlbWFQYXRoID0gaXQuZXJyU2NoZW1hUGF0aCArIFwiL1wiICsgJGtleXdvcmQ7XG4gICAgdmFyICRicmVha09uRXJyb3IgPSAhaXQub3B0cy5hbGxFcnJvcnM7XG4gICAgdmFyICRlcnJvcktleXdvcmQ7XG4gICAgdmFyICRkYXRhID0gXCJkYXRhXCIgKyAoJGRhdGFMdmwgfHwgXCJcIik7XG4gICAgdmFyICR2YWxpZCA9IFwidmFsaWRcIiArICRsdmw7XG4gICAgdmFyICRlcnJzID0gXCJlcnJzX19cIiArICRsdmw7XG4gICAgdmFyICRpc0RhdGEgPSBpdC5vcHRzLiRkYXRhICYmICRzY2hlbWEgJiYgJHNjaGVtYS4kZGF0YSwgJHNjaGVtYVZhbHVlO1xuICAgIGlmICgkaXNEYXRhKSB7XG4gICAgICBvdXQgKz0gXCIgdmFyIHNjaGVtYVwiICsgJGx2bCArIFwiID0gXCIgKyBpdC51dGlsLmdldERhdGEoJHNjaGVtYS4kZGF0YSwgJGRhdGFMdmwsIGl0LmRhdGFQYXRoQXJyKSArIFwiOyBcIjtcbiAgICAgICRzY2hlbWFWYWx1ZSA9IFwic2NoZW1hXCIgKyAkbHZsO1xuICAgIH0gZWxzZSB7XG4gICAgICAkc2NoZW1hVmFsdWUgPSAkc2NoZW1hO1xuICAgIH1cbiAgICB2YXIgJHJ1bGUgPSB0aGlzLCAkZGVmaW5pdGlvbiA9IFwiZGVmaW5pdGlvblwiICsgJGx2bCwgJHJEZWYgPSAkcnVsZS5kZWZpbml0aW9uLCAkY2xvc2luZ0JyYWNlcyA9IFwiXCI7XG4gICAgdmFyICRjb21waWxlLCAkaW5saW5lLCAkbWFjcm8sICRydWxlVmFsaWRhdGUsICR2YWxpZGF0ZUNvZGU7XG4gICAgaWYgKCRpc0RhdGEgJiYgJHJEZWYuJGRhdGEpIHtcbiAgICAgICR2YWxpZGF0ZUNvZGUgPSBcImtleXdvcmRWYWxpZGF0ZVwiICsgJGx2bDtcbiAgICAgIHZhciAkdmFsaWRhdGVTY2hlbWEgPSAkckRlZi52YWxpZGF0ZVNjaGVtYTtcbiAgICAgIG91dCArPSBcIiB2YXIgXCIgKyAkZGVmaW5pdGlvbiArIFwiID0gUlVMRVMuY3VzdG9tWydcIiArICRrZXl3b3JkICsgXCInXS5kZWZpbml0aW9uOyB2YXIgXCIgKyAkdmFsaWRhdGVDb2RlICsgXCIgPSBcIiArICRkZWZpbml0aW9uICsgXCIudmFsaWRhdGU7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICRydWxlVmFsaWRhdGUgPSBpdC51c2VDdXN0b21SdWxlKCRydWxlLCAkc2NoZW1hLCBpdC5zY2hlbWEsIGl0KTtcbiAgICAgIGlmICghJHJ1bGVWYWxpZGF0ZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgJHNjaGVtYVZhbHVlID0gXCJ2YWxpZGF0ZS5zY2hlbWFcIiArICRzY2hlbWFQYXRoO1xuICAgICAgJHZhbGlkYXRlQ29kZSA9ICRydWxlVmFsaWRhdGUuY29kZTtcbiAgICAgICRjb21waWxlID0gJHJEZWYuY29tcGlsZTtcbiAgICAgICRpbmxpbmUgPSAkckRlZi5pbmxpbmU7XG4gICAgICAkbWFjcm8gPSAkckRlZi5tYWNybztcbiAgICB9XG4gICAgdmFyICRydWxlRXJycyA9ICR2YWxpZGF0ZUNvZGUgKyBcIi5lcnJvcnNcIiwgJGkgPSBcImlcIiArICRsdmwsICRydWxlRXJyID0gXCJydWxlRXJyXCIgKyAkbHZsLCAkYXN5bmNLZXl3b3JkID0gJHJEZWYuYXN5bmM7XG4gICAgaWYgKCRhc3luY0tleXdvcmQgJiYgIWl0LmFzeW5jKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKTtcbiAgICBpZiAoISgkaW5saW5lIHx8ICRtYWNybykpIHtcbiAgICAgIG91dCArPSBcIlwiICsgJHJ1bGVFcnJzICsgXCIgPSBudWxsO1wiO1xuICAgIH1cbiAgICBvdXQgKz0gXCJ2YXIgXCIgKyAkZXJycyArIFwiID0gZXJyb3JzO3ZhciBcIiArICR2YWxpZCArIFwiO1wiO1xuICAgIGlmICgkaXNEYXRhICYmICRyRGVmLiRkYXRhKSB7XG4gICAgICAkY2xvc2luZ0JyYWNlcyArPSBcIn1cIjtcbiAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkc2NoZW1hVmFsdWUgKyBcIiA9PT0gdW5kZWZpbmVkKSB7IFwiICsgJHZhbGlkICsgXCIgPSB0cnVlOyB9IGVsc2UgeyBcIjtcbiAgICAgIGlmICgkdmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgJGNsb3NpbmdCcmFjZXMgKz0gXCJ9XCI7XG4gICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gXCIgKyAkZGVmaW5pdGlvbiArIFwiLnZhbGlkYXRlU2NoZW1hKFwiICsgJHNjaGVtYVZhbHVlICsgXCIpOyBpZiAoXCIgKyAkdmFsaWQgKyBcIikgeyBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpbmxpbmUpIHtcbiAgICAgIGlmICgkckRlZi5zdGF0ZW1lbnRzKSB7XG4gICAgICAgIG91dCArPSBcIiBcIiArICRydWxlVmFsaWRhdGUudmFsaWRhdGUgKyBcIiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiBcIiArICR2YWxpZCArIFwiID0gXCIgKyAkcnVsZVZhbGlkYXRlLnZhbGlkYXRlICsgXCI7IFwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJG1hY3JvKSB7XG4gICAgICB2YXIgJGl0ID0gaXQudXRpbC5jb3B5KGl0KTtcbiAgICAgIHZhciAkY2xvc2luZ0JyYWNlcyA9IFwiXCI7XG4gICAgICAkaXQubGV2ZWwrKztcbiAgICAgIHZhciAkbmV4dFZhbGlkID0gXCJ2YWxpZFwiICsgJGl0LmxldmVsO1xuICAgICAgJGl0LnNjaGVtYSA9ICRydWxlVmFsaWRhdGUudmFsaWRhdGU7XG4gICAgICAkaXQuc2NoZW1hUGF0aCA9IFwiXCI7XG4gICAgICB2YXIgJHdhc0NvbXBvc2l0ZSA9IGl0LmNvbXBvc2l0ZVJ1bGU7XG4gICAgICBpdC5jb21wb3NpdGVSdWxlID0gJGl0LmNvbXBvc2l0ZVJ1bGUgPSB0cnVlO1xuICAgICAgdmFyICRjb2RlID0gaXQudmFsaWRhdGUoJGl0KS5yZXBsYWNlKC92YWxpZGF0ZVxcLnNjaGVtYS9nLCAkdmFsaWRhdGVDb2RlKTtcbiAgICAgIGl0LmNvbXBvc2l0ZVJ1bGUgPSAkaXQuY29tcG9zaXRlUnVsZSA9ICR3YXNDb21wb3NpdGU7XG4gICAgICBvdXQgKz0gXCIgXCIgKyAkY29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyICQkb3V0U3RhY2sgPSAkJG91dFN0YWNrIHx8IFtdO1xuICAgICAgJCRvdXRTdGFjay5wdXNoKG91dCk7XG4gICAgICBvdXQgPSBcIlwiO1xuICAgICAgb3V0ICs9IFwiICBcIiArICR2YWxpZGF0ZUNvZGUgKyBcIi5jYWxsKCBcIjtcbiAgICAgIGlmIChpdC5vcHRzLnBhc3NDb250ZXh0KSB7XG4gICAgICAgIG91dCArPSBcInRoaXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcInNlbGZcIjtcbiAgICAgIH1cbiAgICAgIGlmICgkY29tcGlsZSB8fCAkckRlZi5zY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiAsIFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiAsIFwiICsgJHNjaGVtYVZhbHVlICsgXCIgLCBcIiArICRkYXRhICsgXCIgLCB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiBcIjtcbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiAsIChkYXRhUGF0aCB8fCAnJylcIjtcbiAgICAgIGlmIChpdC5lcnJvclBhdGggIT0gJ1wiXCInKSB7XG4gICAgICAgIG91dCArPSBcIiArIFwiICsgaXQuZXJyb3JQYXRoO1xuICAgICAgfVxuICAgICAgdmFyICRwYXJlbnREYXRhID0gJGRhdGFMdmwgPyBcImRhdGFcIiArICgkZGF0YUx2bCAtIDEgfHwgXCJcIikgOiBcInBhcmVudERhdGFcIiwgJHBhcmVudERhdGFQcm9wZXJ0eSA9ICRkYXRhTHZsID8gaXQuZGF0YVBhdGhBcnJbJGRhdGFMdmxdIDogXCJwYXJlbnREYXRhUHJvcGVydHlcIjtcbiAgICAgIG91dCArPSBcIiAsIFwiICsgJHBhcmVudERhdGEgKyBcIiAsIFwiICsgJHBhcmVudERhdGFQcm9wZXJ0eSArIFwiICwgcm9vdERhdGEgKSAgXCI7XG4gICAgICB2YXIgZGVmX2NhbGxSdWxlVmFsaWRhdGUgPSBvdXQ7XG4gICAgICBvdXQgPSAkJG91dFN0YWNrLnBvcCgpO1xuICAgICAgaWYgKCRyRGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgJHZhbGlkICsgXCIgPSBcIjtcbiAgICAgICAgaWYgKCRhc3luY0tleXdvcmQpIHtcbiAgICAgICAgICBvdXQgKz0gXCJhd2FpdCBcIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCJcIiArIGRlZl9jYWxsUnVsZVZhbGlkYXRlICsgXCI7IFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRhc3luY0tleXdvcmQpIHtcbiAgICAgICAgICAkcnVsZUVycnMgPSBcImN1c3RvbUVycm9yc1wiICsgJGx2bDtcbiAgICAgICAgICBvdXQgKz0gXCIgdmFyIFwiICsgJHJ1bGVFcnJzICsgXCIgPSBudWxsOyB0cnkgeyBcIiArICR2YWxpZCArIFwiID0gYXdhaXQgXCIgKyBkZWZfY2FsbFJ1bGVWYWxpZGF0ZSArIFwiOyB9IGNhdGNoIChlKSB7IFwiICsgJHZhbGlkICsgXCIgPSBmYWxzZTsgaWYgKGUgaW5zdGFuY2VvZiBWYWxpZGF0aW9uRXJyb3IpIFwiICsgJHJ1bGVFcnJzICsgXCIgPSBlLmVycm9yczsgZWxzZSB0aHJvdyBlOyB9IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArICRydWxlRXJycyArIFwiID0gbnVsbDsgXCIgKyAkdmFsaWQgKyBcIiA9IFwiICsgZGVmX2NhbGxSdWxlVmFsaWRhdGUgKyBcIjsgXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRyRGVmLm1vZGlmeWluZykge1xuICAgICAgb3V0ICs9IFwiIGlmIChcIiArICRwYXJlbnREYXRhICsgXCIpIFwiICsgJGRhdGEgKyBcIiA9IFwiICsgJHBhcmVudERhdGEgKyBcIltcIiArICRwYXJlbnREYXRhUHJvcGVydHkgKyBcIl07XCI7XG4gICAgfVxuICAgIG91dCArPSBcIlwiICsgJGNsb3NpbmdCcmFjZXM7XG4gICAgaWYgKCRyRGVmLnZhbGlkKSB7XG4gICAgICBpZiAoJGJyZWFrT25FcnJvcikge1xuICAgICAgICBvdXQgKz0gXCIgaWYgKHRydWUpIHsgXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSBcIiBpZiAoIFwiO1xuICAgICAgaWYgKCRyRGVmLnZhbGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0ICs9IFwiICFcIjtcbiAgICAgICAgaWYgKCRtYWNybykge1xuICAgICAgICAgIG91dCArPSBcIlwiICsgJG5leHRWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQgKz0gXCJcIiArICR2YWxpZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIFwiICsgISRyRGVmLnZhbGlkICsgXCIgXCI7XG4gICAgICB9XG4gICAgICBvdXQgKz0gXCIpIHsgXCI7XG4gICAgICAkZXJyb3JLZXl3b3JkID0gJHJ1bGUua2V5d29yZDtcbiAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgb3V0ID0gXCJcIjtcbiAgICAgIHZhciAkJG91dFN0YWNrID0gJCRvdXRTdGFjayB8fCBbXTtcbiAgICAgICQkb3V0U3RhY2sucHVzaChvdXQpO1xuICAgICAgb3V0ID0gXCJcIjtcbiAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgIG91dCArPSBcIiB7IGtleXdvcmQ6ICdcIiArICgkZXJyb3JLZXl3b3JkIHx8IFwiY3VzdG9tXCIpICsgXCInICwgZGF0YVBhdGg6IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiICwgc2NoZW1hUGF0aDogXCIgKyBpdC51dGlsLnRvUXVvdGVkU3RyaW5nKCRlcnJTY2hlbWFQYXRoKSArIFwiICwgcGFyYW1zOiB7IGtleXdvcmQ6ICdcIiArICRydWxlLmtleXdvcmQgKyBcIicgfSBcIjtcbiAgICAgICAgaWYgKGl0Lm9wdHMubWVzc2FnZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9IGAgLCBtZXNzYWdlOiAnc2hvdWxkIHBhc3MgXCJgICsgJHJ1bGUua2V5d29yZCArIGBcIiBrZXl3b3JkIHZhbGlkYXRpb24nIGA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gXCIgfSBcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSBcIiB7fSBcIjtcbiAgICAgIH1cbiAgICAgIHZhciBfX2VyciA9IG91dDtcbiAgICAgIG91dCA9ICQkb3V0U3RhY2sucG9wKCk7XG4gICAgICBpZiAoIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgJGJyZWFrT25FcnJvcikge1xuICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICBvdXQgKz0gXCIgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcihbXCIgKyBfX2VyciArIFwiXSk7IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiB2YWxpZGF0ZS5lcnJvcnMgPSBbXCIgKyBfX2VyciArIFwiXTsgcmV0dXJuIGZhbHNlOyBcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IFwiIHZhciBlcnIgPSBcIiArIF9fZXJyICsgXCI7ICBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFtlcnJdOyBlbHNlIHZFcnJvcnMucHVzaChlcnIpOyBlcnJvcnMrKzsgXCI7XG4gICAgICB9XG4gICAgICB2YXIgZGVmX2N1c3RvbUVycm9yID0gb3V0O1xuICAgICAgb3V0ID0gJCRvdXRTdGFjay5wb3AoKTtcbiAgICAgIGlmICgkaW5saW5lKSB7XG4gICAgICAgIGlmICgkckRlZi5lcnJvcnMpIHtcbiAgICAgICAgICBpZiAoJHJEZWYuZXJyb3JzICE9IFwiZnVsbFwiKSB7XG4gICAgICAgICAgICBvdXQgKz0gXCIgIGZvciAodmFyIFwiICsgJGkgKyBcIj1cIiArICRlcnJzICsgXCI7IFwiICsgJGkgKyBcIjxlcnJvcnM7IFwiICsgJGkgKyBcIisrKSB7IHZhciBcIiArICRydWxlRXJyICsgXCIgPSB2RXJyb3JzW1wiICsgJGkgKyBcIl07IGlmIChcIiArICRydWxlRXJyICsgXCIuZGF0YVBhdGggPT09IHVuZGVmaW5lZCkgXCIgKyAkcnVsZUVyciArIFwiLmRhdGFQYXRoID0gKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCI7IGlmIChcIiArICRydWxlRXJyICsgXCIuc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkKSB7IFwiICsgJHJ1bGVFcnIgKyAnLnNjaGVtYVBhdGggPSBcIicgKyAkZXJyU2NoZW1hUGF0aCArICdcIjsgfSAnO1xuICAgICAgICAgICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgICAgICAgICBvdXQgKz0gXCIgXCIgKyAkcnVsZUVyciArIFwiLnNjaGVtYSA9IFwiICsgJHNjaGVtYVZhbHVlICsgXCI7IFwiICsgJHJ1bGVFcnIgKyBcIi5kYXRhID0gXCIgKyAkZGF0YSArIFwiOyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoJHJEZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgZGVmX2N1c3RvbUVycm9yICsgXCIgXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dCArPSBcIiBpZiAoXCIgKyAkZXJycyArIFwiID09IGVycm9ycykgeyBcIiArIGRlZl9jdXN0b21FcnJvciArIFwiIH0gZWxzZSB7ICBmb3IgKHZhciBcIiArICRpICsgXCI9XCIgKyAkZXJycyArIFwiOyBcIiArICRpICsgXCI8ZXJyb3JzOyBcIiArICRpICsgXCIrKykgeyB2YXIgXCIgKyAkcnVsZUVyciArIFwiID0gdkVycm9yc1tcIiArICRpICsgXCJdOyBpZiAoXCIgKyAkcnVsZUVyciArIFwiLmRhdGFQYXRoID09PSB1bmRlZmluZWQpIFwiICsgJHJ1bGVFcnIgKyBcIi5kYXRhUGF0aCA9IChkYXRhUGF0aCB8fCAnJykgKyBcIiArIGl0LmVycm9yUGF0aCArIFwiOyBpZiAoXCIgKyAkcnVsZUVyciArIFwiLnNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCkgeyBcIiArICRydWxlRXJyICsgJy5zY2hlbWFQYXRoID0gXCInICsgJGVyclNjaGVtYVBhdGggKyAnXCI7IH0gJztcbiAgICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgb3V0ICs9IFwiIFwiICsgJHJ1bGVFcnIgKyBcIi5zY2hlbWEgPSBcIiArICRzY2hlbWFWYWx1ZSArIFwiOyBcIiArICRydWxlRXJyICsgXCIuZGF0YSA9IFwiICsgJGRhdGEgKyBcIjsgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gXCIgfSB9IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgkbWFjcm8pIHtcbiAgICAgICAgb3V0ICs9IFwiICAgdmFyIGVyciA9ICAgXCI7XG4gICAgICAgIGlmIChpdC5jcmVhdGVFcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHsga2V5d29yZDogJ1wiICsgKCRlcnJvcktleXdvcmQgfHwgXCJjdXN0b21cIikgKyBcIicgLCBkYXRhUGF0aDogKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCIgLCBzY2hlbWFQYXRoOiBcIiArIGl0LnV0aWwudG9RdW90ZWRTdHJpbmcoJGVyclNjaGVtYVBhdGgpICsgXCIgLCBwYXJhbXM6IHsga2V5d29yZDogJ1wiICsgJHJ1bGUua2V5d29yZCArIFwiJyB9IFwiO1xuICAgICAgICAgIGlmIChpdC5vcHRzLm1lc3NhZ2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgLCBtZXNzYWdlOiAnc2hvdWxkIHBhc3MgXCJgICsgJHJ1bGUua2V5d29yZCArIGBcIiBrZXl3b3JkIHZhbGlkYXRpb24nIGA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiAsIHNjaGVtYTogdmFsaWRhdGUuc2NoZW1hXCIgKyAkc2NoZW1hUGF0aCArIFwiICwgcGFyZW50U2NoZW1hOiB2YWxpZGF0ZS5zY2hlbWFcIiArIGl0LnNjaGVtYVBhdGggKyBcIiAsIGRhdGE6IFwiICsgJGRhdGEgKyBcIiBcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ICs9IFwiIH0gXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ICs9IFwiIHt9IFwiO1xuICAgICAgICB9XG4gICAgICAgIG91dCArPSBcIjsgIGlmICh2RXJyb3JzID09PSBudWxsKSB2RXJyb3JzID0gW2Vycl07IGVsc2UgdkVycm9ycy5wdXNoKGVycik7IGVycm9ycysrOyBcIjtcbiAgICAgICAgaWYgKCFpdC5jb21wb3NpdGVSdWxlICYmICRicmVha09uRXJyb3IpIHtcbiAgICAgICAgICBpZiAoaXQuYXN5bmMpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKHZFcnJvcnMpOyBcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0ICs9IFwiIHZhbGlkYXRlLmVycm9ycyA9IHZFcnJvcnM7IHJldHVybiBmYWxzZTsgXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJHJEZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICAgIG91dCArPSBcIiBcIiArIGRlZl9jdXN0b21FcnJvciArIFwiIFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCArPSBcIiBpZiAoQXJyYXkuaXNBcnJheShcIiArICRydWxlRXJycyArIFwiKSkgeyBpZiAodkVycm9ycyA9PT0gbnVsbCkgdkVycm9ycyA9IFwiICsgJHJ1bGVFcnJzICsgXCI7IGVsc2UgdkVycm9ycyA9IHZFcnJvcnMuY29uY2F0KFwiICsgJHJ1bGVFcnJzICsgXCIpOyBlcnJvcnMgPSB2RXJyb3JzLmxlbmd0aDsgIGZvciAodmFyIFwiICsgJGkgKyBcIj1cIiArICRlcnJzICsgXCI7IFwiICsgJGkgKyBcIjxlcnJvcnM7IFwiICsgJGkgKyBcIisrKSB7IHZhciBcIiArICRydWxlRXJyICsgXCIgPSB2RXJyb3JzW1wiICsgJGkgKyBcIl07IGlmIChcIiArICRydWxlRXJyICsgXCIuZGF0YVBhdGggPT09IHVuZGVmaW5lZCkgXCIgKyAkcnVsZUVyciArIFwiLmRhdGFQYXRoID0gKGRhdGFQYXRoIHx8ICcnKSArIFwiICsgaXQuZXJyb3JQYXRoICsgXCI7ICBcIiArICRydWxlRXJyICsgJy5zY2hlbWFQYXRoID0gXCInICsgJGVyclNjaGVtYVBhdGggKyAnXCI7ICAnO1xuICAgICAgICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIG91dCArPSBcIiBcIiArICRydWxlRXJyICsgXCIuc2NoZW1hID0gXCIgKyAkc2NoZW1hVmFsdWUgKyBcIjsgXCIgKyAkcnVsZUVyciArIFwiLmRhdGEgPSBcIiArICRkYXRhICsgXCI7IFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gXCIgfSB9IGVsc2UgeyBcIiArIGRlZl9jdXN0b21FcnJvciArIFwiIH0gXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG91dCArPSBcIiB9IFwiO1xuICAgICAgaWYgKCRicmVha09uRXJyb3IpIHtcbiAgICAgICAgb3V0ICs9IFwiIGVsc2UgeyBcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb25cbnZhciByZXF1aXJlX2pzb25fc2NoZW1hX2RyYWZ0XzA3ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgJGlkOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgIHRpdGxlOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gICAgZGVmaW5pdGlvbnM6IHtcbiAgICAgIHNjaGVtYUFycmF5OiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgbWluSXRlbXM6IDEsXG4gICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiI1wiIH1cbiAgICAgIH0sXG4gICAgICBub25OZWdhdGl2ZUludGVnZXI6IHtcbiAgICAgICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgICAgIG1pbmltdW06IDBcbiAgICAgIH0sXG4gICAgICBub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MDoge1xuICAgICAgICBhbGxPZjogW1xuICAgICAgICAgIHsgJHJlZjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwiIH0sXG4gICAgICAgICAgeyBkZWZhdWx0OiAwIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHNpbXBsZVR5cGVzOiB7XG4gICAgICAgIGVudW06IFtcbiAgICAgICAgICBcImFycmF5XCIsXG4gICAgICAgICAgXCJib29sZWFuXCIsXG4gICAgICAgICAgXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJudWxsXCIsXG4gICAgICAgICAgXCJudW1iZXJcIixcbiAgICAgICAgICBcIm9iamVjdFwiLFxuICAgICAgICAgIFwic3RyaW5nXCJcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHN0cmluZ0FycmF5OiB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgICAgICAgZGVmYXVsdDogW11cbiAgICAgIH1cbiAgICB9LFxuICAgIHR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gICAgcHJvcGVydGllczoge1xuICAgICAgJGlkOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICAgIH0sXG4gICAgICAkc2NoZW1hOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1cmlcIlxuICAgICAgfSxcbiAgICAgICRyZWY6IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInVyaS1yZWZlcmVuY2VcIlxuICAgICAgfSxcbiAgICAgICRjb21tZW50OiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICByZWFkT25seToge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBleGFtcGxlczoge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGl0ZW1zOiB0cnVlXG4gICAgICB9LFxuICAgICAgbXVsdGlwbGVPZjoge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBleGNsdXNpdmVNaW5pbXVtOiAwXG4gICAgICB9LFxuICAgICAgbWF4aW11bToge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgZXhjbHVzaXZlTWF4aW11bToge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgbWluaW11bToge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgZXhjbHVzaXZlTWluaW11bToge1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiXG4gICAgICB9LFxuICAgICAgbWF4TGVuZ3RoOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgbWluTGVuZ3RoOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiIH0sXG4gICAgICBwYXR0ZXJuOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJyZWdleFwiXG4gICAgICB9LFxuICAgICAgYWRkaXRpb25hbEl0ZW1zOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICBpdGVtczoge1xuICAgICAgICBhbnlPZjogW1xuICAgICAgICAgIHsgJHJlZjogXCIjXCIgfSxcbiAgICAgICAgICB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH1cbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIG1heEl0ZW1zOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgbWluSXRlbXM6IHsgJHJlZjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCIgfSxcbiAgICAgIHVuaXF1ZUl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNvbnRhaW5zOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICBtYXhQcm9wZXJ0aWVzOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIiB9LFxuICAgICAgbWluUHJvcGVydGllczogeyAkcmVmOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIiB9LFxuICAgICAgcmVxdWlyZWQ6IHsgJHJlZjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICBkZWZpbml0aW9uczoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogeyAkcmVmOiBcIiNcIiB9LFxuICAgICAgICBkZWZhdWx0OiB7fVxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHsgJHJlZjogXCIjXCIgfSxcbiAgICAgICAgZGVmYXVsdDoge31cbiAgICAgIH0sXG4gICAgICBwYXR0ZXJuUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogeyAkcmVmOiBcIiNcIiB9LFxuICAgICAgICBwcm9wZXJ0eU5hbWVzOiB7IGZvcm1hdDogXCJyZWdleFwiIH0sXG4gICAgICAgIGRlZmF1bHQ6IHt9XG4gICAgICB9LFxuICAgICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgYW55T2Y6IFtcbiAgICAgICAgICAgIHsgJHJlZjogXCIjXCIgfSxcbiAgICAgICAgICAgIHsgJHJlZjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BlcnR5TmFtZXM6IHsgJHJlZjogXCIjXCIgfSxcbiAgICAgIGNvbnN0OiB0cnVlLFxuICAgICAgZW51bToge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGl0ZW1zOiB0cnVlLFxuICAgICAgICBtaW5JdGVtczogMSxcbiAgICAgICAgdW5pcXVlSXRlbXM6IHRydWVcbiAgICAgIH0sXG4gICAgICB0eXBlOiB7XG4gICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgeyAkcmVmOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIiB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIGl0ZW1zOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wiIH0sXG4gICAgICAgICAgICBtaW5JdGVtczogMSxcbiAgICAgICAgICAgIHVuaXF1ZUl0ZW1zOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgZm9ybWF0OiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgIGNvbnRlbnRNZWRpYVR5cGU6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgY29udGVudEVuY29kaW5nOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgIGlmOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICB0aGVuOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICBlbHNlOiB7ICRyZWY6IFwiI1wiIH0sXG4gICAgICBhbGxPZjogeyAkcmVmOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIiB9LFxuICAgICAgYW55T2Y6IHsgJHJlZjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCIgfSxcbiAgICAgIG9uZU9mOiB7ICRyZWY6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwiIH0sXG4gICAgICBub3Q6IHsgJHJlZjogXCIjXCIgfVxuICAgIH0sXG4gICAgZGVmYXVsdDogdHJ1ZVxuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2RlZmluaXRpb25fc2NoZW1hLmpzXG52YXIgcmVxdWlyZV9kZWZpbml0aW9uX3NjaGVtYSA9IF9fY29tbW9uSlMoKGV4cG9ydHMsIG1vZHVsZSkgPT4ge1xuICB2YXIgbWV0YVNjaGVtYSA9IHJlcXVpcmVfanNvbl9zY2hlbWFfZHJhZnRfMDcoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJGlkOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9ibG9iL21hc3Rlci9saWIvZGVmaW5pdGlvbl9zY2hlbWEuanNcIixcbiAgICBkZWZpbml0aW9uczoge1xuICAgICAgc2ltcGxlVHlwZXM6IG1ldGFTY2hlbWEuZGVmaW5pdGlvbnMuc2ltcGxlVHlwZXNcbiAgICB9LFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgZGVwZW5kZW5jaWVzOiB7XG4gICAgICBzY2hlbWE6IFtcInZhbGlkYXRlXCJdLFxuICAgICAgJGRhdGE6IFtcInZhbGlkYXRlXCJdLFxuICAgICAgc3RhdGVtZW50czogW1wiaW5saW5lXCJdLFxuICAgICAgdmFsaWQ6IHsgbm90OiB7IHJlcXVpcmVkOiBbXCJtYWNyb1wiXSB9IH1cbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIHR5cGU6IG1ldGFTY2hlbWEucHJvcGVydGllcy50eXBlLFxuICAgICAgc2NoZW1hOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICBzdGF0ZW1lbnRzOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICBkZXBlbmRlbmNpZXM6IHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBpdGVtczogeyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICAgIH0sXG4gICAgICBtZXRhU2NoZW1hOiB7IHR5cGU6IFwib2JqZWN0XCIgfSxcbiAgICAgIG1vZGlmeWluZzogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgdmFsaWQ6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICRkYXRhOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICBhc3luYzogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgIHsgY29uc3Q6IFwiZnVsbFwiIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9rZXl3b3JkLmpzXG52YXIgcmVxdWlyZV9rZXl3b3JkID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciBJREVOVElGSUVSID0gL15bYS16XyRdW2EtejAtOV8kLV0qJC9pO1xuICB2YXIgY3VzdG9tUnVsZUNvZGUgPSByZXF1aXJlX2N1c3RvbSgpO1xuICB2YXIgZGVmaW5pdGlvblNjaGVtYSA9IHJlcXVpcmVfZGVmaW5pdGlvbl9zY2hlbWEoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkOiBhZGRLZXl3b3JkLFxuICAgIGdldDogZ2V0S2V5d29yZCxcbiAgICByZW1vdmU6IHJlbW92ZUtleXdvcmQsXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlS2V5d29yZFxuICB9O1xuICBmdW5jdGlvbiBhZGRLZXl3b3JkKGtleXdvcmQsIGRlZmluaXRpb24pIHtcbiAgICB2YXIgUlVMRVMgPSB0aGlzLlJVTEVTO1xuICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXdvcmQgXCIgKyBrZXl3b3JkICsgXCIgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgIGlmICghSURFTlRJRklFUi50ZXN0KGtleXdvcmQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5d29yZCBcIiArIGtleXdvcmQgKyBcIiBpcyBub3QgYSB2YWxpZCBpZGVudGlmaWVyXCIpO1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlS2V5d29yZChkZWZpbml0aW9uLCB0cnVlKTtcbiAgICAgIHZhciBkYXRhVHlwZSA9IGRlZmluaXRpb24udHlwZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFUeXBlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDtpIDwgZGF0YVR5cGUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgX2FkZFJ1bGUoa2V5d29yZCwgZGF0YVR5cGVbaV0sIGRlZmluaXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZFJ1bGUoa2V5d29yZCwgZGF0YVR5cGUsIGRlZmluaXRpb24pO1xuICAgICAgfVxuICAgICAgdmFyIG1ldGFTY2hlbWEgPSBkZWZpbml0aW9uLm1ldGFTY2hlbWE7XG4gICAgICBpZiAobWV0YVNjaGVtYSkge1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi4kZGF0YSAmJiB0aGlzLl9vcHRzLiRkYXRhKSB7XG4gICAgICAgICAgbWV0YVNjaGVtYSA9IHtcbiAgICAgICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgICAgIG1ldGFTY2hlbWEsXG4gICAgICAgICAgICAgIHsgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIiB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbml0aW9uLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IFJVTEVTLmFsbFtrZXl3b3JkXSA9IHRydWU7XG4gICAgZnVuY3Rpb24gX2FkZFJ1bGUoa2V5d29yZDIsIGRhdGFUeXBlMiwgZGVmaW5pdGlvbjIpIHtcbiAgICAgIHZhciBydWxlR3JvdXA7XG4gICAgICBmb3IgKHZhciBpMiA9IDA7aTIgPCBSVUxFUy5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgdmFyIHJnID0gUlVMRVNbaTJdO1xuICAgICAgICBpZiAocmcudHlwZSA9PSBkYXRhVHlwZTIpIHtcbiAgICAgICAgICBydWxlR3JvdXAgPSByZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFydWxlR3JvdXApIHtcbiAgICAgICAgcnVsZUdyb3VwID0geyB0eXBlOiBkYXRhVHlwZTIsIHJ1bGVzOiBbXSB9O1xuICAgICAgICBSVUxFUy5wdXNoKHJ1bGVHcm91cCk7XG4gICAgICB9XG4gICAgICB2YXIgcnVsZSA9IHtcbiAgICAgICAga2V5d29yZDoga2V5d29yZDIsXG4gICAgICAgIGRlZmluaXRpb246IGRlZmluaXRpb24yLFxuICAgICAgICBjdXN0b206IHRydWUsXG4gICAgICAgIGNvZGU6IGN1c3RvbVJ1bGVDb2RlLFxuICAgICAgICBpbXBsZW1lbnRzOiBkZWZpbml0aW9uMi5pbXBsZW1lbnRzXG4gICAgICB9O1xuICAgICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSk7XG4gICAgICBSVUxFUy5jdXN0b21ba2V5d29yZDJdID0gcnVsZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLlJVTEVTLmN1c3RvbVtrZXl3b3JkXTtcbiAgICByZXR1cm4gcnVsZSA/IHJ1bGUuZGVmaW5pdGlvbiA6IHRoaXMuUlVMRVMua2V5d29yZHNba2V5d29yZF0gfHwgZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlS2V5d29yZChrZXl3b3JkKSB7XG4gICAgdmFyIFJVTEVTID0gdGhpcy5SVUxFUztcbiAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF07XG4gICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXTtcbiAgICBkZWxldGUgUlVMRVMuY3VzdG9tW2tleXdvcmRdO1xuICAgIGZvciAodmFyIGkgPSAwO2kgPCBSVUxFUy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGVzID0gUlVMRVNbaV0ucnVsZXM7XG4gICAgICBmb3IgKHZhciBqID0gMDtqIDwgcnVsZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJ1bGVzW2pdLmtleXdvcmQgPT0ga2V5d29yZCkge1xuICAgICAgICAgIHJ1bGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoZGVmaW5pdGlvbiwgdGhyb3dFcnJvcikge1xuICAgIHZhbGlkYXRlS2V5d29yZC5lcnJvcnMgPSBudWxsO1xuICAgIHZhciB2ID0gdGhpcy5fdmFsaWRhdGVLZXl3b3JkID0gdGhpcy5fdmFsaWRhdGVLZXl3b3JkIHx8IHRoaXMuY29tcGlsZShkZWZpbml0aW9uU2NoZW1hLCB0cnVlKTtcbiAgICBpZiAodihkZWZpbml0aW9uKSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHZhbGlkYXRlS2V5d29yZC5lcnJvcnMgPSB2LmVycm9ycztcbiAgICBpZiAodGhyb3dFcnJvcilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN1c3RvbSBrZXl3b3JkIGRlZmluaXRpb24gaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQodi5lcnJvcnMpKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvYWp2L2xpYi9yZWZzL2RhdGEuanNvblxudmFyIHJlcXVpcmVfZGF0YTIgPSBfX2NvbW1vbkpTKChleHBvcnRzLCBtb2R1bGUpID0+IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAkaWQ6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTWV0YS1zY2hlbWEgZm9yICRkYXRhIHJlZmVyZW5jZSAoSlNPTiBTY2hlbWEgZXh0ZW5zaW9uIHByb3Bvc2FsKVwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVxdWlyZWQ6IFtcIiRkYXRhXCJdLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICRkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgeyBmb3JtYXQ6IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCIgfSxcbiAgICAgICAgICB7IGZvcm1hdDogXCJqc29uLXBvaW50ZXJcIiB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICB9O1xufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9hanYvbGliL2Fqdi5qc1xudmFyIHJlcXVpcmVfYWp2ID0gX19jb21tb25KUygoZXhwb3J0cywgbW9kdWxlKSA9PiB7XG4gIHZhciBjb21waWxlU2NoZW1hID0gcmVxdWlyZV9jb21waWxlKCk7XG4gIHZhciByZXNvbHZlID0gcmVxdWlyZV9yZXNvbHZlKCk7XG4gIHZhciBDYWNoZSA9IHJlcXVpcmVfY2FjaGUoKTtcbiAgdmFyIFNjaGVtYU9iamVjdCA9IHJlcXVpcmVfc2NoZW1hX29iaigpO1xuICB2YXIgc3RhYmxlU3RyaW5naWZ5ID0gcmVxdWlyZV9mYXN0X2pzb25fc3RhYmxlX3N0cmluZ2lmeSgpO1xuICB2YXIgZm9ybWF0cyA9IHJlcXVpcmVfZm9ybWF0cygpO1xuICB2YXIgcnVsZXMgPSByZXF1aXJlX3J1bGVzKCk7XG4gIHZhciAkZGF0YU1ldGFTY2hlbWEgPSByZXF1aXJlX2RhdGEoKTtcbiAgdmFyIHV0aWwzID0gcmVxdWlyZV91dGlsKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gQWp2O1xuICBBanYucHJvdG90eXBlLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4gIEFqdi5wcm90b3R5cGUuY29tcGlsZSA9IGNvbXBpbGU7XG4gIEFqdi5wcm90b3R5cGUuYWRkU2NoZW1hID0gYWRkU2NoZW1hO1xuICBBanYucHJvdG90eXBlLmFkZE1ldGFTY2hlbWEgPSBhZGRNZXRhU2NoZW1hO1xuICBBanYucHJvdG90eXBlLnZhbGlkYXRlU2NoZW1hID0gdmFsaWRhdGVTY2hlbWE7XG4gIEFqdi5wcm90b3R5cGUuZ2V0U2NoZW1hID0gZ2V0U2NoZW1hO1xuICBBanYucHJvdG90eXBlLnJlbW92ZVNjaGVtYSA9IHJlbW92ZVNjaGVtYTtcbiAgQWp2LnByb3RvdHlwZS5hZGRGb3JtYXQgPSBhZGRGb3JtYXQ7XG4gIEFqdi5wcm90b3R5cGUuZXJyb3JzVGV4dCA9IGVycm9yc1RleHQ7XG4gIEFqdi5wcm90b3R5cGUuX2FkZFNjaGVtYSA9IF9hZGRTY2hlbWE7XG4gIEFqdi5wcm90b3R5cGUuX2NvbXBpbGUgPSBfY29tcGlsZTtcbiAgQWp2LnByb3RvdHlwZS5jb21waWxlQXN5bmMgPSByZXF1aXJlX2FzeW5jKCk7XG4gIHZhciBjdXN0b21LZXl3b3JkID0gcmVxdWlyZV9rZXl3b3JkKCk7XG4gIEFqdi5wcm90b3R5cGUuYWRkS2V5d29yZCA9IGN1c3RvbUtleXdvcmQuYWRkO1xuICBBanYucHJvdG90eXBlLmdldEtleXdvcmQgPSBjdXN0b21LZXl3b3JkLmdldDtcbiAgQWp2LnByb3RvdHlwZS5yZW1vdmVLZXl3b3JkID0gY3VzdG9tS2V5d29yZC5yZW1vdmU7XG4gIEFqdi5wcm90b3R5cGUudmFsaWRhdGVLZXl3b3JkID0gY3VzdG9tS2V5d29yZC52YWxpZGF0ZTtcbiAgdmFyIGVycm9yQ2xhc3NlcyA9IHJlcXVpcmVfZXJyb3JfY2xhc3NlcygpO1xuICBBanYuVmFsaWRhdGlvbkVycm9yID0gZXJyb3JDbGFzc2VzLlZhbGlkYXRpb247XG4gIEFqdi5NaXNzaW5nUmVmRXJyb3IgPSBlcnJvckNsYXNzZXMuTWlzc2luZ1JlZjtcbiAgQWp2LiRkYXRhTWV0YVNjaGVtYSA9ICRkYXRhTWV0YVNjaGVtYTtcbiAgdmFyIE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiO1xuICB2YXIgTUVUQV9JR05PUkVfT1BUSU9OUyA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCIsIFwic3RyaWN0RGVmYXVsdHNcIl07XG4gIHZhciBNRVRBX1NVUFBPUlRfREFUQSA9IFtcIi9wcm9wZXJ0aWVzXCJdO1xuICBmdW5jdGlvbiBBanYob3B0cykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBanYpKVxuICAgICAgcmV0dXJuIG5ldyBBanYob3B0cyk7XG4gICAgb3B0cyA9IHRoaXMuX29wdHMgPSB1dGlsMy5jb3B5KG9wdHMpIHx8IHt9O1xuICAgIHNldExvZ2dlcih0aGlzKTtcbiAgICB0aGlzLl9zY2hlbWFzID0ge307XG4gICAgdGhpcy5fcmVmcyA9IHt9O1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IHt9O1xuICAgIHRoaXMuX2Zvcm1hdHMgPSBmb3JtYXRzKG9wdHMuZm9ybWF0KTtcbiAgICB0aGlzLl9jYWNoZSA9IG9wdHMuY2FjaGUgfHwgbmV3IENhY2hlO1xuICAgIHRoaXMuX2xvYWRpbmdTY2hlbWFzID0ge307XG4gICAgdGhpcy5fY29tcGlsYXRpb25zID0gW107XG4gICAgdGhpcy5SVUxFUyA9IHJ1bGVzKCk7XG4gICAgdGhpcy5fZ2V0SWQgPSBjaG9vc2VHZXRJZChvcHRzKTtcbiAgICBvcHRzLmxvb3BSZXF1aXJlZCA9IG9wdHMubG9vcFJlcXVpcmVkIHx8IEluZmluaXR5O1xuICAgIGlmIChvcHRzLmVycm9yRGF0YVBhdGggPT0gXCJwcm9wZXJ0eVwiKVxuICAgICAgb3B0cy5fZXJyb3JEYXRhUGF0aFByb3BlcnR5ID0gdHJ1ZTtcbiAgICBpZiAob3B0cy5zZXJpYWxpemUgPT09IHVuZGVmaW5lZClcbiAgICAgIG9wdHMuc2VyaWFsaXplID0gc3RhYmxlU3RyaW5naWZ5O1xuICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnModGhpcyk7XG4gICAgaWYgKG9wdHMuZm9ybWF0cylcbiAgICAgIGFkZEluaXRpYWxGb3JtYXRzKHRoaXMpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgYWRkSW5pdGlhbEtleXdvcmRzKHRoaXMpO1xuICAgIGFkZERlZmF1bHRNZXRhU2NoZW1hKHRoaXMpO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpXG4gICAgICB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKTtcbiAgICBpZiAob3B0cy5udWxsYWJsZSlcbiAgICAgIHRoaXMuYWRkS2V5d29yZChcIm51bGxhYmxlXCIsIHsgbWV0YVNjaGVtYTogeyB0eXBlOiBcImJvb2xlYW5cIiB9IH0pO1xuICAgIGFkZEluaXRpYWxTY2hlbWFzKHRoaXMpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHNjaGVtYUtleVJlZiwgZGF0YSkge1xuICAgIHZhciB2O1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHYgPSB0aGlzLmdldFNjaGVtYShzY2hlbWFLZXlSZWYpO1xuICAgICAgaWYgKCF2KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCInICsgc2NoZW1hS2V5UmVmICsgJ1wiJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzY2hlbWFPYmogPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hS2V5UmVmKTtcbiAgICAgIHYgPSBzY2hlbWFPYmoudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZShzY2hlbWFPYmopO1xuICAgIH1cbiAgICB2YXIgdmFsaWQgPSB2KGRhdGEpO1xuICAgIGlmICh2LiRhc3luYyAhPT0gdHJ1ZSlcbiAgICAgIHRoaXMuZXJyb3JzID0gdi5lcnJvcnM7XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG4gIGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hLCBfbWV0YSkge1xuICAgIHZhciBzY2hlbWFPYmogPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCB1bmRlZmluZWQsIF9tZXRhKTtcbiAgICByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTY2hlbWEoc2NoZW1hLCBrZXksIF9za2lwVmFsaWRhdGlvbiwgX21ldGEpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDtpIDwgc2NoZW1hLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWFbaV0sIHVuZGVmaW5lZCwgX3NraXBWYWxpZGF0aW9uLCBfbWV0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdmFyIGlkID0gdGhpcy5fZ2V0SWQoc2NoZW1hKTtcbiAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBpZCBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICBrZXkgPSByZXNvbHZlLm5vcm1hbGl6ZUlkKGtleSB8fCBpZCk7XG4gICAgY2hlY2tVbmlxdWUodGhpcywga2V5KTtcbiAgICB0aGlzLl9zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfc2tpcFZhbGlkYXRpb24sIF9tZXRhLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBhZGRNZXRhU2NoZW1hKHNjaGVtYSwga2V5LCBza2lwVmFsaWRhdGlvbikge1xuICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCBza2lwVmFsaWRhdGlvbiwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICB2YXIgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLl9vcHRzLmRlZmF1bHRNZXRhIHx8IGRlZmF1bHRNZXRhKHRoaXMpO1xuICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpO1xuICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KCk7XG4gICAgICBpZiAodGhpcy5fb3B0cy52YWxpZGF0ZVNjaGVtYSA9PSBcImxvZ1wiKVxuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH1cbiAgZnVuY3Rpb24gZGVmYXVsdE1ldGEoc2VsZjIpIHtcbiAgICB2YXIgbWV0YSA9IHNlbGYyLl9vcHRzLm1ldGE7XG4gICAgc2VsZjIuX29wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gc2VsZjIuX2dldElkKG1ldGEpIHx8IG1ldGEgOiBzZWxmMi5nZXRTY2hlbWEoTUVUQV9TQ0hFTUFfSUQpID8gTUVUQV9TQ0hFTUFfSUQgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNlbGYyLl9vcHRzLmRlZmF1bHRNZXRhO1xuICB9XG4gIGZ1bmN0aW9uIGdldFNjaGVtYShrZXlSZWYpIHtcbiAgICB2YXIgc2NoZW1hT2JqID0gX2dldFNjaGVtYU9iaih0aGlzLCBrZXlSZWYpO1xuICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYU9iaikge1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICByZXR1cm4gc2NoZW1hT2JqLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGUoc2NoZW1hT2JqKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2NoZW1hKHNjaGVtYU9iaik7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIHJldHVybiBfZ2V0U2NoZW1hRnJhZ21lbnQodGhpcywga2V5UmVmKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2dldFNjaGVtYUZyYWdtZW50KHNlbGYyLCByZWYpIHtcbiAgICB2YXIgcmVzID0gcmVzb2x2ZS5zY2hlbWEuY2FsbChzZWxmMiwgeyBzY2hlbWE6IHt9IH0sIHJlZik7XG4gICAgaWYgKHJlcykge1xuICAgICAgdmFyIHsgc2NoZW1hLCByb290OiByb290MiwgYmFzZUlkIH0gPSByZXM7XG4gICAgICB2YXIgdiA9IGNvbXBpbGVTY2hlbWEuY2FsbChzZWxmMiwgc2NoZW1hLCByb290MiwgdW5kZWZpbmVkLCBiYXNlSWQpO1xuICAgICAgc2VsZjIuX2ZyYWdtZW50c1tyZWZdID0gbmV3IFNjaGVtYU9iamVjdCh7XG4gICAgICAgIHJlZixcbiAgICAgICAgZnJhZ21lbnQ6IHRydWUsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgcm9vdDogcm9vdDIsXG4gICAgICAgIGJhc2VJZCxcbiAgICAgICAgdmFsaWRhdGU6IHZcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9nZXRTY2hlbWFPYmooc2VsZjIsIGtleVJlZikge1xuICAgIGtleVJlZiA9IHJlc29sdmUubm9ybWFsaXplSWQoa2V5UmVmKTtcbiAgICByZXR1cm4gc2VsZjIuX3NjaGVtYXNba2V5UmVmXSB8fCBzZWxmMi5fcmVmc1trZXlSZWZdIHx8IHNlbGYyLl9mcmFnbWVudHNba2V5UmVmXTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmKSB7XG4gICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgX3JlbW92ZUFsbFNjaGVtYXModGhpcywgdGhpcy5fc2NoZW1hcywgc2NoZW1hS2V5UmVmKTtcbiAgICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3JlZnMsIHNjaGVtYUtleVJlZik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIF9yZW1vdmVBbGxTY2hlbWFzKHRoaXMsIHRoaXMuX3NjaGVtYXMpO1xuICAgICAgICBfcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLCB0aGlzLl9yZWZzKTtcbiAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIHZhciBzY2hlbWFPYmogPSBfZ2V0U2NoZW1hT2JqKHRoaXMsIHNjaGVtYUtleVJlZik7XG4gICAgICAgIGlmIChzY2hlbWFPYmopXG4gICAgICAgICAgdGhpcy5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlbWFzW3NjaGVtYUtleVJlZl07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWZzW3NjaGVtYUtleVJlZl07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fb3B0cy5zZXJpYWxpemU7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IHNlcmlhbGl6ZSA/IHNlcmlhbGl6ZShzY2hlbWFLZXlSZWYpIDogc2NoZW1hS2V5UmVmO1xuICAgICAgICB0aGlzLl9jYWNoZS5kZWwoY2FjaGVLZXkpO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLl9nZXRJZChzY2hlbWFLZXlSZWYpO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZCA9IHJlc29sdmUubm9ybWFsaXplSWQoaWQpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zY2hlbWFzW2lkXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcmVmc1tpZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gX3JlbW92ZUFsbFNjaGVtYXMoc2VsZjIsIHNjaGVtYXMsIHJlZ2V4KSB7XG4gICAgZm9yICh2YXIga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgIHZhciBzY2hlbWFPYmogPSBzY2hlbWFzW2tleVJlZl07XG4gICAgICBpZiAoIXNjaGVtYU9iai5tZXRhICYmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSkge1xuICAgICAgICBzZWxmMi5fY2FjaGUuZGVsKHNjaGVtYU9iai5jYWNoZUtleSk7XG4gICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF9hZGRTY2hlbWEoc2NoZW1hLCBza2lwVmFsaWRhdGlvbiwgbWV0YSwgc2hvdWxkQWRkU2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIHNob3VsZCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKTtcbiAgICB2YXIgc2VyaWFsaXplID0gdGhpcy5fb3B0cy5zZXJpYWxpemU7XG4gICAgdmFyIGNhY2hlS2V5ID0gc2VyaWFsaXplID8gc2VyaWFsaXplKHNjaGVtYSkgOiBzY2hlbWE7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX2NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgc2hvdWxkQWRkU2NoZW1hID0gc2hvdWxkQWRkU2NoZW1hIHx8IHRoaXMuX29wdHMuYWRkVXNlZFNjaGVtYSAhPT0gZmFsc2U7XG4gICAgdmFyIGlkID0gcmVzb2x2ZS5ub3JtYWxpemVJZCh0aGlzLl9nZXRJZChzY2hlbWEpKTtcbiAgICBpZiAoaWQgJiYgc2hvdWxkQWRkU2NoZW1hKVxuICAgICAgY2hlY2tVbmlxdWUodGhpcywgaWQpO1xuICAgIHZhciB3aWxsVmFsaWRhdGUgPSB0aGlzLl9vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSAmJiAhc2tpcFZhbGlkYXRpb247XG4gICAgdmFyIHJlY3Vyc2l2ZU1ldGE7XG4gICAgaWYgKHdpbGxWYWxpZGF0ZSAmJiAhKHJlY3Vyc2l2ZU1ldGEgPSBpZCAmJiBpZCA9PSByZXNvbHZlLm5vcm1hbGl6ZUlkKHNjaGVtYS4kc2NoZW1hKSkpXG4gICAgICB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSk7XG4gICAgdmFyIGxvY2FsUmVmcyA9IHJlc29sdmUuaWRzLmNhbGwodGhpcywgc2NoZW1hKTtcbiAgICB2YXIgc2NoZW1hT2JqID0gbmV3IFNjaGVtYU9iamVjdCh7XG4gICAgICBpZCxcbiAgICAgIHNjaGVtYSxcbiAgICAgIGxvY2FsUmVmcyxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgbWV0YVxuICAgIH0pO1xuICAgIGlmIChpZFswXSAhPSBcIiNcIiAmJiBzaG91bGRBZGRTY2hlbWEpXG4gICAgICB0aGlzLl9yZWZzW2lkXSA9IHNjaGVtYU9iajtcbiAgICB0aGlzLl9jYWNoZS5wdXQoY2FjaGVLZXksIHNjaGVtYU9iaik7XG4gICAgaWYgKHdpbGxWYWxpZGF0ZSAmJiByZWN1cnNpdmVNZXRhKVxuICAgICAgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpO1xuICAgIHJldHVybiBzY2hlbWFPYmo7XG4gIH1cbiAgZnVuY3Rpb24gX2NvbXBpbGUoc2NoZW1hT2JqLCByb290Mikge1xuICAgIGlmIChzY2hlbWFPYmouY29tcGlsaW5nKSB7XG4gICAgICBzY2hlbWFPYmoudmFsaWRhdGUgPSBjYWxsVmFsaWRhdGU7XG4gICAgICBjYWxsVmFsaWRhdGUuc2NoZW1hID0gc2NoZW1hT2JqLnNjaGVtYTtcbiAgICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSBudWxsO1xuICAgICAgY2FsbFZhbGlkYXRlLnJvb3QgPSByb290MiA/IHJvb3QyIDogY2FsbFZhbGlkYXRlO1xuICAgICAgaWYgKHNjaGVtYU9iai5zY2hlbWEuJGFzeW5jID09PSB0cnVlKVxuICAgICAgICBjYWxsVmFsaWRhdGUuJGFzeW5jID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjYWxsVmFsaWRhdGU7XG4gICAgfVxuICAgIHNjaGVtYU9iai5jb21waWxpbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50T3B0cztcbiAgICBpZiAoc2NoZW1hT2JqLm1ldGEpIHtcbiAgICAgIGN1cnJlbnRPcHRzID0gdGhpcy5fb3B0cztcbiAgICAgIHRoaXMuX29wdHMgPSB0aGlzLl9tZXRhT3B0cztcbiAgICB9XG4gICAgdmFyIHY7XG4gICAgdHJ5IHtcbiAgICAgIHYgPSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoZW1hT2JqLnNjaGVtYSwgcm9vdDIsIHNjaGVtYU9iai5sb2NhbFJlZnMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlbGV0ZSBzY2hlbWFPYmoudmFsaWRhdGU7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzY2hlbWFPYmouY29tcGlsaW5nID0gZmFsc2U7XG4gICAgICBpZiAoc2NoZW1hT2JqLm1ldGEpXG4gICAgICAgIHRoaXMuX29wdHMgPSBjdXJyZW50T3B0cztcbiAgICB9XG4gICAgc2NoZW1hT2JqLnZhbGlkYXRlID0gdjtcbiAgICBzY2hlbWFPYmoucmVmcyA9IHYucmVmcztcbiAgICBzY2hlbWFPYmoucmVmVmFsID0gdi5yZWZWYWw7XG4gICAgc2NoZW1hT2JqLnJvb3QgPSB2LnJvb3Q7XG4gICAgcmV0dXJuIHY7XG4gICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKCkge1xuICAgICAgdmFyIF92YWxpZGF0ZSA9IHNjaGVtYU9iai52YWxpZGF0ZTtcbiAgICAgIHZhciByZXN1bHQgPSBfdmFsaWRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGNhbGxWYWxpZGF0ZS5lcnJvcnMgPSBfdmFsaWRhdGUuZXJyb3JzO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2hvb3NlR2V0SWQob3B0cykge1xuICAgIHN3aXRjaCAob3B0cy5zY2hlbWFJZCkge1xuICAgICAgY2FzZSBcImF1dG9cIjpcbiAgICAgICAgcmV0dXJuIF9nZXQkSWRPcklkO1xuICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgIHJldHVybiBfZ2V0SWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2dldCRJZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gX2dldElkKHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEuJGlkKVxuICAgICAgdGhpcy5sb2dnZXIud2FybihcInNjaGVtYSAkaWQgaWdub3JlZFwiLCBzY2hlbWEuJGlkKTtcbiAgICByZXR1cm4gc2NoZW1hLmlkO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXQkSWQoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5pZClcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJzY2hlbWEgaWQgaWdub3JlZFwiLCBzY2hlbWEuaWQpO1xuICAgIHJldHVybiBzY2hlbWEuJGlkO1xuICB9XG4gIGZ1bmN0aW9uIF9nZXQkSWRPcklkKHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEuJGlkICYmIHNjaGVtYS5pZCAmJiBzY2hlbWEuJGlkICE9IHNjaGVtYS5pZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSAkaWQgaXMgZGlmZmVyZW50IGZyb20gaWRcIik7XG4gICAgcmV0dXJuIHNjaGVtYS4kaWQgfHwgc2NoZW1hLmlkO1xuICB9XG4gIGZ1bmN0aW9uIGVycm9yc1RleHQoZXJyb3JzMiwgb3B0aW9ucykge1xuICAgIGVycm9yczIgPSBlcnJvcnMyIHx8IHRoaXMuZXJyb3JzO1xuICAgIGlmICghZXJyb3JzMilcbiAgICAgIHJldHVybiBcIk5vIGVycm9yc1wiO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBzZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciA9PT0gdW5kZWZpbmVkID8gXCIsIFwiIDogb3B0aW9ucy5zZXBhcmF0b3I7XG4gICAgdmFyIGRhdGFWYXIgPSBvcHRpb25zLmRhdGFWYXIgPT09IHVuZGVmaW5lZCA/IFwiZGF0YVwiIDogb3B0aW9ucy5kYXRhVmFyO1xuICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDtpIDwgZXJyb3JzMi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGUgPSBlcnJvcnMyW2ldO1xuICAgICAgaWYgKGUpXG4gICAgICAgIHRleHQgKz0gZGF0YVZhciArIGUuZGF0YVBhdGggKyBcIiBcIiArIGUubWVzc2FnZSArIHNlcGFyYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuc2xpY2UoMCwgLXNlcGFyYXRvci5sZW5ndGgpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEZvcm1hdChuYW1lLCBmb3JtYXQpIHtcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKVxuICAgICAgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpO1xuICAgIHRoaXMuX2Zvcm1hdHNbbmFtZV0gPSBmb3JtYXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRGVmYXVsdE1ldGFTY2hlbWEoc2VsZjIpIHtcbiAgICB2YXIgJGRhdGFTY2hlbWE7XG4gICAgaWYgKHNlbGYyLl9vcHRzLiRkYXRhKSB7XG4gICAgICAkZGF0YVNjaGVtYSA9IHJlcXVpcmVfZGF0YTIoKTtcbiAgICAgIHNlbGYyLmFkZE1ldGFTY2hlbWEoJGRhdGFTY2hlbWEsICRkYXRhU2NoZW1hLiRpZCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzZWxmMi5fb3B0cy5tZXRhID09PSBmYWxzZSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIgbWV0YVNjaGVtYSA9IHJlcXVpcmVfanNvbl9zY2hlbWFfZHJhZnRfMDcoKTtcbiAgICBpZiAoc2VsZjIuX29wdHMuJGRhdGEpXG4gICAgICBtZXRhU2NoZW1hID0gJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKTtcbiAgICBzZWxmMi5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCB0cnVlKTtcbiAgICBzZWxmMi5fcmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSUQ7XG4gIH1cbiAgZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXMoc2VsZjIpIHtcbiAgICB2YXIgb3B0c1NjaGVtYXMgPSBzZWxmMi5fb3B0cy5zY2hlbWFzO1xuICAgIGlmICghb3B0c1NjaGVtYXMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKVxuICAgICAgc2VsZjIuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0c1NjaGVtYXMpXG4gICAgICAgIHNlbGYyLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldLCBrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKHNlbGYyKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBzZWxmMi5fb3B0cy5mb3JtYXRzKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gc2VsZjIuX29wdHMuZm9ybWF0c1tuYW1lXTtcbiAgICAgIHNlbGYyLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoc2VsZjIpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNlbGYyLl9vcHRzLmtleXdvcmRzKSB7XG4gICAgICB2YXIga2V5d29yZCA9IHNlbGYyLl9vcHRzLmtleXdvcmRzW25hbWVdO1xuICAgICAgc2VsZjIuYWRkS2V5d29yZChuYW1lLCBrZXl3b3JkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tVbmlxdWUoc2VsZjIsIGlkKSB7XG4gICAgaWYgKHNlbGYyLl9zY2hlbWFzW2lkXSB8fCBzZWxmMi5fcmVmc1tpZF0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjaGVtYSB3aXRoIGtleSBvciBpZCBcIicgKyBpZCArICdcIiBhbHJlYWR5IGV4aXN0cycpO1xuICB9XG4gIGZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKHNlbGYyKSB7XG4gICAgdmFyIG1ldGFPcHRzID0gdXRpbDMuY29weShzZWxmMi5fb3B0cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7aSA8IE1FVEFfSUdOT1JFX09QVElPTlMubGVuZ3RoOyBpKyspXG4gICAgICBkZWxldGUgbWV0YU9wdHNbTUVUQV9JR05PUkVfT1BUSU9OU1tpXV07XG4gICAgcmV0dXJuIG1ldGFPcHRzO1xuICB9XG4gIGZ1bmN0aW9uIHNldExvZ2dlcihzZWxmMikge1xuICAgIHZhciBsb2dnZXIgPSBzZWxmMi5fb3B0cy5sb2dnZXI7XG4gICAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHtcbiAgICAgIHNlbGYyLmxvZ2dlciA9IHsgbG9nOiBub29wLCB3YXJuOiBub29wLCBlcnJvcjogbm9vcCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgIGxvZ2dlciA9IGNvbnNvbGU7XG4gICAgICBpZiAoISh0eXBlb2YgbG9nZ2VyID09IFwib2JqZWN0XCIgJiYgbG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzXCIpO1xuICAgICAgc2VsZjIubG9nZ2VyID0gbG9nZ2VyO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBub29wKCkge31cbn0pO1xuXG4vLyAuLi9zcmMvZW50cnlwb2ludHMvYWdlbnRTZGsudHNcbmltcG9ydCB7IGpvaW4gYXMgam9pbjMgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gXCJ1cmxcIjtcblxuLy8gLi4vc3JjL3V0aWxzL2Fib3J0Q29udHJvbGxlci50c1xuaW1wb3J0IHsgc2V0TWF4TGlzdGVuZXJzIH0gZnJvbSBcImV2ZW50c1wiO1xudmFyIERFRkFVTFRfTUFYX0xJU1RFTkVSUyA9IDUwO1xuZnVuY3Rpb24gY3JlYXRlQWJvcnRDb250cm9sbGVyKG1heExpc3RlbmVycyA9IERFRkFVTFRfTUFYX0xJU1RFTkVSUykge1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgc2V0TWF4TGlzdGVuZXJzKG1heExpc3RlbmVycywgY29udHJvbGxlci5zaWduYWwpO1xuICByZXR1cm4gY29udHJvbGxlcjtcbn1cblxuLy8gLi4vc3JjL3RyYW5zcG9ydC9Qcm9jZXNzVHJhbnNwb3J0LnRzXG5pbXBvcnQgeyBzcGF3biB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyBjcmVhdGVJbnRlcmZhY2UgfSBmcm9tIFwicmVhZGxpbmVcIjtcblxuLy8gLi4vc3JjL3V0aWxzL2ZzT3BlcmF0aW9ucy50c1xuaW1wb3J0ICogYXMgZnMgZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBzdGF0IGFzIHN0YXRQcm9taXNlLCBvcGVuIH0gZnJvbSBcImZzL3Byb21pc2VzXCI7XG52YXIgTm9kZUZzT3BlcmF0aW9ucyA9IHtcbiAgY3dkKCkge1xuICAgIHJldHVybiBwcm9jZXNzLmN3ZCgpO1xuICB9LFxuICBleGlzdHNTeW5jKGZzUGF0aCkge1xuICAgIHJldHVybiBmcy5leGlzdHNTeW5jKGZzUGF0aCk7XG4gIH0sXG4gIGFzeW5jIHN0YXQoZnNQYXRoKSB7XG4gICAgcmV0dXJuIHN0YXRQcm9taXNlKGZzUGF0aCk7XG4gIH0sXG4gIHN0YXRTeW5jKGZzUGF0aCkge1xuICAgIHJldHVybiBmcy5zdGF0U3luYyhmc1BhdGgpO1xuICB9LFxuICByZWFkRmlsZVN5bmMoZnNQYXRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmc1BhdGgsIHsgZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2RpbmcgfSk7XG4gIH0sXG4gIHJlYWRGaWxlQnl0ZXNTeW5jKGZzUGF0aCkge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZnNQYXRoKTtcbiAgfSxcbiAgcmVhZFN5bmMoZnNQYXRoLCBvcHRpb25zKSB7XG4gICAgbGV0IGZkID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGZzUGF0aCwgXCJyXCIpO1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKG9wdGlvbnMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkLCBidWZmZXIsIDAsIG9wdGlvbnMubGVuZ3RoLCAwKTtcbiAgICAgIHJldHVybiB7IGJ1ZmZlciwgYnl0ZXNSZWFkIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChmZClcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICB9XG4gIH0sXG4gIHdyaXRlRmlsZVN5bmMoZnNQYXRoLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmZsdXNoKSB7XG4gICAgICBjb25zdCB3cml0ZU9wdGlvbnMgPSB7XG4gICAgICAgIGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nXG4gICAgICB9O1xuICAgICAgaWYgKG9wdGlvbnMubW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdyaXRlT3B0aW9ucy5tb2RlID0gb3B0aW9ucy5tb2RlO1xuICAgICAgfVxuICAgICAgZnMud3JpdGVGaWxlU3luYyhmc1BhdGgsIGRhdGEsIHdyaXRlT3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBmZDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb2RlIDogdW5kZWZpbmVkO1xuICAgICAgZmQgPSBmcy5vcGVuU3luYyhmc1BhdGgsIFwid1wiLCBtb2RlKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmQsIGRhdGEsIHsgZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2RpbmcgfSk7XG4gICAgICBmcy5mc3luY1N5bmMoZmQpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoZmQpIHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGFwcGVuZEZpbGVTeW5jKHBhdGgsIGRhdGEpIHtcbiAgICBmcy5hcHBlbmRGaWxlU3luYyhwYXRoLCBkYXRhKTtcbiAgfSxcbiAgY29weUZpbGVTeW5jKHNyYywgZGVzdCkge1xuICAgIGZzLmNvcHlGaWxlU3luYyhzcmMsIGRlc3QpO1xuICB9LFxuICB1bmxpbmtTeW5jKHBhdGgpIHtcbiAgICBmcy51bmxpbmtTeW5jKHBhdGgpO1xuICB9LFxuICByZW5hbWVTeW5jKG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmcy5yZW5hbWVTeW5jKG9sZFBhdGgsIG5ld1BhdGgpO1xuICB9LFxuICBsaW5rU3luYyh0YXJnZXQsIHBhdGgpIHtcbiAgICBmcy5saW5rU3luYyh0YXJnZXQsIHBhdGgpO1xuICB9LFxuICBzeW1saW5rU3luYyh0YXJnZXQsIHBhdGgpIHtcbiAgICBmcy5zeW1saW5rU3luYyh0YXJnZXQsIHBhdGgpO1xuICB9LFxuICByZWFkbGlua1N5bmMocGF0aCkge1xuICAgIHJldHVybiBmcy5yZWFkbGlua1N5bmMocGF0aCk7XG4gIH0sXG4gIHJlYWxwYXRoU3luYyhwYXRoKSB7XG4gICAgcmV0dXJuIGZzLnJlYWxwYXRoU3luYyhwYXRoKTtcbiAgfSxcbiAgbWtkaXJTeW5jKGRpclBhdGgpIHtcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZGlyUGF0aCkpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhkaXJQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgbW9kZTogNDQ4IH0pO1xuICAgIH1cbiAgfSxcbiAgcmVhZGRpclN5bmMoZGlyUGF0aCkge1xuICAgIHJldHVybiBmcy5yZWFkZGlyU3luYyhkaXJQYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSk7XG4gIH0sXG4gIHJlYWRkaXJTdHJpbmdTeW5jKGRpclBhdGgpIHtcbiAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoZGlyUGF0aCk7XG4gIH0sXG4gIGlzRGlyRW1wdHlTeW5jKGRpclBhdGgpIHtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMucmVhZGRpclN5bmMoZGlyUGF0aCk7XG4gICAgcmV0dXJuIGZpbGVzLmxlbmd0aCA9PT0gMDtcbiAgfSxcbiAgcm1kaXJTeW5jKGRpclBhdGgpIHtcbiAgICBmcy5ybWRpclN5bmMoZGlyUGF0aCk7XG4gIH0sXG4gIHJtU3luYyhwYXRoLCBvcHRpb25zKSB7XG4gICAgZnMucm1TeW5jKHBhdGgsIG9wdGlvbnMpO1xuICB9LFxuICBjcmVhdGVXcml0ZVN0cmVhbShwYXRoKSB7XG4gICAgcmV0dXJuIGZzLmNyZWF0ZVdyaXRlU3RyZWFtKHBhdGgpO1xuICB9XG59O1xudmFyIGFjdGl2ZUZzID0gTm9kZUZzT3BlcmF0aW9ucztcbmZ1bmN0aW9uIGdldEZzSW1wbGVtZW50YXRpb24oKSB7XG4gIHJldHVybiBhY3RpdmVGcztcbn1cblxuLy8gLi4vc3JjL2VudHJ5cG9pbnRzL3Nka1R5cGVzLnRzXG5jbGFzcyBBYm9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG4vLyAuLi9zcmMvdXRpbHMvYnVuZGxlZE1vZGUudHNcbmZ1bmN0aW9uIGlzUnVubmluZ1dpdGhCdW4oKSB7XG4gIHJldHVybiBwcm9jZXNzLnZlcnNpb25zLmJ1biAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyAuLi9zcmMvdHJhbnNwb3J0L1Byb2Nlc3NUcmFuc3BvcnQudHNcbmNsYXNzIFByb2Nlc3NUcmFuc3BvcnQge1xuICBvcHRpb25zO1xuICBjaGlsZDtcbiAgY2hpbGRTdGRpbjtcbiAgY2hpbGRTdGRvdXQ7XG4gIHJlYWR5ID0gZmFsc2U7XG4gIGFib3J0Q29udHJvbGxlcjtcbiAgZXhpdEVycm9yO1xuICBleGl0TGlzdGVuZXJzID0gW107XG4gIHByb2Nlc3NFeGl0SGFuZGxlcjtcbiAgYWJvcnRIYW5kbGVyO1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlciA9IG9wdGlvbnMuYWJvcnRDb250cm9sbGVyIHx8IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWRkaXRpb25hbERpcmVjdG9yaWVzID0gW10sXG4gICAgICAgIGFnZW50cyxcbiAgICAgICAgY3dkLFxuICAgICAgICBleGVjdXRhYmxlID0gaXNSdW5uaW5nV2l0aEJ1bigpID8gXCJidW5cIiA6IFwibm9kZVwiLFxuICAgICAgICBleGVjdXRhYmxlQXJncyA9IFtdLFxuICAgICAgICBleHRyYUFyZ3MgPSB7fSxcbiAgICAgICAgcGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUsXG4gICAgICAgIGVudiA9IHsgLi4ucHJvY2Vzcy5lbnYgfSxcbiAgICAgICAgc3RkZXJyLFxuICAgICAgICBjdXN0b21TeXN0ZW1Qcm9tcHQsXG4gICAgICAgIGFwcGVuZFN5c3RlbVByb21wdCxcbiAgICAgICAgbWF4VGhpbmtpbmdUb2tlbnMsXG4gICAgICAgIG1heFR1cm5zLFxuICAgICAgICBtb2RlbCxcbiAgICAgICAgZmFsbGJhY2tNb2RlbCxcbiAgICAgICAgcGVybWlzc2lvbk1vZGUsXG4gICAgICAgIHBlcm1pc3Npb25Qcm9tcHRUb29sTmFtZSxcbiAgICAgICAgY29udGludWVDb252ZXJzYXRpb24sXG4gICAgICAgIHJlc3VtZSxcbiAgICAgICAgc2V0dGluZ1NvdXJjZXMsXG4gICAgICAgIGFsbG93ZWRUb29scyA9IFtdLFxuICAgICAgICBkaXNhbGxvd2VkVG9vbHMgPSBbXSxcbiAgICAgICAgbWNwU2VydmVycyxcbiAgICAgICAgc3RyaWN0TWNwQ29uZmlnLFxuICAgICAgICBjYW5Vc2VUb29sLFxuICAgICAgICBpbmNsdWRlUGFydGlhbE1lc3NhZ2VzXG4gICAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgY29uc3QgYXJncyA9IFtcbiAgICAgICAgXCItLW91dHB1dC1mb3JtYXRcIixcbiAgICAgICAgXCJzdHJlYW0tanNvblwiLFxuICAgICAgICBcIi0tdmVyYm9zZVwiLFxuICAgICAgICBcIi0taW5wdXQtZm9ybWF0XCIsXG4gICAgICAgIFwic3RyZWFtLWpzb25cIlxuICAgICAgXTtcbiAgICAgIGlmICh0eXBlb2YgY3VzdG9tU3lzdGVtUHJvbXB0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICBhcmdzLnB1c2goXCItLXN5c3RlbS1wcm9tcHRcIiwgY3VzdG9tU3lzdGVtUHJvbXB0KTtcbiAgICAgIGlmIChhcHBlbmRTeXN0ZW1Qcm9tcHQpXG4gICAgICAgIGFyZ3MucHVzaChcIi0tYXBwZW5kLXN5c3RlbS1wcm9tcHRcIiwgYXBwZW5kU3lzdGVtUHJvbXB0KTtcbiAgICAgIGlmIChtYXhUaGlua2luZ1Rva2VucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tbWF4LXRoaW5raW5nLXRva2Vuc1wiLCBtYXhUaGlua2luZ1Rva2Vucy50b1N0cmluZygpKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhUdXJucylcbiAgICAgICAgYXJncy5wdXNoKFwiLS1tYXgtdHVybnNcIiwgbWF4VHVybnMudG9TdHJpbmcoKSk7XG4gICAgICBpZiAobW9kZWwpXG4gICAgICAgIGFyZ3MucHVzaChcIi0tbW9kZWxcIiwgbW9kZWwpO1xuICAgICAgaWYgKGVudi5ERUJVRylcbiAgICAgICAgYXJncy5wdXNoKFwiLS1kZWJ1Zy10by1zdGRlcnJcIik7XG4gICAgICBpZiAoY2FuVXNlVG9vbCkge1xuICAgICAgICBpZiAocGVybWlzc2lvblByb21wdFRvb2xOYW1lKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuVXNlVG9vbCBjYWxsYmFjayBjYW5ub3QgYmUgdXNlZCB3aXRoIHBlcm1pc3Npb25Qcm9tcHRUb29sTmFtZS4gUGxlYXNlIHVzZSBvbmUgb3IgdGhlIG90aGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goXCItLXBlcm1pc3Npb24tcHJvbXB0LXRvb2xcIiwgXCJzdGRpb1wiKTtcbiAgICAgIH0gZWxzZSBpZiAocGVybWlzc2lvblByb21wdFRvb2xOYW1lKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tcGVybWlzc2lvbi1wcm9tcHQtdG9vbFwiLCBwZXJtaXNzaW9uUHJvbXB0VG9vbE5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbnRpbnVlQ29udmVyc2F0aW9uKVxuICAgICAgICBhcmdzLnB1c2goXCItLWNvbnRpbnVlXCIpO1xuICAgICAgaWYgKHJlc3VtZSlcbiAgICAgICAgYXJncy5wdXNoKFwiLS1yZXN1bWVcIiwgcmVzdW1lKTtcbiAgICAgIGlmIChhbGxvd2VkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmdzLnB1c2goXCItLWFsbG93ZWRUb29sc1wiLCBhbGxvd2VkVG9vbHMuam9pbihcIixcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FsbG93ZWRUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tZGlzYWxsb3dlZFRvb2xzXCIsIGRpc2FsbG93ZWRUb29scy5qb2luKFwiLFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAobWNwU2VydmVycyAmJiBPYmplY3Qua2V5cyhtY3BTZXJ2ZXJzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tbWNwLWNvbmZpZ1wiLCBKU09OLnN0cmluZ2lmeSh7IG1jcFNlcnZlcnMgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKGFnZW50cyAmJiBPYmplY3Qua2V5cyhhZ2VudHMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXJncy5wdXNoKFwiLS1hZ2VudHNcIiwgSlNPTi5zdHJpbmdpZnkoYWdlbnRzKSk7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ1NvdXJjZXMpIHtcbiAgICAgICAgYXJncy5wdXNoKFwiLS1zZXR0aW5nLXNvdXJjZXNcIiwgc2V0dGluZ1NvdXJjZXMuam9pbihcIixcIikpO1xuICAgICAgfVxuICAgICAgaWYgKHN0cmljdE1jcENvbmZpZykge1xuICAgICAgICBhcmdzLnB1c2goXCItLXN0cmljdC1tY3AtY29uZmlnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBlcm1pc3Npb25Nb2RlKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tcGVybWlzc2lvbi1tb2RlXCIsIHBlcm1pc3Npb25Nb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja01vZGVsKSB7XG4gICAgICAgIGlmIChtb2RlbCAmJiBmYWxsYmFja01vZGVsID09PSBtb2RlbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhbGxiYWNrIG1vZGVsIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbWFpbiBtb2RlbC4gUGxlYXNlIHNwZWNpZnkgYSBkaWZmZXJlbnQgbW9kZWwgZm9yIGZhbGxiYWNrTW9kZWwgb3B0aW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goXCItLWZhbGxiYWNrLW1vZGVsXCIsIGZhbGxiYWNrTW9kZWwpO1xuICAgICAgfVxuICAgICAgaWYgKGluY2x1ZGVQYXJ0aWFsTWVzc2FnZXMpIHtcbiAgICAgICAgYXJncy5wdXNoKFwiLS1pbmNsdWRlLXBhcnRpYWwtbWVzc2FnZXNcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGRpciBvZiBhZGRpdGlvbmFsRGlyZWN0b3JpZXMpIHtcbiAgICAgICAgYXJncy5wdXNoKFwiLS1hZGQtZGlyXCIsIGRpcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmZvcmtTZXNzaW9uKSB7XG4gICAgICAgIGFyZ3MucHVzaChcIi0tZm9yay1zZXNzaW9uXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXN1bWVTZXNzaW9uQXQpIHtcbiAgICAgICAgYXJncy5wdXNoKFwiLS1yZXN1bWUtc2Vzc2lvbi1hdFwiLCB0aGlzLm9wdGlvbnMucmVzdW1lU2Vzc2lvbkF0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2ZsYWcsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhleHRyYUFyZ3MpKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGFyZ3MucHVzaChgLS0ke2ZsYWd9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJncy5wdXNoKGAtLSR7ZmxhZ31gLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZW52LkNMQVVERV9DT0RFX0VOVFJZUE9JTlQpIHtcbiAgICAgICAgZW52LkNMQVVERV9DT0RFX0VOVFJZUE9JTlQgPSBcInNkay10c1wiO1xuICAgICAgfVxuICAgICAgY29uc3QgZnMyID0gZ2V0RnNJbXBsZW1lbnRhdGlvbigpO1xuICAgICAgaWYgKCFmczIuZXhpc3RzU3luYyhwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSkpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gaXNOYXRpdmVCaW5hcnkocGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUpID8gYENsYXVkZSBDb2RlIG5hdGl2ZSBiaW5hcnkgbm90IGZvdW5kIGF0ICR7cGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGV9LiBQbGVhc2UgZW5zdXJlIENsYXVkZSBDb2RlIGlzIGluc3RhbGxlZCB2aWEgbmF0aXZlIGluc3RhbGxlciBvciBzcGVjaWZ5IGEgdmFsaWQgcGF0aCB3aXRoIG9wdGlvbnMucGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUuYCA6IGBDbGF1ZGUgQ29kZSBleGVjdXRhYmxlIG5vdCBmb3VuZCBhdCAke3BhdGhUb0NsYXVkZUNvZGVFeGVjdXRhYmxlfS4gSXMgb3B0aW9ucy5wYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSBzZXQ/YDtcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBpc05hdGl2ZSA9IGlzTmF0aXZlQmluYXJ5KHBhdGhUb0NsYXVkZUNvZGVFeGVjdXRhYmxlKTtcbiAgICAgIGNvbnN0IHNwYXduQ29tbWFuZCA9IGlzTmF0aXZlID8gcGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUgOiBleGVjdXRhYmxlO1xuICAgICAgY29uc3Qgc3Bhd25BcmdzID0gaXNOYXRpdmUgPyBhcmdzIDogWy4uLmV4ZWN1dGFibGVBcmdzLCBwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSwgLi4uYXJnc107XG4gICAgICB0aGlzLmxvZ0ZvckRlYnVnZ2luZyhpc05hdGl2ZSA/IGBTcGF3bmluZyBDbGF1ZGUgQ29kZSBuYXRpdmUgYmluYXJ5OiAke3BhdGhUb0NsYXVkZUNvZGVFeGVjdXRhYmxlfSAke2FyZ3Muam9pbihcIiBcIil9YCA6IGBTcGF3bmluZyBDbGF1ZGUgQ29kZSBwcm9jZXNzOiAke2V4ZWN1dGFibGV9ICR7Wy4uLmV4ZWN1dGFibGVBcmdzLCBwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSwgLi4uYXJnc10uam9pbihcIiBcIil9YCk7XG4gICAgICBjb25zdCBzdGRlcnJNb2RlID0gZW52LkRFQlVHIHx8IHN0ZGVyciA/IFwicGlwZVwiIDogXCJpZ25vcmVcIjtcbiAgICAgIHRoaXMuY2hpbGQgPSBzcGF3bihzcGF3bkNvbW1hbmQsIHNwYXduQXJncywge1xuICAgICAgICBjd2QsXG4gICAgICAgIHN0ZGlvOiBbXCJwaXBlXCIsIFwicGlwZVwiLCBzdGRlcnJNb2RlXSxcbiAgICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGVudlxuICAgICAgfSk7XG4gICAgICB0aGlzLmNoaWxkU3RkaW4gPSB0aGlzLmNoaWxkLnN0ZGluO1xuICAgICAgdGhpcy5jaGlsZFN0ZG91dCA9IHRoaXMuY2hpbGQuc3Rkb3V0O1xuICAgICAgaWYgKGVudi5ERUJVRyB8fCBzdGRlcnIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5zdGRlcnIub24oXCJkYXRhXCIsIChkYXRhKSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2dGb3JEZWJ1Z2dpbmcoZGF0YS50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jaGlsZCAmJiAhdGhpcy5jaGlsZC5raWxsZWQpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkLmtpbGwoXCJTSUdURVJNXCIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5wcm9jZXNzRXhpdEhhbmRsZXIgPSBjbGVhbnVwO1xuICAgICAgdGhpcy5hYm9ydEhhbmRsZXIgPSBjbGVhbnVwO1xuICAgICAgcHJvY2Vzcy5vbihcImV4aXRcIiwgdGhpcy5wcm9jZXNzRXhpdEhhbmRsZXIpO1xuICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0aGlzLmFib3J0SGFuZGxlcik7XG4gICAgICB0aGlzLmNoaWxkLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy5leGl0RXJyb3IgPSBuZXcgQWJvcnRFcnJvcihcIkNsYXVkZSBDb2RlIHByb2Nlc3MgYWJvcnRlZCBieSB1c2VyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZXhpdEVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gc3Bhd24gQ2xhdWRlIENvZGUgcHJvY2VzczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgIHRoaXMubG9nRm9yRGVidWdnaW5nKHRoaXMuZXhpdEVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY2hpbGQub24oXCJjbG9zZVwiLCAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgdGhpcy5leGl0RXJyb3IgPSBuZXcgQWJvcnRFcnJvcihcIkNsYXVkZSBDb2RlIHByb2Nlc3MgYWJvcnRlZCBieSB1c2VyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5nZXRQcm9jZXNzRXhpdEVycm9yKGNvZGUsIHNpZ25hbCk7XG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgdGhpcy5sb2dGb3JEZWJ1Z2dpbmcoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgZ2V0UHJvY2Vzc0V4aXRFcnJvcihjb2RlLCBzaWduYWwpIHtcbiAgICBpZiAoY29kZSAhPT0gMCAmJiBjb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGBDbGF1ZGUgQ29kZSBwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWApO1xuICAgIH0gZWxzZSBpZiAoc2lnbmFsKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGBDbGF1ZGUgQ29kZSBwcm9jZXNzIHRlcm1pbmF0ZWQgYnkgc2lnbmFsICR7c2lnbmFsfWApO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgbG9nRm9yRGVidWdnaW5nKG1lc3NhZ2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuREVCVUcpIHtcbiAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGAke21lc3NhZ2V9XG5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zdGRlcnIpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5zdGRlcnIobWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIHdyaXRlKGRhdGEpIHtcbiAgICBpZiAodGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBYm9ydEVycm9yKFwiT3BlcmF0aW9uIGFib3J0ZWRcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZWFkeSB8fCAhdGhpcy5jaGlsZFN0ZGluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9jZXNzVHJhbnNwb3J0IGlzIG5vdCByZWFkeSBmb3Igd3JpdGluZ1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2hpbGQ/LmtpbGxlZCB8fCB0aGlzLmNoaWxkPy5leGl0Q29kZSAhPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHdyaXRlIHRvIHRlcm1pbmF0ZWQgcHJvY2Vzc1wiKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZXhpdEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB3cml0ZSB0byBwcm9jZXNzIHRoYXQgZXhpdGVkIHdpdGggZXJyb3I6ICR7dGhpcy5leGl0RXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkRFQlVHX1NESykge1xuICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoYFtQcm9jZXNzVHJhbnNwb3J0XSBXcml0aW5nIHRvIHN0ZGluOiAke2RhdGEuc3Vic3RyaW5nKDAsIDEwMCl9XG5gKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHdyaXR0ZW4gPSB0aGlzLmNoaWxkU3RkaW4ud3JpdGUoZGF0YSk7XG4gICAgICBpZiAoIXdyaXR0ZW4gJiYgcHJvY2Vzcy5lbnYuREVCVUdfU0RLKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIltQcm9jZXNzVHJhbnNwb3J0XSBXcml0ZSBidWZmZXIgZnVsbCwgZGF0YSBxdWV1ZWRcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIHRvIHByb2Nlc3Mgc3RkaW46ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRTdGRpbikge1xuICAgICAgdGhpcy5jaGlsZFN0ZGluLmVuZCgpO1xuICAgICAgdGhpcy5jaGlsZFN0ZGluID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9jZXNzRXhpdEhhbmRsZXIpIHtcbiAgICAgIHByb2Nlc3Mub2ZmKFwiZXhpdFwiLCB0aGlzLnByb2Nlc3NFeGl0SGFuZGxlcik7XG4gICAgICB0aGlzLnByb2Nlc3NFeGl0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWJvcnRIYW5kbGVyKSB7XG4gICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIHRoaXMuYWJvcnRIYW5kbGVyKTtcbiAgICAgIHRoaXMuYWJvcnRIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHsgaGFuZGxlciB9IG9mIHRoaXMuZXhpdExpc3RlbmVycykge1xuICAgICAgdGhpcy5jaGlsZD8ub2ZmKFwiZXhpdFwiLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5leGl0TGlzdGVuZXJzID0gW107XG4gICAgaWYgKHRoaXMuY2hpbGQgJiYgIXRoaXMuY2hpbGQua2lsbGVkKSB7XG4gICAgICB0aGlzLmNoaWxkLmtpbGwoXCJTSUdURVJNXCIpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkICYmICF0aGlzLmNoaWxkLmtpbGxlZCkge1xuICAgICAgICAgIHRoaXMuY2hpbGQua2lsbChcIlNJR0tJTExcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIH1cbiAgaXNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkeTtcbiAgfVxuICBhc3luYyogcmVhZE1lc3NhZ2VzKCkge1xuICAgIGlmICghdGhpcy5jaGlsZFN0ZG91dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvY2Vzc1RyYW5zcG9ydCBvdXRwdXQgc3RyZWFtIG5vdCBhdmFpbGFibGVcIik7XG4gICAgfVxuICAgIGNvbnN0IHJsID0gY3JlYXRlSW50ZXJmYWNlKHsgaW5wdXQ6IHRoaXMuY2hpbGRTdGRvdXQgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgbGluZSBvZiBybCkge1xuICAgICAgICBpZiAobGluZS50cmltKCkpIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICB5aWVsZCBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JFeGl0KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBybC5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBlbmRJbnB1dCgpIHtcbiAgICBpZiAodGhpcy5jaGlsZFN0ZGluKSB7XG4gICAgICB0aGlzLmNoaWxkU3RkaW4uZW5kKCk7XG4gICAgfVxuICB9XG4gIGdldElucHV0U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkU3RkaW47XG4gIH1cbiAgb25FeGl0KGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmNoaWxkKVxuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMuZ2V0UHJvY2Vzc0V4aXRFcnJvcihjb2RlLCBzaWduYWwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH07XG4gICAgdGhpcy5jaGlsZC5vbihcImV4aXRcIiwgaGFuZGxlcik7XG4gICAgdGhpcy5leGl0TGlzdGVuZXJzLnB1c2goeyBjYWxsYmFjaywgaGFuZGxlciB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5vZmYoXCJleGl0XCIsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmV4aXRMaXN0ZW5lcnMuZmluZEluZGV4KChsKSA9PiBsLmhhbmRsZXIgPT09IGhhbmRsZXIpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLmV4aXRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFzeW5jIHdhaXRGb3JFeGl0KCkge1xuICAgIGlmICghdGhpcy5jaGlsZCkge1xuICAgICAgaWYgKHRoaXMuZXhpdEVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXhpdEVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5jaGlsZC5leGl0Q29kZSAhPT0gbnVsbCB8fCB0aGlzLmNoaWxkLmtpbGxlZCkge1xuICAgICAgaWYgKHRoaXMuZXhpdEVycm9yKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXhpdEVycm9yO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgZXhpdEhhbmRsZXIgPSAoY29kZSwgc2lnbmFsKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlamVjdChuZXcgQWJvcnRFcnJvcihcIk9wZXJhdGlvbiBhYm9ydGVkXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdldFByb2Nlc3NFeGl0RXJyb3IoY29kZSwgc2lnbmFsKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLmNoaWxkLm9uY2UoXCJleGl0XCIsIGV4aXRIYW5kbGVyKTtcbiAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmNoaWxkLm9mZihcImV4aXRcIiwgZXhpdEhhbmRsZXIpO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2hpbGQub25jZShcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICB0aGlzLmNoaWxkLm9uY2UoXCJleGl0XCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5jaGlsZC5vZmYoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTmF0aXZlQmluYXJ5KGV4ZWN1dGFibGVQYXRoKSB7XG4gIGNvbnN0IGpzRXh0ZW5zaW9ucyA9IFtcIi5qc1wiLCBcIi5tanNcIiwgXCIudHN4XCIsIFwiLnRzXCIsIFwiLmpzeFwiXTtcbiAgcmV0dXJuICFqc0V4dGVuc2lvbnMuc29tZSgoZXh0KSA9PiBleGVjdXRhYmxlUGF0aC5lbmRzV2l0aChleHQpKTtcbn1cblxuLy8gLi4vc3JjL3V0aWxzL3N0cmVhbS50c1xuY2xhc3MgU3RyZWFtIHtcbiAgcmV0dXJuZWQ7XG4gIHF1ZXVlID0gW107XG4gIHJlYWRSZXNvbHZlO1xuICByZWFkUmVqZWN0O1xuICBpc0RvbmUgPSBmYWxzZTtcbiAgaGFzRXJyb3I7XG4gIHN0YXJ0ZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocmV0dXJuZWQpIHtcbiAgICB0aGlzLnJldHVybmVkID0gcmV0dXJuZWQ7XG4gIH1cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY2FuIG9ubHkgYmUgaXRlcmF0ZWQgb25jZVwiKTtcbiAgICB9XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZXh0KCkge1xuICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHRoaXMucXVldWUuc2hpZnQoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRG9uZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5oYXNFcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlYWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVhZFJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMucmVhZFJlc29sdmUpIHtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlYWRSZXNvbHZlO1xuICAgICAgdGhpcy5yZWFkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVhZFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucXVldWUucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGRvbmUoKSB7XG4gICAgdGhpcy5pc0RvbmUgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJlYWRSZXNvbHZlKSB7XG4gICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5yZWFkUmVzb2x2ZTtcbiAgICAgIHRoaXMucmVhZFJlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlYWRSZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICB9XG4gIH1cbiAgZXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmhhc0Vycm9yID0gZXJyb3I7XG4gICAgaWYgKHRoaXMucmVhZFJlamVjdCkge1xuICAgICAgY29uc3QgcmVqZWN0ID0gdGhpcy5yZWFkUmVqZWN0O1xuICAgICAgdGhpcy5yZWFkUmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVhZFJlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybigpIHtcbiAgICB0aGlzLmlzRG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMucmV0dXJuZWQpIHtcbiAgICAgIHRoaXMucmV0dXJuZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gIH1cbn1cblxuLy8gLi4vc3JjL3NlcnZpY2VzL21jcC9TZGtDb250cm9sVHJhbnNwb3J0LnRzXG5jbGFzcyBTZGtDb250cm9sU2VydmVyVHJhbnNwb3J0IHtcbiAgc2VuZE1jcE1lc3NhZ2U7XG4gIGlzQ2xvc2VkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHNlbmRNY3BNZXNzYWdlKSB7XG4gICAgdGhpcy5zZW5kTWNwTWVzc2FnZSA9IHNlbmRNY3BNZXNzYWdlO1xuICB9XG4gIG9uY2xvc2U7XG4gIG9uZXJyb3I7XG4gIG9ubWVzc2FnZTtcbiAgYXN5bmMgc3RhcnQoKSB7fVxuICBhc3luYyBzZW5kKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IGlzIGNsb3NlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5zZW5kTWNwTWVzc2FnZShtZXNzYWdlKTtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9uY2xvc2U/LigpO1xuICB9XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanNcbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xudmFyIF9mcmVlR2xvYmFsX2RlZmF1bHQgPSBmcmVlR2xvYmFsO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSBcIm9iamVjdFwiICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xudmFyIHJvb3QgPSBfZnJlZUdsb2JhbF9kZWZhdWx0IHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbnZhciBfcm9vdF9kZWZhdWx0ID0gcm9vdDtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzXG52YXIgU3ltYm9sMiA9IF9yb290X2RlZmF1bHQuU3ltYm9sO1xudmFyIF9TeW1ib2xfZGVmYXVsdCA9IFN5bWJvbDI7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qc1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG52YXIgc3ltVG9TdHJpbmdUYWcgPSBfU3ltYm9sX2RlZmF1bHQgPyBfU3ltYm9sX2RlZmF1bHQudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgX2dldFJhd1RhZ19kZWZhdWx0ID0gZ2V0UmF3VGFnO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vYmplY3RUb1N0cmluZy5qc1xudmFyIG9iamVjdFByb3RvMiA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcyID0gb2JqZWN0UHJvdG8yLnRvU3RyaW5nO1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nMi5jYWxsKHZhbHVlKTtcbn1cbnZhciBfb2JqZWN0VG9TdHJpbmdfZGVmYXVsdCA9IG9iamVjdFRvU3RyaW5nO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzXG52YXIgbnVsbFRhZyA9IFwiW29iamVjdCBOdWxsXVwiO1xudmFyIHVuZGVmaW5lZFRhZyA9IFwiW29iamVjdCBVbmRlZmluZWRdXCI7XG52YXIgc3ltVG9TdHJpbmdUYWcyID0gX1N5bWJvbF9kZWZhdWx0ID8gX1N5bWJvbF9kZWZhdWx0LnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gc3ltVG9TdHJpbmdUYWcyICYmIHN5bVRvU3RyaW5nVGFnMiBpbiBPYmplY3QodmFsdWUpID8gX2dldFJhd1RhZ19kZWZhdWx0KHZhbHVlKSA6IF9vYmplY3RUb1N0cmluZ19kZWZhdWx0KHZhbHVlKTtcbn1cbnZhciBfYmFzZUdldFRhZ19kZWZhdWx0ID0gYmFzZUdldFRhZztcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qc1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09IFwib2JqZWN0XCIgfHwgdHlwZSA9PSBcImZ1bmN0aW9uXCIpO1xufVxudmFyIGlzT2JqZWN0X2RlZmF1bHQgPSBpc09iamVjdDtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzXG52YXIgYXN5bmNUYWcgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIjtcbnZhciBmdW5jVGFnID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xudmFyIGdlblRhZyA9IFwiW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl1cIjtcbnZhciBwcm94eVRhZyA9IFwiW29iamVjdCBQcm94eV1cIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdF9kZWZhdWx0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdGFnID0gX2Jhc2VHZXRUYWdfZGVmYXVsdCh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG52YXIgaXNGdW5jdGlvbl9kZWZhdWx0ID0gaXNGdW5jdGlvbjtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29yZUpzRGF0YS5qc1xudmFyIGNvcmVKc0RhdGEgPSBfcm9vdF9kZWZhdWx0W1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdO1xudmFyIF9jb3JlSnNEYXRhX2RlZmF1bHQgPSBjb3JlSnNEYXRhO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc01hc2tlZC5qc1xudmFyIG1hc2tTcmNLZXkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoX2NvcmVKc0RhdGFfZGVmYXVsdCAmJiBfY29yZUpzRGF0YV9kZWZhdWx0LmtleXMgJiYgX2NvcmVKc0RhdGFfZGVmYXVsdC5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICByZXR1cm4gdWlkID8gXCJTeW1ib2woc3JjKV8xLlwiICsgdWlkIDogXCJcIjtcbn0oKTtcbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiBtYXNrU3JjS2V5IGluIGZ1bmM7XG59XG52YXIgX2lzTWFza2VkX2RlZmF1bHQgPSBpc01hc2tlZDtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fdG9Tb3VyY2UuanNcbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuYyArIFwiXCI7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cbnZhciBfdG9Tb3VyY2VfZGVmYXVsdCA9IHRvU291cmNlO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNOYXRpdmUuanNcbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcbnZhciBmdW5jUHJvdG8yID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIG9iamVjdFByb3RvMyA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgZnVuY1RvU3RyaW5nMiA9IGZ1bmNQcm90bzIudG9TdHJpbmc7XG52YXIgaGFzT3duUHJvcGVydHkyID0gb2JqZWN0UHJvdG8zLmhhc093blByb3BlcnR5O1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoXCJeXCIgKyBmdW5jVG9TdHJpbmcyLmNhbGwoaGFzT3duUHJvcGVydHkyKS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgXCJcXFxcJCZcIikucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgXCIkMS4qP1wiKSArIFwiJFwiKTtcbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0X2RlZmF1bHQodmFsdWUpIHx8IF9pc01hc2tlZF9kZWZhdWx0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb25fZGVmYXVsdCh2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KF90b1NvdXJjZV9kZWZhdWx0KHZhbHVlKSk7XG59XG52YXIgX2Jhc2VJc05hdGl2ZV9kZWZhdWx0ID0gYmFzZUlzTmF0aXZlO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19nZXRWYWx1ZS5qc1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG52YXIgX2dldFZhbHVlX2RlZmF1bHQgPSBnZXRWYWx1ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TmF0aXZlLmpzXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gX2dldFZhbHVlX2RlZmF1bHQob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gX2Jhc2VJc05hdGl2ZV9kZWZhdWx0KHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxudmFyIF9nZXROYXRpdmVfZGVmYXVsdCA9IGdldE5hdGl2ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9lcS5qc1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbn1cbnZhciBlcV9kZWZhdWx0ID0gZXE7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUNyZWF0ZS5qc1xudmFyIG5hdGl2ZUNyZWF0ZSA9IF9nZXROYXRpdmVfZGVmYXVsdChPYmplY3QsIFwiY3JlYXRlXCIpO1xudmFyIF9uYXRpdmVDcmVhdGVfZGVmYXVsdCA9IG5hdGl2ZUNyZWF0ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaENsZWFyLmpzXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBfbmF0aXZlQ3JlYXRlX2RlZmF1bHQgPyBfbmF0aXZlQ3JlYXRlX2RlZmF1bHQobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cbnZhciBfaGFzaENsZWFyX2RlZmF1bHQgPSBoYXNoQ2xlYXI7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hEZWxldGUuanNcbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBfaGFzaERlbGV0ZV9kZWZhdWx0ID0gaGFzaERlbGV0ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faGFzaEdldC5qc1xudmFyIEhBU0hfVU5ERUZJTkVEID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG52YXIgb2JqZWN0UHJvdG80ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eTMgPSBvYmplY3RQcm90bzQuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChfbmF0aXZlQ3JlYXRlX2RlZmF1bHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eTMuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxudmFyIF9oYXNoR2V0X2RlZmF1bHQgPSBoYXNoR2V0O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19oYXNoSGFzLmpzXG52YXIgb2JqZWN0UHJvdG81ID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eTQgPSBvYmplY3RQcm90bzUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBfbmF0aXZlQ3JlYXRlX2RlZmF1bHQgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5NC5jYWxsKGRhdGEsIGtleSk7XG59XG52YXIgX2hhc2hIYXNfZGVmYXVsdCA9IGhhc2hIYXM7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2hhc2hTZXQuanNcbnZhciBIQVNIX1VOREVGSU5FRDIgPSBcIl9fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX19cIjtcbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IF9uYXRpdmVDcmVhdGVfZGVmYXVsdCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gSEFTSF9VTkRFRklORUQyIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxudmFyIF9oYXNoU2V0X2RlZmF1bHQgPSBoYXNoU2V0O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19IYXNoLmpzXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gX2hhc2hDbGVhcl9kZWZhdWx0O1xuSGFzaC5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBfaGFzaERlbGV0ZV9kZWZhdWx0O1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gX2hhc2hHZXRfZGVmYXVsdDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IF9oYXNoSGFzX2RlZmF1bHQ7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBfaGFzaFNldF9kZWZhdWx0O1xudmFyIF9IYXNoX2RlZmF1bHQgPSBIYXNoO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19saXN0Q2FjaGVDbGVhci5qc1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cbnZhciBfbGlzdENhY2hlQ2xlYXJfZGVmYXVsdCA9IGxpc3RDYWNoZUNsZWFyO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hc3NvY0luZGV4T2YuanNcbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcV9kZWZhdWx0KGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cbnZhciBfYXNzb2NJbmRleE9mX2RlZmF1bHQgPSBhc3NvY0luZGV4T2Y7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2xpc3RDYWNoZURlbGV0ZS5qc1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXywgaW5kZXggPSBfYXNzb2NJbmRleE9mX2RlZmF1bHQoZGF0YSwga2V5KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxudmFyIF9saXN0Q2FjaGVEZWxldGVfZGVmYXVsdCA9IGxpc3RDYWNoZURlbGV0ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlR2V0LmpzXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXywgaW5kZXggPSBfYXNzb2NJbmRleE9mX2RlZmF1bHQoZGF0YSwga2V5KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxudmFyIF9saXN0Q2FjaGVHZXRfZGVmYXVsdCA9IGxpc3RDYWNoZUdldDtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlSGFzLmpzXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBfYXNzb2NJbmRleE9mX2RlZmF1bHQodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxudmFyIF9saXN0Q2FjaGVIYXNfZGVmYXVsdCA9IGxpc3RDYWNoZUhhcztcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbGlzdENhY2hlU2V0LmpzXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gX2Fzc29jSW5kZXhPZl9kZWZhdWx0KGRhdGEsIGtleSk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxudmFyIF9saXN0Q2FjaGVTZXRfZGVmYXVsdCA9IGxpc3RDYWNoZVNldDtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fTGlzdENhY2hlLmpzXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IF9saXN0Q2FjaGVDbGVhcl9kZWZhdWx0O1xuTGlzdENhY2hlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IF9saXN0Q2FjaGVEZWxldGVfZGVmYXVsdDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gX2xpc3RDYWNoZUdldF9kZWZhdWx0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBfbGlzdENhY2hlSGFzX2RlZmF1bHQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IF9saXN0Q2FjaGVTZXRfZGVmYXVsdDtcbnZhciBfTGlzdENhY2hlX2RlZmF1bHQgPSBMaXN0Q2FjaGU7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX01hcC5qc1xudmFyIE1hcDIgPSBfZ2V0TmF0aXZlX2RlZmF1bHQoX3Jvb3RfZGVmYXVsdCwgXCJNYXBcIik7XG52YXIgX01hcF9kZWZhdWx0ID0gTWFwMjtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVDbGVhci5qc1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICBoYXNoOiBuZXcgX0hhc2hfZGVmYXVsdCxcbiAgICBtYXA6IG5ldyAoX01hcF9kZWZhdWx0IHx8IF9MaXN0Q2FjaGVfZGVmYXVsdCksXG4gICAgc3RyaW5nOiBuZXcgX0hhc2hfZGVmYXVsdFxuICB9O1xufVxudmFyIF9tYXBDYWNoZUNsZWFyX2RlZmF1bHQgPSBtYXBDYWNoZUNsZWFyO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0tleWFibGUuanNcbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlID09IFwibnVtYmVyXCIgfHwgdHlwZSA9PSBcInN5bWJvbFwiIHx8IHR5cGUgPT0gXCJib29sZWFuXCIgPyB2YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiA6IHZhbHVlID09PSBudWxsO1xufVxudmFyIF9pc0tleWFibGVfZGVmYXVsdCA9IGlzS2V5YWJsZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0TWFwRGF0YS5qc1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIF9pc0tleWFibGVfZGVmYXVsdChrZXkpID8gZGF0YVt0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgPyBcInN0cmluZ1wiIDogXCJoYXNoXCJdIDogZGF0YS5tYXA7XG59XG52YXIgX2dldE1hcERhdGFfZGVmYXVsdCA9IGdldE1hcERhdGE7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlRGVsZXRlLmpzXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IF9nZXRNYXBEYXRhX2RlZmF1bHQodGhpcywga2V5KVtcImRlbGV0ZVwiXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG52YXIgX21hcENhY2hlRGVsZXRlX2RlZmF1bHQgPSBtYXBDYWNoZURlbGV0ZTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbWFwQ2FjaGVHZXQuanNcbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gX2dldE1hcERhdGFfZGVmYXVsdCh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxudmFyIF9tYXBDYWNoZUdldF9kZWZhdWx0ID0gbWFwQ2FjaGVHZXQ7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX21hcENhY2hlSGFzLmpzXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIF9nZXRNYXBEYXRhX2RlZmF1bHQodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cbnZhciBfbWFwQ2FjaGVIYXNfZGVmYXVsdCA9IG1hcENhY2hlSGFzO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19tYXBDYWNoZVNldC5qc1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IF9nZXRNYXBEYXRhX2RlZmF1bHQodGhpcywga2V5KSwgc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cbnZhciBfbWFwQ2FjaGVTZXRfZGVmYXVsdCA9IG1hcENhY2hlU2V0O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19NYXBDYWNoZS5qc1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gX21hcENhY2hlQ2xlYXJfZGVmYXVsdDtcbk1hcENhY2hlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IF9tYXBDYWNoZURlbGV0ZV9kZWZhdWx0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IF9tYXBDYWNoZUdldF9kZWZhdWx0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IF9tYXBDYWNoZUhhc19kZWZhdWx0O1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IF9tYXBDYWNoZVNldF9kZWZhdWx0O1xudmFyIF9NYXBDYWNoZV9kZWZhdWx0ID0gTWFwQ2FjaGU7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvbWVtb2l6ZS5qc1xudmFyIEZVTkNfRVJST1JfVEVYVCA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiO1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiIHx8IHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9IFwiZnVuY3Rpb25cIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cywga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBfTWFwQ2FjaGVfZGVmYXVsdCk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cbm1lbW9pemUuQ2FjaGUgPSBfTWFwQ2FjaGVfZGVmYXVsdDtcbnZhciBtZW1vaXplX2RlZmF1bHQgPSBtZW1vaXplO1xuLy8gLi4vc3JjL3V0aWxzL3Byb2Nlc3MudHNcbnZhciBDSFVOS19TSVpFID0gMjAwMDtcbmZ1bmN0aW9uIHdyaXRlVG9TdGRlcnIoZGF0YSkge1xuICBmb3IgKGxldCBpID0gMDtpIDwgZGF0YS5sZW5ndGg7IGkgKz0gQ0hVTktfU0laRSkge1xuICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKGRhdGEuc3Vic3RyaW5nKGksIGkgKyBDSFVOS19TSVpFKSk7XG4gIH1cbn1cblxuLy8gLi4vc3JjL3V0aWxzL2RlYnVnRmlsdGVyLnRzXG52YXIgcGFyc2VEZWJ1Z0ZpbHRlciA9IG1lbW9pemVfZGVmYXVsdCgoZmlsdGVyU3RyaW5nKSA9PiB7XG4gIGlmICghZmlsdGVyU3RyaW5nIHx8IGZpbHRlclN0cmluZy50cmltKCkgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBmaWx0ZXJzID0gZmlsdGVyU3RyaW5nLnNwbGl0KFwiLFwiKS5tYXAoKGYpID0+IGYudHJpbSgpKS5maWx0ZXIoQm9vbGVhbik7XG4gIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGhhc0V4Y2x1c2l2ZSA9IGZpbHRlcnMuc29tZSgoZikgPT4gZi5zdGFydHNXaXRoKFwiIVwiKSk7XG4gIGNvbnN0IGhhc0luY2x1c2l2ZSA9IGZpbHRlcnMuc29tZSgoZikgPT4gIWYuc3RhcnRzV2l0aChcIiFcIikpO1xuICBpZiAoaGFzRXhjbHVzaXZlICYmIGhhc0luY2x1c2l2ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGNsZWFuRmlsdGVycyA9IGZpbHRlcnMubWFwKChmKSA9PiBmLnJlcGxhY2UoL14hLywgXCJcIikudG9Mb3dlckNhc2UoKSk7XG4gIHJldHVybiB7XG4gICAgaW5jbHVkZTogaGFzRXhjbHVzaXZlID8gW10gOiBjbGVhbkZpbHRlcnMsXG4gICAgZXhjbHVkZTogaGFzRXhjbHVzaXZlID8gY2xlYW5GaWx0ZXJzIDogW10sXG4gICAgaXNFeGNsdXNpdmU6IGhhc0V4Y2x1c2l2ZVxuICB9O1xufSk7XG5mdW5jdGlvbiBleHRyYWN0RGVidWdDYXRlZ29yaWVzKG1lc3NhZ2UpIHtcbiAgY29uc3QgY2F0ZWdvcmllcyA9IFtdO1xuICBjb25zdCBtY3BNYXRjaCA9IG1lc3NhZ2UubWF0Y2goL15NQ1Agc2VydmVyIFtcIiddKFteXCInXSspW1wiJ10vKTtcbiAgaWYgKG1jcE1hdGNoICYmIG1jcE1hdGNoWzFdKSB7XG4gICAgY2F0ZWdvcmllcy5wdXNoKFwibWNwXCIpO1xuICAgIGNhdGVnb3JpZXMucHVzaChtY3BNYXRjaFsxXS50b0xvd2VyQ2FzZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmVmaXhNYXRjaCA9IG1lc3NhZ2UubWF0Y2goL14oW146W10rKTovKTtcbiAgICBpZiAocHJlZml4TWF0Y2ggJiYgcHJlZml4TWF0Y2hbMV0pIHtcbiAgICAgIGNhdGVnb3JpZXMucHVzaChwcmVmaXhNYXRjaFsxXS50cmltKCkudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGJyYWNrZXRNYXRjaCA9IG1lc3NhZ2UubWF0Y2goL15cXFsoW15cXF1dKyldLyk7XG4gIGlmIChicmFja2V0TWF0Y2ggJiYgYnJhY2tldE1hdGNoWzFdKSB7XG4gICAgY2F0ZWdvcmllcy5wdXNoKGJyYWNrZXRNYXRjaFsxXS50cmltKCkudG9Mb3dlckNhc2UoKSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInN0YXRzaWcgZXZlbnQ6XCIpKSB7XG4gICAgY2F0ZWdvcmllcy5wdXNoKFwic3RhdHNpZ1wiKTtcbiAgfVxuICBjb25zdCBzZWNvbmRhcnlNYXRjaCA9IG1lc3NhZ2UubWF0Y2goLzpcXHMqKFteOl0rPykoPzpcXHMrKD86dHlwZXxtb2RlfHN0YXR1c3xldmVudCkpPzovKTtcbiAgaWYgKHNlY29uZGFyeU1hdGNoICYmIHNlY29uZGFyeU1hdGNoWzFdKSB7XG4gICAgY29uc3Qgc2Vjb25kYXJ5ID0gc2Vjb25kYXJ5TWF0Y2hbMV0udHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHNlY29uZGFyeS5sZW5ndGggPCAzMCAmJiAhc2Vjb25kYXJ5LmluY2x1ZGVzKFwiIFwiKSkge1xuICAgICAgY2F0ZWdvcmllcy5wdXNoKHNlY29uZGFyeSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoY2F0ZWdvcmllcykpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2hvd0RlYnVnQ2F0ZWdvcmllcyhjYXRlZ29yaWVzLCBmaWx0ZXIpIHtcbiAgaWYgKCFmaWx0ZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5pc0V4Y2x1c2l2ZSkge1xuICAgIHJldHVybiAhY2F0ZWdvcmllcy5zb21lKChjYXQpID0+IGZpbHRlci5leGNsdWRlLmluY2x1ZGVzKGNhdCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjYXRlZ29yaWVzLnNvbWUoKGNhdCkgPT4gZmlsdGVyLmluY2x1ZGUuaW5jbHVkZXMoY2F0KSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFNob3dEZWJ1Z01lc3NhZ2UobWVzc2FnZSwgZmlsdGVyKSB7XG4gIGlmICghZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2F0ZWdvcmllcyA9IGV4dHJhY3REZWJ1Z0NhdGVnb3JpZXMobWVzc2FnZSk7XG4gIHJldHVybiBzaG91bGRTaG93RGVidWdDYXRlZ29yaWVzKGNhdGVnb3JpZXMsIGZpbHRlcik7XG59XG5cbi8vIC4uL3NyYy91dGlscy9lbnZVdGlscy50c1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSBcIm9zXCI7XG5mdW5jdGlvbiBnZXRDbGF1ZGVDb25maWdIb21lRGlyKCkge1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuQ0xBVURFX0NPTkZJR19ESVIgPz8gam9pbihob21lZGlyKCksIFwiLmNsYXVkZVwiKTtcbn1cbmZ1bmN0aW9uIGlzRW52VHJ1dGh5KGVudlZhcikge1xuICBpZiAoIWVudlZhcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZW52VmFyID09PSBcImJvb2xlYW5cIilcbiAgICByZXR1cm4gZW52VmFyO1xuICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBlbnZWYXIudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gIHJldHVybiBbXCIxXCIsIFwidHJ1ZVwiLCBcInllc1wiLCBcIm9uXCJdLmluY2x1ZGVzKG5vcm1hbGl6ZWRWYWx1ZSk7XG59XG5cbi8vIC4uL3NyYy91dGlscy9kZWJ1Zy50c1xuaW1wb3J0IHsgZGlybmFtZSwgam9pbiBhcyBqb2luMiB9IGZyb20gXCJwYXRoXCI7XG5cbi8vIC4uL3NyYy9ib290c3RyYXAvc3RhdGUudHNcbmltcG9ydCB7IGN3ZCB9IGZyb20gXCJwcm9jZXNzXCI7XG5pbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSBcImNyeXB0b1wiO1xuXG4vLyAuLi9zcmMvYm9vdHN0cmFwL2VudlZhbGlkYXRvcnMudHNcbnZhciBiYXNoTWF4T3V0cHV0TGVuZ3RoVmFsaWRhdG9yID0ge1xuICBuYW1lOiBcIkJBU0hfTUFYX09VVFBVVF9MRU5HVEhcIixcbiAgZGVmYXVsdDogMzAwMDAsXG4gIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBNQVhfT1VUUFVUX0xFTkdUSCA9IDE1MDAwMDtcbiAgICBjb25zdCBERUZBVUxUX01BWF9PVVRQVVRfTEVOR1RIID0gMzAwMDA7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0aXZlOiBERUZBVUxUX01BWF9PVVRQVVRfTEVOR1RILFxuICAgICAgICBzdGF0dXM6IFwidmFsaWRcIlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSB8fCBwYXJzZWQgPD0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0aXZlOiBERUZBVUxUX01BWF9PVVRQVVRfTEVOR1RILFxuICAgICAgICBzdGF0dXM6IFwiaW52YWxpZFwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCB2YWx1ZSBcIiR7dmFsdWV9XCIgKHVzaW5nIGRlZmF1bHQ6ICR7REVGQVVMVF9NQVhfT1VUUFVUX0xFTkdUSH0pYFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBhcnNlZCA+IE1BWF9PVVRQVVRfTEVOR1RIKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZmZlY3RpdmU6IE1BWF9PVVRQVVRfTEVOR1RILFxuICAgICAgICBzdGF0dXM6IFwiY2FwcGVkXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDYXBwZWQgZnJvbSAke3BhcnNlZH0gdG8gJHtNQVhfT1VUUFVUX0xFTkdUSH1gXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBlZmZlY3RpdmU6IHBhcnNlZCwgc3RhdHVzOiBcInZhbGlkXCIgfTtcbiAgfVxufTtcbnZhciBtYXhPdXRwdXRUb2tlbnNWYWxpZGF0b3IgPSB7XG4gIG5hbWU6IFwiQ0xBVURFX0NPREVfTUFYX09VVFBVVF9UT0tFTlNcIixcbiAgZGVmYXVsdDogMzIwMDAsXG4gIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4geyBlZmZlY3RpdmU6IDMyMDAwLCBzdGF0dXM6IFwidmFsaWRcIiB9O1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIGlmIChpc05hTihwYXJzZWQpIHx8IHBhcnNlZCA8PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlZmZlY3RpdmU6IDMyMDAwLFxuICAgICAgICBzdGF0dXM6IFwiaW52YWxpZFwiLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCB2YWx1ZSBcIiR7dmFsdWV9XCIgKHVzaW5nIGRlZmF1bHQ6IDMyMDAwKWBcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChwYXJzZWQgPiAzMjAwMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWZmZWN0aXZlOiAzMjAwMCxcbiAgICAgICAgc3RhdHVzOiBcImNhcHBlZFwiLFxuICAgICAgICBtZXNzYWdlOiBgQ2FwcGVkIGZyb20gJHtwYXJzZWR9IHRvIDMyMDAwYFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZWZmZWN0aXZlOiBwYXJzZWQsIHN0YXR1czogXCJ2YWxpZFwiIH07XG4gIH1cbn07XG5cbi8vIC4uL3NyYy9ib290c3RyYXAvc3RhdGUudHNcbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbEN3ZDogY3dkKCksXG4gICAgdG90YWxDb3N0VVNEOiAwLFxuICAgIHRvdGFsQVBJRHVyYXRpb246IDAsXG4gICAgdG90YWxBUElEdXJhdGlvbldpdGhvdXRSZXRyaWVzOiAwLFxuICAgIHRvdGFsVG9vbER1cmF0aW9uOiAwLFxuICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICBsYXN0SW50ZXJhY3Rpb25UaW1lOiBEYXRlLm5vdygpLFxuICAgIHRvdGFsTGluZXNBZGRlZDogMCxcbiAgICB0b3RhbExpbmVzUmVtb3ZlZDogMCxcbiAgICBoYXNVbmtub3duTW9kZWxDb3N0OiBmYWxzZSxcbiAgICBjd2Q6IGN3ZCgpLFxuICAgIG1vZGVsVXNhZ2U6IHt9LFxuICAgIG1haW5Mb29wTW9kZWxPdmVycmlkZTogdW5kZWZpbmVkLFxuICAgIG1heFJhdGVMaW1pdEZhbGxiYWNrQWN0aXZlOiBmYWxzZSxcbiAgICBpbml0aWFsTWFpbkxvb3BNb2RlbDogbnVsbCxcbiAgICBtb2RlbFN0cmluZ3M6IG51bGwsXG4gICAgaXNOb25JbnRlcmFjdGl2ZVNlc3Npb246IHRydWUsXG4gICAgaXNJbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgY2xpZW50VHlwZTogXCJjbGlcIixcbiAgICBzZXNzaW9uSW5ncmVzc1Rva2VuOiB1bmRlZmluZWQsXG4gICAgb2F1dGhUb2tlbkZyb21GZDogdW5kZWZpbmVkLFxuICAgIGFwaUtleUZyb21GZDogdW5kZWZpbmVkLFxuICAgIGZsYWdTZXR0aW5nc1BhdGg6IHVuZGVmaW5lZCxcbiAgICBhbGxvd2VkU2V0dGluZ1NvdXJjZXM6IFtcbiAgICAgIFwidXNlclNldHRpbmdzXCIsXG4gICAgICBcInByb2plY3RTZXR0aW5nc1wiLFxuICAgICAgXCJsb2NhbFNldHRpbmdzXCIsXG4gICAgICBcImZsYWdTZXR0aW5nc1wiLFxuICAgICAgXCJwb2xpY3lTZXR0aW5nc1wiXG4gICAgXSxcbiAgICBtZXRlcjogbnVsbCxcbiAgICBzZXNzaW9uQ291bnRlcjogbnVsbCxcbiAgICBsb2NDb3VudGVyOiBudWxsLFxuICAgIHByQ291bnRlcjogbnVsbCxcbiAgICBjb21taXRDb3VudGVyOiBudWxsLFxuICAgIGNvc3RDb3VudGVyOiBudWxsLFxuICAgIHRva2VuQ291bnRlcjogbnVsbCxcbiAgICBjb2RlRWRpdFRvb2xEZWNpc2lvbkNvdW50ZXI6IG51bGwsXG4gICAgYWN0aXZlVGltZUNvdW50ZXI6IG51bGwsXG4gICAgc2Vzc2lvbklkOiByYW5kb21VVUlEKCksXG4gICAgbG9nZ2VyUHJvdmlkZXI6IG51bGwsXG4gICAgZXZlbnRMb2dnZXI6IG51bGwsXG4gICAgbWV0ZXJQcm92aWRlcjogbnVsbCxcbiAgICBhZ2VudENvbG9yTWFwOiBuZXcgTWFwLFxuICAgIGFnZW50Q29sb3JJbmRleDogMCxcbiAgICBlbnZWYXJWYWxpZGF0b3JzOiBbYmFzaE1heE91dHB1dExlbmd0aFZhbGlkYXRvciwgbWF4T3V0cHV0VG9rZW5zVmFsaWRhdG9yXSxcbiAgICBsYXN0QVBJUmVxdWVzdDogbnVsbCxcbiAgICBpbk1lbW9yeUVycm9yTG9nOiBbXVxuICB9O1xufVxudmFyIFNUQVRFID0gZ2V0SW5pdGlhbFN0YXRlKCk7XG5mdW5jdGlvbiBnZXRTZXNzaW9uSWQoKSB7XG4gIHJldHVybiBTVEFURS5zZXNzaW9uSWQ7XG59XG5cbi8vIC4uL3NyYy91dGlscy9kZWJ1Zy50c1xudmFyIGlzRGVidWdNb2RlID0gbWVtb2l6ZV9kZWZhdWx0KCgpID0+IHtcbiAgcmV0dXJuIGlzRW52VHJ1dGh5KHByb2Nlc3MuZW52LkRFQlVHKSB8fCBpc0VudlRydXRoeShwcm9jZXNzLmVudi5ERUJVR19TREspIHx8IHByb2Nlc3MuYXJndi5pbmNsdWRlcyhcIi0tZGVidWdcIikgfHwgcHJvY2Vzcy5hcmd2LmluY2x1ZGVzKFwiLWRcIikgfHwgaXNEZWJ1Z1RvU3RkRXJyKCkgfHwgcHJvY2Vzcy5hcmd2LnNvbWUoKGFyZykgPT4gYXJnLnN0YXJ0c1dpdGgoXCItLWRlYnVnPVwiKSk7XG59KTtcbnZhciBnZXREZWJ1Z0ZpbHRlciA9IG1lbW9pemVfZGVmYXVsdCgoKSA9PiB7XG4gIGNvbnN0IGRlYnVnQXJnID0gcHJvY2Vzcy5hcmd2LmZpbmQoKGFyZykgPT4gYXJnLnN0YXJ0c1dpdGgoXCItLWRlYnVnPVwiKSk7XG4gIGlmICghZGVidWdBcmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBmaWx0ZXJQYXR0ZXJuID0gZGVidWdBcmcuc3Vic3RyaW5nKFwiLS1kZWJ1Zz1cIi5sZW5ndGgpO1xuICByZXR1cm4gcGFyc2VEZWJ1Z0ZpbHRlcihmaWx0ZXJQYXR0ZXJuKTtcbn0pO1xudmFyIGlzRGVidWdUb1N0ZEVyciA9IG1lbW9pemVfZGVmYXVsdCgoKSA9PiB7XG4gIHJldHVybiBwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoXCItLWRlYnVnLXRvLXN0ZGVyclwiKSB8fCBwcm9jZXNzLmFyZ3YuaW5jbHVkZXMoXCItZDJlXCIpO1xufSk7XG5mdW5jdGlvbiBzaG91bGRMb2dEZWJ1Z01lc3NhZ2UobWVzc2FnZSkge1xuICBjb25zdCBmaWx0ZXIgPSBnZXREZWJ1Z0ZpbHRlcigpO1xuICByZXR1cm4gc2hvdWxkU2hvd0RlYnVnTWVzc2FnZShtZXNzYWdlLCBmaWx0ZXIpO1xufVxudmFyIGhhc0Zvcm1hdHRlZE91dHB1dCA9IGZhbHNlO1xuZnVuY3Rpb24gbG9nRm9yRGVidWdnaW5nKG1lc3NhZ2UsIHsgbGV2ZWwgfSA9IHtcbiAgbGV2ZWw6IFwiZGVidWdcIlxufSkge1xuICBpZiAoIXNob3VsZExvZ0RlYnVnTWVzc2FnZShtZXNzYWdlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaGFzRm9ybWF0dGVkT3V0cHV0ICYmIG1lc3NhZ2UuaW5jbHVkZXMoYFxuYCkpIHtcbiAgICBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0ID0gYFske2xldmVsLnRvVXBwZXJDYXNlKCl9XSAke21lc3NhZ2UudHJpbSgpfVxuYDtcbiAgaWYgKGlzRGVidWdUb1N0ZEVycigpKSB7XG4gICAgd3JpdGVUb1N0ZGVycihvdXRwdXQpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWdldEZzSW1wbGVtZW50YXRpb24oKS5leGlzdHNTeW5jKGRpcm5hbWUoZ2V0RGVidWdMb2dQYXRoKCkpKSkge1xuICAgIGdldEZzSW1wbGVtZW50YXRpb24oKS5ta2RpclN5bmMoZGlybmFtZShnZXREZWJ1Z0xvZ1BhdGgoKSkpO1xuICB9XG4gIGdldEZzSW1wbGVtZW50YXRpb24oKS5hcHBlbmRGaWxlU3luYyhnZXREZWJ1Z0xvZ1BhdGgoKSwgb3V0cHV0KTtcbiAgdXBkYXRlTGF0ZXN0RGVidWdMb2dTeW1saW5rKCk7XG59XG5mdW5jdGlvbiBnZXREZWJ1Z0xvZ1BhdGgoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5DTEFVREVfQ09ERV9ERUJVR19MT0dTX0RJUiA/PyBqb2luMihnZXRDbGF1ZGVDb25maWdIb21lRGlyKCksIFwiZGVidWdcIiwgYCR7Z2V0U2Vzc2lvbklkKCl9LnR4dGApO1xufVxudmFyIHVwZGF0ZUxhdGVzdERlYnVnTG9nU3ltbGluayA9IG1lbW9pemVfZGVmYXVsdCgoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZGVidWdMb2dQYXRoID0gZ2V0RGVidWdMb2dQYXRoKCk7XG4gICAgY29uc3QgZGVidWdMb2dzRGlyID0gZGlybmFtZShkZWJ1Z0xvZ1BhdGgpO1xuICAgIGNvbnN0IGxhdGVzdFN5bWxpbmtQYXRoID0gam9pbjIoZGVidWdMb2dzRGlyLCBcImxhdGVzdFwiKTtcbiAgICBpZiAoIWdldEZzSW1wbGVtZW50YXRpb24oKS5leGlzdHNTeW5jKGRlYnVnTG9nc0RpcikpIHtcbiAgICAgIGdldEZzSW1wbGVtZW50YXRpb24oKS5ta2RpclN5bmMoZGVidWdMb2dzRGlyKTtcbiAgICB9XG4gICAgaWYgKGdldEZzSW1wbGVtZW50YXRpb24oKS5leGlzdHNTeW5jKGxhdGVzdFN5bWxpbmtQYXRoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ2V0RnNJbXBsZW1lbnRhdGlvbigpLnVubGlua1N5bmMobGF0ZXN0U3ltbGlua1BhdGgpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBnZXRGc0ltcGxlbWVudGF0aW9uKCkuc3ltbGlua1N5bmMoZGVidWdMb2dQYXRoLCBsYXRlc3RTeW1saW5rUGF0aCk7XG4gIH0gY2F0Y2gge31cbn0pO1xuXG4vLyAuLi9zcmMvY29yZS9RdWVyeS50c1xuY2xhc3MgUXVlcnkge1xuICB0cmFuc3BvcnQ7XG4gIGlzU2luZ2xlVXNlclR1cm47XG4gIGNhblVzZVRvb2w7XG4gIGhvb2tzO1xuICBhYm9ydENvbnRyb2xsZXI7XG4gIHBlbmRpbmdDb250cm9sUmVzcG9uc2VzID0gbmV3IE1hcDtcbiAgY2xlYW51cFBlcmZvcm1lZCA9IGZhbHNlO1xuICBzZGtNZXNzYWdlcztcbiAgaW5wdXRTdHJlYW0gPSBuZXcgU3RyZWFtO1xuICBpbml0aWFsaXphdGlvbjtcbiAgY2FuY2VsQ29udHJvbGxlcnMgPSBuZXcgTWFwO1xuICBob29rQ2FsbGJhY2tzID0gbmV3IE1hcDtcbiAgbmV4dENhbGxiYWNrSWQgPSAwO1xuICBzZGtNY3BUcmFuc3BvcnRzID0gbmV3IE1hcDtcbiAgcGVuZGluZ01jcFJlc3BvbnNlcyA9IG5ldyBNYXA7XG4gIGZpcnN0UmVzdWx0UmVjZWl2ZWRQcm9taXNlO1xuICBmaXJzdFJlc3VsdFJlY2VpdmVkUmVzb2x2ZTtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBpc1NpbmdsZVVzZXJUdXJuLCBjYW5Vc2VUb29sLCBob29rcywgYWJvcnRDb250cm9sbGVyLCBzZGtNY3BTZXJ2ZXJzID0gbmV3IE1hcCkge1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuaXNTaW5nbGVVc2VyVHVybiA9IGlzU2luZ2xlVXNlclR1cm47XG4gICAgdGhpcy5jYW5Vc2VUb29sID0gY2FuVXNlVG9vbDtcbiAgICB0aGlzLmhvb2tzID0gaG9va3M7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgc2VydmVyXSBvZiBzZGtNY3BTZXJ2ZXJzKSB7XG4gICAgICBjb25zdCBzZGtUcmFuc3BvcnQgPSBuZXcgU2RrQ29udHJvbFNlcnZlclRyYW5zcG9ydCgobWVzc2FnZSkgPT4gdGhpcy5zZW5kTWNwU2VydmVyTWVzc2FnZVRvQ2xpKG5hbWUsIG1lc3NhZ2UpKTtcbiAgICAgIHRoaXMuc2RrTWNwVHJhbnNwb3J0cy5zZXQobmFtZSwgc2RrVHJhbnNwb3J0KTtcbiAgICAgIHNlcnZlci5jb25uZWN0KHNka1RyYW5zcG9ydCk7XG4gICAgfVxuICAgIHRoaXMuc2RrTWVzc2FnZXMgPSB0aGlzLnJlYWRTZGtNZXNzYWdlcygpO1xuICAgIHRoaXMuZmlyc3RSZXN1bHRSZWNlaXZlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5maXJzdFJlc3VsdFJlY2VpdmVkUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgdGhpcy5yZWFkTWVzc2FnZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemF0aW9uID0gdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy5pbml0aWFsaXphdGlvbi5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc2V0RXJyb3IoZXJyb3IpIHtcbiAgICB0aGlzLmlucHV0U3RyZWFtLmVycm9yKGVycm9yKTtcbiAgfVxuICBjbGVhbnVwKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuY2xlYW51cFBlcmZvcm1lZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNsZWFudXBQZXJmb3JtZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ29udHJvbFJlc3BvbnNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5wZW5kaW5nTWNwUmVzcG9uc2VzLmNsZWFyKCk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5pbnB1dFN0cmVhbS5lcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlucHV0U3RyZWFtLmRvbmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gIH1cbiAgbmV4dCguLi5bdmFsdWVdKSB7XG4gICAgcmV0dXJuIHRoaXMuc2RrTWVzc2FnZXMubmV4dCguLi5bdmFsdWVdKTtcbiAgfVxuICByZXR1cm4odmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZGtNZXNzYWdlcy5yZXR1cm4odmFsdWUpO1xuICB9XG4gIHRocm93KGUpIHtcbiAgICByZXR1cm4gdGhpcy5zZGtNZXNzYWdlcy50aHJvdyhlKTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLnNka01lc3NhZ2VzO1xuICB9XG4gIFtTeW1ib2wuYXN5bmNEaXNwb3NlXSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZGtNZXNzYWdlc1tTeW1ib2wuYXN5bmNEaXNwb3NlXSgpO1xuICB9XG4gIGFzeW5jIHJlYWRNZXNzYWdlcygpIHtcbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHRoaXMudHJhbnNwb3J0LnJlYWRNZXNzYWdlcygpKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwiY29udHJvbF9yZXNwb25zZVwiKSB7XG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ0NvbnRyb2xSZXNwb25zZXMuZ2V0KG1lc3NhZ2UucmVzcG9uc2UucmVxdWVzdF9pZCk7XG4gICAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZXIobWVzc2FnZS5yZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UudHlwZSA9PT0gXCJjb250cm9sX3JlcXVlc3RcIikge1xuICAgICAgICAgIHRoaXMuaGFuZGxlQ29udHJvbFJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImNvbnRyb2xfY2FuY2VsX3JlcXVlc3RcIikge1xuICAgICAgICAgIHRoaXMuaGFuZGxlQ29udHJvbENhbmNlbFJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS50eXBlID09PSBcImtlZXBfYWxpdmVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlLnR5cGUgPT09IFwicmVzdWx0XCIpIHtcbiAgICAgICAgICBpZiAodGhpcy5maXJzdFJlc3VsdFJlY2VpdmVkUmVzb2x2ZSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFJlc3VsdFJlY2VpdmVkUmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVVzZXJUdXJuKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5lbmRJbnB1dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlucHV0U3RyZWFtLmVucXVldWUobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlucHV0U3RyZWFtLmRvbmUoKTtcbiAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmlucHV0U3RyZWFtLmVycm9yKGVycm9yKTtcbiAgICAgIHRoaXMuY2xlYW51cChlcnJvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGhhbmRsZUNvbnRyb2xSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICB0aGlzLmNhbmNlbENvbnRyb2xsZXJzLnNldChyZXF1ZXN0LnJlcXVlc3RfaWQsIGNvbnRyb2xsZXIpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucHJvY2Vzc0NvbnRyb2xSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgIGNvbnN0IGNvbnRyb2xSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogXCJjb250cm9sX3Jlc3BvbnNlXCIsXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgc3VidHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgcmVxdWVzdF9pZDogcmVxdWVzdC5yZXF1ZXN0X2lkLFxuICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUodGhpcy50cmFuc3BvcnQud3JpdGUoSlNPTi5zdHJpbmdpZnkoY29udHJvbFJlc3BvbnNlKSArIGBcbmApKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgY29udHJvbEVycm9yUmVzcG9uc2UgPSB7XG4gICAgICAgIHR5cGU6IFwiY29udHJvbF9yZXNwb25zZVwiLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgIHN1YnR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICByZXF1ZXN0X2lkOiByZXF1ZXN0LnJlcXVlc3RfaWQsXG4gICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMudHJhbnNwb3J0LndyaXRlKEpTT04uc3RyaW5naWZ5KGNvbnRyb2xFcnJvclJlc3BvbnNlKSArIGBcbmApKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5jYW5jZWxDb250cm9sbGVycy5kZWxldGUocmVxdWVzdC5yZXF1ZXN0X2lkKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ29udHJvbENhbmNlbFJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNhbmNlbENvbnRyb2xsZXJzLmdldChyZXF1ZXN0LnJlcXVlc3RfaWQpO1xuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICB0aGlzLmNhbmNlbENvbnRyb2xsZXJzLmRlbGV0ZShyZXF1ZXN0LnJlcXVlc3RfaWQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzQ29udHJvbFJlcXVlc3QocmVxdWVzdCwgc2lnbmFsKSB7XG4gICAgaWYgKHJlcXVlc3QucmVxdWVzdC5zdWJ0eXBlID09PSBcImNhbl91c2VfdG9vbFwiKSB7XG4gICAgICBpZiAoIXRoaXMuY2FuVXNlVG9vbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5Vc2VUb29sIGNhbGxiYWNrIGlzIG5vdCBwcm92aWRlZC5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jYW5Vc2VUb29sKHJlcXVlc3QucmVxdWVzdC50b29sX25hbWUsIHJlcXVlc3QucmVxdWVzdC5pbnB1dCwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIHN1Z2dlc3Rpb25zOiByZXF1ZXN0LnJlcXVlc3QucGVybWlzc2lvbl9zdWdnZXN0aW9uc1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LnJlcXVlc3Quc3VidHlwZSA9PT0gXCJob29rX2NhbGxiYWNrXCIpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlSG9va0NhbGxiYWNrcyhyZXF1ZXN0LnJlcXVlc3QuY2FsbGJhY2tfaWQsIHJlcXVlc3QucmVxdWVzdC5pbnB1dCwgcmVxdWVzdC5yZXF1ZXN0LnRvb2xfdXNlX2lkLCBzaWduYWwpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVxdWVzdC5zdWJ0eXBlID09PSBcIm1jcF9tZXNzYWdlXCIpIHtcbiAgICAgIGNvbnN0IG1jcFJlcXVlc3QgPSByZXF1ZXN0LnJlcXVlc3Q7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLnNka01jcFRyYW5zcG9ydHMuZ2V0KG1jcFJlcXVlc3Quc2VydmVyX25hbWUpO1xuICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTREsgTUNQIHNlcnZlciBub3QgZm91bmQ6ICR7bWNwUmVxdWVzdC5zZXJ2ZXJfbmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChcIm1ldGhvZFwiIGluIG1jcFJlcXVlc3QubWVzc2FnZSAmJiBcImlkXCIgaW4gbWNwUmVxdWVzdC5tZXNzYWdlICYmIG1jcFJlcXVlc3QubWVzc2FnZS5pZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaGFuZGxlTWNwQ29udHJvbFJlcXVlc3QobWNwUmVxdWVzdC5zZXJ2ZXJfbmFtZSwgbWNwUmVxdWVzdCwgdHJhbnNwb3J0KTtcbiAgICAgICAgcmV0dXJuIHsgbWNwX3Jlc3BvbnNlOiByZXNwb25zZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRyYW5zcG9ydC5vbm1lc3NhZ2UpIHtcbiAgICAgICAgICB0cmFuc3BvcnQub25tZXNzYWdlKG1jcFJlcXVlc3QubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWNwX3Jlc3BvbnNlOiB7IGpzb25ycGM6IFwiMi4wXCIsIHJlc3VsdDoge30sIGlkOiAwIH0gfTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgY29udHJvbCByZXF1ZXN0IHN1YnR5cGU6IFwiICsgcmVxdWVzdC5yZXF1ZXN0LnN1YnR5cGUpO1xuICB9XG4gIGFzeW5jKiByZWFkU2RrTWVzc2FnZXMoKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHRoaXMuaW5wdXRTdHJlYW0pIHtcbiAgICAgIHlpZWxkIG1lc3NhZ2U7XG4gICAgfVxuICB9XG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgbGV0IGhvb2tzO1xuICAgIGlmICh0aGlzLmhvb2tzKSB7XG4gICAgICBob29rcyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBbZXZlbnQsIG1hdGNoZXJzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmhvb2tzKSkge1xuICAgICAgICBpZiAobWF0Y2hlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGhvb2tzW2V2ZW50XSA9IG1hdGNoZXJzLm1hcCgobWF0Y2hlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tJZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgbWF0Y2hlci5ob29rcykge1xuICAgICAgICAgICAgICBjb25zdCBjYWxsYmFja0lkID0gYGhvb2tfJHt0aGlzLm5leHRDYWxsYmFja0lkKyt9YDtcbiAgICAgICAgICAgICAgdGhpcy5ob29rQ2FsbGJhY2tzLnNldChjYWxsYmFja0lkLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIGNhbGxiYWNrSWRzLnB1c2goY2FsbGJhY2tJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBtYXRjaGVyOiBtYXRjaGVyLm1hdGNoZXIsXG4gICAgICAgICAgICAgIGhvb2tDYWxsYmFja0lkczogY2FsbGJhY2tJZHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2RrTWNwU2VydmVycyA9IHRoaXMuc2RrTWNwVHJhbnNwb3J0cy5zaXplID4gMCA/IEFycmF5LmZyb20odGhpcy5zZGtNY3BUcmFuc3BvcnRzLmtleXMoKSkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaW5pdFJlcXVlc3QgPSB7XG4gICAgICBzdWJ0eXBlOiBcImluaXRpYWxpemVcIixcbiAgICAgIGhvb2tzLFxuICAgICAgc2RrTWNwU2VydmVyc1xuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3QoaW5pdFJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZS5yZXNwb25zZTtcbiAgfVxuICBhc3luYyBpbnRlcnJ1cHQoKSB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHN1YnR5cGU6IFwiaW50ZXJydXB0XCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzZXRQZXJtaXNzaW9uTW9kZShtb2RlKSB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHN1YnR5cGU6IFwic2V0X3Blcm1pc3Npb25fbW9kZVwiLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgIHN1YnR5cGU6IFwic2V0X21vZGVsXCIsXG4gICAgICBtb2RlbFxuICAgIH0pO1xuICB9XG4gIHJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSk7XG4gICAgY29uc3Qgc2RrUmVxdWVzdCA9IHtcbiAgICAgIHJlcXVlc3RfaWQ6IHJlcXVlc3RJZCxcbiAgICAgIHR5cGU6IFwiY29udHJvbF9yZXF1ZXN0XCIsXG4gICAgICByZXF1ZXN0XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nQ29udHJvbFJlc3BvbnNlcy5zZXQocmVxdWVzdElkLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1YnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5lcnJvcikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh0aGlzLnRyYW5zcG9ydC53cml0ZShKU09OLnN0cmluZ2lmeShzZGtSZXF1ZXN0KSArIGBcbmApKTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzdXBwb3J0ZWRDb21tYW5kcygpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW5pdGlhbGl6YXRpb24pLmNvbW1hbmRzO1xuICB9XG4gIGFzeW5jIHN1cHBvcnRlZE1vZGVscygpIHtcbiAgICByZXR1cm4gKGF3YWl0IHRoaXMuaW5pdGlhbGl6YXRpb24pLm1vZGVscztcbiAgfVxuICBhc3luYyBtY3BTZXJ2ZXJTdGF0dXMoKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcXVlc3Qoe1xuICAgICAgc3VidHlwZTogXCJtY3Bfc3RhdHVzXCJcbiAgICB9KTtcbiAgICBjb25zdCBtY3BTdGF0dXNSZXNwb25zZSA9IHJlc3BvbnNlLnJlc3BvbnNlO1xuICAgIHJldHVybiBtY3BTdGF0dXNSZXNwb25zZS5tY3BTZXJ2ZXJzO1xuICB9XG4gIGFzeW5jIGFjY291bnRJbmZvKCkge1xuICAgIHJldHVybiAoYXdhaXQgdGhpcy5pbml0aWFsaXphdGlvbikuYWNjb3VudDtcbiAgfVxuICBhc3luYyBzdHJlYW1JbnB1dChzdHJlYW0pIHtcbiAgICBsb2dGb3JEZWJ1Z2dpbmcoYFtRdWVyeS5zdHJlYW1JbnB1dF0gU3RhcnRpbmcgdG8gcHJvY2VzcyBpbnB1dCBzdHJlYW1gKTtcbiAgICBsb2dGb3JEZWJ1Z2dpbmcoYFtRdWVyeS5zdHJlYW1JbnB1dF0gdGhpcy5zZGtNY3BUcmFuc3BvcnRzLnNpemUgPSAke3RoaXMuc2RrTWNwVHJhbnNwb3J0cy5zaXplfWApO1xuICAgIHRyeSB7XG4gICAgICBsZXQgbWVzc2FnZUNvdW50ID0gMDtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgbWVzc2FnZSBvZiBzdHJlYW0pIHtcbiAgICAgICAgbWVzc2FnZUNvdW50Kys7XG4gICAgICAgIGxvZ0ZvckRlYnVnZ2luZyhgW1F1ZXJ5LnN0cmVhbUlucHV0XSBQcm9jZXNzaW5nIG1lc3NhZ2UgJHttZXNzYWdlQ291bnR9OiAke21lc3NhZ2UudHlwZX1gKTtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKHRoaXMudHJhbnNwb3J0LndyaXRlKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpICsgYFxuYCkpO1xuICAgICAgfVxuICAgICAgbG9nRm9yRGVidWdnaW5nKGBbUXVlcnkuc3RyZWFtSW5wdXRdIEZpbmlzaGVkIHByb2Nlc3NpbmcgJHttZXNzYWdlQ291bnR9IG1lc3NhZ2VzIGZyb20gaW5wdXQgc3RyZWFtYCk7XG4gICAgICBsb2dGb3JEZWJ1Z2dpbmcoYFtRdWVyeS5zdHJlYW1JbnB1dF0gQWJvdXQgdG8gY2hlY2sgTUNQIHNlcnZlcnMuIHRoaXMuc2RrTWNwVHJhbnNwb3J0cy5zaXplID0gJHt0aGlzLnNka01jcFRyYW5zcG9ydHMuc2l6ZX1gKTtcbiAgICAgIGlmICh0aGlzLnNka01jcFRyYW5zcG9ydHMuc2l6ZSA+IDAgJiYgdGhpcy5maXJzdFJlc3VsdFJlY2VpdmVkUHJvbWlzZSkge1xuICAgICAgICBsb2dGb3JEZWJ1Z2dpbmcoYFtRdWVyeS5zdHJlYW1JbnB1dF0gRW50ZXJpbmcgUHJvbWlzZS5yYWNlIHRvIHdhaXQgZm9yIHJlc3VsdGApO1xuICAgICAgICBjb25zdCBTVFJFQU1fQ0xPU0VfVElNRU9VVCA9IDFlNDtcbiAgICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICB0aGlzLmZpcnN0UmVzdWx0UmVjZWl2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbG9nRm9yRGVidWdnaW5nKGBbUXVlcnkuc3RyZWFtSW5wdXRdIFJlY2VpdmVkIGZpcnN0IHJlc3VsdCwgY2xvc2luZyBpbnB1dCBzdHJlYW1gKTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksXG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBsb2dGb3JEZWJ1Z2dpbmcoYFtRdWVyeS5zdHJlYW1JbnB1dF0gVGltZWQgb3V0IHdhaXRpbmcgZm9yIGZpcnN0IHJlc3VsdCwgY2xvc2luZyBpbnB1dCBzdHJlYW1gKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgU1RSRUFNX0NMT1NFX1RJTUVPVVQpO1xuICAgICAgICAgIH0pXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxvZ0ZvckRlYnVnZ2luZyhgW1F1ZXJ5XSBDYWxsaW5nIHRyYW5zcG9ydC5lbmRJbnB1dCgpIHRvIGNsb3NlIHN0ZGluIHRvIENMSSBwcm9jZXNzYCk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5lbmRJbnB1dCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEFib3J0RXJyb3IpKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVIb29rQ2FsbGJhY2tzKGNhbGxiYWNrSWQsIGlucHV0LCB0b29sVXNlSUQsIGFib3J0U2lnbmFsKSB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLmhvb2tDYWxsYmFja3MuZ2V0KGNhbGxiYWNrSWQpO1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gaG9vayBjYWxsYmFjayBmb3VuZCBmb3IgSUQ6ICR7Y2FsbGJhY2tJZH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKGlucHV0LCB0b29sVXNlSUQsIHtcbiAgICAgIHNpZ25hbDogYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgfVxuICBzZW5kTWNwU2VydmVyTWVzc2FnZVRvQ2xpKHNlcnZlck5hbWUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoXCJpZFwiIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS5pZCAhPT0gbnVsbCAmJiBtZXNzYWdlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke3NlcnZlck5hbWV9OiR7bWVzc2FnZS5pZH1gO1xuICAgICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ01jcFJlc3BvbnNlcy5nZXQoa2V5KTtcbiAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcucmVzb2x2ZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWNwUmVzcG9uc2VzLmRlbGV0ZShrZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHBlbmRpbmcgcmVxdWVzdCBmb3VuZFwiKTtcbiAgfVxuICBoYW5kbGVNY3BDb250cm9sUmVxdWVzdChzZXJ2ZXJOYW1lLCBtY3BSZXF1ZXN0LCB0cmFuc3BvcnQpIHtcbiAgICBjb25zdCBtZXNzYWdlSWQgPSBcImlkXCIgaW4gbWNwUmVxdWVzdC5tZXNzYWdlID8gbWNwUmVxdWVzdC5tZXNzYWdlLmlkIDogbnVsbDtcbiAgICBjb25zdCBrZXkgPSBgJHtzZXJ2ZXJOYW1lfToke21lc3NhZ2VJZH1gO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBsZXQgdGltZW91dElkID0gbnVsbDtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdNY3BSZXNwb25zZXMuZGVsZXRlKGtleSk7XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVzb2x2ZUFuZENsZWFudXAgPSAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgICBjb25zdCByZWplY3RBbmRDbGVhbnVwID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBlbmRpbmdNY3BSZXNwb25zZXMuc2V0KGtleSwge1xuICAgICAgICByZXNvbHZlOiByZXNvbHZlQW5kQ2xlYW51cCxcbiAgICAgICAgcmVqZWN0OiByZWplY3RBbmRDbGVhbnVwXG4gICAgICB9KTtcbiAgICAgIGlmICh0cmFuc3BvcnQub25tZXNzYWdlKSB7XG4gICAgICAgIHRyYW5zcG9ydC5vbm1lc3NhZ2UobWNwUmVxdWVzdC5tZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIk5vIG1lc3NhZ2UgaGFuZGxlciByZWdpc3RlcmVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgTUNQX1JFUVVFU1RfVElNRU9VVF9NUyA9IE51bWJlcihwcm9jZXNzLmVudi5NQ1BfUkVRVUVTVF9USU1FT1VUX01TID8/IDE4MDAwMCk7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ01jcFJlc3BvbnNlcy5oYXMoa2V5KSkge1xuICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdCB0aW1lb3V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSwgTUNQX1JFUVVFU1RfVElNRU9VVF9NUyk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gLi4vc3JjL2NvcmUvc2hhcmVkUXVlcnkudHNcbmZ1bmN0aW9uIGNyZWF0ZVNoYXJlZFF1ZXJ5KHtcbiAgcHJvbXB0LFxuICBvcHRpb25zOiB7XG4gICAgYWJvcnRDb250cm9sbGVyID0gY3JlYXRlQWJvcnRDb250cm9sbGVyKCksXG4gICAgYWRkaXRpb25hbERpcmVjdG9yaWVzID0gW10sXG4gICAgYWdlbnRzLFxuICAgIGFsbG93ZWRUb29scyA9IFtdLFxuICAgIGFwcGVuZFN5c3RlbVByb21wdCxcbiAgICBjYW5Vc2VUb29sLFxuICAgIGNvbnRpbnVlOiBjb250aW51ZUNvbnZlcnNhdGlvbixcbiAgICBjdXN0b21TeXN0ZW1Qcm9tcHQsXG4gICAgY3dkOiBjd2QyLFxuICAgIGRpc2FsbG93ZWRUb29scyA9IFtdLFxuICAgIGVudixcbiAgICBleGVjdXRhYmxlID0gaXNSdW5uaW5nV2l0aEJ1bigpID8gXCJidW5cIiA6IFwibm9kZVwiLFxuICAgIGV4ZWN1dGFibGVBcmdzID0gW10sXG4gICAgZXh0cmFBcmdzID0ge30sXG4gICAgZmFsbGJhY2tNb2RlbCxcbiAgICBmb3JrU2Vzc2lvbixcbiAgICBob29rcyxcbiAgICBpbmNsdWRlUGFydGlhbE1lc3NhZ2VzLFxuICAgIG1heFRoaW5raW5nVG9rZW5zLFxuICAgIG1heFR1cm5zLFxuICAgIG1jcFNlcnZlcnMsXG4gICAgbW9kZWwsXG4gICAgcGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUsXG4gICAgcGVybWlzc2lvbk1vZGUgPSBcImRlZmF1bHRcIixcbiAgICBwZXJtaXNzaW9uUHJvbXB0VG9vbE5hbWUsXG4gICAgcmVzdW1lLFxuICAgIHJlc3VtZVNlc3Npb25BdCxcbiAgICBzZXR0aW5nU291cmNlcyxcbiAgICBzdGRlcnIsXG4gICAgc3RyaWN0TWNwQ29uZmlnXG4gIH0gPSB7fVxufSkge1xuICBpZiAoIWVudikge1xuICAgIGVudiA9IHsgLi4ucHJvY2Vzcy5lbnYgfTtcbiAgfVxuICBpZiAoIWVudi5DTEFVREVfQ09ERV9FTlRSWVBPSU5UKSB7XG4gICAgZW52LkNMQVVERV9DT0RFX0VOVFJZUE9JTlQgPSBcInNkay10c1wiO1xuICB9XG4gIGlmICghcGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSBpcyByZXF1aXJlZFwiKTtcbiAgfVxuICBjb25zdCBhbGxNY3BTZXJ2ZXJzID0ge307XG4gIGNvbnN0IHNka01jcFNlcnZlcnMgPSBuZXcgTWFwO1xuICBpZiAobWNwU2VydmVycykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbmZpZ10gb2YgT2JqZWN0LmVudHJpZXMobWNwU2VydmVycykpIHtcbiAgICAgIGlmIChjb25maWcudHlwZSA9PT0gXCJzZGtcIiAmJiBcImluc3RhbmNlXCIgaW4gY29uZmlnKSB7XG4gICAgICAgIHNka01jcFNlcnZlcnMuc2V0KG5hbWUsIGNvbmZpZy5pbnN0YW5jZSk7XG4gICAgICAgIGFsbE1jcFNlcnZlcnNbbmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJzZGtcIixcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxNY3BTZXJ2ZXJzW25hbWVdID0gY29uZmlnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBpc1NpbmdsZVVzZXJUdXJuID0gdHlwZW9mIHByb21wdCA9PT0gXCJzdHJpbmdcIjtcbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFByb2Nlc3NUcmFuc3BvcnQoe1xuICAgIGFib3J0Q29udHJvbGxlcixcbiAgICBhZGRpdGlvbmFsRGlyZWN0b3JpZXMsXG4gICAgYWdlbnRzLFxuICAgIGN3ZDogY3dkMixcbiAgICBleGVjdXRhYmxlLFxuICAgIGV4ZWN1dGFibGVBcmdzLFxuICAgIGV4dHJhQXJncyxcbiAgICBwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSxcbiAgICBlbnYsXG4gICAgZm9ya1Nlc3Npb24sXG4gICAgc3RkZXJyLFxuICAgIGN1c3RvbVN5c3RlbVByb21wdCxcbiAgICBhcHBlbmRTeXN0ZW1Qcm9tcHQsXG4gICAgbWF4VGhpbmtpbmdUb2tlbnMsXG4gICAgbWF4VHVybnMsXG4gICAgbW9kZWwsXG4gICAgZmFsbGJhY2tNb2RlbCxcbiAgICBwZXJtaXNzaW9uTW9kZSxcbiAgICBwZXJtaXNzaW9uUHJvbXB0VG9vbE5hbWUsXG4gICAgY29udGludWVDb252ZXJzYXRpb24sXG4gICAgcmVzdW1lLFxuICAgIHJlc3VtZVNlc3Npb25BdCxcbiAgICBzZXR0aW5nU291cmNlcyxcbiAgICBhbGxvd2VkVG9vbHMsXG4gICAgZGlzYWxsb3dlZFRvb2xzLFxuICAgIG1jcFNlcnZlcnM6IGFsbE1jcFNlcnZlcnMsXG4gICAgc3RyaWN0TWNwQ29uZmlnLFxuICAgIGNhblVzZVRvb2w6ICEhY2FuVXNlVG9vbCxcbiAgICBob29rczogISFob29rcyxcbiAgICBpbmNsdWRlUGFydGlhbE1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSh0cmFuc3BvcnQsIGlzU2luZ2xlVXNlclR1cm4sIGNhblVzZVRvb2wsIGhvb2tzLCBhYm9ydENvbnRyb2xsZXIsIHNka01jcFNlcnZlcnMpO1xuICBpZiAodHlwZW9mIHByb21wdCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyYW5zcG9ydC53cml0ZShKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiBcInVzZXJcIixcbiAgICAgIHNlc3Npb25faWQ6IFwiXCIsXG4gICAgICBtZXNzYWdlOiB7XG4gICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcHJvbXB0IH1dXG4gICAgICB9LFxuICAgICAgcGFyZW50X3Rvb2xfdXNlX2lkOiBudWxsXG4gICAgfSkgKyBgXG5gKTtcbiAgfSBlbHNlIHtcbiAgICBxdWVyeS5zdHJlYW1JbnB1dChwcm9tcHQpO1xuICB9XG4gIHJldHVybiBxdWVyeTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC92My9leHRlcm5hbC5qc1xudmFyIGV4cG9ydHNfZXh0ZXJuYWwgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfZXh0ZXJuYWwsIHtcbiAgdm9pZDogKCkgPT4gdm9pZFR5cGUsXG4gIHV0aWw6ICgpID0+IHV0aWwsXG4gIHVua25vd246ICgpID0+IHVua25vd25UeXBlLFxuICB1bmlvbjogKCkgPT4gdW5pb25UeXBlLFxuICB1bmRlZmluZWQ6ICgpID0+IHVuZGVmaW5lZFR5cGUsXG4gIHR1cGxlOiAoKSA9PiB0dXBsZVR5cGUsXG4gIHRyYW5zZm9ybWVyOiAoKSA9PiBlZmZlY3RzVHlwZSxcbiAgc3ltYm9sOiAoKSA9PiBzeW1ib2xUeXBlLFxuICBzdHJpbmc6ICgpID0+IHN0cmluZ1R5cGUsXG4gIHN0cmljdE9iamVjdDogKCkgPT4gc3RyaWN0T2JqZWN0VHlwZSxcbiAgc2V0RXJyb3JNYXA6ICgpID0+IHNldEVycm9yTWFwLFxuICBzZXQ6ICgpID0+IHNldFR5cGUsXG4gIHJlY29yZDogKCkgPT4gcmVjb3JkVHlwZSxcbiAgcXVvdGVsZXNzSnNvbjogKCkgPT4gcXVvdGVsZXNzSnNvbixcbiAgcHJvbWlzZTogKCkgPT4gcHJvbWlzZVR5cGUsXG4gIHByZXByb2Nlc3M6ICgpID0+IHByZXByb2Nlc3NUeXBlLFxuICBwaXBlbGluZTogKCkgPT4gcGlwZWxpbmVUeXBlLFxuICBvc3RyaW5nOiAoKSA9PiBvc3RyaW5nLFxuICBvcHRpb25hbDogKCkgPT4gb3B0aW9uYWxUeXBlLFxuICBvbnVtYmVyOiAoKSA9PiBvbnVtYmVyLFxuICBvYm9vbGVhbjogKCkgPT4gb2Jvb2xlYW4sXG4gIG9iamVjdFV0aWw6ICgpID0+IG9iamVjdFV0aWwsXG4gIG9iamVjdDogKCkgPT4gb2JqZWN0VHlwZSxcbiAgbnVtYmVyOiAoKSA9PiBudW1iZXJUeXBlLFxuICBudWxsYWJsZTogKCkgPT4gbnVsbGFibGVUeXBlLFxuICBudWxsOiAoKSA9PiBudWxsVHlwZSxcbiAgbmV2ZXI6ICgpID0+IG5ldmVyVHlwZSxcbiAgbmF0aXZlRW51bTogKCkgPT4gbmF0aXZlRW51bVR5cGUsXG4gIG5hbjogKCkgPT4gbmFuVHlwZSxcbiAgbWFwOiAoKSA9PiBtYXBUeXBlLFxuICBtYWtlSXNzdWU6ICgpID0+IG1ha2VJc3N1ZSxcbiAgbGl0ZXJhbDogKCkgPT4gbGl0ZXJhbFR5cGUsXG4gIGxhenk6ICgpID0+IGxhenlUeXBlLFxuICBsYXRlOiAoKSA9PiBsYXRlLFxuICBpc1ZhbGlkOiAoKSA9PiBpc1ZhbGlkLFxuICBpc0RpcnR5OiAoKSA9PiBpc0RpcnR5LFxuICBpc0FzeW5jOiAoKSA9PiBpc0FzeW5jLFxuICBpc0Fib3J0ZWQ6ICgpID0+IGlzQWJvcnRlZCxcbiAgaW50ZXJzZWN0aW9uOiAoKSA9PiBpbnRlcnNlY3Rpb25UeXBlLFxuICBpbnN0YW5jZW9mOiAoKSA9PiBpbnN0YW5jZU9mVHlwZSxcbiAgZ2V0UGFyc2VkVHlwZTogKCkgPT4gZ2V0UGFyc2VkVHlwZSxcbiAgZ2V0RXJyb3JNYXA6ICgpID0+IGdldEVycm9yTWFwLFxuICBmdW5jdGlvbjogKCkgPT4gZnVuY3Rpb25UeXBlLFxuICBlbnVtOiAoKSA9PiBlbnVtVHlwZSxcbiAgZWZmZWN0OiAoKSA9PiBlZmZlY3RzVHlwZSxcbiAgZGlzY3JpbWluYXRlZFVuaW9uOiAoKSA9PiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICBkZWZhdWx0RXJyb3JNYXA6ICgpID0+IGVuX2RlZmF1bHQsXG4gIGRhdGV0aW1lUmVnZXg6ICgpID0+IGRhdGV0aW1lUmVnZXgsXG4gIGRhdGU6ICgpID0+IGRhdGVUeXBlLFxuICBjdXN0b206ICgpID0+IGN1c3RvbSxcbiAgY29lcmNlOiAoKSA9PiBjb2VyY2UsXG4gIGJvb2xlYW46ICgpID0+IGJvb2xlYW5UeXBlLFxuICBiaWdpbnQ6ICgpID0+IGJpZ0ludFR5cGUsXG4gIGFycmF5OiAoKSA9PiBhcnJheVR5cGUsXG4gIGFueTogKCkgPT4gYW55VHlwZSxcbiAgYWRkSXNzdWVUb0NvbnRleHQ6ICgpID0+IGFkZElzc3VlVG9Db250ZXh0LFxuICBab2RWb2lkOiAoKSA9PiBab2RWb2lkLFxuICBab2RVbmtub3duOiAoKSA9PiBab2RVbmtub3duLFxuICBab2RVbmlvbjogKCkgPT4gWm9kVW5pb24sXG4gIFpvZFVuZGVmaW5lZDogKCkgPT4gWm9kVW5kZWZpbmVkLFxuICBab2RUeXBlOiAoKSA9PiBab2RUeXBlLFxuICBab2RUdXBsZTogKCkgPT4gWm9kVHVwbGUsXG4gIFpvZFRyYW5zZm9ybWVyOiAoKSA9PiBab2RFZmZlY3RzLFxuICBab2RTeW1ib2w6ICgpID0+IFpvZFN5bWJvbCxcbiAgWm9kU3RyaW5nOiAoKSA9PiBab2RTdHJpbmcsXG4gIFpvZFNldDogKCkgPT4gWm9kU2V0LFxuICBab2RTY2hlbWE6ICgpID0+IFpvZFR5cGUsXG4gIFpvZFJlY29yZDogKCkgPT4gWm9kUmVjb3JkLFxuICBab2RSZWFkb25seTogKCkgPT4gWm9kUmVhZG9ubHksXG4gIFpvZFByb21pc2U6ICgpID0+IFpvZFByb21pc2UsXG4gIFpvZFBpcGVsaW5lOiAoKSA9PiBab2RQaXBlbGluZSxcbiAgWm9kUGFyc2VkVHlwZTogKCkgPT4gWm9kUGFyc2VkVHlwZSxcbiAgWm9kT3B0aW9uYWw6ICgpID0+IFpvZE9wdGlvbmFsLFxuICBab2RPYmplY3Q6ICgpID0+IFpvZE9iamVjdCxcbiAgWm9kTnVtYmVyOiAoKSA9PiBab2ROdW1iZXIsXG4gIFpvZE51bGxhYmxlOiAoKSA9PiBab2ROdWxsYWJsZSxcbiAgWm9kTnVsbDogKCkgPT4gWm9kTnVsbCxcbiAgWm9kTmV2ZXI6ICgpID0+IFpvZE5ldmVyLFxuICBab2ROYXRpdmVFbnVtOiAoKSA9PiBab2ROYXRpdmVFbnVtLFxuICBab2ROYU46ICgpID0+IFpvZE5hTixcbiAgWm9kTWFwOiAoKSA9PiBab2RNYXAsXG4gIFpvZExpdGVyYWw6ICgpID0+IFpvZExpdGVyYWwsXG4gIFpvZExhenk6ICgpID0+IFpvZExhenksXG4gIFpvZElzc3VlQ29kZTogKCkgPT4gWm9kSXNzdWVDb2RlLFxuICBab2RJbnRlcnNlY3Rpb246ICgpID0+IFpvZEludGVyc2VjdGlvbixcbiAgWm9kRnVuY3Rpb246ICgpID0+IFpvZEZ1bmN0aW9uLFxuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQ6ICgpID0+IFpvZEZpcnN0UGFydHlUeXBlS2luZCxcbiAgWm9kRXJyb3I6ICgpID0+IFpvZEVycm9yLFxuICBab2RFbnVtOiAoKSA9PiBab2RFbnVtLFxuICBab2RFZmZlY3RzOiAoKSA9PiBab2RFZmZlY3RzLFxuICBab2REaXNjcmltaW5hdGVkVW5pb246ICgpID0+IFpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgWm9kRGVmYXVsdDogKCkgPT4gWm9kRGVmYXVsdCxcbiAgWm9kRGF0ZTogKCkgPT4gWm9kRGF0ZSxcbiAgWm9kQ2F0Y2g6ICgpID0+IFpvZENhdGNoLFxuICBab2RCcmFuZGVkOiAoKSA9PiBab2RCcmFuZGVkLFxuICBab2RCb29sZWFuOiAoKSA9PiBab2RCb29sZWFuLFxuICBab2RCaWdJbnQ6ICgpID0+IFpvZEJpZ0ludCxcbiAgWm9kQXJyYXk6ICgpID0+IFpvZEFycmF5LFxuICBab2RBbnk6ICgpID0+IFpvZEFueSxcbiAgU2NoZW1hOiAoKSA9PiBab2RUeXBlLFxuICBQYXJzZVN0YXR1czogKCkgPT4gUGFyc2VTdGF0dXMsXG4gIE9LOiAoKSA9PiBPSyxcbiAgTkVWRVI6ICgpID0+IE5FVkVSLFxuICBJTlZBTElEOiAoKSA9PiBJTlZBTElELFxuICBFTVBUWV9QQVRIOiAoKSA9PiBFTVBUWV9QQVRILFxuICBESVJUWTogKCkgPT4gRElSVFksXG4gIEJSQU5EOiAoKSA9PiBCUkFORFxufSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzXG52YXIgdXRpbDtcbihmdW5jdGlvbih1dGlsMikge1xuICB1dGlsMi5hc3NlcnRFcXVhbCA9IChfKSA9PiB7fTtcbiAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykge31cbiAgdXRpbDIuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3I7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgdXRpbDIuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIHV0aWwyLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsMi5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgfVxuICAgIHJldHVybiB1dGlsMi5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICB9O1xuICB1dGlsMi5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHV0aWwyLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICB9KTtcbiAgfTtcbiAgdXRpbDIub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSA6IChvYmplY3QpID0+IHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIHV0aWwyLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIHV0aWwyLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCIgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkuam9pbihzZXBhcmF0b3IpO1xuICB9XG4gIHV0aWwyLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICB1dGlsMi5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbihvYmplY3RVdGlsMikge1xuICBvYmplY3RVdGlsMi5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpcnN0LFxuICAgICAgLi4uc2Vjb25kXG4gICAgfTtcbiAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xudmFyIFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgXCJzdHJpbmdcIixcbiAgXCJuYW5cIixcbiAgXCJudW1iZXJcIixcbiAgXCJpbnRlZ2VyXCIsXG4gIFwiZmxvYXRcIixcbiAgXCJib29sZWFuXCIsXG4gIFwiZGF0ZVwiLFxuICBcImJpZ2ludFwiLFxuICBcInN5bWJvbFwiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwidW5kZWZpbmVkXCIsXG4gIFwibnVsbFwiLFxuICBcImFycmF5XCIsXG4gIFwib2JqZWN0XCIsXG4gIFwidW5rbm93blwiLFxuICBcInByb21pc2VcIixcbiAgXCJ2b2lkXCIsXG4gIFwibmV2ZXJcIixcbiAgXCJtYXBcIixcbiAgXCJzZXRcIlxuXSk7XG52YXIgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gIH1cbn07XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QvdjMvWm9kRXJyb3IuanNcbnZhciBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgXCJpbnZhbGlkX3R5cGVcIixcbiAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgXCJjdXN0b21cIixcbiAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgXCJpbnZhbGlkX2RhdGVcIixcbiAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICBcInRvb19zbWFsbFwiLFxuICBcInRvb19iaWdcIixcbiAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICBcIm5vdF9maW5pdGVcIlxuXSk7XG52YXIgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuXG5jbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gIH1cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICB9O1xuICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgIH07XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbiAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlKSB7XG4gICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0gPSBmaWVsZEVycm9yc1tmaXJzdEVsXSB8fCBbXTtcbiAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICB9XG4gIGdldCBmb3JtRXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICByZXR1cm4gZXJyb3I7XG59O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanNcbnZhciBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICBsZXQgbWVzc2FnZTtcbiAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICB9IGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICBlbHNlXG4gICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgZWxzZVxuICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICB9XG4gIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG52YXIgZW5fZGVmYXVsdCA9IGVycm9yTWFwO1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kL3YzL2Vycm9ycy5qc1xudmFyIG92ZXJyaWRlRXJyb3JNYXAgPSBlbl9kZWZhdWx0O1xuZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG4vLyAuLi9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzXG52YXIgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLmlzc3VlRGF0YS5wYXRoIHx8IFtdXTtcbiAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgIC4uLmlzc3VlRGF0YSxcbiAgICBwYXRoOiBmdWxsUGF0aFxuICB9O1xuICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlXG4gICAgfTtcbiAgfVxuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgY29uc3QgbWFwcyA9IGVycm9yTWFwcy5maWx0ZXIoKG0pID0+ICEhbSkuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGgsXG4gICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlXG4gIH07XG59O1xudmFyIEVNUFRZX1BBVEggPSBbXTtcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgY29uc3QgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgIGlzc3VlRGF0YSxcbiAgICBkYXRhOiBjdHguZGF0YSxcbiAgICBwYXRoOiBjdHgucGF0aCxcbiAgICBlcnJvck1hcHM6IFtcbiAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgb3ZlcnJpZGVNYXAsXG4gICAgICBvdmVycmlkZU1hcCA9PT0gZW5fZGVmYXVsdCA/IHVuZGVmaW5lZCA6IGVuX2RlZmF1bHRcbiAgICBdLmZpbHRlcigoeCkgPT4gISF4KVxuICB9KTtcbiAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XG59XG5cbmNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gIH1cbn1cbnZhciBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHN0YXR1czogXCJhYm9ydGVkXCJcbn0pO1xudmFyIERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG52YXIgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbnZhciBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xudmFyIGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbnZhciBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG52YXIgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcbi8vIC4uL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy9lcnJvclV0aWwuanNcbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24oZXJyb3JVdGlsMikge1xuICBlcnJvclV0aWwyLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICBlcnJvclV0aWwyLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QvdjMvdHlwZXMuanNcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB0aGlzLl9rZXkgPSBrZXk7XG4gIH1cbiAgZ2V0IHBhdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fa2V5KSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgfVxufVxudmFyIGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICBpZiAoIXBhcmFtcylcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgaWYgKGVycm9yTWFwMiAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgfVxuICBpZiAoZXJyb3JNYXAyKVxuICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcDIsIGRlc2NyaXB0aW9uIH07XG4gIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH1cbiAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9O1xuICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuXG5jbGFzcyBab2RUeXBlIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgfVxuICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgIHJldHVybiBjdHggfHwge1xuICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XG4gICAgfTtcbiAgfVxuICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzLFxuICAgICAgY3R4OiB7XG4gICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnRcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICB9XG4gIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgfVxuICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXBcbiAgICAgIH0sXG4gICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luY1xuICAgICAgfSxcbiAgICAgIHBhdGg6IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfTtcbiAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KSA/IHtcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3Vlc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnI/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCk/LmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY29tbW9uID0ge1xuICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdCkgPyB7XG4gICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlXG4gICAgfSA6IHtcbiAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXNcbiAgICB9KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgIGNvbW1vbjoge1xuICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICB9LFxuICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgdmVyc2lvbjogMSxcbiAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKVxuICAgIH07XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICB9XG4gIHByb21pc2UoKSB7XG4gICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgb3Iob3B0aW9uKSB7XG4gICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgfVxuICBhbmQoaW5jb21pbmcpIHtcbiAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgfVxuICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfVxuICAgIH0pO1xuICB9XG4gIGRlZmF1bHQoZGVmKSB7XG4gICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgYnJhbmQoKSB7XG4gICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZilcbiAgICB9KTtcbiAgfVxuICBjYXRjaChkZWYpIHtcbiAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaFxuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbiAgcGlwZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gIH1cbiAgcmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gIH1cbiAgaXNOdWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgfVxufVxudmFyIGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xudmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xudmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbnZhciB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbnZhciBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG52YXIgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xudmFyIGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xudmFyIGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xudmFyIF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbnZhciBlbW9qaVJlZ2V4O1xudmFyIGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG52YXIgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xudmFyIGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xudmFyIGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xudmFyIGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xudmFyIGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICBsZXQgc2Vjb25kc1JlZ2V4U291cmNlID0gYFswLTVdXFxcXGRgO1xuICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICB9IGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICB9XG4gIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiO1xuICByZXR1cm4gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKDoke3NlY29uZHNSZWdleFNvdXJjZX0pJHtzZWNvbmRzUXVhbnRpZmllcn1gO1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG5mdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcbiAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICBjb25zdCBvcHRzID0gW107XG4gIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XG4gIGlmIChhcmdzLm9mZnNldClcbiAgICBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06P1xcXFxkezJ9KWApO1xuICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gIGlmICghand0UmVnZXgudGVzdChqd3QpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYmFzZTY0ID0gaGVhZGVyLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpLnBhZEVuZChoZWFkZXIubGVuZ3RoICsgKDQgLSBoZWFkZXIubGVuZ3RoICUgNCkgJSA0LCBcIj1cIik7XG4gICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICBpZiAodHlwZW9mIGRlY29kZWQgIT09IFwib2JqZWN0XCIgfHwgZGVjb2RlZCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoXCJ0eXBcIiBpbiBkZWNvZGVkICYmIGRlY29kZWQ/LnR5cCAhPT0gXCJKV1RcIilcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhbGcgJiYgZGVjb2RlZC5hbGcgIT09IGFsZylcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NENpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzO1xuICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XG4gICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBkYXRlUmVnZXg7XG4gICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSB0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiand0XCIpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgaWYgKCFpc1ZhbGlkQ2lkcihpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICB2YWxpZGF0aW9uLFxuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgZW1haWwobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHVybChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGN1aWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgY3VpZDIobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHVsaWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGp3dChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICB9XG4gIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgfVxuICBjaWRyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICB9XG4gIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IGZhbHNlLFxuICAgICAgbG9jYWw6IG9wdGlvbnM/LmxvY2FsID8/IGZhbHNlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZGF0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbiAgdGltZShvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBtZXNzYWdlOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICByZWdleCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgIHZhbHVlLFxuICAgICAgcG9zaXRpb246IG9wdGlvbnM/LnBvc2l0aW9uLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgdmFsdWUsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gIH1cbiAgdHJpbSgpIHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dXG4gICAgfSk7XG4gIH1cbiAgdG9Mb3dlckNhc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XVxuICAgIH0pO1xuICB9XG4gIGdldCBpc0RhdGV0aW1lKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gIH1cbiAgZ2V0IGlzRGF0ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gIH1cbiAgZ2V0IGlzVGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gIH1cbiAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgfVxuICBnZXQgaXNFbWFpbCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICB9XG4gIGdldCBpc1VSTCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgfVxuICBnZXQgaXNFbW9qaSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICB9XG4gIGdldCBpc1VVSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICB9XG4gIGdldCBpc05BTk9JRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgfVxuICBnZXQgaXNDVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgfVxuICBnZXQgaXNDVUlEMigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICB9XG4gIGdldCBpc1VMSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICB9XG4gIGdldCBpc0lQKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gIH1cbiAgZ2V0IGlzQ0lEUigpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gIH1cbiAgZ2V0IGlzQmFzZTY0KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcbiAgfVxuICBnZXQgbWluTGVuZ3RoKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gIHJldHVybiB2YWxJbnQgJSBzdGVwSW50IC8gMTAgKiogZGVjQ291bnQ7XG59XG5cbmNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXM7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhjaGVjaykge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGludChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHNhZmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSkuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluVmFsdWUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGdldCBtYXhWYWx1ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgZ2V0IGlzSW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKTtcbiAgfVxuICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgfVxuICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzO1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgIH0pO1xuICAgIHJldHVybiBJTlZBTElEO1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFtcbiAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZEJvb2xlYW4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzO1xuICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcImRhdGVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKVxuICAgIH07XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICBjaGVja3M6IFtdLFxuICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RTeW1ib2woe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufVxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2FueSA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblxuY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgIH0pO1xuICAgIHJldHVybiBJTlZBTElEO1xuICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblxuY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG1heGltdW06IHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgIH0pKS50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0Mik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWluTGVuZ3RoOiB7IHZhbHVlOiBtaW5MZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgdHlwZTogc2NoZW1hLFxuICAgIG1pbkxlbmd0aDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudClcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XG4gICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbn1cblxuY2xhc3MgWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gIH1cbiAgX2dldENhY2hlZCgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpIHt9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICB9KS50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QobWVzc2FnZSkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgIC4uLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gdGhpcy5fZGVmLmVycm9yTWFwPy4oaXNzdWUsIGN0eCkubWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSA/PyBkZWZhdWx0RXJyb3JcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvclxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gOiB7fVxuICAgIH0pO1xuICB9XG4gIHN0cmlwKCkge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiXG4gICAgfSk7XG4gIH1cbiAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLi4uYXVnbWVudGF0aW9uXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIG1lcmdlKG1lcmdpbmcpIHtcbiAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgICAgfSksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdFxuICAgIH0pO1xuICAgIHJldHVybiBtZXJnZWQ7XG4gIH1cbiAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gIH1cbiAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjYXRjaGFsbDogaW5kZXhcbiAgICB9KTtcbiAgfVxuICBwaWNrKG1hc2spIHtcbiAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyhtYXNrKSkge1xuICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgb21pdChtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZVxuICAgIH0pO1xuICB9XG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfVxuICByZXF1aXJlZChtYXNrKSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAga2V5b2YoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblxuY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHhcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjdHg6IGNoaWxkQ3R4XG4gICAgICAgIH07XG4gICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY2hpbGRDdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzMikgPT4gbmV3IFpvZEVycm9yKGlzc3VlczIpKTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgb3B0aW9uczogdHlwZXMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgcmV0dXJuIFtudWxsXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcblxuY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgaWYgKCFvcHRpb24pIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG4gIGdldCBvcHRpb25zTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICBpZiAob3B0aW9uc01hcC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcHRpb25zTWFwLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7aW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gIH1cbn1cblxuY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgfTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pLFxuICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pXG4gICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgICAgfSk7XG4gICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChyZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXN0XG4gICAgfSk7XG4gIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gIH1cbiAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICByZXN0OiBudWxsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgfVxuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXA7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcDtcbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgfVxuICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICB2YWx1ZVR5cGUsXG4gICAga2V5VHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMyKSB7XG4gICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0O1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzMikge1xuICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzMikgPT4gZmluYWxpemVTZXQoZWxlbWVudHMyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgfVxuICB9XG4gIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICB2YWx1ZVR5cGUsXG4gICAgbWluU2l6ZTogbnVsbCxcbiAgICBtYXhTaXplOiBudWxsLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZW5fZGVmYXVsdF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGVuX2RlZmF1bHRdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJncy5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZS5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICByZXR1cm4gT0soZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gIH1cbiAgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gIH1cbiAgYXJncyguLi5pdGVtcykge1xuICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXR1cm5zOiByZXR1cm5UeXBlXG4gICAgfSk7XG4gIH1cbiAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgfVxuICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICBhcmdzOiBhcmdzID8gYXJncyA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcbiAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgZ2V0dGVyLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xuICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgdmFsdWUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG5cbmNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgfVxuICBnZXQgZW51bSgpIHtcbiAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgfVxuICBnZXQgVmFsdWVzKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBFbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgLi4ubmV3RGVmXG4gICAgfSk7XG4gIH1cbn1cblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcblxuY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxuICBnZXQgZW51bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgfVxufVxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICB2YWx1ZXMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJiBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlID8gY3R4LmRhdGEgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXBcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICB0eXBlOiBzY2hlbWEsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5cbmNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgaW5uZXJUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIHNvdXJjZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKSA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQyKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZDIsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC5yZWZpbmVtZW50KGFjYywgY2hlY2tDdHgpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9O1xuICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpO1xuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoe1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgc2NoZW1hLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICBlZmZlY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICBzY2hlbWEsXG4gICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbmNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgIHBhcmVudDogY3R4XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAuLi5jdHgsXG4gICAgICBjb21tb246IHtcbiAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICAuLi5uZXdDdHhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0Mi5zdGF0dXMgPT09IFwidmFsaWRcIiA/IHJlc3VsdDIudmFsdWUgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIgPyByZXN1bHQudmFsdWUgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJlbW92ZUNhdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBwYXJhbXMuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuXG5jbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5cbmNsYXNzIFpvZEJyYW5kZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG59XG5cbmNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBpblJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5pbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KTtcbiAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgIGluOiBhLFxuICAgICAgb3V0OiBiLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoZGF0YSkgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwYXJhbXMgfSA6IHBhcmFtcztcbiAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgcmV0dXJuIHAyO1xufVxuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIGZhdGFsKSB7XG4gIGlmIChjaGVjaylcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSBjaGVjayhkYXRhKTtcbiAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gci50aGVuKChyMikgPT4ge1xuICAgICAgICAgIGlmICghcjIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghcikge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9KTtcbiAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbnZhciBsYXRlID0ge1xuICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlXG59O1xudmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbihab2RGaXJzdFBhcnR5VHlwZUtpbmQyKSB7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVtYmVyXCJdID0gXCJab2ROdW1iZXJcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQm9vbGVhblwiXSA9IFwiWm9kQm9vbGVhblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RDYXRjaFwiXSA9IFwiWm9kQ2F0Y2hcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFBpcGVsaW5lXCJdID0gXCJab2RQaXBlbGluZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG52YXIgaW5zdGFuY2VPZlR5cGUgPSAoY2xzLCBwYXJhbXMgPSB7XG4gIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG52YXIgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG52YXIgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG52YXIgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG52YXIgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG52YXIgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbnZhciBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xudmFyIHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xudmFyIHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xudmFyIG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG52YXIgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG52YXIgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbnZhciBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG52YXIgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbnZhciBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG52YXIgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG52YXIgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG52YXIgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xudmFyIGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xudmFyIGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xudmFyIHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbnZhciByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbnZhciBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcbnZhciBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbnZhciBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG52YXIgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbnZhciBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xudmFyIGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG52YXIgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbnZhciBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xudmFyIGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG52YXIgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xudmFyIG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbnZhciBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG52YXIgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xudmFyIG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbnZhciBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgY29lcmNlID0ge1xuICBzdHJpbmc6IChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSxcbiAgbnVtYmVyOiAoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIGJvb2xlYW46IChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAuLi5hcmcsXG4gICAgY29lcmNlOiB0cnVlXG4gIH0pLFxuICBiaWdpbnQ6IChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSxcbiAgZGF0ZTogKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KVxufTtcbnZhciBORVZFUiA9IElOVkFMSUQ7XG4vLyAuLi9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2VzbS90eXBlcy5qc1xudmFyIExBVEVTVF9QUk9UT0NPTF9WRVJTSU9OID0gXCIyMDI1LTA2LTE4XCI7XG52YXIgU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05TID0gW1xuICBMQVRFU1RfUFJPVE9DT0xfVkVSU0lPTixcbiAgXCIyMDI1LTAzLTI2XCIsXG4gIFwiMjAyNC0xMS0wNVwiLFxuICBcIjIwMjQtMTAtMDdcIlxuXTtcbnZhciBKU09OUlBDX1ZFUlNJT04gPSBcIjIuMFwiO1xudmFyIFByb2dyZXNzVG9rZW5TY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLCBleHBvcnRzX2V4dGVybmFsLm51bWJlcigpLmludCgpXSk7XG52YXIgQ3Vyc29yU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKTtcbnZhciBSZXF1ZXN0TWV0YVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgcHJvZ3Jlc3NUb2tlbjogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChQcm9ncmVzc1Rva2VuU2NoZW1hKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoUmVxdWVzdE1ldGFTY2hlbWEpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSxcbiAgcGFyYW1zOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hKVxufSk7XG52YXIgQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICBwYXJhbXM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYSlcbn0pO1xudmFyIFJlc3VsdFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlcXVlc3RJZFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW2V4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksIGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCkuaW50KCldKTtcbnZhciBKU09OUlBDUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAganNvbnJwYzogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiBSZXF1ZXN0SWRTY2hlbWFcbn0pLm1lcmdlKFJlcXVlc3RTY2hlbWEpLnN0cmljdCgpO1xudmFyIGlzSlNPTlJQQ1JlcXVlc3QgPSAodmFsdWUpID0+IEpTT05SUENSZXF1ZXN0U2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbnZhciBKU09OUlBDTm90aWZpY2F0aW9uU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICBqc29ucnBjOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoSlNPTlJQQ19WRVJTSU9OKVxufSkubWVyZ2UoTm90aWZpY2F0aW9uU2NoZW1hKS5zdHJpY3QoKTtcbnZhciBpc0pTT05SUENOb3RpZmljYXRpb24gPSAodmFsdWUpID0+IEpTT05SUENOb3RpZmljYXRpb25TY2hlbWEuc2FmZVBhcnNlKHZhbHVlKS5zdWNjZXNzO1xudmFyIEpTT05SUENSZXNwb25zZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAganNvbnJwYzogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiBSZXF1ZXN0SWRTY2hlbWEsXG4gIHJlc3VsdDogUmVzdWx0U2NoZW1hXG59KS5zdHJpY3QoKTtcbnZhciBpc0pTT05SUENSZXNwb25zZSA9ICh2YWx1ZSkgPT4gSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbnZhciBFcnJvckNvZGU7XG4oZnVuY3Rpb24oRXJyb3JDb2RlMikge1xuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJDb25uZWN0aW9uQ2xvc2VkXCJdID0gLTMyMDAwXSA9IFwiQ29ubmVjdGlvbkNsb3NlZFwiO1xuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJSZXF1ZXN0VGltZW91dFwiXSA9IC0zMjAwMV0gPSBcIlJlcXVlc3RUaW1lb3V0XCI7XG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIlBhcnNlRXJyb3JcIl0gPSAtMzI3MDBdID0gXCJQYXJzZUVycm9yXCI7XG4gIEVycm9yQ29kZTJbRXJyb3JDb2RlMltcIkludmFsaWRSZXF1ZXN0XCJdID0gLTMyNjAwXSA9IFwiSW52YWxpZFJlcXVlc3RcIjtcbiAgRXJyb3JDb2RlMltFcnJvckNvZGUyW1wiTWV0aG9kTm90Rm91bmRcIl0gPSAtMzI2MDFdID0gXCJNZXRob2ROb3RGb3VuZFwiO1xuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJJbnZhbGlkUGFyYW1zXCJdID0gLTMyNjAyXSA9IFwiSW52YWxpZFBhcmFtc1wiO1xuICBFcnJvckNvZGUyW0Vycm9yQ29kZTJbXCJJbnRlcm5hbEVycm9yXCJdID0gLTMyNjAzXSA9IFwiSW50ZXJuYWxFcnJvclwiO1xufSkoRXJyb3JDb2RlIHx8IChFcnJvckNvZGUgPSB7fSkpO1xudmFyIEpTT05SUENFcnJvclNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAganNvbnJwYzogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKEpTT05SUENfVkVSU0lPTiksXG4gIGlkOiBSZXF1ZXN0SWRTY2hlbWEsXG4gIGVycm9yOiBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgY29kZTogZXhwb3J0c19leHRlcm5hbC5udW1iZXIoKS5pbnQoKSxcbiAgICBtZXNzYWdlOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICAgIGRhdGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC51bmtub3duKCkpXG4gIH0pXG59KS5zdHJpY3QoKTtcbnZhciBpc0pTT05SUENFcnJvciA9ICh2YWx1ZSkgPT4gSlNPTlJQQ0Vycm9yU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSkuc3VjY2VzcztcbnZhciBKU09OUlBDTWVzc2FnZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW1xuICBKU09OUlBDUmVxdWVzdFNjaGVtYSxcbiAgSlNPTlJQQ05vdGlmaWNhdGlvblNjaGVtYSxcbiAgSlNPTlJQQ1Jlc3BvbnNlU2NoZW1hLFxuICBKU09OUlBDRXJyb3JTY2hlbWFcbl0pO1xudmFyIEVtcHR5UmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLnN0cmljdCgpO1xudmFyIENhbmNlbGxlZE5vdGlmaWNhdGlvblNjaGVtYSA9IE5vdGlmaWNhdGlvblNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcIm5vdGlmaWNhdGlvbnMvY2FuY2VsbGVkXCIpLFxuICBwYXJhbXM6IEJhc2VOb3RpZmljYXRpb25QYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICByZXF1ZXN0SWQ6IFJlcXVlc3RJZFNjaGVtYSxcbiAgICByZWFzb246IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkub3B0aW9uYWwoKVxuICB9KVxufSk7XG52YXIgQmFzZU1ldGFkYXRhU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICBuYW1lOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICB0aXRsZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBJbXBsZW1lbnRhdGlvblNjaGVtYSA9IEJhc2VNZXRhZGF0YVNjaGVtYS5leHRlbmQoe1xuICB2ZXJzaW9uOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpXG59KTtcbnZhciBDbGllbnRDYXBhYmlsaXRpZXNTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIGV4cGVyaW1lbnRhbDogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIHNhbXBsaW5nOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgZWxpY2l0YXRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICByb290czogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgbGlzdENoYW5nZWQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG4gIH0pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIEluaXRpYWxpemVSZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcImluaXRpYWxpemVcIiksXG4gIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICBwcm90b2NvbFZlcnNpb246IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksXG4gICAgY2FwYWJpbGl0aWVzOiBDbGllbnRDYXBhYmlsaXRpZXNTY2hlbWEsXG4gICAgY2xpZW50SW5mbzogSW1wbGVtZW50YXRpb25TY2hlbWFcbiAgfSlcbn0pO1xudmFyIFNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgZXhwZXJpbWVudGFsOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgbG9nZ2luZzogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSksXG4gIGNvbXBsZXRpb25zOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgcHJvbXB0czogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgbGlzdENoYW5nZWQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG4gIH0pLnBhc3N0aHJvdWdoKCkpLFxuICByZXNvdXJjZXM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICAgIHN1YnNjcmliZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLmJvb2xlYW4oKSksXG4gICAgbGlzdENoYW5nZWQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG4gIH0pLnBhc3N0aHJvdWdoKCkpLFxuICB0b29sczogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgbGlzdENoYW5nZWQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG4gIH0pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIEluaXRpYWxpemVSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvdG9jb2xWZXJzaW9uOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICBjYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllc1NjaGVtYSxcbiAgc2VydmVySW5mbzogSW1wbGVtZW50YXRpb25TY2hlbWEsXG4gIGluc3RydWN0aW9uczogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKVxufSk7XG52YXIgSW5pdGlhbGl6ZWROb3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJub3RpZmljYXRpb25zL2luaXRpYWxpemVkXCIpXG59KTtcbnZhciBQaW5nUmVxdWVzdFNjaGVtYSA9IFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJwaW5nXCIpXG59KTtcbnZhciBQcm9ncmVzc1NjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgcHJvZ3Jlc3M6IGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCksXG4gIHRvdGFsOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCkpLFxuICBtZXNzYWdlOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hID0gTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwibm90aWZpY2F0aW9ucy9wcm9ncmVzc1wiKSxcbiAgcGFyYW1zOiBCYXNlTm90aWZpY2F0aW9uUGFyYW1zU2NoZW1hLm1lcmdlKFByb2dyZXNzU2NoZW1hKS5leHRlbmQoe1xuICAgIHByb2dyZXNzVG9rZW46IFByb2dyZXNzVG9rZW5TY2hlbWFcbiAgfSlcbn0pO1xudmFyIFBhZ2luYXRlZFJlcXVlc3RTY2hlbWEgPSBSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICBjdXJzb3I6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoQ3Vyc29yU2NoZW1hKVxuICB9KS5vcHRpb25hbCgpXG59KTtcbnZhciBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEgPSBSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgbmV4dEN1cnNvcjogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChDdXJzb3JTY2hlbWEpXG59KTtcbnZhciBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICB1cmk6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksXG4gIG1pbWVUeXBlOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLFxuICBfbWV0YTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgVGV4dFJlc291cmNlQ29udGVudHNTY2hlbWEgPSBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gIHRleHQ6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKClcbn0pO1xudmFyIEJhc2U2NFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkucmVmaW5lKCh2YWwpID0+IHtcbiAgdHJ5IHtcbiAgICBhdG9iKHZhbCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKF9hKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59LCB7IG1lc3NhZ2U6IFwiSW52YWxpZCBCYXNlNjQgc3RyaW5nXCIgfSk7XG52YXIgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWEgPSBSZXNvdXJjZUNvbnRlbnRzU2NoZW1hLmV4dGVuZCh7XG4gIGJsb2I6IEJhc2U2NFNjaGVtYVxufSk7XG52YXIgUmVzb3VyY2VTY2hlbWEgPSBCYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgdXJpOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICBkZXNjcmlwdGlvbjogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgbWltZVR5cGU6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIF9tZXRhOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSk7XG52YXIgUmVzb3VyY2VUZW1wbGF0ZVNjaGVtYSA9IEJhc2VNZXRhZGF0YVNjaGVtYS5leHRlbmQoe1xuICB1cmlUZW1wbGF0ZTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIG1pbWVUeXBlOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLFxuICBfbWV0YTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pO1xudmFyIExpc3RSZXNvdXJjZXNSZXF1ZXN0U2NoZW1hID0gUGFnaW5hdGVkUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInJlc291cmNlcy9saXN0XCIpXG59KTtcbnZhciBMaXN0UmVzb3VyY2VzUmVzdWx0U2NoZW1hID0gUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHJlc291cmNlczogZXhwb3J0c19leHRlcm5hbC5hcnJheShSZXNvdXJjZVNjaGVtYSlcbn0pO1xudmFyIExpc3RSZXNvdXJjZVRlbXBsYXRlc1JlcXVlc3RTY2hlbWEgPSBQYWdpbmF0ZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicmVzb3VyY2VzL3RlbXBsYXRlcy9saXN0XCIpXG59KTtcbnZhciBMaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXN1bHRTY2hlbWEgPSBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgcmVzb3VyY2VUZW1wbGF0ZXM6IGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoUmVzb3VyY2VUZW1wbGF0ZVNjaGVtYSlcbn0pO1xudmFyIFJlYWRSZXNvdXJjZVJlcXVlc3RTY2hlbWEgPSBSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicmVzb3VyY2VzL3JlYWRcIiksXG4gIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICB1cmk6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKClcbiAgfSlcbn0pO1xudmFyIFJlYWRSZXNvdXJjZVJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBjb250ZW50czogZXhwb3J0c19leHRlcm5hbC5hcnJheShleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSwgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWFdKSlcbn0pO1xudmFyIFJlc291cmNlTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJub3RpZmljYXRpb25zL3Jlc291cmNlcy9saXN0X2NoYW5nZWRcIilcbn0pO1xudmFyIFN1YnNjcmliZVJlcXVlc3RTY2hlbWEgPSBSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicmVzb3VyY2VzL3N1YnNjcmliZVwiKSxcbiAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgIHVyaTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKVxuICB9KVxufSk7XG52YXIgVW5zdWJzY3JpYmVSZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInJlc291cmNlcy91bnN1YnNjcmliZVwiKSxcbiAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgIHVyaTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKVxuICB9KVxufSk7XG52YXIgUmVzb3VyY2VVcGRhdGVkTm90aWZpY2F0aW9uU2NoZW1hID0gTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwibm90aWZpY2F0aW9ucy9yZXNvdXJjZXMvdXBkYXRlZFwiKSxcbiAgcGFyYW1zOiBCYXNlTm90aWZpY2F0aW9uUGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgdXJpOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpXG4gIH0pXG59KTtcbnZhciBQcm9tcHRBcmd1bWVudFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgbmFtZTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIHJlcXVpcmVkOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYm9vbGVhbigpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBQcm9tcHRTY2hlbWEgPSBCYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIGFyZ3VtZW50czogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLmFycmF5KFByb21wdEFyZ3VtZW50U2NoZW1hKSksXG4gIF9tZXRhOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSk7XG52YXIgTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hID0gUGFnaW5hdGVkUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInByb21wdHMvbGlzdFwiKVxufSk7XG52YXIgTGlzdFByb21wdHNSZXN1bHRTY2hlbWEgPSBQYWdpbmF0ZWRSZXN1bHRTY2hlbWEuZXh0ZW5kKHtcbiAgcHJvbXB0czogZXhwb3J0c19leHRlcm5hbC5hcnJheShQcm9tcHRTY2hlbWEpXG59KTtcbnZhciBHZXRQcm9tcHRSZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInByb21wdHMvZ2V0XCIpLFxuICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgbmFtZTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSxcbiAgICBhcmd1bWVudHM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5yZWNvcmQoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpXG4gIH0pXG59KTtcbnZhciBUZXh0Q29udGVudFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSxcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIEltYWdlQ29udGVudFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGRhdGE6IEJhc2U2NFNjaGVtYSxcbiAgbWltZVR5cGU6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksXG4gIF9tZXRhOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBBdWRpb0NvbnRlbnRTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIHR5cGU6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcImF1ZGlvXCIpLFxuICBkYXRhOiBCYXNlNjRTY2hlbWEsXG4gIG1pbWVUeXBlOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICBfbWV0YTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicmVzb3VyY2VcIiksXG4gIHJlc291cmNlOiBleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtUZXh0UmVzb3VyY2VDb250ZW50c1NjaGVtYSwgQmxvYlJlc291cmNlQ29udGVudHNTY2hlbWFdKSxcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFJlc291cmNlTGlua1NjaGVtYSA9IFJlc291cmNlU2NoZW1hLmV4dGVuZCh7XG4gIHR5cGU6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInJlc291cmNlX2xpbmtcIilcbn0pO1xudmFyIENvbnRlbnRCbG9ja1NjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW1xuICBUZXh0Q29udGVudFNjaGVtYSxcbiAgSW1hZ2VDb250ZW50U2NoZW1hLFxuICBBdWRpb0NvbnRlbnRTY2hlbWEsXG4gIFJlc291cmNlTGlua1NjaGVtYSxcbiAgRW1iZWRkZWRSZXNvdXJjZVNjaGVtYVxuXSk7XG52YXIgUHJvbXB0TWVzc2FnZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgcm9sZTogZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICBjb250ZW50OiBDb250ZW50QmxvY2tTY2hlbWFcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgR2V0UHJvbXB0UmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIGRlc2NyaXB0aW9uOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLFxuICBtZXNzYWdlczogZXhwb3J0c19leHRlcm5hbC5hcnJheShQcm9tcHRNZXNzYWdlU2NoZW1hKVxufSk7XG52YXIgUHJvbXB0TGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJub3RpZmljYXRpb25zL3Byb21wdHMvbGlzdF9jaGFuZ2VkXCIpXG59KTtcbnZhciBUb29sQW5ub3RhdGlvbnNTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIHRpdGxlOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLFxuICByZWFkT25seUhpbnQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpLFxuICBkZXN0cnVjdGl2ZUhpbnQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpLFxuICBpZGVtcG90ZW50SGludDogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLmJvb2xlYW4oKSksXG4gIG9wZW5Xb3JsZEhpbnQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFRvb2xTY2hlbWEgPSBCYXNlTWV0YWRhdGFTY2hlbWEuZXh0ZW5kKHtcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIGlucHV0U2NoZW1hOiBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwib2JqZWN0XCIpLFxuICAgIHByb3BlcnRpZXM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIHJlcXVpcmVkOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpXG4gIH0pLnBhc3N0aHJvdWdoKCksXG4gIG91dHB1dFNjaGVtYTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwib2JqZWN0XCIpLFxuICAgIHByb3BlcnRpZXM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpLFxuICAgIHJlcXVpcmVkOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpXG4gIH0pLnBhc3N0aHJvdWdoKCkpLFxuICBhbm5vdGF0aW9uczogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChUb29sQW5ub3RhdGlvbnNTY2hlbWEpLFxuICBfbWV0YTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKSlcbn0pO1xudmFyIExpc3RUb29sc1JlcXVlc3RTY2hlbWEgPSBQYWdpbmF0ZWRSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwidG9vbHMvbGlzdFwiKVxufSk7XG52YXIgTGlzdFRvb2xzUmVzdWx0U2NoZW1hID0gUGFnaW5hdGVkUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHRvb2xzOiBleHBvcnRzX2V4dGVybmFsLmFycmF5KFRvb2xTY2hlbWEpXG59KTtcbnZhciBDYWxsVG9vbFJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBjb250ZW50OiBleHBvcnRzX2V4dGVybmFsLmFycmF5KENvbnRlbnRCbG9ja1NjaGVtYSkuZGVmYXVsdChbXSksXG4gIHN0cnVjdHVyZWRDb250ZW50OiBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7fSkucGFzc3Rocm91Z2goKS5vcHRpb25hbCgpLFxuICBpc0Vycm9yOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYm9vbGVhbigpKVxufSk7XG52YXIgQ29tcGF0aWJpbGl0eUNhbGxUb29sUmVzdWx0U2NoZW1hID0gQ2FsbFRvb2xSZXN1bHRTY2hlbWEub3IoUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHRvb2xSZXN1bHQ6IGV4cG9ydHNfZXh0ZXJuYWwudW5rbm93bigpXG59KSk7XG52YXIgQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInRvb2xzL2NhbGxcIiksXG4gIHBhcmFtczogQmFzZVJlcXVlc3RQYXJhbXNTY2hlbWEuZXh0ZW5kKHtcbiAgICBuYW1lOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICAgIGFyZ3VtZW50czogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnJlY29yZChleHBvcnRzX2V4dGVybmFsLnVua25vd24oKSkpXG4gIH0pXG59KTtcbnZhciBUb29sTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJub3RpZmljYXRpb25zL3Rvb2xzL2xpc3RfY2hhbmdlZFwiKVxufSk7XG52YXIgTG9nZ2luZ0xldmVsU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcbiAgXCJkZWJ1Z1wiLFxuICBcImluZm9cIixcbiAgXCJub3RpY2VcIixcbiAgXCJ3YXJuaW5nXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJjcml0aWNhbFwiLFxuICBcImFsZXJ0XCIsXG4gIFwiZW1lcmdlbmN5XCJcbl0pO1xudmFyIFNldExldmVsUmVxdWVzdFNjaGVtYSA9IFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJsb2dnaW5nL3NldExldmVsXCIpLFxuICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgbGV2ZWw6IExvZ2dpbmdMZXZlbFNjaGVtYVxuICB9KVxufSk7XG52YXIgTG9nZ2luZ01lc3NhZ2VOb3RpZmljYXRpb25TY2hlbWEgPSBOb3RpZmljYXRpb25TY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJub3RpZmljYXRpb25zL21lc3NhZ2VcIiksXG4gIHBhcmFtczogQmFzZU5vdGlmaWNhdGlvblBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgIGxldmVsOiBMb2dnaW5nTGV2ZWxTY2hlbWEsXG4gICAgbG9nZ2VyOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLFxuICAgIGRhdGE6IGV4cG9ydHNfZXh0ZXJuYWwudW5rbm93bigpXG4gIH0pXG59KTtcbnZhciBNb2RlbEhpbnRTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIG5hbWU6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkub3B0aW9uYWwoKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBNb2RlbFByZWZlcmVuY2VzU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICBoaW50czogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLmFycmF5KE1vZGVsSGludFNjaGVtYSkpLFxuICBjb3N0UHJpb3JpdHk6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5udW1iZXIoKS5taW4oMCkubWF4KDEpKSxcbiAgc3BlZWRQcmlvcml0eTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm51bWJlcigpLm1pbigwKS5tYXgoMSkpLFxuICBpbnRlbGxpZ2VuY2VQcmlvcml0eTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm51bWJlcigpLm1pbigwKS5tYXgoMSkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFNhbXBsaW5nTWVzc2FnZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgcm9sZTogZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICBjb250ZW50OiBleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtUZXh0Q29udGVudFNjaGVtYSwgSW1hZ2VDb250ZW50U2NoZW1hLCBBdWRpb0NvbnRlbnRTY2hlbWFdKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBDcmVhdGVNZXNzYWdlUmVxdWVzdFNjaGVtYSA9IFJlcXVlc3RTY2hlbWEuZXh0ZW5kKHtcbiAgbWV0aG9kOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJzYW1wbGluZy9jcmVhdGVNZXNzYWdlXCIpLFxuICBwYXJhbXM6IEJhc2VSZXF1ZXN0UGFyYW1zU2NoZW1hLmV4dGVuZCh7XG4gICAgbWVzc2FnZXM6IGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoU2FtcGxpbmdNZXNzYWdlU2NoZW1hKSxcbiAgICBzeXN0ZW1Qcm9tcHQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gICAgaW5jbHVkZUNvbnRleHQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcIm5vbmVcIiwgXCJ0aGlzU2VydmVyXCIsIFwiYWxsU2VydmVyc1wiXSkpLFxuICAgIHRlbXBlcmF0dXJlOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCkpLFxuICAgIG1heFRva2VuczogZXhwb3J0c19leHRlcm5hbC5udW1iZXIoKS5pbnQoKSxcbiAgICBzdG9wU2VxdWVuY2VzOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpLFxuICAgIG1ldGFkYXRhOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpKSxcbiAgICBtb2RlbFByZWZlcmVuY2VzOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKE1vZGVsUHJlZmVyZW5jZXNTY2hlbWEpXG4gIH0pXG59KTtcbnZhciBDcmVhdGVNZXNzYWdlUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIG1vZGVsOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLFxuICBzdG9wUmVhc29uOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuZW51bShbXCJlbmRUdXJuXCIsIFwic3RvcFNlcXVlbmNlXCIsIFwibWF4VG9rZW5zXCJdKS5vcihleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSksXG4gIHJvbGU6IGV4cG9ydHNfZXh0ZXJuYWwuZW51bShbXCJ1c2VyXCIsIFwiYXNzaXN0YW50XCJdKSxcbiAgY29udGVudDogZXhwb3J0c19leHRlcm5hbC5kaXNjcmltaW5hdGVkVW5pb24oXCJ0eXBlXCIsIFtcbiAgICBUZXh0Q29udGVudFNjaGVtYSxcbiAgICBJbWFnZUNvbnRlbnRTY2hlbWEsXG4gICAgQXVkaW9Db250ZW50U2NoZW1hXG4gIF0pXG59KTtcbnZhciBCb29sZWFuU2NoZW1hU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe1xuICB0eXBlOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJib29sZWFuXCIpLFxuICB0aXRsZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIGRlZmF1bHQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFN0cmluZ1NjaGVtYVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwic3RyaW5nXCIpLFxuICB0aXRsZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIG1pbkxlbmd0aDogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm51bWJlcigpKSxcbiAgbWF4TGVuZ3RoOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCkpLFxuICBmb3JtYXQ6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcImVtYWlsXCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiXSkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIE51bWJlclNjaGVtYVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcIm51bWJlclwiLCBcImludGVnZXJcIl0pLFxuICB0aXRsZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIG1pbmltdW06IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5udW1iZXIoKSksXG4gIG1heGltdW06IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5udW1iZXIoKSlcbn0pLnBhc3N0aHJvdWdoKCk7XG52YXIgRW51bVNjaGVtYVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwic3RyaW5nXCIpLFxuICB0aXRsZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgZGVzY3JpcHRpb246IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIGVudW06IGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSksXG4gIGVudW1OYW1lczogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLmFycmF5KGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBQcmltaXRpdmVTY2hlbWFEZWZpbml0aW9uU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC51bmlvbihbXG4gIEJvb2xlYW5TY2hlbWFTY2hlbWEsXG4gIFN0cmluZ1NjaGVtYVNjaGVtYSxcbiAgTnVtYmVyU2NoZW1hU2NoZW1hLFxuICBFbnVtU2NoZW1hU2NoZW1hXG5dKTtcbnZhciBFbGljaXRSZXF1ZXN0U2NoZW1hID0gUmVxdWVzdFNjaGVtYS5leHRlbmQoe1xuICBtZXRob2Q6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcImVsaWNpdGF0aW9uL2NyZWF0ZVwiKSxcbiAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgIG1lc3NhZ2U6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksXG4gICAgcmVxdWVzdGVkU2NoZW1hOiBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgICB0eXBlOiBleHBvcnRzX2V4dGVybmFsLmxpdGVyYWwoXCJvYmplY3RcIiksXG4gICAgICBwcm9wZXJ0aWVzOiBleHBvcnRzX2V4dGVybmFsLnJlY29yZChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpLCBQcmltaXRpdmVTY2hlbWFEZWZpbml0aW9uU2NoZW1hKSxcbiAgICAgIHJlcXVpcmVkOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwuYXJyYXkoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpXG4gICAgfSkucGFzc3Rocm91Z2goKVxuICB9KVxufSk7XG52YXIgRWxpY2l0UmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIGFjdGlvbjogZXhwb3J0c19leHRlcm5hbC5lbnVtKFtcImFjY2VwdFwiLCBcImRlY2xpbmVcIiwgXCJjYW5jZWxcIl0pLFxuICBjb250ZW50OiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwucmVjb3JkKGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksIGV4cG9ydHNfZXh0ZXJuYWwudW5rbm93bigpKSlcbn0pO1xudmFyIFJlc291cmNlVGVtcGxhdGVSZWZlcmVuY2VTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIHR5cGU6IGV4cG9ydHNfZXh0ZXJuYWwubGl0ZXJhbChcInJlZi9yZXNvdXJjZVwiKSxcbiAgdXJpOiBleHBvcnRzX2V4dGVybmFsLnN0cmluZygpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIFByb21wdFJlZmVyZW5jZVNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgdHlwZTogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicmVmL3Byb21wdFwiKSxcbiAgbmFtZTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKVxufSkucGFzc3Rocm91Z2goKTtcbnZhciBDb21wbGV0ZVJlcXVlc3RTY2hlbWEgPSBSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwiY29tcGxldGlvbi9jb21wbGV0ZVwiKSxcbiAgcGFyYW1zOiBCYXNlUmVxdWVzdFBhcmFtc1NjaGVtYS5leHRlbmQoe1xuICAgIHJlZjogZXhwb3J0c19leHRlcm5hbC51bmlvbihbUHJvbXB0UmVmZXJlbmNlU2NoZW1hLCBSZXNvdXJjZVRlbXBsYXRlUmVmZXJlbmNlU2NoZW1hXSksXG4gICAgYXJndW1lbnQ6IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHtcbiAgICAgIG5hbWU6IGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCksXG4gICAgICB2YWx1ZTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKVxuICAgIH0pLnBhc3N0aHJvdWdoKCksXG4gICAgY29udGV4dDogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgICBhcmd1bWVudHM6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5yZWNvcmQoZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSwgZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKSkpXG4gICAgfSkpXG4gIH0pXG59KTtcbnZhciBDb21wbGV0ZVJlc3VsdFNjaGVtYSA9IFJlc3VsdFNjaGVtYS5leHRlbmQoe1xuICBjb21wbGV0aW9uOiBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gICAgdmFsdWVzOiBleHBvcnRzX2V4dGVybmFsLmFycmF5KGV4cG9ydHNfZXh0ZXJuYWwuc3RyaW5nKCkpLm1heCgxMDApLFxuICAgIHRvdGFsOiBleHBvcnRzX2V4dGVybmFsLm9wdGlvbmFsKGV4cG9ydHNfZXh0ZXJuYWwubnVtYmVyKCkuaW50KCkpLFxuICAgIGhhc01vcmU6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5ib29sZWFuKCkpXG4gIH0pLnBhc3N0aHJvdWdoKClcbn0pO1xudmFyIFJvb3RTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLm9iamVjdCh7XG4gIHVyaTogZXhwb3J0c19leHRlcm5hbC5zdHJpbmcoKS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSxcbiAgbmFtZTogZXhwb3J0c19leHRlcm5hbC5vcHRpb25hbChleHBvcnRzX2V4dGVybmFsLnN0cmluZygpKSxcbiAgX21ldGE6IGV4cG9ydHNfZXh0ZXJuYWwub3B0aW9uYWwoZXhwb3J0c19leHRlcm5hbC5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCkpXG59KS5wYXNzdGhyb3VnaCgpO1xudmFyIExpc3RSb290c1JlcXVlc3RTY2hlbWEgPSBSZXF1ZXN0U2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwicm9vdHMvbGlzdFwiKVxufSk7XG52YXIgTGlzdFJvb3RzUmVzdWx0U2NoZW1hID0gUmVzdWx0U2NoZW1hLmV4dGVuZCh7XG4gIHJvb3RzOiBleHBvcnRzX2V4dGVybmFsLmFycmF5KFJvb3RTY2hlbWEpXG59KTtcbnZhciBSb290c0xpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hID0gTm90aWZpY2F0aW9uU2NoZW1hLmV4dGVuZCh7XG4gIG1ldGhvZDogZXhwb3J0c19leHRlcm5hbC5saXRlcmFsKFwibm90aWZpY2F0aW9ucy9yb290cy9saXN0X2NoYW5nZWRcIilcbn0pO1xudmFyIENsaWVudFJlcXVlc3RTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtcbiAgUGluZ1JlcXVlc3RTY2hlbWEsXG4gIEluaXRpYWxpemVSZXF1ZXN0U2NoZW1hLFxuICBDb21wbGV0ZVJlcXVlc3RTY2hlbWEsXG4gIFNldExldmVsUmVxdWVzdFNjaGVtYSxcbiAgR2V0UHJvbXB0UmVxdWVzdFNjaGVtYSxcbiAgTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hLFxuICBMaXN0UmVzb3VyY2VzUmVxdWVzdFNjaGVtYSxcbiAgTGlzdFJlc291cmNlVGVtcGxhdGVzUmVxdWVzdFNjaGVtYSxcbiAgUmVhZFJlc291cmNlUmVxdWVzdFNjaGVtYSxcbiAgU3Vic2NyaWJlUmVxdWVzdFNjaGVtYSxcbiAgVW5zdWJzY3JpYmVSZXF1ZXN0U2NoZW1hLFxuICBDYWxsVG9vbFJlcXVlc3RTY2hlbWEsXG4gIExpc3RUb29sc1JlcXVlc3RTY2hlbWFcbl0pO1xudmFyIENsaWVudE5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW1xuICBDYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEsXG4gIFByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hLFxuICBJbml0aWFsaXplZE5vdGlmaWNhdGlvblNjaGVtYSxcbiAgUm9vdHNMaXN0Q2hhbmdlZE5vdGlmaWNhdGlvblNjaGVtYVxuXSk7XG52YXIgQ2xpZW50UmVzdWx0U2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC51bmlvbihbXG4gIEVtcHR5UmVzdWx0U2NoZW1hLFxuICBDcmVhdGVNZXNzYWdlUmVzdWx0U2NoZW1hLFxuICBFbGljaXRSZXN1bHRTY2hlbWEsXG4gIExpc3RSb290c1Jlc3VsdFNjaGVtYVxuXSk7XG52YXIgU2VydmVyUmVxdWVzdFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW1xuICBQaW5nUmVxdWVzdFNjaGVtYSxcbiAgQ3JlYXRlTWVzc2FnZVJlcXVlc3RTY2hlbWEsXG4gIEVsaWNpdFJlcXVlc3RTY2hlbWEsXG4gIExpc3RSb290c1JlcXVlc3RTY2hlbWFcbl0pO1xudmFyIFNlcnZlck5vdGlmaWNhdGlvblNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwudW5pb24oW1xuICBDYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEsXG4gIFByb2dyZXNzTm90aWZpY2F0aW9uU2NoZW1hLFxuICBMb2dnaW5nTWVzc2FnZU5vdGlmaWNhdGlvblNjaGVtYSxcbiAgUmVzb3VyY2VVcGRhdGVkTm90aWZpY2F0aW9uU2NoZW1hLFxuICBSZXNvdXJjZUxpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hLFxuICBUb29sTGlzdENoYW5nZWROb3RpZmljYXRpb25TY2hlbWEsXG4gIFByb21wdExpc3RDaGFuZ2VkTm90aWZpY2F0aW9uU2NoZW1hXG5dKTtcbnZhciBTZXJ2ZXJSZXN1bHRTY2hlbWEgPSBleHBvcnRzX2V4dGVybmFsLnVuaW9uKFtcbiAgRW1wdHlSZXN1bHRTY2hlbWEsXG4gIEluaXRpYWxpemVSZXN1bHRTY2hlbWEsXG4gIENvbXBsZXRlUmVzdWx0U2NoZW1hLFxuICBHZXRQcm9tcHRSZXN1bHRTY2hlbWEsXG4gIExpc3RQcm9tcHRzUmVzdWx0U2NoZW1hLFxuICBMaXN0UmVzb3VyY2VzUmVzdWx0U2NoZW1hLFxuICBMaXN0UmVzb3VyY2VUZW1wbGF0ZXNSZXN1bHRTY2hlbWEsXG4gIFJlYWRSZXNvdXJjZVJlc3VsdFNjaGVtYSxcbiAgQ2FsbFRvb2xSZXN1bHRTY2hlbWEsXG4gIExpc3RUb29sc1Jlc3VsdFNjaGVtYVxuXSk7XG5cbmNsYXNzIE1jcEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgc3VwZXIoYE1DUCBlcnJvciAke2NvZGV9OiAke21lc3NhZ2V9YCk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubmFtZSA9IFwiTWNwRXJyb3JcIjtcbiAgfVxufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2VzbS9zaGFyZWQvcHJvdG9jb2wuanNcbnZhciBERUZBVUxUX1JFUVVFU1RfVElNRU9VVF9NU0VDID0gNjAwMDA7XG5cbmNsYXNzIFByb3RvY29sIHtcbiAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgdGhpcy5fcmVxdWVzdE1lc3NhZ2VJZCA9IDA7XG4gICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcDtcbiAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMgPSBuZXcgTWFwO1xuICAgIHRoaXMuX25vdGlmaWNhdGlvbkhhbmRsZXJzID0gbmV3IE1hcDtcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcDtcbiAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzID0gbmV3IE1hcDtcbiAgICB0aGlzLl90aW1lb3V0SW5mbyA9IG5ldyBNYXA7XG4gICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMgPSBuZXcgU2V0O1xuICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uSGFuZGxlcihDYW5jZWxsZWROb3RpZmljYXRpb25TY2hlbWEsIChub3RpZmljYXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlckFib3J0Q29udHJvbGxlcnMuZ2V0KG5vdGlmaWNhdGlvbi5wYXJhbXMucmVxdWVzdElkKTtcbiAgICAgIGNvbnRyb2xsZXIgPT09IG51bGwgfHwgY29udHJvbGxlciA9PT0gdW5kZWZpbmVkIHx8IGNvbnRyb2xsZXIuYWJvcnQobm90aWZpY2F0aW9uLnBhcmFtcy5yZWFzb24pO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0Tm90aWZpY2F0aW9uSGFuZGxlcihQcm9ncmVzc05vdGlmaWNhdGlvblNjaGVtYSwgKG5vdGlmaWNhdGlvbikgPT4ge1xuICAgICAgdGhpcy5fb25wcm9ncmVzcyhub3RpZmljYXRpb24pO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0UmVxdWVzdEhhbmRsZXIoUGluZ1JlcXVlc3RTY2hlbWEsIChfcmVxdWVzdCkgPT4gKHt9KSk7XG4gIH1cbiAgX3NldHVwVGltZW91dChtZXNzYWdlSWQsIHRpbWVvdXQsIG1heFRvdGFsVGltZW91dCwgb25UaW1lb3V0LCByZXNldFRpbWVvdXRPblByb2dyZXNzID0gZmFsc2UpIHtcbiAgICB0aGlzLl90aW1lb3V0SW5mby5zZXQobWVzc2FnZUlkLCB7XG4gICAgICB0aW1lb3V0SWQ6IHNldFRpbWVvdXQob25UaW1lb3V0LCB0aW1lb3V0KSxcbiAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBtYXhUb3RhbFRpbWVvdXQsXG4gICAgICByZXNldFRpbWVvdXRPblByb2dyZXNzLFxuICAgICAgb25UaW1lb3V0XG4gICAgfSk7XG4gIH1cbiAgX3Jlc2V0VGltZW91dChtZXNzYWdlSWQpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5fdGltZW91dEluZm8uZ2V0KG1lc3NhZ2VJZCk7XG4gICAgaWYgKCFpbmZvKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRvdGFsRWxhcHNlZCA9IERhdGUubm93KCkgLSBpbmZvLnN0YXJ0VGltZTtcbiAgICBpZiAoaW5mby5tYXhUb3RhbFRpbWVvdXQgJiYgdG90YWxFbGFwc2VkID49IGluZm8ubWF4VG90YWxUaW1lb3V0KSB7XG4gICAgICB0aGlzLl90aW1lb3V0SW5mby5kZWxldGUobWVzc2FnZUlkKTtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuUmVxdWVzdFRpbWVvdXQsIFwiTWF4aW11bSB0b3RhbCB0aW1lb3V0IGV4Y2VlZGVkXCIsIHsgbWF4VG90YWxUaW1lb3V0OiBpbmZvLm1heFRvdGFsVGltZW91dCwgdG90YWxFbGFwc2VkIH0pO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoaW5mby50aW1lb3V0SWQpO1xuICAgIGluZm8udGltZW91dElkID0gc2V0VGltZW91dChpbmZvLm9uVGltZW91dCwgaW5mby50aW1lb3V0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBfY2xlYW51cFRpbWVvdXQobWVzc2FnZUlkKSB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuX3RpbWVvdXRJbmZvLmdldChtZXNzYWdlSWQpO1xuICAgIGlmIChpbmZvKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW5mby50aW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdGltZW91dEluZm8uZGVsZXRlKG1lc3NhZ2VJZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNvbm5lY3QodHJhbnNwb3J0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIGNvbnN0IF9vbmNsb3NlID0gKF9hID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfYS5vbmNsb3NlO1xuICAgIHRoaXMuX3RyYW5zcG9ydC5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgX29uY2xvc2UgPT09IG51bGwgfHwgX29uY2xvc2UgPT09IHVuZGVmaW5lZCB8fCBfb25jbG9zZSgpO1xuICAgICAgdGhpcy5fb25jbG9zZSgpO1xuICAgIH07XG4gICAgY29uc3QgX29uZXJyb3IgPSAoX2IgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9iLm9uZXJyb3I7XG4gICAgdGhpcy5fdHJhbnNwb3J0Lm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIF9vbmVycm9yID09PSBudWxsIHx8IF9vbmVycm9yID09PSB1bmRlZmluZWQgfHwgX29uZXJyb3IoZXJyb3IpO1xuICAgICAgdGhpcy5fb25lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBjb25zdCBfb25tZXNzYWdlID0gKF9jID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2Mub25tZXNzYWdlO1xuICAgIHRoaXMuX3RyYW5zcG9ydC5vbm1lc3NhZ2UgPSAobWVzc2FnZSwgZXh0cmEpID0+IHtcbiAgICAgIF9vbm1lc3NhZ2UgPT09IG51bGwgfHwgX29ubWVzc2FnZSA9PT0gdW5kZWZpbmVkIHx8IF9vbm1lc3NhZ2UobWVzc2FnZSwgZXh0cmEpO1xuICAgICAgaWYgKGlzSlNPTlJQQ1Jlc3BvbnNlKG1lc3NhZ2UpIHx8IGlzSlNPTlJQQ0Vycm9yKG1lc3NhZ2UpKSB7XG4gICAgICAgIHRoaXMuX29ucmVzcG9uc2UobWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzSlNPTlJQQ1JlcXVlc3QobWVzc2FnZSkpIHtcbiAgICAgICAgdGhpcy5fb25yZXF1ZXN0KG1lc3NhZ2UsIGV4dHJhKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNKU09OUlBDTm90aWZpY2F0aW9uKG1lc3NhZ2UpKSB7XG4gICAgICAgIHRoaXMuX29ubm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYFVua25vd24gbWVzc2FnZSB0eXBlOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2UpfWApKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5zdGFydCgpO1xuICB9XG4gIF9vbmNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNwb25zZUhhbmRsZXJzID0gdGhpcy5fcmVzcG9uc2VIYW5kbGVycztcbiAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzID0gbmV3IE1hcDtcbiAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMuY2xlYXIoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG4gICAgKF9hID0gdGhpcy5vbmNsb3NlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdW5kZWZpbmVkIHx8IF9hLmNhbGwodGhpcyk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgTWNwRXJyb3IoRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQsIFwiQ29ubmVjdGlvbiBjbG9zZWRcIik7XG4gICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIHJlc3BvbnNlSGFuZGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIGhhbmRsZXIoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBfb25lcnJvcihlcnJvcikge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB1bmRlZmluZWQgfHwgX2EuY2FsbCh0aGlzLCBlcnJvcik7XG4gIH1cbiAgX29ubm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBoYW5kbGVyID0gKF9hID0gdGhpcy5fbm90aWZpY2F0aW9uSGFuZGxlcnMuZ2V0KG5vdGlmaWNhdGlvbi5tZXRob2QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdW5kZWZpbmVkID8gX2EgOiB0aGlzLmZhbGxiYWNrTm90aWZpY2F0aW9uSGFuZGxlcjtcbiAgICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gaGFuZGxlcihub3RpZmljYXRpb24pKS5jYXRjaCgoZXJyb3IpID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBVbmNhdWdodCBlcnJvciBpbiBub3RpZmljYXRpb24gaGFuZGxlcjogJHtlcnJvcn1gKSkpO1xuICB9XG4gIF9vbnJlcXVlc3QocmVxdWVzdCwgZXh0cmEpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoX2EgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcnMuZ2V0KHJlcXVlc3QubWV0aG9kKSkgIT09IG51bGwgJiYgX2EgIT09IHVuZGVmaW5lZCA/IF9hIDogdGhpcy5mYWxsYmFja1JlcXVlc3RIYW5kbGVyO1xuICAgIGNvbnN0IGNhcHR1cmVkVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0O1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhcHR1cmVkVHJhbnNwb3J0ID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNwb3J0ID09PSB1bmRlZmluZWQgfHwgY2FwdHVyZWRUcmFuc3BvcnQuc2VuZCh7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIGlkOiByZXF1ZXN0LmlkLFxuICAgICAgICBlcnJvcjoge1xuICAgICAgICAgIGNvZGU6IEVycm9yQ29kZS5NZXRob2ROb3RGb3VuZCxcbiAgICAgICAgICBtZXNzYWdlOiBcIk1ldGhvZCBub3QgZm91bmRcIlxuICAgICAgICB9XG4gICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gc2VuZCBhbiBlcnJvciByZXNwb25zZTogJHtlcnJvcn1gKSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyQWJvcnRDb250cm9sbGVycy5zZXQocmVxdWVzdC5pZCwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBjb25zdCBmdWxsRXh0cmEgPSB7XG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICBzZXNzaW9uSWQ6IGNhcHR1cmVkVHJhbnNwb3J0ID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNwb3J0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjYXB0dXJlZFRyYW5zcG9ydC5zZXNzaW9uSWQsXG4gICAgICBfbWV0YTogKF9iID0gcmVxdWVzdC5wYXJhbXMpID09PSBudWxsIHx8IF9iID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBfYi5fbWV0YSxcbiAgICAgIHNlbmROb3RpZmljYXRpb246IChub3RpZmljYXRpb24pID0+IHRoaXMubm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbiwgeyByZWxhdGVkUmVxdWVzdElkOiByZXF1ZXN0LmlkIH0pLFxuICAgICAgc2VuZFJlcXVlc3Q6IChyLCByZXN1bHRTY2hlbWEsIG9wdGlvbnMpID0+IHRoaXMucmVxdWVzdChyLCByZXN1bHRTY2hlbWEsIHsgLi4ub3B0aW9ucywgcmVsYXRlZFJlcXVlc3RJZDogcmVxdWVzdC5pZCB9KSxcbiAgICAgIGF1dGhJbmZvOiBleHRyYSA9PT0gbnVsbCB8fCBleHRyYSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZXh0cmEuYXV0aEluZm8sXG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QuaWQsXG4gICAgICByZXF1ZXN0SW5mbzogZXh0cmEgPT09IG51bGwgfHwgZXh0cmEgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGV4dHJhLnJlcXVlc3RJbmZvXG4gICAgfTtcbiAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGhhbmRsZXIocmVxdWVzdCwgZnVsbEV4dHJhKSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zcG9ydCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY2FwdHVyZWRUcmFuc3BvcnQuc2VuZCh7XG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IHJlcXVlc3QuaWRcbiAgICAgIH0pO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmVkVHJhbnNwb3J0ID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNwb3J0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjYXB0dXJlZFRyYW5zcG9ydC5zZW5kKHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IHJlcXVlc3QuaWQsXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgY29kZTogTnVtYmVyLmlzU2FmZUludGVnZXIoZXJyb3JbXCJjb2RlXCJdKSA/IGVycm9yW1wiY29kZVwiXSA6IEVycm9yQ29kZS5JbnRlcm5hbEVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IChfYTIgPSBlcnJvci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYTIgIT09IHVuZGVmaW5lZCA/IF9hMiA6IFwiSW50ZXJuYWwgZXJyb3JcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gc2VuZCByZXNwb25zZTogJHtlcnJvcn1gKSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXJBYm9ydENvbnRyb2xsZXJzLmRlbGV0ZShyZXF1ZXN0LmlkKTtcbiAgICB9KTtcbiAgfVxuICBfb25wcm9ncmVzcyhub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7IHByb2dyZXNzVG9rZW4sIC4uLnBhcmFtcyB9ID0gbm90aWZpY2F0aW9uLnBhcmFtcztcbiAgICBjb25zdCBtZXNzYWdlSWQgPSBOdW1iZXIocHJvZ3Jlc3NUb2tlbik7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX3Byb2dyZXNzSGFuZGxlcnMuZ2V0KG1lc3NhZ2VJZCk7XG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihgUmVjZWl2ZWQgYSBwcm9ncmVzcyBub3RpZmljYXRpb24gZm9yIGFuIHVua25vd24gdG9rZW46ICR7SlNPTi5zdHJpbmdpZnkobm90aWZpY2F0aW9uKX1gKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlSGFuZGxlciA9IHRoaXMuX3Jlc3BvbnNlSGFuZGxlcnMuZ2V0KG1lc3NhZ2VJZCk7XG4gICAgY29uc3QgdGltZW91dEluZm8gPSB0aGlzLl90aW1lb3V0SW5mby5nZXQobWVzc2FnZUlkKTtcbiAgICBpZiAodGltZW91dEluZm8gJiYgcmVzcG9uc2VIYW5kbGVyICYmIHRpbWVvdXRJbmZvLnJlc2V0VGltZW91dE9uUHJvZ3Jlc3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0VGltZW91dChtZXNzYWdlSWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmVzcG9uc2VIYW5kbGVyKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVyKHBhcmFtcyk7XG4gIH1cbiAgX29ucmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBtZXNzYWdlSWQgPSBOdW1iZXIocmVzcG9uc2UuaWQpO1xuICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmdldChtZXNzYWdlSWQpO1xuICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX29uZXJyb3IobmV3IEVycm9yKGBSZWNlaXZlZCBhIHJlc3BvbnNlIGZvciBhbiB1bmtub3duIG1lc3NhZ2UgSUQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpfWApKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVzcG9uc2VIYW5kbGVycy5kZWxldGUobWVzc2FnZUlkKTtcbiAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgIHRoaXMuX2NsZWFudXBUaW1lb3V0KG1lc3NhZ2VJZCk7XG4gICAgaWYgKGlzSlNPTlJQQ1Jlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgaGFuZGxlcihyZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1jcEVycm9yKHJlc3BvbnNlLmVycm9yLmNvZGUsIHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlLmVycm9yLmRhdGEpO1xuICAgICAgaGFuZGxlcihlcnJvcik7XG4gICAgfVxuICB9XG4gIGdldCB0cmFuc3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydDtcbiAgfVxuICBhc3luYyBjbG9zZSgpIHtcbiAgICB2YXIgX2E7XG4gICAgYXdhaXQgKChfYSA9IHRoaXMuX3RyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9hLmNsb3NlKCkpO1xuICB9XG4gIHJlcXVlc3QocmVxdWVzdCwgcmVzdWx0U2NoZW1hLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWxhdGVkUmVxdWVzdElkLCByZXN1bXB0aW9uVG9rZW4sIG9ucmVzdW1wdGlvbnRva2VuIH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMgOiB7fTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZFwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9hID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9hLmVuZm9yY2VTdHJpY3RDYXBhYmlsaXRpZXMpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0Q2FwYWJpbGl0eUZvck1ldGhvZChyZXF1ZXN0Lm1ldGhvZCk7XG4gICAgICB9XG4gICAgICAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdW5kZWZpbmVkIHx8IF9iLnRocm93SWZBYm9ydGVkKCk7XG4gICAgICBjb25zdCBtZXNzYWdlSWQgPSB0aGlzLl9yZXF1ZXN0TWVzc2FnZUlkKys7XG4gICAgICBjb25zdCBqc29ucnBjUmVxdWVzdCA9IHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IG1lc3NhZ2VJZFxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMub25wcm9ncmVzcykge1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLnNldChtZXNzYWdlSWQsIG9wdGlvbnMub25wcm9ncmVzcyk7XG4gICAgICAgIGpzb25ycGNSZXF1ZXN0LnBhcmFtcyA9IHtcbiAgICAgICAgICAuLi5yZXF1ZXN0LnBhcmFtcyxcbiAgICAgICAgICBfbWV0YToge1xuICAgICAgICAgICAgLi4uKChfYyA9IHJlcXVlc3QucGFyYW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2MuX21ldGEpIHx8IHt9LFxuICAgICAgICAgICAgcHJvZ3Jlc3NUb2tlbjogbWVzc2FnZUlkXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY2FuY2VsID0gKHJlYXNvbikgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0hhbmRsZXJzLmRlbGV0ZShtZXNzYWdlSWQpO1xuICAgICAgICB0aGlzLl9jbGVhbnVwVGltZW91dChtZXNzYWdlSWQpO1xuICAgICAgICAoX2EyID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYTIgPT09IHVuZGVmaW5lZCB8fCBfYTIuc2VuZCh7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBtZXRob2Q6IFwibm90aWZpY2F0aW9ucy9jYW5jZWxsZWRcIixcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHJlcXVlc3RJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgcmVhc29uOiBTdHJpbmcocmVhc29uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyByZWxhdGVkUmVxdWVzdElkLCByZXN1bXB0aW9uVG9rZW4sIG9ucmVzdW1wdGlvbnRva2VuIH0pLmNhdGNoKChlcnJvcikgPT4gdGhpcy5fb25lcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBzZW5kIGNhbmNlbGxhdGlvbjogJHtlcnJvcn1gKSkpO1xuICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9yZXNwb25zZUhhbmRsZXJzLnNldChtZXNzYWdlSWQsIChyZXNwb25zZSkgPT4ge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAoKF9hMiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9hMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2EyLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3VsdFNjaGVtYS5wYXJzZShyZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5zaWduYWwpID09PSBudWxsIHx8IF9kID09PSB1bmRlZmluZWQgfHwgX2QuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgY2FuY2VsKChfYTIgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuc2lnbmFsKSA9PT0gbnVsbCB8fCBfYTIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9hMi5yZWFzb24pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0aW1lb3V0ID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9lICE9PSB1bmRlZmluZWQgPyBfZSA6IERFRkFVTFRfUkVRVUVTVF9USU1FT1VUX01TRUM7XG4gICAgICBjb25zdCB0aW1lb3V0SGFuZGxlciA9ICgpID0+IGNhbmNlbChuZXcgTWNwRXJyb3IoRXJyb3JDb2RlLlJlcXVlc3RUaW1lb3V0LCBcIlJlcXVlc3QgdGltZWQgb3V0XCIsIHsgdGltZW91dCB9KSk7XG4gICAgICB0aGlzLl9zZXR1cFRpbWVvdXQobWVzc2FnZUlkLCB0aW1lb3V0LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMubWF4VG90YWxUaW1lb3V0LCB0aW1lb3V0SGFuZGxlciwgKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnJlc2V0VGltZW91dE9uUHJvZ3Jlc3MpICE9PSBudWxsICYmIF9mICE9PSB1bmRlZmluZWQgPyBfZiA6IGZhbHNlKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGpzb25ycGNSZXF1ZXN0LCB7IHJlbGF0ZWRSZXF1ZXN0SWQsIHJlc3VtcHRpb25Ub2tlbiwgb25yZXN1bXB0aW9udG9rZW4gfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBUaW1lb3V0KG1lc3NhZ2VJZCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBhc3luYyBub3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGNvbm5lY3RlZFwiKTtcbiAgICB9XG4gICAgdGhpcy5hc3NlcnROb3RpZmljYXRpb25DYXBhYmlsaXR5KG5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgIGNvbnN0IGRlYm91bmNlZE1ldGhvZHMgPSAoX2IgPSAoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2EuZGVib3VuY2VkTm90aWZpY2F0aW9uTWV0aG9kcykgIT09IG51bGwgJiYgX2IgIT09IHVuZGVmaW5lZCA/IF9iIDogW107XG4gICAgY29uc3QgY2FuRGVib3VuY2UgPSBkZWJvdW5jZWRNZXRob2RzLmluY2x1ZGVzKG5vdGlmaWNhdGlvbi5tZXRob2QpICYmICFub3RpZmljYXRpb24ucGFyYW1zICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvcHRpb25zLnJlbGF0ZWRSZXF1ZXN0SWQpO1xuICAgIGlmIChjYW5EZWJvdW5jZSkge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdEZWJvdW5jZWROb3RpZmljYXRpb25zLmhhcyhub3RpZmljYXRpb24ubWV0aG9kKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9wZW5kaW5nRGVib3VuY2VkTm90aWZpY2F0aW9ucy5hZGQobm90aWZpY2F0aW9uLm1ldGhvZCk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0RlYm91bmNlZE5vdGlmaWNhdGlvbnMuZGVsZXRlKG5vdGlmaWNhdGlvbi5tZXRob2QpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc29ucnBjTm90aWZpY2F0aW9uMiA9IHtcbiAgICAgICAgICAuLi5ub3RpZmljYXRpb24sXG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICAoX2EyID0gdGhpcy5fdHJhbnNwb3J0KSA9PT0gbnVsbCB8fCBfYTIgPT09IHVuZGVmaW5lZCB8fCBfYTIuc2VuZChqc29ucnBjTm90aWZpY2F0aW9uMiwgb3B0aW9ucykuY2F0Y2goKGVycm9yKSA9PiB0aGlzLl9vbmVycm9yKGVycm9yKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QganNvbnJwY05vdGlmaWNhdGlvbiA9IHtcbiAgICAgIC4uLm5vdGlmaWNhdGlvbixcbiAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICB9O1xuICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC5zZW5kKGpzb25ycGNOb3RpZmljYXRpb24sIG9wdGlvbnMpO1xuICB9XG4gIHNldFJlcXVlc3RIYW5kbGVyKHJlcXVlc3RTY2hlbWEsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXF1ZXN0U2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZTtcbiAgICB0aGlzLmFzc2VydFJlcXVlc3RIYW5kbGVyQ2FwYWJpbGl0eShtZXRob2QpO1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVycy5zZXQobWV0aG9kLCAocmVxdWVzdCwgZXh0cmEpID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaGFuZGxlcihyZXF1ZXN0U2NoZW1hLnBhcnNlKHJlcXVlc3QpLCBleHRyYSkpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZVJlcXVlc3RIYW5kbGVyKG1ldGhvZCkge1xuICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxuICBhc3NlcnRDYW5TZXRSZXF1ZXN0SGFuZGxlcihtZXRob2QpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdEhhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcmVxdWVzdCBoYW5kbGVyIGZvciAke21ldGhvZH0gYWxyZWFkeSBleGlzdHMsIHdoaWNoIHdvdWxkIGJlIG92ZXJyaWRkZW5gKTtcbiAgICB9XG4gIH1cbiAgc2V0Tm90aWZpY2F0aW9uSGFuZGxlcihub3RpZmljYXRpb25TY2hlbWEsIGhhbmRsZXIpIHtcbiAgICB0aGlzLl9ub3RpZmljYXRpb25IYW5kbGVycy5zZXQobm90aWZpY2F0aW9uU2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSwgKG5vdGlmaWNhdGlvbikgPT4gUHJvbWlzZS5yZXNvbHZlKGhhbmRsZXIobm90aWZpY2F0aW9uU2NoZW1hLnBhcnNlKG5vdGlmaWNhdGlvbikpKSk7XG4gIH1cbiAgcmVtb3ZlTm90aWZpY2F0aW9uSGFuZGxlcihtZXRob2QpIHtcbiAgICB0aGlzLl9ub3RpZmljYXRpb25IYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VDYXBhYmlsaXRpZXMoYmFzZSwgYWRkaXRpb25hbCkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYWRkaXRpb25hbCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGFjY1trZXldID0gYWNjW2tleV0gPyB7IC4uLmFjY1trZXldLCAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBhY2M7XG4gIH0sIHsgLi4uYmFzZSB9KTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvZGlzdC9lc20vc2VydmVyL2luZGV4LmpzXG52YXIgaW1wb3J0X2FqdiA9IF9fdG9FU00ocmVxdWlyZV9hanYoKSwgMSk7XG5cbmNsYXNzIFNlcnZlciBleHRlbmRzIFByb3RvY29sIHtcbiAgY29uc3RydWN0b3IoX3NlcnZlckluZm8sIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5fc2VydmVySW5mbyA9IF9zZXJ2ZXJJbmZvO1xuICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5jYXBhYmlsaXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB1bmRlZmluZWQgPyBfYSA6IHt9O1xuICAgIHRoaXMuX2luc3RydWN0aW9ucyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5zZXRSZXF1ZXN0SGFuZGxlcihJbml0aWFsaXplUmVxdWVzdFNjaGVtYSwgKHJlcXVlc3QpID0+IHRoaXMuX29uaW5pdGlhbGl6ZShyZXF1ZXN0KSk7XG4gICAgdGhpcy5zZXROb3RpZmljYXRpb25IYW5kbGVyKEluaXRpYWxpemVkTm90aWZpY2F0aW9uU2NoZW1hLCAoKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgcmV0dXJuIChfYTIgPSB0aGlzLm9uaW5pdGlhbGl6ZWQpID09PSBudWxsIHx8IF9hMiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2EyLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbiAgcmVnaXN0ZXJDYXBhYmlsaXRpZXMoY2FwYWJpbGl0aWVzKSB7XG4gICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVnaXN0ZXIgY2FwYWJpbGl0aWVzIGFmdGVyIGNvbm5lY3RpbmcgdG8gdHJhbnNwb3J0XCIpO1xuICAgIH1cbiAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSBtZXJnZUNhcGFiaWxpdGllcyh0aGlzLl9jYXBhYmlsaXRpZXMsIGNhcGFiaWxpdGllcyk7XG4gIH1cbiAgYXNzZXJ0Q2FwYWJpbGl0eUZvck1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSBcInNhbXBsaW5nL2NyZWF0ZU1lc3NhZ2VcIjpcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fY2xpZW50Q2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2Euc2FtcGxpbmcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCBzYW1wbGluZyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbGljaXRhdGlvbi9jcmVhdGVcIjpcbiAgICAgICAgaWYgKCEoKF9iID0gdGhpcy5fY2xpZW50Q2FwYWJpbGl0aWVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogX2IuZWxpY2l0YXRpb24pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDbGllbnQgZG9lcyBub3Qgc3VwcG9ydCBlbGljaXRhdGlvbiAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyb290cy9saXN0XCI6XG4gICAgICAgIGlmICghKChfYyA9IHRoaXMuX2NsaWVudENhcGFiaWxpdGllcykgPT09IG51bGwgfHwgX2MgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IF9jLnJvb3RzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xpZW50IGRvZXMgbm90IHN1cHBvcnQgbGlzdGluZyByb290cyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwaW5nXCI6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhc3NlcnROb3RpZmljYXRpb25DYXBhYmlsaXR5KG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICBjYXNlIFwibm90aWZpY2F0aW9ucy9tZXNzYWdlXCI6XG4gICAgICAgIGlmICghdGhpcy5fY2FwYWJpbGl0aWVzLmxvZ2dpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IGxvZ2dpbmcgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibm90aWZpY2F0aW9ucy9yZXNvdXJjZXMvdXBkYXRlZFwiOlxuICAgICAgY2FzZSBcIm5vdGlmaWNhdGlvbnMvcmVzb3VyY2VzL2xpc3RfY2hhbmdlZFwiOlxuICAgICAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcy5yZXNvdXJjZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IG5vdGlmeWluZyBhYm91dCByZXNvdXJjZXMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibm90aWZpY2F0aW9ucy90b29scy9saXN0X2NoYW5nZWRcIjpcbiAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMudG9vbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IG5vdGlmeWluZyBvZiB0b29sIGxpc3QgY2hhbmdlcyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJub3RpZmljYXRpb25zL3Byb21wdHMvbGlzdF9jaGFuZ2VkXCI6XG4gICAgICAgIGlmICghdGhpcy5fY2FwYWJpbGl0aWVzLnByb21wdHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IG5vdGlmeWluZyBvZiBwcm9tcHQgbGlzdCBjaGFuZ2VzIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5vdGlmaWNhdGlvbnMvY2FuY2VsbGVkXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm5vdGlmaWNhdGlvbnMvcHJvZ3Jlc3NcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFzc2VydFJlcXVlc3RIYW5kbGVyQ2FwYWJpbGl0eShtZXRob2QpIHtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSBcInNhbXBsaW5nL2NyZWF0ZU1lc3NhZ2VcIjpcbiAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMuc2FtcGxpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHNhbXBsaW5nIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImxvZ2dpbmcvc2V0TGV2ZWxcIjpcbiAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMubG9nZ2luZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGRvZXMgbm90IHN1cHBvcnQgbG9nZ2luZyAocmVxdWlyZWQgZm9yICR7bWV0aG9kfSlgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcm9tcHRzL2dldFwiOlxuICAgICAgY2FzZSBcInByb21wdHMvbGlzdFwiOlxuICAgICAgICBpZiAoIXRoaXMuX2NhcGFiaWxpdGllcy5wcm9tcHRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBwcm9tcHRzIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJlc291cmNlcy9saXN0XCI6XG4gICAgICBjYXNlIFwicmVzb3VyY2VzL3RlbXBsYXRlcy9saXN0XCI6XG4gICAgICBjYXNlIFwicmVzb3VyY2VzL3JlYWRcIjpcbiAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMucmVzb3VyY2VzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCByZXNvdXJjZXMgKHJlcXVpcmVkIGZvciAke21ldGhvZH0pYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9vbHMvY2FsbFwiOlxuICAgICAgY2FzZSBcInRvb2xzL2xpc3RcIjpcbiAgICAgICAgaWYgKCF0aGlzLl9jYXBhYmlsaXRpZXMudG9vbHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBkb2VzIG5vdCBzdXBwb3J0IHRvb2xzIChyZXF1aXJlZCBmb3IgJHttZXRob2R9KWApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgIGNhc2UgXCJpbml0aWFsaXplXCI6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhc3luYyBfb25pbml0aWFsaXplKHJlcXVlc3QpIHtcbiAgICBjb25zdCByZXF1ZXN0ZWRWZXJzaW9uID0gcmVxdWVzdC5wYXJhbXMucHJvdG9jb2xWZXJzaW9uO1xuICAgIHRoaXMuX2NsaWVudENhcGFiaWxpdGllcyA9IHJlcXVlc3QucGFyYW1zLmNhcGFiaWxpdGllcztcbiAgICB0aGlzLl9jbGllbnRWZXJzaW9uID0gcmVxdWVzdC5wYXJhbXMuY2xpZW50SW5mbztcbiAgICBjb25zdCBwcm90b2NvbFZlcnNpb24gPSBTVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTlMuaW5jbHVkZXMocmVxdWVzdGVkVmVyc2lvbikgPyByZXF1ZXN0ZWRWZXJzaW9uIDogTEFURVNUX1BST1RPQ09MX1ZFUlNJT047XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvY29sVmVyc2lvbixcbiAgICAgIGNhcGFiaWxpdGllczogdGhpcy5nZXRDYXBhYmlsaXRpZXMoKSxcbiAgICAgIHNlcnZlckluZm86IHRoaXMuX3NlcnZlckluZm8sXG4gICAgICAuLi50aGlzLl9pbnN0cnVjdGlvbnMgJiYgeyBpbnN0cnVjdGlvbnM6IHRoaXMuX2luc3RydWN0aW9ucyB9XG4gICAgfTtcbiAgfVxuICBnZXRDbGllbnRDYXBhYmlsaXRpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudENhcGFiaWxpdGllcztcbiAgfVxuICBnZXRDbGllbnRWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRWZXJzaW9uO1xuICB9XG4gIGdldENhcGFiaWxpdGllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0aWVzO1xuICB9XG4gIGFzeW5jIHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogXCJwaW5nXCIgfSwgRW1wdHlSZXN1bHRTY2hlbWEpO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU1lc3NhZ2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7IG1ldGhvZDogXCJzYW1wbGluZy9jcmVhdGVNZXNzYWdlXCIsIHBhcmFtcyB9LCBDcmVhdGVNZXNzYWdlUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBlbGljaXRJbnB1dChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6IFwiZWxpY2l0YXRpb24vY3JlYXRlXCIsIHBhcmFtcyB9LCBFbGljaXRSZXN1bHRTY2hlbWEsIG9wdGlvbnMpO1xuICAgIGlmIChyZXN1bHQuYWN0aW9uID09PSBcImFjY2VwdFwiICYmIHJlc3VsdC5jb250ZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhanYgPSBuZXcgaW1wb3J0X2Fqdi5kZWZhdWx0O1xuICAgICAgICBjb25zdCB2YWxpZGF0ZSA9IGFqdi5jb21waWxlKHBhcmFtcy5yZXF1ZXN0ZWRTY2hlbWEpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkMiA9IHZhbGlkYXRlKHJlc3VsdC5jb250ZW50KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkMikge1xuICAgICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYEVsaWNpdGF0aW9uIHJlc3BvbnNlIGNvbnRlbnQgZG9lcyBub3QgbWF0Y2ggcmVxdWVzdGVkIHNjaGVtYTogJHthanYuZXJyb3JzVGV4dCh2YWxpZGF0ZS5lcnJvcnMpfWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNY3BFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW50ZXJuYWxFcnJvciwgYEVycm9yIHZhbGlkYXRpbmcgZWxpY2l0YXRpb24gcmVzcG9uc2U6ICR7ZXJyb3J9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXN5bmMgbGlzdFJvb3RzKHBhcmFtcywgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6IFwicm9vdHMvbGlzdFwiLCBwYXJhbXMgfSwgTGlzdFJvb3RzUmVzdWx0U2NoZW1hLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBzZW5kTG9nZ2luZ01lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9uKHsgbWV0aG9kOiBcIm5vdGlmaWNhdGlvbnMvbWVzc2FnZVwiLCBwYXJhbXMgfSk7XG4gIH1cbiAgYXN5bmMgc2VuZFJlc291cmNlVXBkYXRlZChwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb24oe1xuICAgICAgbWV0aG9kOiBcIm5vdGlmaWNhdGlvbnMvcmVzb3VyY2VzL3VwZGF0ZWRcIixcbiAgICAgIHBhcmFtc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHNlbmRSZXNvdXJjZUxpc3RDaGFuZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLm5vdGlmaWNhdGlvbih7XG4gICAgICBtZXRob2Q6IFwibm90aWZpY2F0aW9ucy9yZXNvdXJjZXMvbGlzdF9jaGFuZ2VkXCJcbiAgICB9KTtcbiAgfVxuICBhc3luYyBzZW5kVG9vbExpc3RDaGFuZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLm5vdGlmaWNhdGlvbih7IG1ldGhvZDogXCJub3RpZmljYXRpb25zL3Rvb2xzL2xpc3RfY2hhbmdlZFwiIH0pO1xuICB9XG4gIGFzeW5jIHNlbmRQcm9tcHRMaXN0Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb24oeyBtZXRob2Q6IFwibm90aWZpY2F0aW9ucy9wcm9tcHRzL2xpc3RfY2hhbmdlZFwiIH0pO1xuICB9XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vT3B0aW9ucy5qc1xudmFyIGlnbm9yZU92ZXJyaWRlID0gU3ltYm9sKFwiTGV0IHpvZFRvSnNvblNjaGVtYSBkZWNpZGUgb24gd2hpY2ggcGFyc2VyIHRvIHVzZVwiKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgbmFtZTogdW5kZWZpbmVkLFxuICAkcmVmU3RyYXRlZ3k6IFwicm9vdFwiLFxuICBiYXNlUGF0aDogW1wiI1wiXSxcbiAgZWZmZWN0U3RyYXRlZ3k6IFwiaW5wdXRcIixcbiAgcGlwZVN0cmF0ZWd5OiBcImFsbFwiLFxuICBkYXRlU3RyYXRlZ3k6IFwiZm9ybWF0OmRhdGUtdGltZVwiLFxuICBtYXBTdHJhdGVneTogXCJlbnRyaWVzXCIsXG4gIHJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneTogXCJwYXNzdGhyb3VnaFwiLFxuICBhbGxvd2VkQWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHJlamVjdGVkQWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICBkZWZpbml0aW9uUGF0aDogXCJkZWZpbml0aW9uc1wiLFxuICB0YXJnZXQ6IFwianNvblNjaGVtYTdcIixcbiAgc3RyaWN0VW5pb25zOiBmYWxzZSxcbiAgZGVmaW5pdGlvbnM6IHt9LFxuICBlcnJvck1lc3NhZ2VzOiBmYWxzZSxcbiAgbWFya2Rvd25EZXNjcmlwdGlvbjogZmFsc2UsXG4gIHBhdHRlcm5TdHJhdGVneTogXCJlc2NhcGVcIixcbiAgYXBwbHlSZWdleEZsYWdzOiBmYWxzZSxcbiAgZW1haWxTdHJhdGVneTogXCJmb3JtYXQ6ZW1haWxcIixcbiAgYmFzZTY0U3RyYXRlZ3k6IFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiLFxuICBuYW1lU3RyYXRlZ3k6IFwicmVmXCJcbn07XG52YXIgZ2V0RGVmYXVsdE9wdGlvbnMgPSAob3B0aW9ucykgPT4gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyB7XG4gIC4uLmRlZmF1bHRPcHRpb25zLFxuICBuYW1lOiBvcHRpb25zXG59IDoge1xuICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgLi4ub3B0aW9uc1xufTtcbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vUmVmcy5qc1xudmFyIGdldFJlZnMgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBfb3B0aW9ucyA9IGdldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCBjdXJyZW50UGF0aCA9IF9vcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IFsuLi5fb3B0aW9ucy5iYXNlUGF0aCwgX29wdGlvbnMuZGVmaW5pdGlvblBhdGgsIF9vcHRpb25zLm5hbWVdIDogX29wdGlvbnMuYmFzZVBhdGg7XG4gIHJldHVybiB7XG4gICAgLi4uX29wdGlvbnMsXG4gICAgY3VycmVudFBhdGgsXG4gICAgcHJvcGVydHlQYXRoOiB1bmRlZmluZWQsXG4gICAgc2VlbjogbmV3IE1hcChPYmplY3QuZW50cmllcyhfb3B0aW9ucy5kZWZpbml0aW9ucykubWFwKChbbmFtZSwgZGVmXSkgPT4gW1xuICAgICAgZGVmLl9kZWYsXG4gICAgICB7XG4gICAgICAgIGRlZjogZGVmLl9kZWYsXG4gICAgICAgIHBhdGg6IFsuLi5fb3B0aW9ucy5iYXNlUGF0aCwgX29wdGlvbnMuZGVmaW5pdGlvblBhdGgsIG5hbWVdLFxuICAgICAgICBqc29uU2NoZW1hOiB1bmRlZmluZWRcbiAgICAgIH1cbiAgICBdKSlcbiAgfTtcbn07XG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL2Vycm9yTWVzc2FnZXMuanNcbmZ1bmN0aW9uIGFkZEVycm9yTWVzc2FnZShyZXMsIGtleSwgZXJyb3JNZXNzYWdlLCByZWZzKSB7XG4gIGlmICghcmVmcz8uZXJyb3JNZXNzYWdlcylcbiAgICByZXR1cm47XG4gIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICByZXMuZXJyb3JNZXNzYWdlID0ge1xuICAgICAgLi4ucmVzLmVycm9yTWVzc2FnZSxcbiAgICAgIFtrZXldOiBlcnJvck1lc3NhZ2VcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywga2V5LCB2YWx1ZSwgZXJyb3JNZXNzYWdlLCByZWZzKSB7XG4gIHJlc1trZXldID0gdmFsdWU7XG4gIGFkZEVycm9yTWVzc2FnZShyZXMsIGtleSwgZXJyb3JNZXNzYWdlLCByZWZzKTtcbn1cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9hbnkuanNcbmZ1bmN0aW9uIHBhcnNlQW55RGVmKCkge1xuICByZXR1cm4ge307XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9hcnJheS5qc1xuZnVuY3Rpb24gcGFyc2VBcnJheURlZihkZWYsIHJlZnMpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwiYXJyYXlcIlxuICB9O1xuICBpZiAoZGVmLnR5cGU/Ll9kZWYgJiYgZGVmLnR5cGU/Ll9kZWY/LnR5cGVOYW1lICE9PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55KSB7XG4gICAgcmVzLml0ZW1zID0gcGFyc2VEZWYoZGVmLnR5cGUuX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiXVxuICAgIH0pO1xuICB9XG4gIGlmIChkZWYubWluTGVuZ3RoKSB7XG4gICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluSXRlbXNcIiwgZGVmLm1pbkxlbmd0aC52YWx1ZSwgZGVmLm1pbkxlbmd0aC5tZXNzYWdlLCByZWZzKTtcbiAgfVxuICBpZiAoZGVmLm1heExlbmd0aCkge1xuICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heEl0ZW1zXCIsIGRlZi5tYXhMZW5ndGgudmFsdWUsIGRlZi5tYXhMZW5ndGgubWVzc2FnZSwgcmVmcyk7XG4gIH1cbiAgaWYgKGRlZi5leGFjdExlbmd0aCkge1xuICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkl0ZW1zXCIsIGRlZi5leGFjdExlbmd0aC52YWx1ZSwgZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsIHJlZnMpO1xuICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heEl0ZW1zXCIsIGRlZi5leGFjdExlbmd0aC52YWx1ZSwgZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsIHJlZnMpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9iaWdpbnQuanNcbmZ1bmN0aW9uIHBhcnNlQmlnaW50RGVmKGRlZiwgcmVmcykge1xuICBjb25zdCByZXMgPSB7XG4gICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgZm9ybWF0OiBcImludDY0XCJcbiAgfTtcbiAgaWYgKCFkZWYuY2hlY2tzKVxuICAgIHJldHVybiByZXM7XG4gIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICBpZiAocmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTdcIikge1xuICAgICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbmltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJleGNsdXNpdmVNaW5pbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJlcy5leGNsdXNpdmVNaW5pbXVtID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluaW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgIGlmIChyZWZzLnRhcmdldCA9PT0gXCJqc29uU2NoZW1hN1wiKSB7XG4gICAgICAgICAgaWYgKGNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4aW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcImV4Y2x1c2l2ZU1heGltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNoZWNrLmluY2x1c2l2ZSkge1xuICAgICAgICAgICAgcmVzLmV4Y2x1c2l2ZU1heGltdW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhpbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtdWx0aXBsZU9mXCI6XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm11bHRpcGxlT2ZcIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2Jvb2xlYW4uanNcbmZ1bmN0aW9uIHBhcnNlQm9vbGVhbkRlZigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIlxuICB9O1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvYnJhbmRlZC5qc1xuZnVuY3Rpb24gcGFyc2VCcmFuZGVkRGVmKF9kZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHBhcnNlRGVmKF9kZWYudHlwZS5fZGVmLCByZWZzKTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2NhdGNoLmpzXG52YXIgcGFyc2VDYXRjaERlZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgcmV0dXJuIHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyk7XG59O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvZGF0ZS5qc1xuZnVuY3Rpb24gcGFyc2VEYXRlRGVmKGRlZiwgcmVmcywgb3ZlcnJpZGVEYXRlU3RyYXRlZ3kpIHtcbiAgY29uc3Qgc3RyYXRlZ3kgPSBvdmVycmlkZURhdGVTdHJhdGVneSA/PyByZWZzLmRhdGVTdHJhdGVneTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyYXRlZ3kpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFueU9mOiBzdHJhdGVneS5tYXAoKGl0ZW0sIGkpID0+IHBhcnNlRGF0ZURlZihkZWYsIHJlZnMsIGl0ZW0pKVxuICAgIH07XG4gIH1cbiAgc3dpdGNoIChzdHJhdGVneSkge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwiZm9ybWF0OmRhdGUtdGltZVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGUtdGltZVwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJmb3JtYXQ6ZGF0ZVwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGVcIlxuICAgICAgfTtcbiAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgcmV0dXJuIGludGVnZXJEYXRlUGFyc2VyKGRlZiwgcmVmcyk7XG4gIH1cbn1cbnZhciBpbnRlZ2VyRGF0ZVBhcnNlciA9IChkZWYsIHJlZnMpID0+IHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwiaW50ZWdlclwiLFxuICAgIGZvcm1hdDogXCJ1bml4LXRpbWVcIlxuICB9O1xuICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIikge1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbmltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4aW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL2RlZmF1bHQuanNcbmZ1bmN0aW9uIHBhcnNlRGVmYXVsdERlZihfZGVmLCByZWZzKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGFyc2VEZWYoX2RlZi5pbm5lclR5cGUuX2RlZiwgcmVmcyksXG4gICAgZGVmYXVsdDogX2RlZi5kZWZhdWx0VmFsdWUoKVxuICB9O1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvZWZmZWN0cy5qc1xuZnVuY3Rpb24gcGFyc2VFZmZlY3RzRGVmKF9kZWYsIHJlZnMpIHtcbiAgcmV0dXJuIHJlZnMuZWZmZWN0U3RyYXRlZ3kgPT09IFwiaW5wdXRcIiA/IHBhcnNlRGVmKF9kZWYuc2NoZW1hLl9kZWYsIHJlZnMpIDoge307XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9lbnVtLmpzXG5mdW5jdGlvbiBwYXJzZUVudW1EZWYoZGVmKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBlbnVtOiBBcnJheS5mcm9tKGRlZi52YWx1ZXMpXG4gIH07XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9pbnRlcnNlY3Rpb24uanNcbnZhciBpc0pzb25TY2hlbWE3QWxsT2ZUeXBlID0gKHR5cGUpID0+IHtcbiAgaWYgKFwidHlwZVwiIGluIHR5cGUgJiYgdHlwZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFwiYWxsT2ZcIiBpbiB0eXBlO1xufTtcbmZ1bmN0aW9uIHBhcnNlSW50ZXJzZWN0aW9uRGVmKGRlZiwgcmVmcykge1xuICBjb25zdCBhbGxPZiA9IFtcbiAgICBwYXJzZURlZihkZWYubGVmdC5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIFwiMFwiXVxuICAgIH0pLFxuICAgIHBhcnNlRGVmKGRlZi5yaWdodC5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFsbE9mXCIsIFwiMVwiXVxuICAgIH0pXG4gIF0uZmlsdGVyKCh4KSA9PiAhIXgpO1xuICBsZXQgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID0gcmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTIwMTktMDlcIiA/IHsgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzOiBmYWxzZSB9IDogdW5kZWZpbmVkO1xuICBjb25zdCBtZXJnZWRBbGxPZiA9IFtdO1xuICBhbGxPZi5mb3JFYWNoKChzY2hlbWEpID0+IHtcbiAgICBpZiAoaXNKc29uU2NoZW1hN0FsbE9mVHlwZShzY2hlbWEpKSB7XG4gICAgICBtZXJnZWRBbGxPZi5wdXNoKC4uLnNjaGVtYS5hbGxPZik7XG4gICAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVuZXZhbHVhdGVkUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5lc3RlZFNjaGVtYSA9IHNjaGVtYTtcbiAgICAgIGlmIChcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIgaW4gc2NoZW1hICYmIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBhZGRpdGlvbmFsUHJvcGVydGllcywgLi4ucmVzdCB9ID0gc2NoZW1hO1xuICAgICAgICBuZXN0ZWRTY2hlbWEgPSByZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbWVyZ2VkQWxsT2YucHVzaChuZXN0ZWRTY2hlbWEpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtZXJnZWRBbGxPZi5sZW5ndGggPyB7XG4gICAgYWxsT2Y6IG1lcmdlZEFsbE9mLFxuICAgIC4uLnVuZXZhbHVhdGVkUHJvcGVydGllc1xuICB9IDogdW5kZWZpbmVkO1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvbGl0ZXJhbC5qc1xuZnVuY3Rpb24gcGFyc2VMaXRlcmFsRGVmKGRlZiwgcmVmcykge1xuICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZW9mIGRlZi52YWx1ZTtcbiAgaWYgKHBhcnNlZFR5cGUgIT09IFwiYmlnaW50XCIgJiYgcGFyc2VkVHlwZSAhPT0gXCJudW1iZXJcIiAmJiBwYXJzZWRUeXBlICE9PSBcImJvb2xlYW5cIiAmJiBwYXJzZWRUeXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IEFycmF5LmlzQXJyYXkoZGVmLnZhbHVlKSA/IFwiYXJyYXlcIiA6IFwib2JqZWN0XCJcbiAgICB9O1xuICB9XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IHBhcnNlZFR5cGUgPT09IFwiYmlnaW50XCIgPyBcImludGVnZXJcIiA6IHBhcnNlZFR5cGUsXG4gICAgICBlbnVtOiBbZGVmLnZhbHVlXVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBwYXJzZWRUeXBlID09PSBcImJpZ2ludFwiID8gXCJpbnRlZ2VyXCIgOiBwYXJzZWRUeXBlLFxuICAgIGNvbnN0OiBkZWYudmFsdWVcbiAgfTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qc1xudmFyIGVtb2ppUmVnZXgyID0gdW5kZWZpbmVkO1xudmFyIHpvZFBhdHRlcm5zID0ge1xuICBjdWlkOiAvXltjQ11bXlxccy1dezgsfSQvLFxuICBjdWlkMjogL15bMC05YS16XSskLyxcbiAgdWxpZDogL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC8sXG4gIGVtYWlsOiAvXig/IVxcLikoPyEuKlxcLlxcLikoW2EtekEtWjAtOV8nK1xcLVxcLl0qKVthLXpBLVowLTlfKy1dQChbYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlxcLikrW2EtekEtWl17Mix9JC8sXG4gIGVtb2ppOiAoKSA9PiB7XG4gICAgaWYgKGVtb2ppUmVnZXgyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVtb2ppUmVnZXgyID0gUmVnRXhwKFwiXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRcIiwgXCJ1XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZW1vamlSZWdleDI7XG4gIH0sXG4gIHV1aWQ6IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC8sXG4gIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sXG4gIGlwdjRDaWRyOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLyxcbiAgaXB2NjogL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC8sXG4gIGlwdjZDaWRyOiAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLFxuICBiYXNlNjQ6IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLyxcbiAgYmFzZTY0dXJsOiAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC8sXG4gIG5hbm9pZDogL15bYS16QS1aMC05Xy1dezIxfSQvLFxuICBqd3Q6IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC9cbn07XG5mdW5jdGlvbiBwYXJzZVN0cmluZ0RlZihkZWYsIHJlZnMpIHtcbiAgY29uc3QgcmVzID0ge1xuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfTtcbiAgaWYgKGRlZi5jaGVja3MpIHtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluTGVuZ3RoXCIsIHR5cGVvZiByZXMubWluTGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4TGVuZ3RoXCIsIHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW1haWxcIjpcbiAgICAgICAgICBzd2l0Y2ggKHJlZnMuZW1haWxTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSBcImZvcm1hdDplbWFpbFwiOlxuICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6aWRuLWVtYWlsXCI6XG4gICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaWRuLWVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOlxuICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1haWwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInVyaVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInV1aWRcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInV1aWRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWdleFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBjaGVjay5yZWdleCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjdWlkXCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY3VpZDJcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuY3VpZDIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3RhcnRzV2l0aFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYF4ke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX1gKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbmRzV2l0aFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYCR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfSRgKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZGF0ZS10aW1lXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZGF0ZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZHVyYXRpb25cIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5MZW5ndGhcIiwgdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCIgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSkgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4TGVuZ3RoXCIsIHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5jbHVkZXNcIjoge1xuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImlwXCI6IHtcbiAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NlwiKSB7XG4gICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY0XCIpIHtcbiAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaXB2NlwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjR1cmwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiand0XCI6XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmp3dCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjaWRyXCI6IHtcbiAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NlwiKSB7XG4gICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuaXB2NENpZHIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuaXB2NkNpZHIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZW1vamlcIjpcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1vamkoKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ1bGlkXCI6IHtcbiAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMudWxpZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOiB7XG4gICAgICAgICAgc3dpdGNoIChyZWZzLmJhc2U2NFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlIFwiZm9ybWF0OmJpbmFyeVwiOiB7XG4gICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiYmluYXJ5XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RW5jb2Rpbmc6YmFzZTY0XCI6IHtcbiAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwiY29udGVudEVuY29kaW5nXCIsIFwiYmFzZTY0XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOiB7XG4gICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm5hbm9pZFwiOiB7XG4gICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLm5hbm9pZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvTG93ZXJDYXNlXCI6XG4gICAgICAgIGNhc2UgXCJ0b1VwcGVyQ2FzZVwiOlxuICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgoXykgPT4ge30pKGNoZWNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGVzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGxpdGVyYWwsIHJlZnMpIHtcbiAgcmV0dXJuIHJlZnMucGF0dGVyblN0cmF0ZWd5ID09PSBcImVzY2FwZVwiID8gZXNjYXBlTm9uQWxwaGFOdW1lcmljKGxpdGVyYWwpIDogbGl0ZXJhbDtcbn1cbnZhciBBTFBIQV9OVU1FUklDID0gbmV3IFNldChcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2eHl6MDEyMzQ1Njc4OVwiKTtcbmZ1bmN0aW9uIGVzY2FwZU5vbkFscGhhTnVtZXJpYyhzb3VyY2UpIHtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIUFMUEhBX05VTUVSSUMuaGFzKHNvdXJjZVtpXSkpIHtcbiAgICAgIHJlc3VsdCArPSBcIlxcXFxcIjtcbiAgICB9XG4gICAgcmVzdWx0ICs9IHNvdXJjZVtpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYWRkRm9ybWF0KHNjaGVtYSwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgaWYgKHNjaGVtYS5mb3JtYXQgfHwgc2NoZW1hLmFueU9mPy5zb21lKCh4KSA9PiB4LmZvcm1hdCkpIHtcbiAgICBpZiAoIXNjaGVtYS5hbnlPZikge1xuICAgICAgc2NoZW1hLmFueU9mID0gW107XG4gICAgfVxuICAgIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICBzY2hlbWEuYW55T2YucHVzaCh7XG4gICAgICAgIGZvcm1hdDogc2NoZW1hLmZvcm1hdCxcbiAgICAgICAgLi4uc2NoZW1hLmVycm9yTWVzc2FnZSAmJiByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgIGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IHNjaGVtYS5lcnJvck1lc3NhZ2UuZm9ybWF0IH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgc2NoZW1hLmZvcm1hdDtcbiAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLmZvcm1hdDtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5lcnJvck1lc3NhZ2UpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgIGZvcm1hdDogdmFsdWUsXG4gICAgICAuLi5tZXNzYWdlICYmIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7IGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IG1lc3NhZ2UgfSB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwiZm9ybWF0XCIsIHZhbHVlLCBtZXNzYWdlLCByZWZzKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUGF0dGVybihzY2hlbWEsIHJlZ2V4LCBtZXNzYWdlLCByZWZzKSB7XG4gIGlmIChzY2hlbWEucGF0dGVybiB8fCBzY2hlbWEuYWxsT2Y/LnNvbWUoKHgpID0+IHgucGF0dGVybikpIHtcbiAgICBpZiAoIXNjaGVtYS5hbGxPZikge1xuICAgICAgc2NoZW1hLmFsbE9mID0gW107XG4gICAgfVxuICAgIGlmIChzY2hlbWEucGF0dGVybikge1xuICAgICAgc2NoZW1hLmFsbE9mLnB1c2goe1xuICAgICAgICBwYXR0ZXJuOiBzY2hlbWEucGF0dGVybixcbiAgICAgICAgLi4uc2NoZW1hLmVycm9yTWVzc2FnZSAmJiByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgIGVycm9yTWVzc2FnZTogeyBwYXR0ZXJuOiBzY2hlbWEuZXJyb3JNZXNzYWdlLnBhdHRlcm4gfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBzY2hlbWEucGF0dGVybjtcbiAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLnBhdHRlcm47XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZXJyb3JNZXNzYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICBwYXR0ZXJuOiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpLFxuICAgICAgLi4ubWVzc2FnZSAmJiByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogbWVzc2FnZSB9IH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHNjaGVtYSwgXCJwYXR0ZXJuXCIsIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcyksIG1lc3NhZ2UsIHJlZnMpO1xuICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpIHtcbiAgaWYgKCFyZWZzLmFwcGx5UmVnZXhGbGFncyB8fCAhcmVnZXguZmxhZ3MpIHtcbiAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICB9XG4gIGNvbnN0IGZsYWdzID0ge1xuICAgIGk6IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICBtOiByZWdleC5mbGFncy5pbmNsdWRlcyhcIm1cIiksXG4gICAgczogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJzXCIpXG4gIH07XG4gIGNvbnN0IHNvdXJjZSA9IGZsYWdzLmkgPyByZWdleC5zb3VyY2UudG9Mb3dlckNhc2UoKSA6IHJlZ2V4LnNvdXJjZTtcbiAgbGV0IHBhdHRlcm4gPSBcIlwiO1xuICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG4gIGxldCBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICBsZXQgaW5DaGFyUmFuZ2UgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7aSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc0VzY2FwZWQpIHtcbiAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmkpIHtcbiAgICAgIGlmIChpbkNoYXJHcm91cCkge1xuICAgICAgICBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgaWYgKGluQ2hhclJhbmdlKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2kgLSAyXX0tJHtzb3VyY2VbaV19YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZVtpICsgMV0gPT09IFwiLVwiICYmIHNvdXJjZVtpICsgMl0/Lm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGluQ2hhclJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3VyY2VbaV0ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgcGF0dGVybiArPSBgWyR7c291cmNlW2ldfSR7c291cmNlW2ldLnRvVXBwZXJDYXNlKCl9XWA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmxhZ3MubSkge1xuICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgcGF0dGVybiArPSBgKF58KD88PVtcXHJcbl0pKWA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VbaV0gPT09IFwiJFwiKSB7XG4gICAgICAgIHBhdHRlcm4gKz0gYCgkfCg/PVtcXHJcbl0pKWA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmxhZ3MucyAmJiBzb3VyY2VbaV0gPT09IFwiLlwiKSB7XG4gICAgICBwYXR0ZXJuICs9IGluQ2hhckdyb3VwID8gYCR7c291cmNlW2ldfVxcclxuYCA6IGBbJHtzb3VyY2VbaV19XFxyXG5dYDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICBpZiAoc291cmNlW2ldID09PSBcIlxcXFxcIikge1xuICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJdXCIpIHtcbiAgICAgIGluQ2hhckdyb3VwID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaW5DaGFyR3JvdXAgJiYgc291cmNlW2ldID09PSBcIltcIikge1xuICAgICAgaW5DaGFyR3JvdXAgPSB0cnVlO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIG5ldyBSZWdFeHAocGF0dGVybik7XG4gIH0gY2F0Y2gge1xuICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGNvbnZlcnQgcmVnZXggcGF0dGVybiBhdCAke3JlZnMuY3VycmVudFBhdGguam9pbihcIi9cIil9IHRvIGEgZmxhZy1pbmRlcGVuZGVudCBmb3JtISBGYWxsaW5nIGJhY2sgdG8gdGhlIGZsYWctaWdub3JhbnQgc291cmNlYCk7XG4gICAgcmV0dXJuIHJlZ2V4LnNvdXJjZTtcbiAgfVxuICByZXR1cm4gcGF0dGVybjtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3JlY29yZC5qc1xuZnVuY3Rpb24gcGFyc2VSZWNvcmREZWYoZGVmLCByZWZzKSB7XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQWlcIikge1xuICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IE9wZW5BSSBtYXkgbm90IHN1cHBvcnQgcmVjb3JkcyBpbiBzY2hlbWFzISBUcnkgYW4gYXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiICYmIGRlZi5rZXlUeXBlPy5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcmVxdWlyZWQ6IGRlZi5rZXlUeXBlLl9kZWYudmFsdWVzLFxuICAgICAgcHJvcGVydGllczogZGVmLmtleVR5cGUuX2RlZi52YWx1ZXMucmVkdWNlKChhY2MsIGtleSkgPT4gKHtcbiAgICAgICAgLi4uYWNjLFxuICAgICAgICBba2V5XTogcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwicHJvcGVydGllc1wiLCBrZXldXG4gICAgICAgIH0pID8/IHt9XG4gICAgICB9KSwge30pLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHJlZnMucmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllc1xuICAgIH07XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0ge1xuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHBhcnNlRGVmKGRlZi52YWx1ZVR5cGUuX2RlZiwge1xuICAgICAgLi4ucmVmcyxcbiAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXVxuICAgIH0pID8/IHJlZnMuYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gIH07XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKSB7XG4gICAgcmV0dXJuIHNjaGVtYTtcbiAgfVxuICBpZiAoZGVmLmtleVR5cGU/Ll9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcgJiYgZGVmLmtleVR5cGUuX2RlZi5jaGVja3M/Lmxlbmd0aCkge1xuICAgIGNvbnN0IHsgdHlwZSwgLi4ua2V5VHlwZSB9ID0gcGFyc2VTdHJpbmdEZWYoZGVmLmtleVR5cGUuX2RlZiwgcmVmcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNjaGVtYSxcbiAgICAgIHByb3BlcnR5TmFtZXM6IGtleVR5cGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRlZi5rZXlUeXBlPy5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zY2hlbWEsXG4gICAgICBwcm9wZXJ0eU5hbWVzOiB7XG4gICAgICAgIGVudW06IGRlZi5rZXlUeXBlLl9kZWYudmFsdWVzXG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChkZWYua2V5VHlwZT8uX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQgJiYgZGVmLmtleVR5cGUuX2RlZi50eXBlLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcgJiYgZGVmLmtleVR5cGUuX2RlZi50eXBlLl9kZWYuY2hlY2tzPy5sZW5ndGgpIHtcbiAgICBjb25zdCB7IHR5cGUsIC4uLmtleVR5cGUgfSA9IHBhcnNlQnJhbmRlZERlZihkZWYua2V5VHlwZS5fZGVmLCByZWZzKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc2NoZW1hLFxuICAgICAgcHJvcGVydHlOYW1lczoga2V5VHlwZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL21hcC5qc1xuZnVuY3Rpb24gcGFyc2VNYXBEZWYoZGVmLCByZWZzKSB7XG4gIGlmIChyZWZzLm1hcFN0cmF0ZWd5ID09PSBcInJlY29yZFwiKSB7XG4gICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IHBhcnNlRGVmKGRlZi5rZXlUeXBlLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBcIml0ZW1zXCIsIFwiMFwiXVxuICB9KSB8fCB7fTtcbiAgY29uc3QgdmFsdWVzID0gcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIiwgXCJpdGVtc1wiLCBcIjFcIl1cbiAgfSkgfHwge307XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIG1heEl0ZW1zOiAxMjUsXG4gICAgaXRlbXM6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGl0ZW1zOiBba2V5cywgdmFsdWVzXSxcbiAgICAgIG1pbkl0ZW1zOiAyLFxuICAgICAgbWF4SXRlbXM6IDJcbiAgICB9XG4gIH07XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9uYXRpdmVFbnVtLmpzXG5mdW5jdGlvbiBwYXJzZU5hdGl2ZUVudW1EZWYoZGVmKSB7XG4gIGNvbnN0IG9iamVjdCA9IGRlZi52YWx1ZXM7XG4gIGNvbnN0IGFjdHVhbEtleXMgPSBPYmplY3Qua2V5cyhkZWYudmFsdWVzKS5maWx0ZXIoKGtleSkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0W29iamVjdFtrZXldXSAhPT0gXCJudW1iZXJcIjtcbiAgfSk7XG4gIGNvbnN0IGFjdHVhbFZhbHVlcyA9IGFjdHVhbEtleXMubWFwKChrZXkpID0+IG9iamVjdFtrZXldKTtcbiAgY29uc3QgcGFyc2VkVHlwZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoYWN0dWFsVmFsdWVzLm1hcCgodmFsdWVzKSA9PiB0eXBlb2YgdmFsdWVzKSkpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHBhcnNlZFR5cGVzLmxlbmd0aCA9PT0gMSA/IHBhcnNlZFR5cGVzWzBdID09PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwibnVtYmVyXCIgOiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIl0sXG4gICAgZW51bTogYWN0dWFsVmFsdWVzXG4gIH07XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9uZXZlci5qc1xuZnVuY3Rpb24gcGFyc2VOZXZlckRlZigpIHtcbiAgcmV0dXJuIHtcbiAgICBub3Q6IHt9XG4gIH07XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9udWxsLmpzXG5mdW5jdGlvbiBwYXJzZU51bGxEZWYocmVmcykge1xuICByZXR1cm4gcmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIiA/IHtcbiAgICBlbnVtOiBbXCJudWxsXCJdLFxuICAgIG51bGxhYmxlOiB0cnVlXG4gIH0gOiB7XG4gICAgdHlwZTogXCJudWxsXCJcbiAgfTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3VuaW9uLmpzXG52YXIgcHJpbWl0aXZlTWFwcGluZ3MgPSB7XG4gIFpvZFN0cmluZzogXCJzdHJpbmdcIixcbiAgWm9kTnVtYmVyOiBcIm51bWJlclwiLFxuICBab2RCaWdJbnQ6IFwiaW50ZWdlclwiLFxuICBab2RCb29sZWFuOiBcImJvb2xlYW5cIixcbiAgWm9kTnVsbDogXCJudWxsXCJcbn07XG5mdW5jdGlvbiBwYXJzZVVuaW9uRGVmKGRlZiwgcmVmcykge1xuICBpZiAocmVmcy50YXJnZXQgPT09IFwib3BlbkFwaTNcIilcbiAgICByZXR1cm4gYXNBbnlPZihkZWYsIHJlZnMpO1xuICBjb25zdCBvcHRpb25zID0gZGVmLm9wdGlvbnMgaW5zdGFuY2VvZiBNYXAgPyBBcnJheS5mcm9tKGRlZi5vcHRpb25zLnZhbHVlcygpKSA6IGRlZi5vcHRpb25zO1xuICBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4gKHguX2RlZi50eXBlTmFtZSBpbiBwcmltaXRpdmVNYXBwaW5ncykgJiYgKCF4Ll9kZWYuY2hlY2tzIHx8ICF4Ll9kZWYuY2hlY2tzLmxlbmd0aCkpKSB7XG4gICAgY29uc3QgdHlwZXMyID0gb3B0aW9ucy5yZWR1Y2UoKHR5cGVzMywgeCkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IHByaW1pdGl2ZU1hcHBpbmdzW3guX2RlZi50eXBlTmFtZV07XG4gICAgICByZXR1cm4gdHlwZSAmJiAhdHlwZXMzLmluY2x1ZGVzKHR5cGUpID8gWy4uLnR5cGVzMywgdHlwZV0gOiB0eXBlczM7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlczIubGVuZ3RoID4gMSA/IHR5cGVzMiA6IHR5cGVzMlswXVxuICAgIH07XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5ldmVyeSgoeCkgPT4geC5fZGVmLnR5cGVOYW1lID09PSBcIlpvZExpdGVyYWxcIiAmJiAheC5kZXNjcmlwdGlvbikpIHtcbiAgICBjb25zdCB0eXBlczIgPSBvcHRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gdHlwZW9mIHguX2RlZi52YWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICByZXR1cm4gWy4uLmFjYywgdHlwZV07XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICByZXR1cm4gWy4uLmFjYywgXCJpbnRlZ2VyXCJdO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgaWYgKHguX2RlZi52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBbLi4uYWNjLCBcIm51bGxcIl07XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBpZiAodHlwZXMyLmxlbmd0aCA9PT0gb3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZVR5cGVzID0gdHlwZXMyLmZpbHRlcigoeCwgaSwgYSkgPT4gYS5pbmRleE9mKHgpID09PSBpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHVuaXF1ZVR5cGVzLmxlbmd0aCA+IDEgPyB1bmlxdWVUeXBlcyA6IHVuaXF1ZVR5cGVzWzBdLFxuICAgICAgICBlbnVtOiBvcHRpb25zLnJlZHVjZSgoYWNjLCB4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGFjYy5pbmNsdWRlcyh4Ll9kZWYudmFsdWUpID8gYWNjIDogWy4uLmFjYywgeC5fZGVmLnZhbHVlXTtcbiAgICAgICAgfSwgW10pXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChvcHRpb25zLmV2ZXJ5KCh4KSA9PiB4Ll9kZWYudHlwZU5hbWUgPT09IFwiWm9kRW51bVwiKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZW51bTogb3B0aW9ucy5yZWR1Y2UoKGFjYywgeCkgPT4gW1xuICAgICAgICAuLi5hY2MsXG4gICAgICAgIC4uLnguX2RlZi52YWx1ZXMuZmlsdGVyKCh4MikgPT4gIWFjYy5pbmNsdWRlcyh4MikpXG4gICAgICBdLCBbXSlcbiAgICB9O1xuICB9XG4gIHJldHVybiBhc0FueU9mKGRlZiwgcmVmcyk7XG59XG52YXIgYXNBbnlPZiA9IChkZWYsIHJlZnMpID0+IHtcbiAgY29uc3QgYW55T2YgPSAoZGVmLm9wdGlvbnMgaW5zdGFuY2VvZiBNYXAgPyBBcnJheS5mcm9tKGRlZi5vcHRpb25zLnZhbHVlcygpKSA6IGRlZi5vcHRpb25zKS5tYXAoKHgsIGkpID0+IHBhcnNlRGVmKHguX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFueU9mXCIsIGAke2l9YF1cbiAgfSkpLmZpbHRlcigoeCkgPT4gISF4ICYmICghcmVmcy5zdHJpY3RVbmlvbnMgfHwgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoeCkubGVuZ3RoID4gMCkpO1xuICByZXR1cm4gYW55T2YubGVuZ3RoID8geyBhbnlPZiB9IDogdW5kZWZpbmVkO1xufTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL251bGxhYmxlLmpzXG5mdW5jdGlvbiBwYXJzZU51bGxhYmxlRGVmKGRlZiwgcmVmcykge1xuICBpZiAoW1wiWm9kU3RyaW5nXCIsIFwiWm9kTnVtYmVyXCIsIFwiWm9kQmlnSW50XCIsIFwiWm9kQm9vbGVhblwiLCBcIlpvZE51bGxcIl0uaW5jbHVkZXMoZGVmLmlubmVyVHlwZS5fZGVmLnR5cGVOYW1lKSAmJiAoIWRlZi5pbm5lclR5cGUuX2RlZi5jaGVja3MgfHwgIWRlZi5pbm5lclR5cGUuX2RlZi5jaGVja3MubGVuZ3RoKSkge1xuICAgIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBwcmltaXRpdmVNYXBwaW5nc1tkZWYuaW5uZXJUeXBlLl9kZWYudHlwZU5hbWVdLFxuICAgICAgICBudWxsYWJsZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFtcbiAgICAgICAgcHJpbWl0aXZlTWFwcGluZ3NbZGVmLmlubmVyVHlwZS5fZGVmLnR5cGVOYW1lXSxcbiAgICAgICAgXCJudWxsXCJcbiAgICAgIF1cbiAgICB9O1xuICB9XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQXBpM1wiKSB7XG4gICAgY29uc3QgYmFzZTIgPSBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGhdXG4gICAgfSk7XG4gICAgaWYgKGJhc2UyICYmIFwiJHJlZlwiIGluIGJhc2UyKVxuICAgICAgcmV0dXJuIHsgYWxsT2Y6IFtiYXNlMl0sIG51bGxhYmxlOiB0cnVlIH07XG4gICAgcmV0dXJuIGJhc2UyICYmIHsgLi4uYmFzZTIsIG51bGxhYmxlOiB0cnVlIH07XG4gIH1cbiAgY29uc3QgYmFzZSA9IHBhcnNlRGVmKGRlZi5pbm5lclR5cGUuX2RlZiwge1xuICAgIC4uLnJlZnMsXG4gICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFueU9mXCIsIFwiMFwiXVxuICB9KTtcbiAgcmV0dXJuIGJhc2UgJiYgeyBhbnlPZjogW2Jhc2UsIHsgdHlwZTogXCJudWxsXCIgfV0gfTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL251bWJlci5qc1xuZnVuY3Rpb24gcGFyc2VOdW1iZXJEZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IHJlcyA9IHtcbiAgICB0eXBlOiBcIm51bWJlclwiXG4gIH07XG4gIGlmICghZGVmLmNoZWNrcylcbiAgICByZXR1cm4gcmVzO1xuICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJpbnRcIjpcbiAgICAgICAgcmVzLnR5cGUgPSBcImludGVnZXJcIjtcbiAgICAgICAgYWRkRXJyb3JNZXNzYWdlKHJlcywgXCJ0eXBlXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgaWYgKHJlZnMudGFyZ2V0ID09PSBcImpzb25TY2hlbWE3XCIpIHtcbiAgICAgICAgICBpZiAoY2hlY2suaW5jbHVzaXZlKSB7XG4gICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5pbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwiZXhjbHVzaXZlTWluaW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2hlY2suaW5jbHVzaXZlKSB7XG4gICAgICAgICAgICByZXMuZXhjbHVzaXZlTWluaW11bSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbmltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICBpZiAocmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTdcIikge1xuICAgICAgICAgIGlmIChjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heGltdW1cIiwgY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJleGNsdXNpdmVNYXhpbXVtXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjaGVjay5pbmNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJlcy5leGNsdXNpdmVNYXhpbXVtID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4aW11bVwiLCBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibXVsdGlwbGVPZlwiOlxuICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtdWx0aXBsZU9mXCIsIGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9vYmplY3QuanNcbmZ1bmN0aW9uIHBhcnNlT2JqZWN0RGVmKGRlZiwgcmVmcykge1xuICBjb25zdCBmb3JjZU9wdGlvbmFsSW50b051bGxhYmxlID0gcmVmcy50YXJnZXQgPT09IFwib3BlbkFpXCI7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHByb3BlcnRpZXM6IHt9XG4gIH07XG4gIGNvbnN0IHJlcXVpcmVkID0gW107XG4gIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlKCk7XG4gIGZvciAoY29uc3QgcHJvcE5hbWUgaW4gc2hhcGUpIHtcbiAgICBsZXQgcHJvcERlZiA9IHNoYXBlW3Byb3BOYW1lXTtcbiAgICBpZiAocHJvcERlZiA9PT0gdW5kZWZpbmVkIHx8IHByb3BEZWYuX2RlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHByb3BPcHRpb25hbCA9IHNhZmVJc09wdGlvbmFsKHByb3BEZWYpO1xuICAgIGlmIChwcm9wT3B0aW9uYWwgJiYgZm9yY2VPcHRpb25hbEludG9OdWxsYWJsZSkge1xuICAgICAgaWYgKHByb3BEZWYgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICBwcm9wRGVmID0gcHJvcERlZi5fZGVmLmlubmVyVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcERlZi5pc051bGxhYmxlKCkpIHtcbiAgICAgICAgcHJvcERlZiA9IHByb3BEZWYubnVsbGFibGUoKTtcbiAgICAgIH1cbiAgICAgIHByb3BPcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWREZWYgPSBwYXJzZURlZihwcm9wRGVmLl9kZWYsIHtcbiAgICAgIC4uLnJlZnMsXG4gICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwicHJvcGVydGllc1wiLCBwcm9wTmFtZV0sXG4gICAgICBwcm9wZXJ0eVBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcInByb3BlcnRpZXNcIiwgcHJvcE5hbWVdXG4gICAgfSk7XG4gICAgaWYgKHBhcnNlZERlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcGFyc2VkRGVmO1xuICAgIGlmICghcHJvcE9wdGlvbmFsKSB7XG4gICAgICByZXF1aXJlZC5wdXNoKHByb3BOYW1lKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcXVpcmVkLmxlbmd0aCkge1xuICAgIHJlc3VsdC5yZXF1aXJlZCA9IHJlcXVpcmVkO1xuICB9XG4gIGNvbnN0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZGVjaWRlQWRkaXRpb25hbFByb3BlcnRpZXMoZGVmLCByZWZzKTtcbiAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXN1bHQuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVjaWRlQWRkaXRpb25hbFByb3BlcnRpZXMoZGVmLCByZWZzKSB7XG4gIGlmIChkZWYuY2F0Y2hhbGwuX2RlZi50eXBlTmFtZSAhPT0gXCJab2ROZXZlclwiKSB7XG4gICAgcmV0dXJuIHBhcnNlRGVmKGRlZi5jYXRjaGFsbC5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdXG4gICAgfSk7XG4gIH1cbiAgc3dpdGNoIChkZWYudW5rbm93bktleXMpIHtcbiAgICBjYXNlIFwicGFzc3Rocm91Z2hcIjpcbiAgICAgIHJldHVybiByZWZzLmFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICBjYXNlIFwic3RyaWN0XCI6XG4gICAgICByZXR1cm4gcmVmcy5yZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzO1xuICAgIGNhc2UgXCJzdHJpcFwiOlxuICAgICAgcmV0dXJuIHJlZnMucmVtb3ZlQWRkaXRpb25hbFN0cmF0ZWd5ID09PSBcInN0cmljdFwiID8gcmVmcy5hbGxvd2VkQWRkaXRpb25hbFByb3BlcnRpZXMgOiByZWZzLnJlamVjdGVkQWRkaXRpb25hbFByb3BlcnRpZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVJc09wdGlvbmFsKHNjaGVtYSkge1xuICB0cnkge1xuICAgIHJldHVybiBzY2hlbWEuaXNPcHRpb25hbCgpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvb3B0aW9uYWwuanNcbnZhciBwYXJzZU9wdGlvbmFsRGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICBpZiAocmVmcy5jdXJyZW50UGF0aC50b1N0cmluZygpID09PSByZWZzLnByb3BlcnR5UGF0aD8udG9TdHJpbmcoKSkge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYuaW5uZXJUeXBlLl9kZWYsIHJlZnMpO1xuICB9XG4gIGNvbnN0IGlubmVyU2NoZW1hID0gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYW55T2ZcIiwgXCIxXCJdXG4gIH0pO1xuICByZXR1cm4gaW5uZXJTY2hlbWEgPyB7XG4gICAgYW55T2Y6IFtcbiAgICAgIHtcbiAgICAgICAgbm90OiB7fVxuICAgICAgfSxcbiAgICAgIGlubmVyU2NoZW1hXG4gICAgXVxuICB9IDoge307XG59O1xuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvcGlwZWxpbmUuanNcbnZhciBwYXJzZVBpcGVsaW5lRGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICBpZiAocmVmcy5waXBlU3RyYXRlZ3kgPT09IFwiaW5wdXRcIikge1xuICAgIHJldHVybiBwYXJzZURlZihkZWYuaW4uX2RlZiwgcmVmcyk7XG4gIH0gZWxzZSBpZiAocmVmcy5waXBlU3RyYXRlZ3kgPT09IFwib3V0cHV0XCIpIHtcbiAgICByZXR1cm4gcGFyc2VEZWYoZGVmLm91dC5fZGVmLCByZWZzKTtcbiAgfVxuICBjb25zdCBhID0gcGFyc2VEZWYoZGVmLmluLl9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbGxPZlwiLCBcIjBcIl1cbiAgfSk7XG4gIGNvbnN0IGIgPSBwYXJzZURlZihkZWYub3V0Ll9kZWYsIHtcbiAgICAuLi5yZWZzLFxuICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJhbGxPZlwiLCBhID8gXCIxXCIgOiBcIjBcIl1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYWxsT2Y6IFthLCBiXS5maWx0ZXIoKHgpID0+IHggIT09IHVuZGVmaW5lZClcbiAgfTtcbn07XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy9wcm9taXNlLmpzXG5mdW5jdGlvbiBwYXJzZVByb21pc2VEZWYoZGVmLCByZWZzKSB7XG4gIHJldHVybiBwYXJzZURlZihkZWYudHlwZS5fZGVmLCByZWZzKTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3NldC5qc1xuZnVuY3Rpb24gcGFyc2VTZXREZWYoZGVmLCByZWZzKSB7XG4gIGNvbnN0IGl0ZW1zID0gcGFyc2VEZWYoZGVmLnZhbHVlVHlwZS5fZGVmLCB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiaXRlbXNcIl1cbiAgfSk7XG4gIGNvbnN0IHNjaGVtYSA9IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdW5pcXVlSXRlbXM6IHRydWUsXG4gICAgaXRlbXNcbiAgfTtcbiAgaWYgKGRlZi5taW5TaXplKSB7XG4gICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwibWluSXRlbXNcIiwgZGVmLm1pblNpemUudmFsdWUsIGRlZi5taW5TaXplLm1lc3NhZ2UsIHJlZnMpO1xuICB9XG4gIGlmIChkZWYubWF4U2l6ZSkge1xuICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMoc2NoZW1hLCBcIm1heEl0ZW1zXCIsIGRlZi5tYXhTaXplLnZhbHVlLCBkZWYubWF4U2l6ZS5tZXNzYWdlLCByZWZzKTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvdHVwbGUuanNcbmZ1bmN0aW9uIHBhcnNlVHVwbGVEZWYoZGVmLCByZWZzKSB7XG4gIGlmIChkZWYucmVzdCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBtaW5JdGVtczogZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgIGl0ZW1zOiBkZWYuaXRlbXMubWFwKCh4LCBpKSA9PiBwYXJzZURlZih4Ll9kZWYsIHtcbiAgICAgICAgLi4ucmVmcyxcbiAgICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmN1cnJlbnRQYXRoLCBcIml0ZW1zXCIsIGAke2l9YF1cbiAgICAgIH0pKS5yZWR1Y2UoKGFjYywgeCkgPT4geCA9PT0gdW5kZWZpbmVkID8gYWNjIDogWy4uLmFjYywgeF0sIFtdKSxcbiAgICAgIGFkZGl0aW9uYWxJdGVtczogcGFyc2VEZWYoZGVmLnJlc3QuX2RlZiwge1xuICAgICAgICAuLi5yZWZzLFxuICAgICAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuY3VycmVudFBhdGgsIFwiYWRkaXRpb25hbEl0ZW1zXCJdXG4gICAgICB9KVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIG1pbkl0ZW1zOiBkZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgbWF4SXRlbXM6IGRlZi5pdGVtcy5sZW5ndGgsXG4gICAgICBpdGVtczogZGVmLml0ZW1zLm1hcCgoeCwgaSkgPT4gcGFyc2VEZWYoeC5fZGVmLCB7XG4gICAgICAgIC4uLnJlZnMsXG4gICAgICAgIGN1cnJlbnRQYXRoOiBbLi4ucmVmcy5jdXJyZW50UGF0aCwgXCJpdGVtc1wiLCBgJHtpfWBdXG4gICAgICB9KSkucmVkdWNlKChhY2MsIHgpID0+IHggPT09IHVuZGVmaW5lZCA/IGFjYyA6IFsuLi5hY2MsIHhdLCBbXSlcbiAgICB9O1xuICB9XG59XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vcGFyc2Vycy91bmRlZmluZWQuanNcbmZ1bmN0aW9uIHBhcnNlVW5kZWZpbmVkRGVmKCkge1xuICByZXR1cm4ge1xuICAgIG5vdDoge31cbiAgfTtcbn1cblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3Vua25vd24uanNcbmZ1bmN0aW9uIHBhcnNlVW5rbm93bkRlZigpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvem9kLXRvLWpzb24tc2NoZW1hL2Rpc3QvZXNtL3BhcnNlcnMvcmVhZG9ubHkuanNcbnZhciBwYXJzZVJlYWRvbmx5RGVmID0gKGRlZiwgcmVmcykgPT4ge1xuICByZXR1cm4gcGFyc2VEZWYoZGVmLmlubmVyVHlwZS5fZGVmLCByZWZzKTtcbn07XG5cbi8vIC4uL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vc2VsZWN0UGFyc2VyLmpzXG52YXIgc2VsZWN0UGFyc2VyID0gKGRlZiwgdHlwZU5hbWUsIHJlZnMpID0+IHtcbiAgc3dpdGNoICh0eXBlTmFtZSkge1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZzpcbiAgICAgIHJldHVybiBwYXJzZVN0cmluZ0RlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcjpcbiAgICAgIHJldHVybiBwYXJzZU51bWJlckRlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdDpcbiAgICAgIHJldHVybiBwYXJzZU9iamVjdERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludDpcbiAgICAgIHJldHVybiBwYXJzZUJpZ2ludERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW46XG4gICAgICByZXR1cm4gcGFyc2VCb29sZWFuRGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZTpcbiAgICAgIHJldHVybiBwYXJzZURhdGVEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQ6XG4gICAgICByZXR1cm4gcGFyc2VVbmRlZmluZWREZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsOlxuICAgICAgcmV0dXJuIHBhcnNlTnVsbERlZihyZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheTpcbiAgICAgIHJldHVybiBwYXJzZUFycmF5RGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb246XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uOlxuICAgICAgcmV0dXJuIHBhcnNlVW5pb25EZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb246XG4gICAgICByZXR1cm4gcGFyc2VJbnRlcnNlY3Rpb25EZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZTpcbiAgICAgIHJldHVybiBwYXJzZVR1cGxlRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkOlxuICAgICAgcmV0dXJuIHBhcnNlUmVjb3JkRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbDpcbiAgICAgIHJldHVybiBwYXJzZUxpdGVyYWxEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtOlxuICAgICAgcmV0dXJuIHBhcnNlRW51bURlZihkZWYpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW06XG4gICAgICByZXR1cm4gcGFyc2VOYXRpdmVFbnVtRGVmKGRlZik7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGU6XG4gICAgICByZXR1cm4gcGFyc2VOdWxsYWJsZURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsOlxuICAgICAgcmV0dXJuIHBhcnNlT3B0aW9uYWxEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXA6XG4gICAgICByZXR1cm4gcGFyc2VNYXBEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQ6XG4gICAgICByZXR1cm4gcGFyc2VTZXREZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5OlxuICAgICAgcmV0dXJuICgpID0+IGRlZi5nZXR0ZXIoKS5fZGVmO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2U6XG4gICAgICByZXR1cm4gcGFyc2VQcm9taXNlRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOOlxuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyOlxuICAgICAgcmV0dXJuIHBhcnNlTmV2ZXJEZWYoKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzOlxuICAgICAgcmV0dXJuIHBhcnNlRWZmZWN0c0RlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueTpcbiAgICAgIHJldHVybiBwYXJzZUFueURlZigpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd246XG4gICAgICByZXR1cm4gcGFyc2VVbmtub3duRGVmKCk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdDpcbiAgICAgIHJldHVybiBwYXJzZURlZmF1bHREZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkOlxuICAgICAgcmV0dXJuIHBhcnNlQnJhbmRlZERlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5OlxuICAgICAgcmV0dXJuIHBhcnNlUmVhZG9ubHlEZWYoZGVmLCByZWZzKTtcbiAgICBjYXNlIFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaDpcbiAgICAgIHJldHVybiBwYXJzZUNhdGNoRGVmKGRlZiwgcmVmcyk7XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmU6XG4gICAgICByZXR1cm4gcGFyc2VQaXBlbGluZURlZihkZWYsIHJlZnMpO1xuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uOlxuICAgIGNhc2UgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQ6XG4gICAgY2FzZSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sOlxuICAgICAgcmV0dXJuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKChfKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0pKHR5cGVOYW1lKTtcbiAgfVxufTtcblxuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZURlZi5qc1xuZnVuY3Rpb24gcGFyc2VEZWYoZGVmLCByZWZzLCBmb3JjZVJlc29sdXRpb24gPSBmYWxzZSkge1xuICBjb25zdCBzZWVuSXRlbSA9IHJlZnMuc2Vlbi5nZXQoZGVmKTtcbiAgaWYgKHJlZnMub3ZlcnJpZGUpIHtcbiAgICBjb25zdCBvdmVycmlkZVJlc3VsdCA9IHJlZnMub3ZlcnJpZGU/LihkZWYsIHJlZnMsIHNlZW5JdGVtLCBmb3JjZVJlc29sdXRpb24pO1xuICAgIGlmIChvdmVycmlkZVJlc3VsdCAhPT0gaWdub3JlT3ZlcnJpZGUpIHtcbiAgICAgIHJldHVybiBvdmVycmlkZVJlc3VsdDtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZW5JdGVtICYmICFmb3JjZVJlc29sdXRpb24pIHtcbiAgICBjb25zdCBzZWVuU2NoZW1hID0gZ2V0JHJlZihzZWVuSXRlbSwgcmVmcyk7XG4gICAgaWYgKHNlZW5TY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHNlZW5TY2hlbWE7XG4gICAgfVxuICB9XG4gIGNvbnN0IG5ld0l0ZW0gPSB7IGRlZiwgcGF0aDogcmVmcy5jdXJyZW50UGF0aCwganNvblNjaGVtYTogdW5kZWZpbmVkIH07XG4gIHJlZnMuc2Vlbi5zZXQoZGVmLCBuZXdJdGVtKTtcbiAgY29uc3QganNvblNjaGVtYU9yR2V0dGVyID0gc2VsZWN0UGFyc2VyKGRlZiwgZGVmLnR5cGVOYW1lLCByZWZzKTtcbiAgY29uc3QganNvblNjaGVtYSA9IHR5cGVvZiBqc29uU2NoZW1hT3JHZXR0ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHBhcnNlRGVmKGpzb25TY2hlbWFPckdldHRlcigpLCByZWZzKSA6IGpzb25TY2hlbWFPckdldHRlcjtcbiAgaWYgKGpzb25TY2hlbWEpIHtcbiAgICBhZGRNZXRhKGRlZiwgcmVmcywganNvblNjaGVtYSk7XG4gIH1cbiAgaWYgKHJlZnMucG9zdFByb2Nlc3MpIHtcbiAgICBjb25zdCBwb3N0UHJvY2Vzc1Jlc3VsdCA9IHJlZnMucG9zdFByb2Nlc3MoanNvblNjaGVtYSwgZGVmLCByZWZzKTtcbiAgICBuZXdJdGVtLmpzb25TY2hlbWEgPSBqc29uU2NoZW1hO1xuICAgIHJldHVybiBwb3N0UHJvY2Vzc1Jlc3VsdDtcbiAgfVxuICBuZXdJdGVtLmpzb25TY2hlbWEgPSBqc29uU2NoZW1hO1xuICByZXR1cm4ganNvblNjaGVtYTtcbn1cbnZhciBnZXQkcmVmID0gKGl0ZW0sIHJlZnMpID0+IHtcbiAgc3dpdGNoIChyZWZzLiRyZWZTdHJhdGVneSkge1xuICAgIGNhc2UgXCJyb290XCI6XG4gICAgICByZXR1cm4geyAkcmVmOiBpdGVtLnBhdGguam9pbihcIi9cIikgfTtcbiAgICBjYXNlIFwicmVsYXRpdmVcIjpcbiAgICAgIHJldHVybiB7ICRyZWY6IGdldFJlbGF0aXZlUGF0aChyZWZzLmN1cnJlbnRQYXRoLCBpdGVtLnBhdGgpIH07XG4gICAgY2FzZSBcIm5vbmVcIjpcbiAgICBjYXNlIFwic2VlblwiOiB7XG4gICAgICBpZiAoaXRlbS5wYXRoLmxlbmd0aCA8IHJlZnMuY3VycmVudFBhdGgubGVuZ3RoICYmIGl0ZW0ucGF0aC5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiByZWZzLmN1cnJlbnRQYXRoW2luZGV4XSA9PT0gdmFsdWUpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgUmVjdXJzaXZlIHJlZmVyZW5jZSBkZXRlY3RlZCBhdCAke3JlZnMuY3VycmVudFBhdGguam9pbihcIi9cIil9ISBEZWZhdWx0aW5nIHRvIGFueWApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmcy4kcmVmU3RyYXRlZ3kgPT09IFwic2VlblwiID8ge30gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59O1xudmFyIGdldFJlbGF0aXZlUGF0aCA9IChwYXRoQSwgcGF0aEIpID0+IHtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKDtpIDwgcGF0aEEubGVuZ3RoICYmIGkgPCBwYXRoQi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXRoQVtpXSAhPT0gcGF0aEJbaV0pXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gWyhwYXRoQS5sZW5ndGggLSBpKS50b1N0cmluZygpLCAuLi5wYXRoQi5zbGljZShpKV0uam9pbihcIi9cIik7XG59O1xudmFyIGFkZE1ldGEgPSAoZGVmLCByZWZzLCBqc29uU2NoZW1hKSA9PiB7XG4gIGlmIChkZWYuZGVzY3JpcHRpb24pIHtcbiAgICBqc29uU2NoZW1hLmRlc2NyaXB0aW9uID0gZGVmLmRlc2NyaXB0aW9uO1xuICAgIGlmIChyZWZzLm1hcmtkb3duRGVzY3JpcHRpb24pIHtcbiAgICAgIGpzb25TY2hlbWEubWFya2Rvd25EZXNjcmlwdGlvbiA9IGRlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGpzb25TY2hlbWE7XG59O1xuLy8gLi4vbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS96b2RUb0pzb25TY2hlbWEuanNcbnZhciB6b2RUb0pzb25TY2hlbWEgPSAoc2NoZW1hLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHJlZnMgPSBnZXRSZWZzKG9wdGlvbnMpO1xuICBjb25zdCBkZWZpbml0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuZGVmaW5pdGlvbnMgPyBPYmplY3QuZW50cmllcyhvcHRpb25zLmRlZmluaXRpb25zKS5yZWR1Y2UoKGFjYywgW25hbWUyLCBzY2hlbWEyXSkgPT4gKHtcbiAgICAuLi5hY2MsXG4gICAgW25hbWUyXTogcGFyc2VEZWYoc2NoZW1hMi5fZGVmLCB7XG4gICAgICAuLi5yZWZzLFxuICAgICAgY3VycmVudFBhdGg6IFsuLi5yZWZzLmJhc2VQYXRoLCByZWZzLmRlZmluaXRpb25QYXRoLCBuYW1lMl1cbiAgICB9LCB0cnVlKSA/PyB7fVxuICB9KSwge30pIDogdW5kZWZpbmVkO1xuICBjb25zdCBuYW1lID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyBvcHRpb25zIDogb3B0aW9ucz8ubmFtZVN0cmF0ZWd5ID09PSBcInRpdGxlXCIgPyB1bmRlZmluZWQgOiBvcHRpb25zPy5uYW1lO1xuICBjb25zdCBtYWluID0gcGFyc2VEZWYoc2NoZW1hLl9kZWYsIG5hbWUgPT09IHVuZGVmaW5lZCA/IHJlZnMgOiB7XG4gICAgLi4ucmVmcyxcbiAgICBjdXJyZW50UGF0aDogWy4uLnJlZnMuYmFzZVBhdGgsIHJlZnMuZGVmaW5pdGlvblBhdGgsIG5hbWVdXG4gIH0sIGZhbHNlKSA/PyB7fTtcbiAgY29uc3QgdGl0bGUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm5hbWVTdHJhdGVneSA9PT0gXCJ0aXRsZVwiID8gb3B0aW9ucy5uYW1lIDogdW5kZWZpbmVkO1xuICBpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1haW4udGl0bGUgPSB0aXRsZTtcbiAgfVxuICBjb25zdCBjb21iaW5lZCA9IG5hbWUgPT09IHVuZGVmaW5lZCA/IGRlZmluaXRpb25zID8ge1xuICAgIC4uLm1haW4sXG4gICAgW3JlZnMuZGVmaW5pdGlvblBhdGhdOiBkZWZpbml0aW9uc1xuICB9IDogbWFpbiA6IHtcbiAgICAkcmVmOiBbXG4gICAgICAuLi5yZWZzLiRyZWZTdHJhdGVneSA9PT0gXCJyZWxhdGl2ZVwiID8gW10gOiByZWZzLmJhc2VQYXRoLFxuICAgICAgcmVmcy5kZWZpbml0aW9uUGF0aCxcbiAgICAgIG5hbWVcbiAgICBdLmpvaW4oXCIvXCIpLFxuICAgIFtyZWZzLmRlZmluaXRpb25QYXRoXToge1xuICAgICAgLi4uZGVmaW5pdGlvbnMsXG4gICAgICBbbmFtZV06IG1haW5cbiAgICB9XG4gIH07XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJqc29uU2NoZW1hN1wiKSB7XG4gICAgY29tYmluZWQuJHNjaGVtYSA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCI7XG4gIH0gZWxzZSBpZiAocmVmcy50YXJnZXQgPT09IFwianNvblNjaGVtYTIwMTktMDlcIiB8fCByZWZzLnRhcmdldCA9PT0gXCJvcGVuQWlcIikge1xuICAgIGNvbWJpbmVkLiRzY2hlbWEgPSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMTktMDkvc2NoZW1hI1wiO1xuICB9XG4gIGlmIChyZWZzLnRhcmdldCA9PT0gXCJvcGVuQWlcIiAmJiAoKFwiYW55T2ZcIiBpbiBjb21iaW5lZCkgfHwgKFwib25lT2ZcIiBpbiBjb21iaW5lZCkgfHwgKFwiYWxsT2ZcIiBpbiBjb21iaW5lZCkgfHwgKFwidHlwZVwiIGluIGNvbWJpbmVkKSAmJiBBcnJheS5pc0FycmF5KGNvbWJpbmVkLnR5cGUpKSkge1xuICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IE9wZW5BSSBtYXkgbm90IHN1cHBvcnQgc2NoZW1hcyB3aXRoIHVuaW9ucyBhcyByb290cyEgVHJ5IHdyYXBwaW5nIGl0IGluIGFuIG9iamVjdCBwcm9wZXJ0eS5cIik7XG4gIH1cbiAgcmV0dXJuIGNvbWJpbmVkO1xufTtcbi8vIC4uL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL2Rpc3QvZXNtL3NlcnZlci9jb21wbGV0YWJsZS5qc1xudmFyIE1jcFpvZFR5cGVLaW5kO1xuKGZ1bmN0aW9uKE1jcFpvZFR5cGVLaW5kMikge1xuICBNY3Bab2RUeXBlS2luZDJbXCJDb21wbGV0YWJsZVwiXSA9IFwiTWNwQ29tcGxldGFibGVcIjtcbn0pKE1jcFpvZFR5cGVLaW5kIHx8IChNY3Bab2RUeXBlS2luZCA9IHt9KSk7XG5cbmNsYXNzIENvbXBsZXRhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgIHBhcmVudDogY3R4XG4gICAgfSk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxufVxuQ29tcGxldGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IENvbXBsZXRhYmxlKHtcbiAgICB0eXBlLFxuICAgIHR5cGVOYW1lOiBNY3Bab2RUeXBlS2luZC5Db21wbGV0YWJsZSxcbiAgICBjb21wbGV0ZTogcGFyYW1zLmNvbXBsZXRlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMyKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtczIocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICB9XG4gIGlmIChlcnJvck1hcDIpXG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgZGVzY3JpcHRpb24gfTtcbiAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB1bmRlZmluZWQgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB1bmRlZmluZWQgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdW5kZWZpbmVkID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHVuZGVmaW5lZCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9O1xuICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuXG4vLyAuLi9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9kaXN0L2VzbS9zZXJ2ZXIvbWNwLmpzXG5jbGFzcyBNY3BTZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2ZXJJbmZvLCBvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlcyA9IHt9O1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlcyA9IHt9O1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRUb29scyA9IHt9O1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRQcm9tcHRzID0ge307XG4gICAgdGhpcy5fdG9vbEhhbmRsZXJzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jb21wbGV0aW9uSGFuZGxlckluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVzb3VyY2VIYW5kbGVyc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvbXB0SGFuZGxlcnNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuc2VydmVyID0gbmV3IFNlcnZlcihzZXJ2ZXJJbmZvLCBvcHRpb25zKTtcbiAgfVxuICBhc3luYyBjb25uZWN0KHRyYW5zcG9ydCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlcnZlci5jb25uZWN0KHRyYW5zcG9ydCk7XG4gIH1cbiAgYXN5bmMgY2xvc2UoKSB7XG4gICAgYXdhaXQgdGhpcy5zZXJ2ZXIuY2xvc2UoKTtcbiAgfVxuICBzZXRUb29sUmVxdWVzdEhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl90b29sSGFuZGxlcnNJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlcnZlci5hc3NlcnRDYW5TZXRSZXF1ZXN0SGFuZGxlcihMaXN0VG9vbHNSZXF1ZXN0U2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSk7XG4gICAgdGhpcy5zZXJ2ZXIuYXNzZXJ0Q2FuU2V0UmVxdWVzdEhhbmRsZXIoQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSk7XG4gICAgdGhpcy5zZXJ2ZXIucmVnaXN0ZXJDYXBhYmlsaXRpZXMoe1xuICAgICAgdG9vbHM6IHtcbiAgICAgICAgbGlzdENoYW5nZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihMaXN0VG9vbHNSZXF1ZXN0U2NoZW1hLCAoKSA9PiAoe1xuICAgICAgdG9vbHM6IE9iamVjdC5lbnRyaWVzKHRoaXMuX3JlZ2lzdGVyZWRUb29scykuZmlsdGVyKChbLCB0b29sXSkgPT4gdG9vbC5lbmFibGVkKS5tYXAoKFtuYW1lLCB0b29sXSkgPT4ge1xuICAgICAgICBjb25zdCB0b29sRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRpdGxlOiB0b29sLnRpdGxlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB0b29sLmlucHV0U2NoZW1hID8gem9kVG9Kc29uU2NoZW1hKHRvb2wuaW5wdXRTY2hlbWEsIHtcbiAgICAgICAgICAgIHN0cmljdFVuaW9uczogdHJ1ZVxuICAgICAgICAgIH0pIDogRU1QVFlfT0JKRUNUX0pTT05fU0NIRU1BLFxuICAgICAgICAgIGFubm90YXRpb25zOiB0b29sLmFubm90YXRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0b29sLm91dHB1dFNjaGVtYSkge1xuICAgICAgICAgIHRvb2xEZWZpbml0aW9uLm91dHB1dFNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYSh0b29sLm91dHB1dFNjaGVtYSwgeyBzdHJpY3RVbmlvbnM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2xEZWZpbml0aW9uO1xuICAgICAgfSlcbiAgICB9KSk7XG4gICAgdGhpcy5zZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLCBhc3luYyAocmVxdWVzdCwgZXh0cmEpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wgPSB0aGlzLl9yZWdpc3RlcmVkVG9vbHNbcmVxdWVzdC5wYXJhbXMubmFtZV07XG4gICAgICBpZiAoIXRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgVG9vbCAke3JlcXVlc3QucGFyYW1zLm5hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgaWYgKCF0b29sLmVuYWJsZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgVG9vbCAke3JlcXVlc3QucGFyYW1zLm5hbWV9IGRpc2FibGVkYCk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0O1xuICAgICAgaWYgKHRvb2wuaW5wdXRTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCB0b29sLmlucHV0U2NoZW1hLnNhZmVQYXJzZUFzeW5jKHJlcXVlc3QucGFyYW1zLmFyZ3VtZW50cyk7XG4gICAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYEludmFsaWQgYXJndW1lbnRzIGZvciB0b29sICR7cmVxdWVzdC5wYXJhbXMubmFtZX06ICR7cGFyc2VSZXN1bHQuZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gcGFyc2VSZXN1bHQuZGF0YTtcbiAgICAgICAgY29uc3QgY2IgPSB0b29sLmNhbGxiYWNrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZShjYihhcmdzLCBleHRyYSkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaXNFcnJvcjogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNiID0gdG9vbC5jYWxsYmFjaztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2IoZXh0cmEpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlzRXJyb3I6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodG9vbC5vdXRwdXRTY2hlbWEgJiYgIXJlc3VsdC5pc0Vycm9yKSB7XG4gICAgICAgIGlmICghcmVzdWx0LnN0cnVjdHVyZWRDb250ZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgVG9vbCAke3JlcXVlc3QucGFyYW1zLm5hbWV9IGhhcyBhbiBvdXRwdXQgc2NoZW1hIGJ1dCBubyBzdHJ1Y3R1cmVkIGNvbnRlbnQgd2FzIHByb3ZpZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCB0b29sLm91dHB1dFNjaGVtYS5zYWZlUGFyc2VBc3luYyhyZXN1bHQuc3RydWN0dXJlZENvbnRlbnQpO1xuICAgICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsIGBJbnZhbGlkIHN0cnVjdHVyZWQgY29udGVudCBmb3IgdG9vbCAke3JlcXVlc3QucGFyYW1zLm5hbWV9OiAke3BhcnNlUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gICAgdGhpcy5fdG9vbEhhbmRsZXJzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIHNldENvbXBsZXRpb25SZXF1ZXN0SGFuZGxlcigpIHtcbiAgICBpZiAodGhpcy5fY29tcGxldGlvbkhhbmRsZXJJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlcnZlci5hc3NlcnRDYW5TZXRSZXF1ZXN0SGFuZGxlcihDb21wbGV0ZVJlcXVlc3RTY2hlbWEuc2hhcGUubWV0aG9kLnZhbHVlKTtcbiAgICB0aGlzLnNlcnZlci5yZWdpc3RlckNhcGFiaWxpdGllcyh7XG4gICAgICBjb21wbGV0aW9uczoge31cbiAgICB9KTtcbiAgICB0aGlzLnNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihDb21wbGV0ZVJlcXVlc3RTY2hlbWEsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBzd2l0Y2ggKHJlcXVlc3QucGFyYW1zLnJlZi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyZWYvcHJvbXB0XCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUHJvbXB0Q29tcGxldGlvbihyZXF1ZXN0LCByZXF1ZXN0LnBhcmFtcy5yZWYpO1xuICAgICAgICBjYXNlIFwicmVmL3Jlc291cmNlXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzb3VyY2VDb21wbGV0aW9uKHJlcXVlc3QsIHJlcXVlc3QucGFyYW1zLnJlZik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgSW52YWxpZCBjb21wbGV0aW9uIHJlZmVyZW5jZTogJHtyZXF1ZXN0LnBhcmFtcy5yZWZ9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY29tcGxldGlvbkhhbmRsZXJJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgYXN5bmMgaGFuZGxlUHJvbXB0Q29tcGxldGlvbihyZXF1ZXN0LCByZWYpIHtcbiAgICBjb25zdCBwcm9tcHQgPSB0aGlzLl9yZWdpc3RlcmVkUHJvbXB0c1tyZWYubmFtZV07XG4gICAgaWYgKCFwcm9tcHQpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYFByb21wdCAke3JlZi5uYW1lfSBub3QgZm91bmRgKTtcbiAgICB9XG4gICAgaWYgKCFwcm9tcHQuZW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgUHJvbXB0ICR7cmVmLm5hbWV9IGRpc2FibGVkYCk7XG4gICAgfVxuICAgIGlmICghcHJvbXB0LmFyZ3NTY2hlbWEpIHtcbiAgICAgIHJldHVybiBFTVBUWV9DT01QTEVUSU9OX1JFU1VMVDtcbiAgICB9XG4gICAgY29uc3QgZmllbGQgPSBwcm9tcHQuYXJnc1NjaGVtYS5zaGFwZVtyZXF1ZXN0LnBhcmFtcy5hcmd1bWVudC5uYW1lXTtcbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIENvbXBsZXRhYmxlKSkge1xuICAgICAgcmV0dXJuIEVNUFRZX0NPTVBMRVRJT05fUkVTVUxUO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBmaWVsZC5fZGVmO1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gYXdhaXQgZGVmLmNvbXBsZXRlKHJlcXVlc3QucGFyYW1zLmFyZ3VtZW50LnZhbHVlLCByZXF1ZXN0LnBhcmFtcy5jb250ZXh0KTtcbiAgICByZXR1cm4gY3JlYXRlQ29tcGxldGlvblJlc3VsdChzdWdnZXN0aW9ucyk7XG4gIH1cbiAgYXN5bmMgaGFuZGxlUmVzb3VyY2VDb21wbGV0aW9uKHJlcXVlc3QsIHJlZikge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gT2JqZWN0LnZhbHVlcyh0aGlzLl9yZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZXMpLmZpbmQoKHQpID0+IHQucmVzb3VyY2VUZW1wbGF0ZS51cmlUZW1wbGF0ZS50b1N0cmluZygpID09PSByZWYudXJpKTtcbiAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlc1tyZWYudXJpXSkge1xuICAgICAgICByZXR1cm4gRU1QVFlfQ09NUExFVElPTl9SRVNVTFQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsIGBSZXNvdXJjZSB0ZW1wbGF0ZSAke3JlcXVlc3QucGFyYW1zLnJlZi51cml9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBjb25zdCBjb21wbGV0ZXIgPSB0ZW1wbGF0ZS5yZXNvdXJjZVRlbXBsYXRlLmNvbXBsZXRlQ2FsbGJhY2socmVxdWVzdC5wYXJhbXMuYXJndW1lbnQubmFtZSk7XG4gICAgaWYgKCFjb21wbGV0ZXIpIHtcbiAgICAgIHJldHVybiBFTVBUWV9DT01QTEVUSU9OX1JFU1VMVDtcbiAgICB9XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnMgPSBhd2FpdCBjb21wbGV0ZXIocmVxdWVzdC5wYXJhbXMuYXJndW1lbnQudmFsdWUsIHJlcXVlc3QucGFyYW1zLmNvbnRleHQpO1xuICAgIHJldHVybiBjcmVhdGVDb21wbGV0aW9uUmVzdWx0KHN1Z2dlc3Rpb25zKTtcbiAgfVxuICBzZXRSZXNvdXJjZVJlcXVlc3RIYW5kbGVycygpIHtcbiAgICBpZiAodGhpcy5fcmVzb3VyY2VIYW5kbGVyc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VydmVyLmFzc2VydENhblNldFJlcXVlc3RIYW5kbGVyKExpc3RSZXNvdXJjZXNSZXF1ZXN0U2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSk7XG4gICAgdGhpcy5zZXJ2ZXIuYXNzZXJ0Q2FuU2V0UmVxdWVzdEhhbmRsZXIoTGlzdFJlc291cmNlVGVtcGxhdGVzUmVxdWVzdFNjaGVtYS5zaGFwZS5tZXRob2QudmFsdWUpO1xuICAgIHRoaXMuc2VydmVyLmFzc2VydENhblNldFJlcXVlc3RIYW5kbGVyKFJlYWRSZXNvdXJjZVJlcXVlc3RTY2hlbWEuc2hhcGUubWV0aG9kLnZhbHVlKTtcbiAgICB0aGlzLnNlcnZlci5yZWdpc3RlckNhcGFiaWxpdGllcyh7XG4gICAgICByZXNvdXJjZXM6IHtcbiAgICAgICAgbGlzdENoYW5nZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihMaXN0UmVzb3VyY2VzUmVxdWVzdFNjaGVtYSwgYXN5bmMgKHJlcXVlc3QsIGV4dHJhKSA9PiB7XG4gICAgICBjb25zdCByZXNvdXJjZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9yZWdpc3RlcmVkUmVzb3VyY2VzKS5maWx0ZXIoKFtfLCByZXNvdXJjZV0pID0+IHJlc291cmNlLmVuYWJsZWQpLm1hcCgoW3VyaSwgcmVzb3VyY2VdKSA9PiAoe1xuICAgICAgICB1cmksXG4gICAgICAgIG5hbWU6IHJlc291cmNlLm5hbWUsXG4gICAgICAgIC4uLnJlc291cmNlLm1ldGFkYXRhXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVJlc291cmNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCB0ZW1wbGF0ZSBvZiBPYmplY3QudmFsdWVzKHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlcykpIHtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZS5yZXNvdXJjZVRlbXBsYXRlLmxpc3RDYWxsYmFjaykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRlbXBsYXRlLnJlc291cmNlVGVtcGxhdGUubGlzdENhbGxiYWNrKGV4dHJhKTtcbiAgICAgICAgZm9yIChjb25zdCByZXNvdXJjZSBvZiByZXN1bHQucmVzb3VyY2VzKSB7XG4gICAgICAgICAgdGVtcGxhdGVSZXNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICAuLi50ZW1wbGF0ZS5tZXRhZGF0YSxcbiAgICAgICAgICAgIC4uLnJlc291cmNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHJlc291cmNlczogWy4uLnJlc291cmNlcywgLi4udGVtcGxhdGVSZXNvdXJjZXNdIH07XG4gICAgfSk7XG4gICAgdGhpcy5zZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoTGlzdFJlc291cmNlVGVtcGxhdGVzUmVxdWVzdFNjaGVtYSwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzb3VyY2VUZW1wbGF0ZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9yZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZXMpLm1hcCgoW25hbWUsIHRlbXBsYXRlXSkgPT4gKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdXJpVGVtcGxhdGU6IHRlbXBsYXRlLnJlc291cmNlVGVtcGxhdGUudXJpVGVtcGxhdGUudG9TdHJpbmcoKSxcbiAgICAgICAgLi4udGVtcGxhdGUubWV0YWRhdGFcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB7IHJlc291cmNlVGVtcGxhdGVzIH07XG4gICAgfSk7XG4gICAgdGhpcy5zZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoUmVhZFJlc291cmNlUmVxdWVzdFNjaGVtYSwgYXN5bmMgKHJlcXVlc3QsIGV4dHJhKSA9PiB7XG4gICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHJlcXVlc3QucGFyYW1zLnVyaSk7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZXNbdXJpLnRvU3RyaW5nKCldO1xuICAgICAgaWYgKHJlc291cmNlKSB7XG4gICAgICAgIGlmICghcmVzb3VyY2UuZW5hYmxlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYFJlc291cmNlICR7dXJpfSBkaXNhYmxlZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvdXJjZS5yZWFkQ2FsbGJhY2sodXJpLCBleHRyYSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIE9iamVjdC52YWx1ZXModGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGVzKSkge1xuICAgICAgICBjb25zdCB2YXJpYWJsZXMgPSB0ZW1wbGF0ZS5yZXNvdXJjZVRlbXBsYXRlLnVyaVRlbXBsYXRlLm1hdGNoKHVyaS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlcykge1xuICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZWFkQ2FsbGJhY2sodXJpLCB2YXJpYWJsZXMsIGV4dHJhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgUmVzb3VyY2UgJHt1cml9IG5vdCBmb3VuZGApO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0Q29tcGxldGlvblJlcXVlc3RIYW5kbGVyKCk7XG4gICAgdGhpcy5fcmVzb3VyY2VIYW5kbGVyc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICBzZXRQcm9tcHRSZXF1ZXN0SGFuZGxlcnMoKSB7XG4gICAgaWYgKHRoaXMuX3Byb21wdEhhbmRsZXJzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXJ2ZXIuYXNzZXJ0Q2FuU2V0UmVxdWVzdEhhbmRsZXIoTGlzdFByb21wdHNSZXF1ZXN0U2NoZW1hLnNoYXBlLm1ldGhvZC52YWx1ZSk7XG4gICAgdGhpcy5zZXJ2ZXIuYXNzZXJ0Q2FuU2V0UmVxdWVzdEhhbmRsZXIoR2V0UHJvbXB0UmVxdWVzdFNjaGVtYS5zaGFwZS5tZXRob2QudmFsdWUpO1xuICAgIHRoaXMuc2VydmVyLnJlZ2lzdGVyQ2FwYWJpbGl0aWVzKHtcbiAgICAgIHByb21wdHM6IHtcbiAgICAgICAgbGlzdENoYW5nZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihMaXN0UHJvbXB0c1JlcXVlc3RTY2hlbWEsICgpID0+ICh7XG4gICAgICBwcm9tcHRzOiBPYmplY3QuZW50cmllcyh0aGlzLl9yZWdpc3RlcmVkUHJvbXB0cykuZmlsdGVyKChbLCBwcm9tcHRdKSA9PiBwcm9tcHQuZW5hYmxlZCkubWFwKChbbmFtZSwgcHJvbXB0XSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGl0bGU6IHByb21wdC50aXRsZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcHJvbXB0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGFyZ3VtZW50czogcHJvbXB0LmFyZ3NTY2hlbWEgPyBwcm9tcHRBcmd1bWVudHNGcm9tU2NoZW1hKHByb21wdC5hcmdzU2NoZW1hKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9KSk7XG4gICAgdGhpcy5zZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoR2V0UHJvbXB0UmVxdWVzdFNjaGVtYSwgYXN5bmMgKHJlcXVlc3QsIGV4dHJhKSA9PiB7XG4gICAgICBjb25zdCBwcm9tcHQgPSB0aGlzLl9yZWdpc3RlcmVkUHJvbXB0c1tyZXF1ZXN0LnBhcmFtcy5uYW1lXTtcbiAgICAgIGlmICghcHJvbXB0KSB7XG4gICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihFcnJvckNvZGUuSW52YWxpZFBhcmFtcywgYFByb21wdCAke3JlcXVlc3QucGFyYW1zLm5hbWV9IG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgaWYgKCFwcm9tcHQuZW5hYmxlZCkge1xuICAgICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsIGBQcm9tcHQgJHtyZXF1ZXN0LnBhcmFtcy5uYW1lfSBkaXNhYmxlZGApO1xuICAgICAgfVxuICAgICAgaWYgKHByb21wdC5hcmdzU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgcHJvbXB0LmFyZ3NTY2hlbWEuc2FmZVBhcnNlQXN5bmMocmVxdWVzdC5wYXJhbXMuYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLCBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHByb21wdCAke3JlcXVlc3QucGFyYW1zLm5hbWV9OiAke3BhcnNlUmVzdWx0LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJncyA9IHBhcnNlUmVzdWx0LmRhdGE7XG4gICAgICAgIGNvbnN0IGNiID0gcHJvbXB0LmNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKGNiKGFyZ3MsIGV4dHJhKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjYiA9IHByb21wdC5jYWxsYmFjaztcbiAgICAgICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZShjYihleHRyYSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0Q29tcGxldGlvblJlcXVlc3RIYW5kbGVyKCk7XG4gICAgdGhpcy5fcHJvbXB0SGFuZGxlcnNJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cbiAgcmVzb3VyY2UobmFtZSwgdXJpT3JUZW1wbGF0ZSwgLi4ucmVzdCkge1xuICAgIGxldCBtZXRhZGF0YTtcbiAgICBpZiAodHlwZW9mIHJlc3RbMF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG1ldGFkYXRhID0gcmVzdC5zaGlmdCgpO1xuICAgIH1cbiAgICBjb25zdCByZWFkQ2FsbGJhY2sgPSByZXN0WzBdO1xuICAgIGlmICh0eXBlb2YgdXJpT3JUZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZXNbdXJpT3JUZW1wbGF0ZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSAke3VyaU9yVGVtcGxhdGV9IGlzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlc291cmNlID0gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFJlc291cmNlKG5hbWUsIHVuZGVmaW5lZCwgdXJpT3JUZW1wbGF0ZSwgbWV0YWRhdGEsIHJlYWRDYWxsYmFjayk7XG4gICAgICB0aGlzLnNldFJlc291cmNlUmVxdWVzdEhhbmRsZXJzKCk7XG4gICAgICB0aGlzLnNlbmRSZXNvdXJjZUxpc3RDaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGVzW25hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2UgdGVtcGxhdGUgJHtuYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlID0gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGUobmFtZSwgdW5kZWZpbmVkLCB1cmlPclRlbXBsYXRlLCBtZXRhZGF0YSwgcmVhZENhbGxiYWNrKTtcbiAgICAgIHRoaXMuc2V0UmVzb3VyY2VSZXF1ZXN0SGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuc2VuZFJlc291cmNlTGlzdENoYW5nZWQoKTtcbiAgICAgIHJldHVybiByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJSZXNvdXJjZShuYW1lLCB1cmlPclRlbXBsYXRlLCBjb25maWcsIHJlYWRDYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgdXJpT3JUZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZXNbdXJpT3JUZW1wbGF0ZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSAke3VyaU9yVGVtcGxhdGV9IGlzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVnaXN0ZXJlZFJlc291cmNlID0gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFJlc291cmNlKG5hbWUsIGNvbmZpZy50aXRsZSwgdXJpT3JUZW1wbGF0ZSwgY29uZmlnLCByZWFkQ2FsbGJhY2spO1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZVJlcXVlc3RIYW5kbGVycygpO1xuICAgICAgdGhpcy5zZW5kUmVzb3VyY2VMaXN0Q2hhbmdlZCgpO1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlc1tuYW1lXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHRlbXBsYXRlICR7bmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZSA9IHRoaXMuX2NyZWF0ZVJlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlKG5hbWUsIGNvbmZpZy50aXRsZSwgdXJpT3JUZW1wbGF0ZSwgY29uZmlnLCByZWFkQ2FsbGJhY2spO1xuICAgICAgdGhpcy5zZXRSZXNvdXJjZVJlcXVlc3RIYW5kbGVycygpO1xuICAgICAgdGhpcy5zZW5kUmVzb3VyY2VMaXN0Q2hhbmdlZCgpO1xuICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlUmVnaXN0ZXJlZFJlc291cmNlKG5hbWUsIHRpdGxlLCB1cmksIG1ldGFkYXRhLCByZWFkQ2FsbGJhY2spIHtcbiAgICBjb25zdCByZWdpc3RlcmVkUmVzb3VyY2UgPSB7XG4gICAgICBuYW1lLFxuICAgICAgdGl0bGUsXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIHJlYWRDYWxsYmFjayxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBkaXNhYmxlOiAoKSA9PiByZWdpc3RlcmVkUmVzb3VyY2UudXBkYXRlKHsgZW5hYmxlZDogZmFsc2UgfSksXG4gICAgICBlbmFibGU6ICgpID0+IHJlZ2lzdGVyZWRSZXNvdXJjZS51cGRhdGUoeyBlbmFibGVkOiB0cnVlIH0pLFxuICAgICAgcmVtb3ZlOiAoKSA9PiByZWdpc3RlcmVkUmVzb3VyY2UudXBkYXRlKHsgdXJpOiBudWxsIH0pLFxuICAgICAgdXBkYXRlOiAodXBkYXRlcykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudXJpICE9PSBcInVuZGVmaW5lZFwiICYmIHVwZGF0ZXMudXJpICE9PSB1cmkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlc1t1cmldO1xuICAgICAgICAgIGlmICh1cGRhdGVzLnVyaSlcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZXNbdXBkYXRlcy51cmldID0gcmVnaXN0ZXJlZFJlc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5uYW1lICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRSZXNvdXJjZS5uYW1lID0gdXBkYXRlcy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudGl0bGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFJlc291cmNlLnRpdGxlID0gdXBkYXRlcy50aXRsZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLm1ldGFkYXRhICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRSZXNvdXJjZS5tZXRhZGF0YSA9IHVwZGF0ZXMubWV0YWRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5jYWxsYmFjayAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUmVzb3VyY2UucmVhZENhbGxiYWNrID0gdXBkYXRlcy5jYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmVuYWJsZWQgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFJlc291cmNlLmVuYWJsZWQgPSB1cGRhdGVzLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuc2VuZFJlc291cmNlTGlzdENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZXNbdXJpXSA9IHJlZ2lzdGVyZWRSZXNvdXJjZTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc291cmNlO1xuICB9XG4gIF9jcmVhdGVSZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZShuYW1lLCB0aXRsZSwgdGVtcGxhdGUsIG1ldGFkYXRhLCByZWFkQ2FsbGJhY2spIHtcbiAgICBjb25zdCByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZSA9IHtcbiAgICAgIHJlc291cmNlVGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgICAgdGl0bGUsXG4gICAgICBtZXRhZGF0YSxcbiAgICAgIHJlYWRDYWxsYmFjayxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBkaXNhYmxlOiAoKSA9PiByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZS51cGRhdGUoeyBlbmFibGVkOiBmYWxzZSB9KSxcbiAgICAgIGVuYWJsZTogKCkgPT4gcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGUudXBkYXRlKHsgZW5hYmxlZDogdHJ1ZSB9KSxcbiAgICAgIHJlbW92ZTogKCkgPT4gcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGUudXBkYXRlKHsgbmFtZTogbnVsbCB9KSxcbiAgICAgIHVwZGF0ZTogKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLm5hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgdXBkYXRlcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3JlZ2lzdGVyZWRSZXNvdXJjZVRlbXBsYXRlc1tuYW1lXTtcbiAgICAgICAgICBpZiAodXBkYXRlcy5uYW1lKVxuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGVzW3VwZGF0ZXMubmFtZV0gPSByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudGl0bGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGUudGl0bGUgPSB1cGRhdGVzLnRpdGxlO1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudGVtcGxhdGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGUucmVzb3VyY2VUZW1wbGF0ZSA9IHVwZGF0ZXMudGVtcGxhdGU7XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5tZXRhZGF0YSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZS5tZXRhZGF0YSA9IHVwZGF0ZXMubWV0YWRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5jYWxsYmFjayAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZS5yZWFkQ2FsbGJhY2sgPSB1cGRhdGVzLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMuZW5hYmxlZCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZS5lbmFibGVkID0gdXBkYXRlcy5lbmFibGVkO1xuICAgICAgICB0aGlzLnNlbmRSZXNvdXJjZUxpc3RDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZXNbbmFtZV0gPSByZWdpc3RlcmVkUmVzb3VyY2VUZW1wbGF0ZTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc291cmNlVGVtcGxhdGU7XG4gIH1cbiAgX2NyZWF0ZVJlZ2lzdGVyZWRQcm9tcHQobmFtZSwgdGl0bGUsIGRlc2NyaXB0aW9uLCBhcmdzU2NoZW1hLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRQcm9tcHQgPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgYXJnc1NjaGVtYTogYXJnc1NjaGVtYSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZXhwb3J0c19leHRlcm5hbC5vYmplY3QoYXJnc1NjaGVtYSksXG4gICAgICBjYWxsYmFjayxcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBkaXNhYmxlOiAoKSA9PiByZWdpc3RlcmVkUHJvbXB0LnVwZGF0ZSh7IGVuYWJsZWQ6IGZhbHNlIH0pLFxuICAgICAgZW5hYmxlOiAoKSA9PiByZWdpc3RlcmVkUHJvbXB0LnVwZGF0ZSh7IGVuYWJsZWQ6IHRydWUgfSksXG4gICAgICByZW1vdmU6ICgpID0+IHJlZ2lzdGVyZWRQcm9tcHQudXBkYXRlKHsgbmFtZTogbnVsbCB9KSxcbiAgICAgIHVwZGF0ZTogKHVwZGF0ZXMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLm5hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgdXBkYXRlcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX3JlZ2lzdGVyZWRQcm9tcHRzW25hbWVdO1xuICAgICAgICAgIGlmICh1cGRhdGVzLm5hbWUpXG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlcmVkUHJvbXB0c1t1cGRhdGVzLm5hbWVdID0gcmVnaXN0ZXJlZFByb21wdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMudGl0bGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFByb21wdC50aXRsZSA9IHVwZGF0ZXMudGl0bGU7XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5kZXNjcmlwdGlvbiAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUHJvbXB0LmRlc2NyaXB0aW9uID0gdXBkYXRlcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmFyZ3NTY2hlbWEgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFByb21wdC5hcmdzU2NoZW1hID0gZXhwb3J0c19leHRlcm5hbC5vYmplY3QodXBkYXRlcy5hcmdzU2NoZW1hKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmNhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRQcm9tcHQuY2FsbGJhY2sgPSB1cGRhdGVzLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXMuZW5hYmxlZCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkUHJvbXB0LmVuYWJsZWQgPSB1cGRhdGVzLmVuYWJsZWQ7XG4gICAgICAgIHRoaXMuc2VuZFByb21wdExpc3RDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkUHJvbXB0c1tuYW1lXSA9IHJlZ2lzdGVyZWRQcm9tcHQ7XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRQcm9tcHQ7XG4gIH1cbiAgX2NyZWF0ZVJlZ2lzdGVyZWRUb29sKG5hbWUsIHRpdGxlLCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEsIG91dHB1dFNjaGVtYSwgYW5ub3RhdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZFRvb2wgPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgaW5wdXRTY2hlbWE6IGlucHV0U2NoZW1hID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBleHBvcnRzX2V4dGVybmFsLm9iamVjdChpbnB1dFNjaGVtYSksXG4gICAgICBvdXRwdXRTY2hlbWE6IG91dHB1dFNjaGVtYSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZXhwb3J0c19leHRlcm5hbC5vYmplY3Qob3V0cHV0U2NoZW1hKSxcbiAgICAgIGFubm90YXRpb25zLFxuICAgICAgY2FsbGJhY2ssXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZGlzYWJsZTogKCkgPT4gcmVnaXN0ZXJlZFRvb2wudXBkYXRlKHsgZW5hYmxlZDogZmFsc2UgfSksXG4gICAgICBlbmFibGU6ICgpID0+IHJlZ2lzdGVyZWRUb29sLnVwZGF0ZSh7IGVuYWJsZWQ6IHRydWUgfSksXG4gICAgICByZW1vdmU6ICgpID0+IHJlZ2lzdGVyZWRUb29sLnVwZGF0ZSh7IG5hbWU6IG51bGwgfSksXG4gICAgICB1cGRhdGU6ICh1cGRhdGVzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBkYXRlcy5uYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHVwZGF0ZXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZWdpc3RlcmVkVG9vbHNbbmFtZV07XG4gICAgICAgICAgaWYgKHVwZGF0ZXMubmFtZSlcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRUb29sc1t1cGRhdGVzLm5hbWVdID0gcmVnaXN0ZXJlZFRvb2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLnRpdGxlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRUb29sLnRpdGxlID0gdXBkYXRlcy50aXRsZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmRlc2NyaXB0aW9uICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRUb29sLmRlc2NyaXB0aW9uID0gdXBkYXRlcy5kZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLnBhcmFtc1NjaGVtYSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICByZWdpc3RlcmVkVG9vbC5pbnB1dFNjaGVtYSA9IGV4cG9ydHNfZXh0ZXJuYWwub2JqZWN0KHVwZGF0ZXMucGFyYW1zU2NoZW1hKTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmNhbGxiYWNrICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRUb29sLmNhbGxiYWNrID0gdXBkYXRlcy5jYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmFubm90YXRpb25zICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgIHJlZ2lzdGVyZWRUb29sLmFubm90YXRpb25zID0gdXBkYXRlcy5hbm5vdGF0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVzLmVuYWJsZWQgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgcmVnaXN0ZXJlZFRvb2wuZW5hYmxlZCA9IHVwZGF0ZXMuZW5hYmxlZDtcbiAgICAgICAgdGhpcy5zZW5kVG9vbExpc3RDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkVG9vbHNbbmFtZV0gPSByZWdpc3RlcmVkVG9vbDtcbiAgICB0aGlzLnNldFRvb2xSZXF1ZXN0SGFuZGxlcnMoKTtcbiAgICB0aGlzLnNlbmRUb29sTGlzdENoYW5nZWQoKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZFRvb2w7XG4gIH1cbiAgdG9vbChuYW1lLCAuLi5yZXN0KSB7XG4gICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRUb29sc1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUb29sICR7bmFtZX0gaXMgYWxyZWFkeSByZWdpc3RlcmVkYCk7XG4gICAgfVxuICAgIGxldCBkZXNjcmlwdGlvbjtcbiAgICBsZXQgaW5wdXRTY2hlbWE7XG4gICAgbGV0IG91dHB1dFNjaGVtYTtcbiAgICBsZXQgYW5ub3RhdGlvbnM7XG4gICAgaWYgKHR5cGVvZiByZXN0WzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IHJlc3Quc2hpZnQoKTtcbiAgICB9XG4gICAgaWYgKHJlc3QubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgZmlyc3RBcmcgPSByZXN0WzBdO1xuICAgICAgaWYgKGlzWm9kUmF3U2hhcGUoZmlyc3RBcmcpKSB7XG4gICAgICAgIGlucHV0U2NoZW1hID0gcmVzdC5zaGlmdCgpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPiAxICYmIHR5cGVvZiByZXN0WzBdID09PSBcIm9iamVjdFwiICYmIHJlc3RbMF0gIT09IG51bGwgJiYgIWlzWm9kUmF3U2hhcGUocmVzdFswXSkpIHtcbiAgICAgICAgICBhbm5vdGF0aW9ucyA9IHJlc3Quc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmlyc3RBcmcgPT09IFwib2JqZWN0XCIgJiYgZmlyc3RBcmcgIT09IG51bGwpIHtcbiAgICAgICAgYW5ub3RhdGlvbnMgPSByZXN0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbGxiYWNrID0gcmVzdFswXTtcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFRvb2wobmFtZSwgdW5kZWZpbmVkLCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEsIG91dHB1dFNjaGVtYSwgYW5ub3RhdGlvbnMsIGNhbGxiYWNrKTtcbiAgfVxuICByZWdpc3RlclRvb2wobmFtZSwgY29uZmlnLCBjYikge1xuICAgIGlmICh0aGlzLl9yZWdpc3RlcmVkVG9vbHNbbmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVG9vbCAke25hbWV9IGlzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICBjb25zdCB7IHRpdGxlLCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEsIG91dHB1dFNjaGVtYSwgYW5ub3RhdGlvbnMgfSA9IGNvbmZpZztcbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFRvb2wobmFtZSwgdGl0bGUsIGRlc2NyaXB0aW9uLCBpbnB1dFNjaGVtYSwgb3V0cHV0U2NoZW1hLCBhbm5vdGF0aW9ucywgY2IpO1xuICB9XG4gIHByb21wdChuYW1lLCAuLi5yZXN0KSB7XG4gICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWRQcm9tcHRzW25hbWVdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb21wdCAke25hbWV9IGlzIGFscmVhZHkgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICBsZXQgZGVzY3JpcHRpb247XG4gICAgaWYgKHR5cGVvZiByZXN0WzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IHJlc3Quc2hpZnQoKTtcbiAgICB9XG4gICAgbGV0IGFyZ3NTY2hlbWE7XG4gICAgaWYgKHJlc3QubGVuZ3RoID4gMSkge1xuICAgICAgYXJnc1NjaGVtYSA9IHJlc3Quc2hpZnQoKTtcbiAgICB9XG4gICAgY29uc3QgY2IgPSByZXN0WzBdO1xuICAgIGNvbnN0IHJlZ2lzdGVyZWRQcm9tcHQgPSB0aGlzLl9jcmVhdGVSZWdpc3RlcmVkUHJvbXB0KG5hbWUsIHVuZGVmaW5lZCwgZGVzY3JpcHRpb24sIGFyZ3NTY2hlbWEsIGNiKTtcbiAgICB0aGlzLnNldFByb21wdFJlcXVlc3RIYW5kbGVycygpO1xuICAgIHRoaXMuc2VuZFByb21wdExpc3RDaGFuZ2VkKCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRQcm9tcHQ7XG4gIH1cbiAgcmVnaXN0ZXJQcm9tcHQobmFtZSwgY29uZmlnLCBjYikge1xuICAgIGlmICh0aGlzLl9yZWdpc3RlcmVkUHJvbXB0c1tuYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9tcHQgJHtuYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgeyB0aXRsZSwgZGVzY3JpcHRpb24sIGFyZ3NTY2hlbWEgfSA9IGNvbmZpZztcbiAgICBjb25zdCByZWdpc3RlcmVkUHJvbXB0ID0gdGhpcy5fY3JlYXRlUmVnaXN0ZXJlZFByb21wdChuYW1lLCB0aXRsZSwgZGVzY3JpcHRpb24sIGFyZ3NTY2hlbWEsIGNiKTtcbiAgICB0aGlzLnNldFByb21wdFJlcXVlc3RIYW5kbGVycygpO1xuICAgIHRoaXMuc2VuZFByb21wdExpc3RDaGFuZ2VkKCk7XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWRQcm9tcHQ7XG4gIH1cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VydmVyLnRyYW5zcG9ydCAhPT0gdW5kZWZpbmVkO1xuICB9XG4gIHNlbmRSZXNvdXJjZUxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgIHRoaXMuc2VydmVyLnNlbmRSZXNvdXJjZUxpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG4gIHNlbmRUb29sTGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5zZXJ2ZXIuc2VuZFRvb2xMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICBzZW5kUHJvbXB0TGlzdENoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgdGhpcy5zZXJ2ZXIuc2VuZFByb21wdExpc3RDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG59XG52YXIgRU1QVFlfT0JKRUNUX0pTT05fU0NIRU1BID0ge1xuICB0eXBlOiBcIm9iamVjdFwiLFxuICBwcm9wZXJ0aWVzOiB7fVxufTtcbmZ1bmN0aW9uIGlzWm9kUmF3U2hhcGUob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGlzRW1wdHlPYmplY3QgPSBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgcmV0dXJuIGlzRW1wdHlPYmplY3QgfHwgT2JqZWN0LnZhbHVlcyhvYmopLnNvbWUoaXNab2RUeXBlTGlrZSk7XG59XG5mdW5jdGlvbiBpc1pvZFR5cGVMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJwYXJzZVwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5wYXJzZSA9PT0gXCJmdW5jdGlvblwiICYmIFwic2FmZVBhcnNlXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNhZmVQYXJzZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gcHJvbXB0QXJndW1lbnRzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5zaGFwZSkubWFwKChbbmFtZSwgZmllbGRdKSA9PiAoe1xuICAgIG5hbWUsXG4gICAgZGVzY3JpcHRpb246IGZpZWxkLmRlc2NyaXB0aW9uLFxuICAgIHJlcXVpcmVkOiAhZmllbGQuaXNPcHRpb25hbCgpXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBsZXRpb25SZXN1bHQoc3VnZ2VzdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0aW9uOiB7XG4gICAgICB2YWx1ZXM6IHN1Z2dlc3Rpb25zLnNsaWNlKDAsIDEwMCksXG4gICAgICB0b3RhbDogc3VnZ2VzdGlvbnMubGVuZ3RoLFxuICAgICAgaGFzTW9yZTogc3VnZ2VzdGlvbnMubGVuZ3RoID4gMTAwXG4gICAgfVxuICB9O1xufVxudmFyIEVNUFRZX0NPTVBMRVRJT05fUkVTVUxUID0ge1xuICBjb21wbGV0aW9uOiB7XG4gICAgdmFsdWVzOiBbXSxcbiAgICBoYXNNb3JlOiBmYWxzZVxuICB9XG59O1xuXG4vLyAuLi9zcmMvc2VydmljZXMvbWNwL2NyZWF0ZVNka01jcFNlcnZlci50c1xuZnVuY3Rpb24gdG9vbChuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXRTY2hlbWEsIGhhbmRsZXIpIHtcbiAgcmV0dXJuIHsgbmFtZSwgZGVzY3JpcHRpb24sIGlucHV0U2NoZW1hLCBoYW5kbGVyIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZGtNY3BTZXJ2ZXIob3B0aW9ucykge1xuICBjb25zdCBzZXJ2ZXIgPSBuZXcgTWNwU2VydmVyKHtcbiAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uID8/IFwiMS4wLjBcIlxuICB9LCB7XG4gICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICB0b29sczogb3B0aW9ucy50b29scyA/IHt9IDogdW5kZWZpbmVkXG4gICAgfVxuICB9KTtcbiAgaWYgKG9wdGlvbnMudG9vbHMpIHtcbiAgICBvcHRpb25zLnRvb2xzLmZvckVhY2goKHRvb2xEZWYpID0+IHtcbiAgICAgIHNlcnZlci50b29sKHRvb2xEZWYubmFtZSwgdG9vbERlZi5kZXNjcmlwdGlvbiwgdG9vbERlZi5pbnB1dFNjaGVtYSwgdG9vbERlZi5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwic2RrXCIsXG4gICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgIGluc3RhbmNlOiBzZXJ2ZXJcbiAgfTtcbn1cbi8vIC4uL3NyYy9lbnRyeXBvaW50cy9hZ2VudFNkay50c1xuZnVuY3Rpb24gcXVlcnkoe1xuICBwcm9tcHQsXG4gIG9wdGlvbnNcbn0pIHtcbiAgY29uc3QgeyBzeXN0ZW1Qcm9tcHQsIHNldHRpbmdTb3VyY2VzLCAuLi5yZXN0IH0gPSBvcHRpb25zID8/IHt9O1xuICBsZXQgY3VzdG9tU3lzdGVtUHJvbXB0O1xuICBsZXQgYXBwZW5kU3lzdGVtUHJvbXB0O1xuICBpZiAoc3lzdGVtUHJvbXB0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjdXN0b21TeXN0ZW1Qcm9tcHQgPSBcIlwiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzeXN0ZW1Qcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjdXN0b21TeXN0ZW1Qcm9tcHQgPSBzeXN0ZW1Qcm9tcHQ7XG4gIH0gZWxzZSBpZiAoc3lzdGVtUHJvbXB0LnR5cGUgPT09IFwicHJlc2V0XCIpIHtcbiAgICBhcHBlbmRTeXN0ZW1Qcm9tcHQgPSBzeXN0ZW1Qcm9tcHQuYXBwZW5kO1xuICB9XG4gIGxldCBwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSA9IHJlc3QucGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGU7XG4gIGlmICghcGF0aFRvQ2xhdWRlQ29kZUV4ZWN1dGFibGUpIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKTtcbiAgICBjb25zdCBkaXJuYW1lMiA9IGpvaW4zKGZpbGVuYW1lLCBcIi4uXCIpO1xuICAgIHBhdGhUb0NsYXVkZUNvZGVFeGVjdXRhYmxlID0gam9pbjMoZGlybmFtZTIsIFwiY2xpLmpzXCIpO1xuICB9XG4gIHByb2Nlc3MuZW52LkNMQVVERV9BR0VOVF9TREtfVkVSU0lPTiA9IFwiMC4xLjE0XCI7XG4gIHJldHVybiBjcmVhdGVTaGFyZWRRdWVyeSh7XG4gICAgcHJvbXB0LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnJlc3QsXG4gICAgICBwYXRoVG9DbGF1ZGVDb2RlRXhlY3V0YWJsZSxcbiAgICAgIGN1c3RvbVN5c3RlbVByb21wdCxcbiAgICAgIGFwcGVuZFN5c3RlbVByb21wdCxcbiAgICAgIHNldHRpbmdTb3VyY2VzOiBzZXR0aW5nU291cmNlcyA/PyBbXVxuICAgIH1cbiAgfSk7XG59XG5leHBvcnQge1xuICB0b29sLFxuICBxdWVyeSxcbiAgY3JlYXRlU2RrTWNwU2VydmVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partialParse: () => (/* binding */ partialParse)\n/* harmony export */ });\nconst tokenize = (input) => {\n    let current = 0;\n    let tokens = [];\n    while (current < input.length) {\n        let char = input[current];\n        if (char === '\\\\') {\n            current++;\n            continue;\n        }\n        if (char === '{') {\n            tokens.push({\n                type: 'brace',\n                value: '{',\n            });\n            current++;\n            continue;\n        }\n        if (char === '}') {\n            tokens.push({\n                type: 'brace',\n                value: '}',\n            });\n            current++;\n            continue;\n        }\n        if (char === '[') {\n            tokens.push({\n                type: 'paren',\n                value: '[',\n            });\n            current++;\n            continue;\n        }\n        if (char === ']') {\n            tokens.push({\n                type: 'paren',\n                value: ']',\n            });\n            current++;\n            continue;\n        }\n        if (char === ':') {\n            tokens.push({\n                type: 'separator',\n                value: ':',\n            });\n            current++;\n            continue;\n        }\n        if (char === ',') {\n            tokens.push({\n                type: 'delimiter',\n                value: ',',\n            });\n            current++;\n            continue;\n        }\n        if (char === '\"') {\n            let value = '';\n            let danglingQuote = false;\n            char = input[++current];\n            while (char !== '\"') {\n                if (current === input.length) {\n                    danglingQuote = true;\n                    break;\n                }\n                if (char === '\\\\') {\n                    current++;\n                    if (current === input.length) {\n                        danglingQuote = true;\n                        break;\n                    }\n                    value += char + input[current];\n                    char = input[++current];\n                }\n                else {\n                    value += char;\n                    char = input[++current];\n                }\n            }\n            char = input[++current];\n            if (!danglingQuote) {\n                tokens.push({\n                    type: 'string',\n                    value,\n                });\n            }\n            continue;\n        }\n        let WHITESPACE = /\\s/;\n        if (char && WHITESPACE.test(char)) {\n            current++;\n            continue;\n        }\n        let NUMBERS = /[0-9]/;\n        if ((char && NUMBERS.test(char)) || char === '-' || char === '.') {\n            let value = '';\n            if (char === '-') {\n                value += char;\n                char = input[++current];\n            }\n            while ((char && NUMBERS.test(char)) || char === '.') {\n                value += char;\n                char = input[++current];\n            }\n            tokens.push({\n                type: 'number',\n                value,\n            });\n            continue;\n        }\n        let LETTERS = /[a-z]/i;\n        if (char && LETTERS.test(char)) {\n            let value = '';\n            while (char && LETTERS.test(char)) {\n                if (current === input.length) {\n                    break;\n                }\n                value += char;\n                char = input[++current];\n            }\n            if (value == 'true' || value == 'false' || value === 'null') {\n                tokens.push({\n                    type: 'name',\n                    value,\n                });\n            }\n            else {\n                // unknown token, e.g. `nul` which isn't quite `null`\n                current++;\n                continue;\n            }\n            continue;\n        }\n        current++;\n    }\n    return tokens;\n}, strip = (tokens) => {\n    if (tokens.length === 0) {\n        return tokens;\n    }\n    let lastToken = tokens[tokens.length - 1];\n    switch (lastToken.type) {\n        case 'separator':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n        case 'number':\n            let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];\n            if (lastCharacterOfLastToken === '.' || lastCharacterOfLastToken === '-') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n        case 'string':\n            let tokenBeforeTheLastToken = tokens[tokens.length - 2];\n            if (tokenBeforeTheLastToken?.type === 'delimiter') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            else if (tokenBeforeTheLastToken?.type === 'brace' && tokenBeforeTheLastToken.value === '{') {\n                tokens = tokens.slice(0, tokens.length - 1);\n                return strip(tokens);\n            }\n            break;\n        case 'delimiter':\n            tokens = tokens.slice(0, tokens.length - 1);\n            return strip(tokens);\n            break;\n    }\n    return tokens;\n}, unstrip = (tokens) => {\n    let tail = [];\n    tokens.map((token) => {\n        if (token.type === 'brace') {\n            if (token.value === '{') {\n                tail.push('}');\n            }\n            else {\n                tail.splice(tail.lastIndexOf('}'), 1);\n            }\n        }\n        if (token.type === 'paren') {\n            if (token.value === '[') {\n                tail.push(']');\n            }\n            else {\n                tail.splice(tail.lastIndexOf(']'), 1);\n            }\n        }\n    });\n    if (tail.length > 0) {\n        tail.reverse().map((item) => {\n            if (item === '}') {\n                tokens.push({\n                    type: 'brace',\n                    value: '}',\n                });\n            }\n            else if (item === ']') {\n                tokens.push({\n                    type: 'paren',\n                    value: ']',\n                });\n            }\n        });\n    }\n    return tokens;\n}, generate = (tokens) => {\n    let output = '';\n    tokens.map((token) => {\n        switch (token.type) {\n            case 'string':\n                output += '\"' + token.value + '\"';\n                break;\n            default:\n                output += token.value;\n                break;\n        }\n    });\n    return output;\n}, partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));\n\n//# sourceMappingURL=parser.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDdUI7QUFDeEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9fdmVuZG9yL3BhcnRpYWwtanNvbi1wYXJzZXIvcGFyc2VyLm1qcz85MjVmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHRva2VuaXplID0gKGlucHV0KSA9PiB7XG4gICAgbGV0IGN1cnJlbnQgPSAwO1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICB3aGlsZSAoY3VycmVudCA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBsZXQgY2hhciA9IGlucHV0W2N1cnJlbnRdO1xuICAgICAgICBpZiAoY2hhciA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ3snKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ3snLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ30nKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2JyYWNlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ30nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ1snKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcmVuJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ1snLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJ10nKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcmVuJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ10nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhciA9PT0gJzonKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NlcGFyYXRvcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc6JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICcsJykge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkZWxpbWl0ZXInLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnLCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnQrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyID09PSAnXCInKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGxldCBkYW5nbGluZ1F1b3RlID0gZmFsc2U7XG4gICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgIHdoaWxlIChjaGFyICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkYW5nbGluZ1F1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYW5nbGluZ1F1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNoYXIgKyBpbnB1dFtjdXJyZW50XTtcbiAgICAgICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgIGlmICghZGFuZ2xpbmdRdW90ZSkge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFdISVRFU1BBQ0UgPSAvXFxzLztcbiAgICAgICAgaWYgKGNoYXIgJiYgV0hJVEVTUEFDRS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgTlVNQkVSUyA9IC9bMC05XS87XG4gICAgICAgIGlmICgoY2hhciAmJiBOVU1CRVJTLnRlc3QoY2hhcikpIHx8IGNoYXIgPT09ICctJyB8fCBjaGFyID09PSAnLicpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICctJykge1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGNoYXI7XG4gICAgICAgICAgICAgICAgY2hhciA9IGlucHV0WysrY3VycmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKGNoYXIgJiYgTlVNQkVSUy50ZXN0KGNoYXIpKSB8fCBjaGFyID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgIGNoYXIgPSBpbnB1dFsrK2N1cnJlbnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgTEVUVEVSUyA9IC9bYS16XS9pO1xuICAgICAgICBpZiAoY2hhciAmJiBMRVRURVJTLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKGNoYXIgJiYgTEVUVEVSUy50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICBjaGFyID0gaW5wdXRbKytjdXJyZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSAndHJ1ZScgfHwgdmFsdWUgPT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5rbm93biB0b2tlbiwgZS5nLiBgbnVsYCB3aGljaCBpc24ndCBxdWl0ZSBgbnVsbGBcbiAgICAgICAgICAgICAgICBjdXJyZW50Kys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50Kys7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59LCBzdHJpcCA9ICh0b2tlbnMpID0+IHtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBsZXQgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGxhc3RUb2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlcGFyYXRvcic6XG4gICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMCwgdG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGxldCBsYXN0Q2hhcmFjdGVyT2ZMYXN0VG9rZW4gPSBsYXN0VG9rZW4udmFsdWVbbGFzdFRva2VuLnZhbHVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKGxhc3RDaGFyYWN0ZXJPZkxhc3RUb2tlbiA9PT0gJy4nIHx8IGxhc3RDaGFyYWN0ZXJPZkxhc3RUb2tlbiA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXAodG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGxldCB0b2tlbkJlZm9yZVRoZUxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBpZiAodG9rZW5CZWZvcmVUaGVMYXN0VG9rZW4/LnR5cGUgPT09ICdkZWxpbWl0ZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIHRva2Vucy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXAodG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuQmVmb3JlVGhlTGFzdFRva2VuPy50eXBlID09PSAnYnJhY2UnICYmIHRva2VuQmVmb3JlVGhlTGFzdFRva2VuLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMCwgdG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcCh0b2tlbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RlbGltaXRlcic6XG4gICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoMCwgdG9rZW5zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cmlwKHRva2Vucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn0sIHVuc3RyaXAgPSAodG9rZW5zKSA9PiB7XG4gICAgbGV0IHRhaWwgPSBbXTtcbiAgICB0b2tlbnMubWFwKCh0b2tlbikgPT4ge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2JyYWNlJykge1xuICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICAgICAgICB0YWlsLnB1c2goJ30nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhaWwuc3BsaWNlKHRhaWwubGFzdEluZGV4T2YoJ30nKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdwYXJlbicpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgdGFpbC5wdXNoKCddJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YWlsLnNwbGljZSh0YWlsLmxhc3RJbmRleE9mKCddJyksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhaWwubGVuZ3RoID4gMCkge1xuICAgICAgICB0YWlsLnJldmVyc2UoKS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnfScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwYXJlbicsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiAnXScsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufSwgZ2VuZXJhdGUgPSAodG9rZW5zKSA9PiB7XG4gICAgbGV0IG91dHB1dCA9ICcnO1xuICAgIHRva2Vucy5tYXAoKHRva2VuKSA9PiB7XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ1wiJyArIHRva2VuLnZhbHVlICsgJ1wiJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IHRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn0sIHBhcnRpYWxQYXJzZSA9IChpbnB1dCkgPT4gSlNPTi5wYXJzZShnZW5lcmF0ZSh1bnN0cmlwKHN0cmlwKHRva2VuaXplKGlucHV0KSkpKSk7XG5leHBvcnQgeyBwYXJ0aWFsUGFyc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/client.mjs":
/*!*******************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/client.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_PROMPT: () => (/* binding */ AI_PROMPT),\n/* harmony export */   Anthropic: () => (/* binding */ Anthropic),\n/* harmony export */   BaseAnthropic: () => (/* binding */ BaseAnthropic),\n/* harmony export */   HUMAN_PROMPT: () => (/* binding */ HUMAN_PROMPT)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _internal_utils_uuid_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/utils/uuid.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs\");\n/* harmony import */ var _internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/utils/values.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\");\n/* harmony import */ var _internal_utils_sleep_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/utils/sleep.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs\");\n/* harmony import */ var _internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/errors.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\");\n/* harmony import */ var _internal_detect_platform_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./internal/detect-platform.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs\");\n/* harmony import */ var _internal_shims_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./internal/shims.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs\");\n/* harmony import */ var _internal_request_options_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal/request-options.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/request-options.mjs\");\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./version.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/version.mjs\");\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _core_uploads_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/uploads.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/uploads.mjs\");\n/* harmony import */ var _resources_index_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./resources/index.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/index.mjs\");\n/* harmony import */ var _core_api_promise_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/api-promise.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs\");\n/* harmony import */ var _resources_completions_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./resources/completions.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/completions.mjs\");\n/* harmony import */ var _resources_models_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./resources/models.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/models.mjs\");\n/* harmony import */ var _resources_beta_beta_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./resources/beta/beta.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs\");\n/* harmony import */ var _resources_messages_messages_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./resources/messages/messages.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_utils_env_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./internal/utils/env.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/env.mjs\");\n/* harmony import */ var _internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./internal/utils/log.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _BaseAnthropic_instances, _a, _BaseAnthropic_encoder, _BaseAnthropic_baseURLOverridden;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst HUMAN_PROMPT = '\\\\n\\\\nHuman:';\nconst AI_PROMPT = '\\\\n\\\\nAssistant:';\n/**\n * Base class for Anthropic API clients.\n */\nclass BaseAnthropic {\n    /**\n     * API Client for interfacing with the Anthropic API.\n     *\n     * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]\n     * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]\n     * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.\n     * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.\n     * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.\n     * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.\n     * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.\n     * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.\n     * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.\n     * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.\n     */\n    constructor({ baseURL = (0,_internal_utils_env_mjs__WEBPACK_IMPORTED_MODULE_19__.readEnv)('ANTHROPIC_BASE_URL'), apiKey = (0,_internal_utils_env_mjs__WEBPACK_IMPORTED_MODULE_19__.readEnv)('ANTHROPIC_API_KEY') ?? null, authToken = (0,_internal_utils_env_mjs__WEBPACK_IMPORTED_MODULE_19__.readEnv)('ANTHROPIC_AUTH_TOKEN') ?? null, ...opts } = {}) {\n        _BaseAnthropic_instances.add(this);\n        _BaseAnthropic_encoder.set(this, void 0);\n        const options = {\n            apiKey,\n            authToken,\n            ...opts,\n            baseURL: baseURL || `https://api.anthropic.com`,\n        };\n        if (!options.dangerouslyAllowBrowser && (0,_internal_detect_platform_mjs__WEBPACK_IMPORTED_MODULE_5__.isRunningInBrowser)()) {\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AnthropicError(\"It looks like you're running in a browser-like environment.\\n\\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\\nIf you understand the risks and have appropriate mitigations in place,\\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\\n\\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\\n\");\n        }\n        this.baseURL = options.baseURL;\n        this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT /* 10 minutes */;\n        this.logger = options.logger ?? console;\n        const defaultLogLevel = 'warn';\n        // Set default logLevel early so that we can log a warning in parseLogLevel.\n        this.logLevel = defaultLogLevel;\n        this.logLevel =\n            (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.parseLogLevel)(options.logLevel, 'ClientOptions.logLevel', this) ??\n                (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.parseLogLevel)((0,_internal_utils_env_mjs__WEBPACK_IMPORTED_MODULE_19__.readEnv)('ANTHROPIC_LOG'), \"process.env['ANTHROPIC_LOG']\", this) ??\n                defaultLogLevel;\n        this.fetchOptions = options.fetchOptions;\n        this.maxRetries = options.maxRetries ?? 2;\n        this.fetch = options.fetch ?? _internal_shims_mjs__WEBPACK_IMPORTED_MODULE_6__.getDefaultFetch();\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BaseAnthropic_encoder, _internal_request_options_mjs__WEBPACK_IMPORTED_MODULE_7__.FallbackEncoder, \"f\");\n        this._options = options;\n        this.apiKey = apiKey;\n        this.authToken = authToken;\n    }\n    /**\n     * Create a new client instance re-using the same options given to the current client with optional overriding.\n     */\n    withOptions(options) {\n        const client = new this.constructor({\n            ...this._options,\n            baseURL: this.baseURL,\n            maxRetries: this.maxRetries,\n            timeout: this.timeout,\n            logger: this.logger,\n            logLevel: this.logLevel,\n            fetch: this.fetch,\n            fetchOptions: this.fetchOptions,\n            apiKey: this.apiKey,\n            authToken: this.authToken,\n            ...options,\n        });\n        return client;\n    }\n    defaultQuery() {\n        return this._options.defaultQuery;\n    }\n    validateHeaders({ values, nulls }) {\n        if (this.apiKey && values.get('x-api-key')) {\n            return;\n        }\n        if (nulls.has('x-api-key')) {\n            return;\n        }\n        if (this.authToken && values.get('authorization')) {\n            return;\n        }\n        if (nulls.has('authorization')) {\n            return;\n        }\n        throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the \"X-Api-Key\" or \"Authorization\" headers to be explicitly omitted');\n    }\n    async authHeaders(opts) {\n        return (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__.buildHeaders)([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);\n    }\n    async apiKeyAuth(opts) {\n        if (this.apiKey == null) {\n            return undefined;\n        }\n        return (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__.buildHeaders)([{ 'X-Api-Key': this.apiKey }]);\n    }\n    async bearerAuth(opts) {\n        if (this.authToken == null) {\n            return undefined;\n        }\n        return (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__.buildHeaders)([{ Authorization: `Bearer ${this.authToken}` }]);\n    }\n    /**\n     * Basic re-implementation of `qs.stringify` for primitive types.\n     */\n    stringifyQuery(query) {\n        return Object.entries(query)\n            .filter(([_, value]) => typeof value !== 'undefined')\n            .map(([key, value]) => {\n            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n                return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;\n            }\n            if (value === null) {\n                return `${encodeURIComponent(key)}=`;\n            }\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);\n        })\n            .join('&');\n    }\n    getUserAgent() {\n        return `${this.constructor.name}/JS ${_version_mjs__WEBPACK_IMPORTED_MODULE_8__.VERSION}`;\n    }\n    defaultIdempotencyKey() {\n        return `stainless-node-retry-${(0,_internal_utils_uuid_mjs__WEBPACK_IMPORTED_MODULE_1__.uuid4)()}`;\n    }\n    makeStatusError(status, error, message, headers) {\n        return _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIError.generate(status, error, message, headers);\n    }\n    buildURL(path, query, defaultBaseURL) {\n        const baseURL = (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BaseAnthropic_instances, \"m\", _BaseAnthropic_baseURLOverridden).call(this) && defaultBaseURL) || this.baseURL;\n        const url = (0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_2__.isAbsoluteURL)(path) ?\n            new URL(path)\n            : new URL(baseURL + (baseURL.endsWith('/') && path.startsWith('/') ? path.slice(1) : path));\n        const defaultQuery = this.defaultQuery();\n        if (!(0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_2__.isEmptyObj)(defaultQuery)) {\n            query = { ...defaultQuery, ...query };\n        }\n        if (typeof query === 'object' && query && !Array.isArray(query)) {\n            url.search = this.stringifyQuery(query);\n        }\n        return url.toString();\n    }\n    _calculateNonstreamingTimeout(maxTokens) {\n        const defaultTimeout = 10 * 60;\n        const expectedTimeout = (60 * 60 * maxTokens) / 128000;\n        if (expectedTimeout > defaultTimeout) {\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AnthropicError('Streaming is required for operations that may take longer than 10 minutes. ' +\n                'See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details');\n        }\n        return defaultTimeout * 1000;\n    }\n    /**\n     * Used as a callback for mutating the given `FinalRequestOptions` object.\n     */\n    async prepareOptions(options) { }\n    /**\n     * Used as a callback for mutating the given `RequestInit` object.\n     *\n     * This is useful for cases where you want to add certain headers based off of\n     * the request properties, e.g. `method` or `url`.\n     */\n    async prepareRequest(request, { url, options }) { }\n    get(path, opts) {\n        return this.methodRequest('get', path, opts);\n    }\n    post(path, opts) {\n        return this.methodRequest('post', path, opts);\n    }\n    patch(path, opts) {\n        return this.methodRequest('patch', path, opts);\n    }\n    put(path, opts) {\n        return this.methodRequest('put', path, opts);\n    }\n    delete(path, opts) {\n        return this.methodRequest('delete', path, opts);\n    }\n    methodRequest(method, path, opts) {\n        return this.request(Promise.resolve(opts).then((opts) => {\n            return { method, path, ...opts };\n        }));\n    }\n    request(options, remainingRetries = null) {\n        return new _core_api_promise_mjs__WEBPACK_IMPORTED_MODULE_13__.APIPromise(this, this.makeRequest(options, remainingRetries, undefined));\n    }\n    async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {\n        const options = await optionsInput;\n        const maxRetries = options.maxRetries ?? this.maxRetries;\n        if (retriesRemaining == null) {\n            retriesRemaining = maxRetries;\n        }\n        await this.prepareOptions(options);\n        const { req, url, timeout } = await this.buildRequest(options, {\n            retryCount: maxRetries - retriesRemaining,\n        });\n        await this.prepareRequest(req, { url, options });\n        /** Not an API request ID, just for correlating local log entries. */\n        const requestLogID = 'log_' + ((Math.random() * (1 << 24)) | 0).toString(16).padStart(6, '0');\n        const retryLogStr = retryOfRequestLogID === undefined ? '' : `, retryOf: ${retryOfRequestLogID}`;\n        const startTime = Date.now();\n        (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] sending request`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n            retryOfRequestLogID,\n            method: options.method,\n            url,\n            options,\n            headers: req.headers,\n        }));\n        if (options.signal?.aborted) {\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIUserAbortError();\n        }\n        const controller = new AbortController();\n        const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.castToError);\n        const headersTime = Date.now();\n        if (response instanceof globalThis.Error) {\n            const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n            if (options.signal?.aborted) {\n                throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIUserAbortError();\n            }\n            // detect native connection timeout errors\n            // deno throws \"TypeError: error sending request for url (https://example/): client error (Connect): tcp connect error: Operation timed out (os error 60): Operation timed out (os error 60)\"\n            // undici throws \"TypeError: fetch failed\" with cause \"ConnectTimeoutError: Connect Timeout Error (attempted address: example:443, timeout: 1ms)\"\n            // others do not provide enough information to distinguish timeouts from other connection errors\n            const isTimeout = (0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.isAbortError)(response) ||\n                /timed? ?out/i.test(String(response) + ('cause' in response ? String(response.cause) : ''));\n            if (retriesRemaining) {\n                (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - ${retryMessage}`);\n                (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (${retryMessage})`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n                    retryOfRequestLogID,\n                    url,\n                    durationMs: headersTime - startTime,\n                    message: response.message,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);\n            }\n            (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).info(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} - error; no more retries left`);\n            (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] connection ${isTimeout ? 'timed out' : 'failed'} (error; no more retries left)`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n                retryOfRequestLogID,\n                url,\n                durationMs: headersTime - startTime,\n                message: response.message,\n            }));\n            if (isTimeout) {\n                throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIConnectionTimeoutError();\n            }\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIConnectionError({ cause: response });\n        }\n        const specialHeaders = [...response.headers.entries()]\n            .filter(([name]) => name === 'request-id')\n            .map(([name, value]) => ', ' + name + ': ' + JSON.stringify(value))\n            .join('');\n        const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? 'succeeded' : 'failed'} with status ${response.status} in ${headersTime - startTime}ms`;\n        if (!response.ok) {\n            const shouldRetry = await this.shouldRetry(response);\n            if (retriesRemaining && shouldRetry) {\n                const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;\n                // We don't need the body of this response.\n                await _internal_shims_mjs__WEBPACK_IMPORTED_MODULE_6__.CancelReadableStream(response.body);\n                (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).info(`${responseInfo} - ${retryMessage}`);\n                (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage})`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n                    retryOfRequestLogID,\n                    url: response.url,\n                    status: response.status,\n                    headers: response.headers,\n                    durationMs: headersTime - startTime,\n                }));\n                return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);\n            }\n            const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;\n            (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).info(`${responseInfo} - ${retryMessage}`);\n            const errText = await response.text().catch((err) => (0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.castToError)(err).message);\n            const errJSON = (0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_2__.safeJSON)(errText);\n            const errMessage = errJSON ? undefined : errText;\n            (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] response error (${retryMessage})`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n                retryOfRequestLogID,\n                url: response.url,\n                status: response.status,\n                headers: response.headers,\n                message: errMessage,\n                durationMs: Date.now() - startTime,\n            }));\n            const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);\n            throw err;\n        }\n        (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).info(responseInfo);\n        (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.loggerFor)(this).debug(`[${requestLogID}] response start`, (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_20__.formatRequestDetails)({\n            retryOfRequestLogID,\n            url: response.url,\n            status: response.status,\n            headers: response.headers,\n            durationMs: headersTime - startTime,\n        }));\n        return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };\n    }\n    getAPIList(path, Page, opts) {\n        return this.requestAPIList(Page, { method: 'get', path, ...opts });\n    }\n    requestAPIList(Page, options) {\n        const request = this.makeRequest(options, null, undefined);\n        return new _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_10__.PagePromise(this, request, Page);\n    }\n    async fetchWithTimeout(url, init, ms, controller) {\n        const { signal, method, ...options } = init || {};\n        if (signal)\n            signal.addEventListener('abort', () => controller.abort());\n        const timeout = setTimeout(() => controller.abort(), ms);\n        const isReadableBody = (globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream) ||\n            (typeof options.body === 'object' && options.body !== null && Symbol.asyncIterator in options.body);\n        const fetchOptions = {\n            signal: controller.signal,\n            ...(isReadableBody ? { duplex: 'half' } : {}),\n            method: 'GET',\n            ...options,\n        };\n        if (method) {\n            // Custom methods like 'patch' need to be uppercased\n            // See https://github.com/nodejs/undici/issues/2294\n            fetchOptions.method = method.toUpperCase();\n        }\n        try {\n            // use undefined this binding; fetch errors if bound to something else in browser/cloudflare\n            return await this.fetch.call(undefined, url, fetchOptions);\n        }\n        finally {\n            clearTimeout(timeout);\n        }\n    }\n    async shouldRetry(response) {\n        // Note this is not a standard header.\n        const shouldRetryHeader = response.headers.get('x-should-retry');\n        // If the server explicitly says whether or not to retry, obey.\n        if (shouldRetryHeader === 'true')\n            return true;\n        if (shouldRetryHeader === 'false')\n            return false;\n        // Retry on request timeouts.\n        if (response.status === 408)\n            return true;\n        // Retry on lock timeouts.\n        if (response.status === 409)\n            return true;\n        // Retry on rate limits.\n        if (response.status === 429)\n            return true;\n        // Retry internal errors.\n        if (response.status >= 500)\n            return true;\n        return false;\n    }\n    async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {\n        let timeoutMillis;\n        // Note the `retry-after-ms` header may not be standard, but is a good idea and we'd like proactive support for it.\n        const retryAfterMillisHeader = responseHeaders?.get('retry-after-ms');\n        if (retryAfterMillisHeader) {\n            const timeoutMs = parseFloat(retryAfterMillisHeader);\n            if (!Number.isNaN(timeoutMs)) {\n                timeoutMillis = timeoutMs;\n            }\n        }\n        // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n        const retryAfterHeader = responseHeaders?.get('retry-after');\n        if (retryAfterHeader && !timeoutMillis) {\n            const timeoutSeconds = parseFloat(retryAfterHeader);\n            if (!Number.isNaN(timeoutSeconds)) {\n                timeoutMillis = timeoutSeconds * 1000;\n            }\n            else {\n                timeoutMillis = Date.parse(retryAfterHeader) - Date.now();\n            }\n        }\n        // If the API asks us to wait a certain amount of time (and it's a reasonable amount),\n        // just do what it says, but otherwise calculate a default\n        if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {\n            const maxRetries = options.maxRetries ?? this.maxRetries;\n            timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);\n        }\n        await (0,_internal_utils_sleep_mjs__WEBPACK_IMPORTED_MODULE_3__.sleep)(timeoutMillis);\n        return this.makeRequest(options, retriesRemaining - 1, requestLogID);\n    }\n    calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {\n        const initialRetryDelay = 0.5;\n        const maxRetryDelay = 8.0;\n        const numRetries = maxRetries - retriesRemaining;\n        // Apply exponential backoff, but not more than the max.\n        const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);\n        // Apply some jitter, take up to at most 25 percent of the retry time.\n        const jitter = 1 - Math.random() * 0.25;\n        return sleepSeconds * jitter * 1000;\n    }\n    calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {\n        const maxTime = 60 * 60 * 1000; // 60 minutes\n        const defaultTime = 60 * 10 * 1000; // 10 minutes\n        const expectedTime = (maxTime * maxTokens) / 128000;\n        if (expectedTime > defaultTime || (maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens)) {\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AnthropicError('Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details');\n        }\n        return defaultTime;\n    }\n    async buildRequest(inputOptions, { retryCount = 0 } = {}) {\n        const options = { ...inputOptions };\n        const { method, path, query, defaultBaseURL } = options;\n        const url = this.buildURL(path, query, defaultBaseURL);\n        if ('timeout' in options)\n            (0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_2__.validatePositiveInteger)('timeout', options.timeout);\n        options.timeout = options.timeout ?? this.timeout;\n        const { bodyHeaders, body } = this.buildBody({ options });\n        const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });\n        const req = {\n            method,\n            headers: reqHeaders,\n            ...(options.signal && { signal: options.signal }),\n            ...(globalThis.ReadableStream &&\n                body instanceof globalThis.ReadableStream && { duplex: 'half' }),\n            ...(body && { body }),\n            ...(this.fetchOptions ?? {}),\n            ...(options.fetchOptions ?? {}),\n        };\n        return { req, url, timeout: options.timeout };\n    }\n    async buildHeaders({ options, method, bodyHeaders, retryCount, }) {\n        let idempotencyHeaders = {};\n        if (this.idempotencyHeader && method !== 'get') {\n            if (!options.idempotencyKey)\n                options.idempotencyKey = this.defaultIdempotencyKey();\n            idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;\n        }\n        const headers = (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__.buildHeaders)([\n            idempotencyHeaders,\n            {\n                Accept: 'application/json',\n                'User-Agent': this.getUserAgent(),\n                'X-Stainless-Retry-Count': String(retryCount),\n                ...(options.timeout ? { 'X-Stainless-Timeout': String(Math.trunc(options.timeout / 1000)) } : {}),\n                ...(0,_internal_detect_platform_mjs__WEBPACK_IMPORTED_MODULE_5__.getPlatformHeaders)(),\n                ...(this._options.dangerouslyAllowBrowser ?\n                    { 'anthropic-dangerous-direct-browser-access': 'true' }\n                    : undefined),\n                'anthropic-version': '2023-06-01',\n            },\n            await this.authHeaders(options),\n            this._options.defaultHeaders,\n            bodyHeaders,\n            options.headers,\n        ]);\n        this.validateHeaders(headers);\n        return headers.values;\n    }\n    buildBody({ options: { body, headers: rawHeaders } }) {\n        if (!body) {\n            return { bodyHeaders: undefined, body: undefined };\n        }\n        const headers = (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_18__.buildHeaders)([rawHeaders]);\n        if (\n        // Pass raw type verbatim\n        ArrayBuffer.isView(body) ||\n            body instanceof ArrayBuffer ||\n            body instanceof DataView ||\n            (typeof body === 'string' &&\n                // Preserve legacy string encoding behavior for now\n                headers.values.has('content-type')) ||\n            // `Blob` is superset of `File`\n            (globalThis.Blob && body instanceof globalThis.Blob) ||\n            // `FormData` -> `multipart/form-data`\n            body instanceof FormData ||\n            // `URLSearchParams` -> `application/x-www-form-urlencoded`\n            body instanceof URLSearchParams ||\n            // Send chunked stream (each chunk has own `length`)\n            (globalThis.ReadableStream && body instanceof globalThis.ReadableStream)) {\n            return { bodyHeaders: undefined, body: body };\n        }\n        else if (typeof body === 'object' &&\n            (Symbol.asyncIterator in body ||\n                (Symbol.iterator in body && 'next' in body && typeof body.next === 'function'))) {\n            return { bodyHeaders: undefined, body: _internal_shims_mjs__WEBPACK_IMPORTED_MODULE_6__.ReadableStreamFrom(body) };\n        }\n        else {\n            return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BaseAnthropic_encoder, \"f\").call(this, { body, headers });\n        }\n    }\n}\n_a = BaseAnthropic, _BaseAnthropic_encoder = new WeakMap(), _BaseAnthropic_instances = new WeakSet(), _BaseAnthropic_baseURLOverridden = function _BaseAnthropic_baseURLOverridden() {\n    return this.baseURL !== 'https://api.anthropic.com';\n};\nBaseAnthropic.Anthropic = _a;\nBaseAnthropic.HUMAN_PROMPT = HUMAN_PROMPT;\nBaseAnthropic.AI_PROMPT = AI_PROMPT;\nBaseAnthropic.DEFAULT_TIMEOUT = 600000; // 10 minutes\nBaseAnthropic.AnthropicError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AnthropicError;\nBaseAnthropic.APIError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIError;\nBaseAnthropic.APIConnectionError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIConnectionError;\nBaseAnthropic.APIConnectionTimeoutError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIConnectionTimeoutError;\nBaseAnthropic.APIUserAbortError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.APIUserAbortError;\nBaseAnthropic.NotFoundError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.NotFoundError;\nBaseAnthropic.ConflictError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.ConflictError;\nBaseAnthropic.RateLimitError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.RateLimitError;\nBaseAnthropic.BadRequestError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.BadRequestError;\nBaseAnthropic.AuthenticationError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.AuthenticationError;\nBaseAnthropic.InternalServerError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.InternalServerError;\nBaseAnthropic.PermissionDeniedError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.PermissionDeniedError;\nBaseAnthropic.UnprocessableEntityError = _core_error_mjs__WEBPACK_IMPORTED_MODULE_9__.UnprocessableEntityError;\nBaseAnthropic.toFile = _core_uploads_mjs__WEBPACK_IMPORTED_MODULE_11__.toFile;\n/**\n * API Client for interfacing with the Anthropic API.\n */\nclass Anthropic extends BaseAnthropic {\n    constructor() {\n        super(...arguments);\n        this.completions = new _resources_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Completions(this);\n        this.messages = new _resources_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Messages(this);\n        this.models = new _resources_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Models(this);\n        this.beta = new _resources_index_mjs__WEBPACK_IMPORTED_MODULE_12__.Beta(this);\n    }\n}\nAnthropic.Completions = _resources_completions_mjs__WEBPACK_IMPORTED_MODULE_14__.Completions;\nAnthropic.Messages = _resources_messages_messages_mjs__WEBPACK_IMPORTED_MODULE_17__.Messages;\nAnthropic.Models = _resources_models_mjs__WEBPACK_IMPORTED_MODULE_15__.Models;\nAnthropic.Beta = _resources_beta_beta_mjs__WEBPACK_IMPORTED_MODULE_16__.Beta;\n//# sourceMappingURL=client.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NsaWVudC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Y7QUFDcEM7QUFDNkM7QUFDNUM7QUFDZTtBQUNFO0FBQ3RCO0FBQ1M7QUFDZjtBQUNHO0FBQ1M7QUFDTjtBQUNEO0FBQ087QUFDTztBQUNYO0FBQ0U7QUFDWTtBQUNNO0FBQ2Q7QUFDSDtBQUN3QztBQUNsQztBQUNsRDtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsbUJBQW1CO0FBQ2xDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsb0NBQW9DO0FBQ25ELGVBQWUsU0FBUztBQUN4QjtBQUNBLGtCQUFrQixVQUFVLGlFQUFPLGlDQUFpQyxpRUFBTywyQ0FBMkMsaUVBQU8sNENBQTRDLElBQUk7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxpRkFBa0I7QUFDbEUsc0JBQXNCLDJEQUFxQiwyVEFBMlQsdUNBQXVDLEVBQUU7QUFDL1k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUVBQWE7QUFDekIsZ0JBQWdCLHVFQUFhLENBQUMsaUVBQU87QUFDckM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdFQUFxQjtBQUMzRCxRQUFRLDJFQUFzQiwrQkFBK0IsMEVBQW9CO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFD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QXFCLDhCQUE4QixtRUFBd0I7QUFDM0U7QUFDQTtBQUNBLG1CQUFtQiwyRUFBc0IsaURBQWlELGVBQWU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLCtCQUErQiwyREFBcUI7QUFDcEQseUJBQXlCLHFEQUFlO0FBQ3hDLG1DQUFtQywrREFBeUI7QUFDNUQsMENBQTBDLHNFQUFnQztBQUMxRSxrQ0FBa0MsOERBQXdCO0FBQzFELDhCQUE4QiwwREFBb0I7QUFDbEQsOEJBQThCLDBEQUFvQjtBQUNsRCwrQkFBK0IsMkRBQXFCO0FBQ3BELGdDQUFnQyw0REFBc0I7QUFDdEQsb0NBQW9DLGdFQUEwQjtBQUM5RCxvQ0FBb0MsZ0VBQTBCO0FBQzlELHNDQUFzQyxrRUFBNEI7QUFDbEUseUNBQXlDLHFFQUErQjtBQUN4RSx1QkFBdUIsc0RBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsK0JBQStCLDhEQUFlO0FBQzlDLDRCQUE0QiwyREFBWTtBQUN4QywwQkFBMEIseURBQVU7QUFDcEMsd0JBQXdCLHVEQUFRO0FBQ2hDO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQVc7QUFDbkMscUJBQXFCLHVFQUFRO0FBQzdCLG1CQUFtQiwwREFBTTtBQUN6QixpQkFBaUIsMkRBQUk7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9jbGllbnQubWpzPzQxMTkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbnZhciBfQmFzZUFudGhyb3BpY19pbnN0YW5jZXMsIF9hLCBfQmFzZUFudGhyb3BpY19lbmNvZGVyLCBfQmFzZUFudGhyb3BpY19iYXNlVVJMT3ZlcnJpZGRlbjtcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwiLi9pbnRlcm5hbC90c2xpYi5tanNcIjtcbmltcG9ydCB7IHV1aWQ0IH0gZnJvbSBcIi4vaW50ZXJuYWwvdXRpbHMvdXVpZC5tanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyLCBpc0Fic29sdXRlVVJMLCBzYWZlSlNPTiB9IGZyb20gXCIuL2ludGVybmFsL3V0aWxzL3ZhbHVlcy5tanNcIjtcbmltcG9ydCB7IHNsZWVwIH0gZnJvbSBcIi4vaW50ZXJuYWwvdXRpbHMvc2xlZXAubWpzXCI7XG5pbXBvcnQgeyBjYXN0VG9FcnJvciwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIi4vaW50ZXJuYWwvZXJyb3JzLm1qc1wiO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm1IZWFkZXJzIH0gZnJvbSBcIi4vaW50ZXJuYWwvZGV0ZWN0LXBsYXRmb3JtLm1qc1wiO1xuaW1wb3J0ICogYXMgU2hpbXMgZnJvbSBcIi4vaW50ZXJuYWwvc2hpbXMubWpzXCI7XG5pbXBvcnQgKiBhcyBPcHRzIGZyb20gXCIuL2ludGVybmFsL3JlcXVlc3Qtb3B0aW9ucy5tanNcIjtcbmltcG9ydCB7IFZFUlNJT04gfSBmcm9tIFwiLi92ZXJzaW9uLm1qc1wiO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gXCIuL2NvcmUvZXJyb3IubWpzXCI7XG5pbXBvcnQgKiBhcyBQYWdpbmF0aW9uIGZyb20gXCIuL2NvcmUvcGFnaW5hdGlvbi5tanNcIjtcbmltcG9ydCAqIGFzIFVwbG9hZHMgZnJvbSBcIi4vY29yZS91cGxvYWRzLm1qc1wiO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL3Jlc291cmNlcy9pbmRleC5tanNcIjtcbmltcG9ydCB7IEFQSVByb21pc2UgfSBmcm9tIFwiLi9jb3JlL2FwaS1wcm9taXNlLm1qc1wiO1xuaW1wb3J0IHsgQ29tcGxldGlvbnMsIH0gZnJvbSBcIi4vcmVzb3VyY2VzL2NvbXBsZXRpb25zLm1qc1wiO1xuaW1wb3J0IHsgTW9kZWxzIH0gZnJvbSBcIi4vcmVzb3VyY2VzL21vZGVscy5tanNcIjtcbmltcG9ydCB7IEJldGEsIH0gZnJvbSBcIi4vcmVzb3VyY2VzL2JldGEvYmV0YS5tanNcIjtcbmltcG9ydCB7IE1lc3NhZ2VzLCB9IGZyb20gXCIuL3Jlc291cmNlcy9tZXNzYWdlcy9tZXNzYWdlcy5tanNcIjtcbmltcG9ydCB7IGlzUnVubmluZ0luQnJvd3NlciB9IGZyb20gXCIuL2ludGVybmFsL2RldGVjdC1wbGF0Zm9ybS5tanNcIjtcbmltcG9ydCB7IGJ1aWxkSGVhZGVycyB9IGZyb20gXCIuL2ludGVybmFsL2hlYWRlcnMubWpzXCI7XG5pbXBvcnQgeyByZWFkRW52IH0gZnJvbSBcIi4vaW50ZXJuYWwvdXRpbHMvZW52Lm1qc1wiO1xuaW1wb3J0IHsgZm9ybWF0UmVxdWVzdERldGFpbHMsIGxvZ2dlckZvciwgcGFyc2VMb2dMZXZlbCwgfSBmcm9tIFwiLi9pbnRlcm5hbC91dGlscy9sb2cubWpzXCI7XG5pbXBvcnQgeyBpc0VtcHR5T2JqIH0gZnJvbSBcIi4vaW50ZXJuYWwvdXRpbHMvdmFsdWVzLm1qc1wiO1xuZXhwb3J0IGNvbnN0IEhVTUFOX1BST01QVCA9ICdcXFxcblxcXFxuSHVtYW46JztcbmV4cG9ydCBjb25zdCBBSV9QUk9NUFQgPSAnXFxcXG5cXFxcbkFzc2lzdGFudDonO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBBbnRocm9waWMgQVBJIGNsaWVudHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlQW50aHJvcGljIHtcbiAgICAvKipcbiAgICAgKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBbnRocm9waWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0cy5hcGlLZXk9cHJvY2Vzcy5lbnZbJ0FOVEhST1BJQ19BUElfS0VZJ10gPz8gbnVsbF1cbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRzLmF1dGhUb2tlbj1wcm9jZXNzLmVudlsnQU5USFJPUElDX0FVVEhfVE9LRU4nXSA/PyBudWxsXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5iYXNlVVJMPXByb2Nlc3MuZW52WydBTlRIUk9QSUNfQkFTRV9VUkwnXSA/PyBodHRwczovL2FwaS5hbnRocm9waWMuY29tXSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0cy50aW1lb3V0PTEwIG1pbnV0ZXNdIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdGhlIGNsaWVudCB3aWxsIHdhaXQgZm9yIGEgcmVzcG9uc2UgYmVmb3JlIHRpbWluZyBvdXQuXG4gICAgICogQHBhcmFtIHtNZXJnZWRSZXF1ZXN0SW5pdH0gW29wdHMuZmV0Y2hPcHRpb25zXSAtIEFkZGl0aW9uYWwgYFJlcXVlc3RJbml0YCBvcHRpb25zIHRvIGJlIHBhc3NlZCB0byBgZmV0Y2hgIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7RmV0Y2h9IFtvcHRzLmZldGNoXSAtIFNwZWNpZnkgYSBjdXN0b20gYGZldGNoYCBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB7SGVhZGVyc0xpa2V9IG9wdHMuZGVmYXVsdEhlYWRlcnMgLSBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD59IG9wdHMuZGVmYXVsdFF1ZXJ5IC0gRGVmYXVsdCBxdWVyeSBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgd2l0aCBldmVyeSByZXF1ZXN0IHRvIHRoZSBBUEkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5kYW5nZXJvdXNseUFsbG93QnJvd3Nlcj1mYWxzZV0gLSBCeSBkZWZhdWx0LCBjbGllbnQtc2lkZSB1c2Ugb2YgdGhpcyBsaWJyYXJ5IGlzIG5vdCBhbGxvd2VkLCBhcyBpdCByaXNrcyBleHBvc2luZyB5b3VyIHNlY3JldCBBUEkgY3JlZGVudGlhbHMgdG8gYXR0YWNrZXJzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgYmFzZVVSTCA9IHJlYWRFbnYoJ0FOVEhST1BJQ19CQVNFX1VSTCcpLCBhcGlLZXkgPSByZWFkRW52KCdBTlRIUk9QSUNfQVBJX0tFWScpID8/IG51bGwsIGF1dGhUb2tlbiA9IHJlYWRFbnYoJ0FOVEhST1BJQ19BVVRIX1RPS0VOJykgPz8gbnVsbCwgLi4ub3B0cyB9ID0ge30pIHtcbiAgICAgICAgX0Jhc2VBbnRocm9waWNfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX0Jhc2VBbnRocm9waWNfZW5jb2Rlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgIGF1dGhUb2tlbixcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBiYXNlVVJMOiBiYXNlVVJMIHx8IGBodHRwczovL2FwaS5hbnRocm9waWMuY29tYCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyICYmIGlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkFudGhyb3BpY0Vycm9yKFwiSXQgbG9va3MgbGlrZSB5b3UncmUgcnVubmluZyBpbiBhIGJyb3dzZXItbGlrZSBlbnZpcm9ubWVudC5cXG5cXG5UaGlzIGlzIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXFxuSWYgeW91IHVuZGVyc3RhbmQgdGhlIHJpc2tzIGFuZCBoYXZlIGFwcHJvcHJpYXRlIG1pdGlnYXRpb25zIGluIHBsYWNlLFxcbnlvdSBjYW4gc2V0IHRoZSBgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXJgIG9wdGlvbiB0byBgdHJ1ZWAsIGUuZy4sXFxuXFxubmV3IEFudGhyb3BpYyh7IGFwaUtleSwgZGFuZ2Vyb3VzbHlBbGxvd0Jyb3dzZXI6IHRydWUgfSk7XFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFzZVVSTCA9IG9wdGlvbnMuYmFzZVVSTDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IF9hLkRFRkFVTFRfVElNRU9VVCAvKiAxMCBtaW51dGVzICovO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IG9wdGlvbnMubG9nZ2VyID8/IGNvbnNvbGU7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRMb2dMZXZlbCA9ICd3YXJuJztcbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgbG9nTGV2ZWwgZWFybHkgc28gdGhhdCB3ZSBjYW4gbG9nIGEgd2FybmluZyBpbiBwYXJzZUxvZ0xldmVsLlxuICAgICAgICB0aGlzLmxvZ0xldmVsID0gZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICB0aGlzLmxvZ0xldmVsID1cbiAgICAgICAgICAgIHBhcnNlTG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCwgJ0NsaWVudE9wdGlvbnMubG9nTGV2ZWwnLCB0aGlzKSA/P1xuICAgICAgICAgICAgICAgIHBhcnNlTG9nTGV2ZWwocmVhZEVudignQU5USFJPUElDX0xPRycpLCBcInByb2Nlc3MuZW52WydBTlRIUk9QSUNfTE9HJ11cIiwgdGhpcykgPz9cbiAgICAgICAgICAgICAgICBkZWZhdWx0TG9nTGV2ZWw7XG4gICAgICAgIHRoaXMuZmV0Y2hPcHRpb25zID0gb3B0aW9ucy5mZXRjaE9wdGlvbnM7XG4gICAgICAgIHRoaXMubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcyA/PyAyO1xuICAgICAgICB0aGlzLmZldGNoID0gb3B0aW9ucy5mZXRjaCA/PyBTaGltcy5nZXREZWZhdWx0RmV0Y2goKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmFzZUFudGhyb3BpY19lbmNvZGVyLCBPcHRzLkZhbGxiYWNrRW5jb2RlciwgXCJmXCIpO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBhcGlLZXk7XG4gICAgICAgIHRoaXMuYXV0aFRva2VuID0gYXV0aFRva2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgY2xpZW50IGluc3RhbmNlIHJlLXVzaW5nIHRoZSBzYW1lIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlIGN1cnJlbnQgY2xpZW50IHdpdGggb3B0aW9uYWwgb3ZlcnJpZGluZy5cbiAgICAgKi9cbiAgICB3aXRoT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgICBiYXNlVVJMOiB0aGlzLmJhc2VVUkwsXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiB0aGlzLm1heFJldHJpZXMsXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICAgICAgICBsb2dnZXI6IHRoaXMubG9nZ2VyLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IHRoaXMubG9nTGV2ZWwsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIGZldGNoT3B0aW9uczogdGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmF1dGhUb2tlbixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xpZW50O1xuICAgIH1cbiAgICBkZWZhdWx0UXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmRlZmF1bHRRdWVyeTtcbiAgICB9XG4gICAgdmFsaWRhdGVIZWFkZXJzKHsgdmFsdWVzLCBudWxscyB9KSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSAmJiB2YWx1ZXMuZ2V0KCd4LWFwaS1rZXknKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxscy5oYXMoJ3gtYXBpLWtleScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuICYmIHZhbHVlcy5nZXQoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudWxscy5oYXMoJ2F1dGhvcml6YXRpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlc29sdmUgYXV0aGVudGljYXRpb24gbWV0aG9kLiBFeHBlY3RlZCBlaXRoZXIgYXBpS2V5IG9yIGF1dGhUb2tlbiB0byBiZSBzZXQuIE9yIGZvciBvbmUgb2YgdGhlIFwiWC1BcGktS2V5XCIgb3IgXCJBdXRob3JpemF0aW9uXCIgaGVhZGVycyB0byBiZSBleHBsaWNpdGx5IG9taXR0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgYXV0aEhlYWRlcnMob3B0cykge1xuICAgICAgICByZXR1cm4gYnVpbGRIZWFkZXJzKFthd2FpdCB0aGlzLmFwaUtleUF1dGgob3B0cyksIGF3YWl0IHRoaXMuYmVhcmVyQXV0aChvcHRzKV0pO1xuICAgIH1cbiAgICBhc3luYyBhcGlLZXlBdXRoKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVycyhbeyAnWC1BcGktS2V5JzogdGhpcy5hcGlLZXkgfV0pO1xuICAgIH1cbiAgICBhc3luYyBiZWFyZXJBdXRoKG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSGVhZGVycyhbeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hdXRoVG9rZW59YCB9XSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2ljIHJlLWltcGxlbWVudGF0aW9uIG9mIGBxcy5zdHJpbmdpZnlgIGZvciBwcmltaXRpdmUgdHlwZXMuXG4gICAgICovXG4gICAgc3RyaW5naWZ5UXVlcnkocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHF1ZXJ5KVxuICAgICAgICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkFudGhyb3BpY0Vycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcmJyk7XG4gICAgfVxuICAgIGdldFVzZXJBZ2VudCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0vSlMgJHtWRVJTSU9OfWA7XG4gICAgfVxuICAgIGRlZmF1bHRJZGVtcG90ZW5jeUtleSgpIHtcbiAgICAgICAgcmV0dXJuIGBzdGFpbmxlc3Mtbm9kZS1yZXRyeS0ke3V1aWQ0KCl9YDtcbiAgICB9XG4gICAgbWFrZVN0YXR1c0Vycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpIHtcbiAgICAgICAgcmV0dXJuIEVycm9ycy5BUElFcnJvci5nZW5lcmF0ZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG4gICAgYnVpbGRVUkwocGF0aCwgcXVlcnksIGRlZmF1bHRCYXNlVVJMKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVUkwgPSAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VBbnRocm9waWNfaW5zdGFuY2VzLCBcIm1cIiwgX0Jhc2VBbnRocm9waWNfYmFzZVVSTE92ZXJyaWRkZW4pLmNhbGwodGhpcykgJiYgZGVmYXVsdEJhc2VVUkwpIHx8IHRoaXMuYmFzZVVSTDtcbiAgICAgICAgY29uc3QgdXJsID0gaXNBYnNvbHV0ZVVSTChwYXRoKSA/XG4gICAgICAgICAgICBuZXcgVVJMKHBhdGgpXG4gICAgICAgICAgICA6IG5ldyBVUkwoYmFzZVVSTCArIChiYXNlVVJMLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykgPyBwYXRoLnNsaWNlKDEpIDogcGF0aCkpO1xuICAgICAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgICAgICBpZiAoIWlzRW1wdHlPYmooZGVmYXVsdFF1ZXJ5KSkge1xuICAgICAgICAgICAgcXVlcnkgPSB7IC4uLmRlZmF1bHRRdWVyeSwgLi4ucXVlcnkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIF9jYWxjdWxhdGVOb25zdHJlYW1pbmdUaW1lb3V0KG1heFRva2Vucykge1xuICAgICAgICBjb25zdCBkZWZhdWx0VGltZW91dCA9IDEwICogNjA7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVGltZW91dCA9ICg2MCAqIDYwICogbWF4VG9rZW5zKSAvIDEyODAwMDtcbiAgICAgICAgaWYgKGV4cGVjdGVkVGltZW91dCA+IGRlZmF1bHRUaW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkFudGhyb3BpY0Vycm9yKCdTdHJlYW1pbmcgaXMgcmVxdWlyZWQgZm9yIG9wZXJhdGlvbnMgdGhhdCBtYXkgdGFrZSBsb25nZXIgdGhhbiAxMCBtaW51dGVzLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRocm9waWNzL2FudGhyb3BpYy1zZGstdHlwZXNjcmlwdCNzdHJlYW1pbmctcmVzcG9uc2VzIGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFRpbWVvdXQgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgRmluYWxSZXF1ZXN0T3B0aW9uc2Agb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHByZXBhcmVPcHRpb25zKG9wdGlvbnMpIHsgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgYXMgYSBjYWxsYmFjayBmb3IgbXV0YXRpbmcgdGhlIGdpdmVuIGBSZXF1ZXN0SW5pdGAgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdSB3YW50IHRvIGFkZCBjZXJ0YWluIGhlYWRlcnMgYmFzZWQgb2ZmIG9mXG4gICAgICogdGhlIHJlcXVlc3QgcHJvcGVydGllcywgZS5nLiBgbWV0aG9kYCBvciBgdXJsYC5cbiAgICAgKi9cbiAgICBhc3luYyBwcmVwYXJlUmVxdWVzdChyZXF1ZXN0LCB7IHVybCwgb3B0aW9ucyB9KSB7IH1cbiAgICBnZXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcG9zdChwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3Bvc3QnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgcGF0Y2gocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwYXRjaCcsIHBhdGgsIG9wdHMpO1xuICAgIH1cbiAgICBwdXQocGF0aCwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgICB9XG4gICAgZGVsZXRlKHBhdGgsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kUmVxdWVzdCgnZGVsZXRlJywgcGF0aCwgb3B0cyk7XG4gICAgfVxuICAgIG1ldGhvZFJlcXVlc3QobWV0aG9kLCBwYXRoLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoUHJvbWlzZS5yZXNvbHZlKG9wdHMpLnRoZW4oKG9wdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGhvZCwgcGF0aCwgLi4ub3B0cyB9O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMsIHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcywgdW5kZWZpbmVkKSk7XG4gICAgfVxuICAgIGFzeW5jIG1ha2VSZXF1ZXN0KG9wdGlvbnNJbnB1dCwgcmV0cmllc1JlbWFpbmluZywgcmV0cnlPZlJlcXVlc3RMb2dJRCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc0lucHV0O1xuICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IHRoaXMubWF4UmV0cmllcztcbiAgICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0cmllc1JlbWFpbmluZyA9IG1heFJldHJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyByZXEsIHVybCwgdGltZW91dCB9ID0gYXdhaXQgdGhpcy5idWlsZFJlcXVlc3Qob3B0aW9ucywge1xuICAgICAgICAgICAgcmV0cnlDb3VudDogbWF4UmV0cmllcyAtIHJldHJpZXNSZW1haW5pbmcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVSZXF1ZXN0KHJlcSwgeyB1cmwsIG9wdGlvbnMgfSk7XG4gICAgICAgIC8qKiBOb3QgYW4gQVBJIHJlcXVlc3QgSUQsIGp1c3QgZm9yIGNvcnJlbGF0aW5nIGxvY2FsIGxvZyBlbnRyaWVzLiAqL1xuICAgICAgICBjb25zdCByZXF1ZXN0TG9nSUQgPSAnbG9nXycgKyAoKE1hdGgucmFuZG9tKCkgKiAoMSA8PCAyNCkpIHwgMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDYsICcwJyk7XG4gICAgICAgIGNvbnN0IHJldHJ5TG9nU3RyID0gcmV0cnlPZlJlcXVlc3RMb2dJRCA9PT0gdW5kZWZpbmVkID8gJycgOiBgLCByZXRyeU9mOiAke3JldHJ5T2ZSZXF1ZXN0TG9nSUR9YDtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSBzZW5kaW5nIHJlcXVlc3RgLCBmb3JtYXRSZXF1ZXN0RGV0YWlscyh7XG4gICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXEuaGVhZGVycyxcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2hXaXRoVGltZW91dCh1cmwsIHJlcSwgdGltZW91dCwgY29udHJvbGxlcikuY2F0Y2goY2FzdFRvRXJyb3IpO1xuICAgICAgICBjb25zdCBoZWFkZXJzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IGByZXRyeWluZywgJHtyZXRyaWVzUmVtYWluaW5nfSBhdHRlbXB0cyByZW1haW5pbmdgO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5BUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGV0ZWN0IG5hdGl2ZSBjb25uZWN0aW9uIHRpbWVvdXQgZXJyb3JzXG4gICAgICAgICAgICAvLyBkZW5vIHRocm93cyBcIlR5cGVFcnJvcjogZXJyb3Igc2VuZGluZyByZXF1ZXN0IGZvciB1cmwgKGh0dHBzOi8vZXhhbXBsZS8pOiBjbGllbnQgZXJyb3IgKENvbm5lY3QpOiB0Y3AgY29ubmVjdCBlcnJvcjogT3BlcmF0aW9uIHRpbWVkIG91dCAob3MgZXJyb3IgNjApOiBPcGVyYXRpb24gdGltZWQgb3V0IChvcyBlcnJvciA2MClcIlxuICAgICAgICAgICAgLy8gdW5kaWNpIHRocm93cyBcIlR5cGVFcnJvcjogZmV0Y2ggZmFpbGVkXCIgd2l0aCBjYXVzZSBcIkNvbm5lY3RUaW1lb3V0RXJyb3I6IENvbm5lY3QgVGltZW91dCBFcnJvciAoYXR0ZW1wdGVkIGFkZHJlc3M6IGV4YW1wbGU6NDQzLCB0aW1lb3V0OiAxbXMpXCJcbiAgICAgICAgICAgIC8vIG90aGVycyBkbyBub3QgcHJvdmlkZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZGlzdGluZ3Vpc2ggdGltZW91dHMgZnJvbSBvdGhlciBjb25uZWN0aW9uIGVycm9yc1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lb3V0ID0gaXNBYm9ydEVycm9yKHJlc3BvbnNlKSB8fFxuICAgICAgICAgICAgICAgIC90aW1lZD8gP291dC9pLnRlc3QoU3RyaW5nKHJlc3BvbnNlKSArICgnY2F1c2UnIGluIHJlc3BvbnNlID8gU3RyaW5nKHJlc3BvbnNlLmNhdXNlKSA6ICcnKSk7XG4gICAgICAgICAgICBpZiAocmV0cmllc1JlbWFpbmluZykge1xuICAgICAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5pbmZvKGBbJHtyZXF1ZXN0TG9nSUR9XSBjb25uZWN0aW9uICR7aXNUaW1lb3V0ID8gJ3RpbWVkIG91dCcgOiAnZmFpbGVkJ30gLSAke3JldHJ5TWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIGNvbm5lY3Rpb24gJHtpc1RpbWVvdXQgPyAndGltZWQgb3V0JyA6ICdmYWlsZWQnfSAoJHtyZXRyeU1lc3NhZ2V9KWAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbk1zOiBoZWFkZXJzVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJldHJ5T2ZSZXF1ZXN0TG9nSUQgPz8gcmVxdWVzdExvZ0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5pbmZvKGBbJHtyZXF1ZXN0TG9nSUR9XSBjb25uZWN0aW9uICR7aXNUaW1lb3V0ID8gJ3RpbWVkIG91dCcgOiAnZmFpbGVkJ30gLSBlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnRgKTtcbiAgICAgICAgICAgIGxvZ2dlckZvcih0aGlzKS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gY29ubmVjdGlvbiAke2lzVGltZW91dCA/ICd0aW1lZCBvdXQnIDogJ2ZhaWxlZCd9IChlcnJvcjsgbm8gbW9yZSByZXRyaWVzIGxlZnQpYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgICAgIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uTXM6IGhlYWRlcnNUaW1lIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLm1lc3NhZ2UsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5BUElDb25uZWN0aW9uVGltZW91dEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGVjaWFsSGVhZGVycyA9IFsuLi5yZXNwb25zZS5oZWFkZXJzLmVudHJpZXMoKV1cbiAgICAgICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4gbmFtZSA9PT0gJ3JlcXVlc3QtaWQnKVxuICAgICAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gJywgJyArIG5hbWUgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICBjb25zdCByZXNwb25zZUluZm8gPSBgWyR7cmVxdWVzdExvZ0lEfSR7cmV0cnlMb2dTdHJ9JHtzcGVjaWFsSGVhZGVyc31dICR7cmVxLm1ldGhvZH0gJHt1cmx9ICR7cmVzcG9uc2Uub2sgPyAnc3VjY2VlZGVkJyA6ICdmYWlsZWQnfSB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c30gaW4gJHtoZWFkZXJzVGltZSAtIHN0YXJ0VGltZX1tc2A7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJldHJ5ID0gYXdhaXQgdGhpcy5zaG91bGRSZXRyeShyZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAocmV0cmllc1JlbWFpbmluZyAmJiBzaG91bGRSZXRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IGByZXRyeWluZywgJHtyZXRyaWVzUmVtYWluaW5nfSBhdHRlbXB0cyByZW1haW5pbmdgO1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdGhlIGJvZHkgb2YgdGhpcyByZXNwb25zZS5cbiAgICAgICAgICAgICAgICBhd2FpdCBTaGltcy5DYW5jZWxSZWFkYWJsZVN0cmVhbShyZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgICBsb2dnZXJGb3IodGhpcykuaW5mbyhgJHtyZXNwb25zZUluZm99IC0gJHtyZXRyeU1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSByZXNwb25zZSBlcnJvciAoJHtyZXRyeU1lc3NhZ2V9KWAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZXNwb25zZS51cmwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbk1zOiBoZWFkZXJzVGltZSAtIHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJldHJ5T2ZSZXF1ZXN0TG9nSUQgPz8gcmVxdWVzdExvZ0lELCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IHNob3VsZFJldHJ5ID8gYGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdGAgOiBgZXJyb3I7IG5vdCByZXRyeWFibGVgO1xuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmluZm8oYCR7cmVzcG9uc2VJbmZvfSAtICR7cmV0cnlNZXNzYWdlfWApO1xuICAgICAgICAgICAgY29uc3QgZXJyVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoZXJyKSA9PiBjYXN0VG9FcnJvcihlcnIpLm1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgZXJySlNPTiA9IHNhZmVKU09OKGVyclRleHQpO1xuICAgICAgICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGVyckpTT04gPyB1bmRlZmluZWQgOiBlcnJUZXh0O1xuICAgICAgICAgICAgbG9nZ2VyRm9yKHRoaXMpLmRlYnVnKGBbJHtyZXF1ZXN0TG9nSUR9XSByZXNwb25zZSBlcnJvciAoJHtyZXRyeU1lc3NhZ2V9KWAsIGZvcm1hdFJlcXVlc3REZXRhaWxzKHtcbiAgICAgICAgICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbk1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgZXJyID0gdGhpcy5tYWtlU3RhdHVzRXJyb3IocmVzcG9uc2Uuc3RhdHVzLCBlcnJKU09OLCBlcnJNZXNzYWdlLCByZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJGb3IodGhpcykuaW5mbyhyZXNwb25zZUluZm8pO1xuICAgICAgICBsb2dnZXJGb3IodGhpcykuZGVidWcoYFske3JlcXVlc3RMb2dJRH1dIHJlc3BvbnNlIHN0YXJ0YCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICAgICAgcmV0cnlPZlJlcXVlc3RMb2dJRCxcbiAgICAgICAgICAgIHVybDogcmVzcG9uc2UudXJsLFxuICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgZHVyYXRpb25NczogaGVhZGVyc1RpbWUgLSBzdGFydFRpbWUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHsgcmVzcG9uc2UsIG9wdGlvbnMsIGNvbnRyb2xsZXIsIHJlcXVlc3RMb2dJRCwgcmV0cnlPZlJlcXVlc3RMb2dJRCwgc3RhcnRUaW1lIH07XG4gICAgfVxuICAgIGdldEFQSUxpc3QocGF0aCwgUGFnZSwgb3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QVBJTGlzdChQYWdlLCB7IG1ldGhvZDogJ2dldCcsIHBhdGgsIC4uLm9wdHMgfSk7XG4gICAgfVxuICAgIHJlcXVlc3RBUElMaXN0KFBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgbnVsbCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWdpbmF0aW9uLlBhZ2VQcm9taXNlKHRoaXMsIHJlcXVlc3QsIFBhZ2UpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KHVybCwgaW5pdCwgbXMsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICAgICAgaWYgKHNpZ25hbClcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgbXMpO1xuICAgICAgICBjb25zdCBpc1JlYWRhYmxlQm9keSA9IChnbG9iYWxUaGlzLlJlYWRhYmxlU3RyZWFtICYmIG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5ib2R5ICE9PSBudWxsICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIG9wdGlvbnMuYm9keSk7XG4gICAgICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgICAgICAuLi4oaXNSZWFkYWJsZUJvZHkgPyB7IGR1cGxleDogJ2hhbGYnIH0gOiB7fSksXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIG1ldGhvZHMgbGlrZSAncGF0Y2gnIG5lZWQgdG8gYmUgdXBwZXJjYXNlZFxuICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMjk0XG4gICAgICAgICAgICBmZXRjaE9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHVzZSB1bmRlZmluZWQgdGhpcyBiaW5kaW5nOyBmZXRjaCBlcnJvcnMgaWYgYm91bmQgdG8gc29tZXRoaW5nIGVsc2UgaW4gYnJvd3Nlci9jbG91ZGZsYXJlXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5mZXRjaC5jYWxsKHVuZGVmaW5lZCwgdXJsLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNob3VsZFJldHJ5KHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgYSBzdGFuZGFyZCBoZWFkZXIuXG4gICAgICAgIGNvbnN0IHNob3VsZFJldHJ5SGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtc2hvdWxkLXJldHJ5Jyk7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgZXhwbGljaXRseSBzYXlzIHdoZXRoZXIgb3Igbm90IHRvIHJldHJ5LCBvYmV5LlxuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICd0cnVlJylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoc2hvdWxkUmV0cnlIZWFkZXIgPT09ICdmYWxzZScpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFJldHJ5IG9uIHJlcXVlc3QgdGltZW91dHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwOClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBvbiBsb2NrIHRpbWVvdXRzLlxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQyOSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBSZXRyeSBpbnRlcm5hbCBlcnJvcnMuXG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gNTAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcmV0cnlSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcsIHJlcXVlc3RMb2dJRCwgcmVzcG9uc2VIZWFkZXJzKSB7XG4gICAgICAgIGxldCB0aW1lb3V0TWlsbGlzO1xuICAgICAgICAvLyBOb3RlIHRoZSBgcmV0cnktYWZ0ZXItbXNgIGhlYWRlciBtYXkgbm90IGJlIHN0YW5kYXJkLCBidXQgaXMgYSBnb29kIGlkZWEgYW5kIHdlJ2QgbGlrZSBwcm9hY3RpdmUgc3VwcG9ydCBmb3IgaXQuXG4gICAgICAgIGNvbnN0IHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LmdldCgncmV0cnktYWZ0ZXItbXMnKTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRNcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlck1pbGxpc0hlYWRlcik7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTih0aW1lb3V0TXMpKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRNcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBYm91dCB0aGUgUmV0cnktQWZ0ZXIgaGVhZGVyOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmV0cnktQWZ0ZXJcbiAgICAgICAgY29uc3QgcmV0cnlBZnRlckhlYWRlciA9IHJlc3BvbnNlSGVhZGVycz8uZ2V0KCdyZXRyeS1hZnRlcicpO1xuICAgICAgICBpZiAocmV0cnlBZnRlckhlYWRlciAmJiAhdGltZW91dE1pbGxpcykge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFNlY29uZHMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJIZWFkZXIpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRTZWNvbmRzICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSBEYXRlLnBhcnNlKHJldHJ5QWZ0ZXJIZWFkZXIpIC0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgQVBJIGFza3MgdXMgdG8gd2FpdCBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUgKGFuZCBpdCdzIGEgcmVhc29uYWJsZSBhbW91bnQpLFxuICAgICAgICAvLyBqdXN0IGRvIHdoYXQgaXQgc2F5cywgYnV0IG90aGVyd2lzZSBjYWxjdWxhdGUgYSBkZWZhdWx0XG4gICAgICAgIGlmICghKHRpbWVvdXRNaWxsaXMgJiYgMCA8PSB0aW1lb3V0TWlsbGlzICYmIHRpbWVvdXRNaWxsaXMgPCA2MCAqIDEwMDApKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IHRoaXMubWF4UmV0cmllcztcbiAgICAgICAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aGlzLmNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZywgbWF4UmV0cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgc2xlZXAodGltZW91dE1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1ha2VSZXF1ZXN0KG9wdGlvbnMsIHJldHJpZXNSZW1haW5pbmcgLSAxLCByZXF1ZXN0TG9nSUQpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmcsIG1heFJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbFJldHJ5RGVsYXkgPSAwLjU7XG4gICAgICAgIGNvbnN0IG1heFJldHJ5RGVsYXkgPSA4LjA7XG4gICAgICAgIGNvbnN0IG51bVJldHJpZXMgPSBtYXhSZXRyaWVzIC0gcmV0cmllc1JlbWFpbmluZztcbiAgICAgICAgLy8gQXBwbHkgZXhwb25lbnRpYWwgYmFja29mZiwgYnV0IG5vdCBtb3JlIHRoYW4gdGhlIG1heC5cbiAgICAgICAgY29uc3Qgc2xlZXBTZWNvbmRzID0gTWF0aC5taW4oaW5pdGlhbFJldHJ5RGVsYXkgKiBNYXRoLnBvdygyLCBudW1SZXRyaWVzKSwgbWF4UmV0cnlEZWxheSk7XG4gICAgICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCB0YWtlIHVwIHRvIGF0IG1vc3QgMjUgcGVyY2VudCBvZiB0aGUgcmV0cnkgdGltZS5cbiAgICAgICAgY29uc3Qgaml0dGVyID0gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI1O1xuICAgICAgICByZXR1cm4gc2xlZXBTZWNvbmRzICogaml0dGVyICogMTAwMDtcbiAgICB9XG4gICAgY2FsY3VsYXRlTm9uc3RyZWFtaW5nVGltZW91dChtYXhUb2tlbnMsIG1heE5vbnN0cmVhbWluZ1Rva2Vucykge1xuICAgICAgICBjb25zdCBtYXhUaW1lID0gNjAgKiA2MCAqIDEwMDA7IC8vIDYwIG1pbnV0ZXNcbiAgICAgICAgY29uc3QgZGVmYXVsdFRpbWUgPSA2MCAqIDEwICogMTAwMDsgLy8gMTAgbWludXRlc1xuICAgICAgICBjb25zdCBleHBlY3RlZFRpbWUgPSAobWF4VGltZSAqIG1heFRva2VucykgLyAxMjgwMDA7XG4gICAgICAgIGlmIChleHBlY3RlZFRpbWUgPiBkZWZhdWx0VGltZSB8fCAobWF4Tm9uc3RyZWFtaW5nVG9rZW5zICE9IG51bGwgJiYgbWF4VG9rZW5zID4gbWF4Tm9uc3RyZWFtaW5nVG9rZW5zKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5BbnRocm9waWNFcnJvcignU3RyZWFtaW5nIGlzIHJlcXVpcmVkIGZvciBvcGVyYXRpb25zIHRoYXQgbWF5IHRha2UgbG9uZ2VyIHRoYW4gMTAgbWludXRlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnRocm9waWNzL2FudGhyb3BpYy1zZGstdHlwZXNjcmlwdCNsb25nLXJlcXVlc3RzIGZvciBtb3JlIGRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFRpbWU7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkUmVxdWVzdChpbnB1dE9wdGlvbnMsIHsgcmV0cnlDb3VudCA9IDAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IC4uLmlucHV0T3B0aW9ucyB9O1xuICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGF0aCwgcXVlcnksIGRlZmF1bHRCYXNlVVJMIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGgsIHF1ZXJ5LCBkZWZhdWx0QmFzZVVSTCk7XG4gICAgICAgIGlmICgndGltZW91dCcgaW4gb3B0aW9ucylcbiAgICAgICAgICAgIHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0Jywgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgb3B0aW9ucy50aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0ID8/IHRoaXMudGltZW91dDtcbiAgICAgICAgY29uc3QgeyBib2R5SGVhZGVycywgYm9keSB9ID0gdGhpcy5idWlsZEJvZHkoeyBvcHRpb25zIH0pO1xuICAgICAgICBjb25zdCByZXFIZWFkZXJzID0gYXdhaXQgdGhpcy5idWlsZEhlYWRlcnMoeyBvcHRpb25zOiBpbnB1dE9wdGlvbnMsIG1ldGhvZCwgYm9keUhlYWRlcnMsIHJldHJ5Q291bnQgfSk7XG4gICAgICAgIGNvbnN0IHJlcSA9IHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHJlcUhlYWRlcnMsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5zaWduYWwgJiYgeyBzaWduYWw6IG9wdGlvbnMuc2lnbmFsIH0pLFxuICAgICAgICAgICAgLi4uKGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gJiZcbiAgICAgICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSAmJiB7IGR1cGxleDogJ2hhbGYnIH0pLFxuICAgICAgICAgICAgLi4uKGJvZHkgJiYgeyBib2R5IH0pLFxuICAgICAgICAgICAgLi4uKHRoaXMuZmV0Y2hPcHRpb25zID8/IHt9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zLmZldGNoT3B0aW9ucyA/PyB7fSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IHJlcSwgdXJsLCB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQgfTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGRIZWFkZXJzKHsgb3B0aW9ucywgbWV0aG9kLCBib2R5SGVhZGVycywgcmV0cnlDb3VudCwgfSkge1xuICAgICAgICBsZXQgaWRlbXBvdGVuY3lIZWFkZXJzID0ge307XG4gICAgICAgIGlmICh0aGlzLmlkZW1wb3RlbmN5SGVhZGVyICYmIG1ldGhvZCAhPT0gJ2dldCcpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZGVtcG90ZW5jeUtleSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlkZW1wb3RlbmN5S2V5ID0gdGhpcy5kZWZhdWx0SWRlbXBvdGVuY3lLZXkoKTtcbiAgICAgICAgICAgIGlkZW1wb3RlbmN5SGVhZGVyc1t0aGlzLmlkZW1wb3RlbmN5SGVhZGVyXSA9IG9wdGlvbnMuaWRlbXBvdGVuY3lLZXk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICBpZGVtcG90ZW5jeUhlYWRlcnMsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiB0aGlzLmdldFVzZXJBZ2VudCgpLFxuICAgICAgICAgICAgICAgICdYLVN0YWlubGVzcy1SZXRyeS1Db3VudCc6IFN0cmluZyhyZXRyeUNvdW50KSxcbiAgICAgICAgICAgICAgICAuLi4ob3B0aW9ucy50aW1lb3V0ID8geyAnWC1TdGFpbmxlc3MtVGltZW91dCc6IFN0cmluZyhNYXRoLnRydW5jKG9wdGlvbnMudGltZW91dCAvIDEwMDApKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIC4uLmdldFBsYXRmb3JtSGVhZGVycygpLFxuICAgICAgICAgICAgICAgIC4uLih0aGlzLl9vcHRpb25zLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyID9cbiAgICAgICAgICAgICAgICAgICAgeyAnYW50aHJvcGljLWRhbmdlcm91cy1kaXJlY3QtYnJvd3Nlci1hY2Nlc3MnOiAndHJ1ZScgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgJ2FudGhyb3BpYy12ZXJzaW9uJzogJzIwMjMtMDYtMDEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXV0aEhlYWRlcnMob3B0aW9ucyksXG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgICAgICAgICAgYm9keUhlYWRlcnMsXG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnZhbGlkYXRlSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnMudmFsdWVzO1xuICAgIH1cbiAgICBidWlsZEJvZHkoeyBvcHRpb25zOiB7IGJvZHksIGhlYWRlcnM6IHJhd0hlYWRlcnMgfSB9KSB7XG4gICAgICAgIGlmICghYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgYm9keUhlYWRlcnM6IHVuZGVmaW5lZCwgYm9keTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhbcmF3SGVhZGVyc10pO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIFBhc3MgcmF3IHR5cGUgdmVyYmF0aW1cbiAgICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpIHx8XG4gICAgICAgICAgICBib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAgICAgICAgIGJvZHkgaW5zdGFuY2VvZiBEYXRhVmlldyB8fFxuICAgICAgICAgICAgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGxlZ2FjeSBzdHJpbmcgZW5jb2RpbmcgYmVoYXZpb3IgZm9yIG5vd1xuICAgICAgICAgICAgICAgIGhlYWRlcnMudmFsdWVzLmhhcygnY29udGVudC10eXBlJykpIHx8XG4gICAgICAgICAgICAvLyBgQmxvYmAgaXMgc3VwZXJzZXQgb2YgYEZpbGVgXG4gICAgICAgICAgICAoZ2xvYmFsVGhpcy5CbG9iICYmIGJvZHkgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkJsb2IpIHx8XG4gICAgICAgICAgICAvLyBgRm9ybURhdGFgIC0+IGBtdWx0aXBhcnQvZm9ybS1kYXRhYFxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhIHx8XG4gICAgICAgICAgICAvLyBgVVJMU2VhcmNoUGFyYW1zYCAtPiBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYFxuICAgICAgICAgICAgYm9keSBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcyB8fFxuICAgICAgICAgICAgLy8gU2VuZCBjaHVua2VkIHN0cmVhbSAoZWFjaCBjaHVuayBoYXMgb3duIGBsZW5ndGhgKVxuICAgICAgICAgICAgKGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gJiYgYm9keSBpbnN0YW5jZW9mIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBib2R5SGVhZGVyczogdW5kZWZpbmVkLCBib2R5OiBib2R5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gYm9keSB8fFxuICAgICAgICAgICAgICAgIChTeW1ib2wuaXRlcmF0b3IgaW4gYm9keSAmJiAnbmV4dCcgaW4gYm9keSAmJiB0eXBlb2YgYm9keS5uZXh0ID09PSAnZnVuY3Rpb24nKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGJvZHlIZWFkZXJzOiB1bmRlZmluZWQsIGJvZHk6IFNoaW1zLlJlYWRhYmxlU3RyZWFtRnJvbShib2R5KSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Jhc2VBbnRocm9waWNfZW5jb2RlciwgXCJmXCIpLmNhbGwodGhpcywgeyBib2R5LCBoZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuX2EgPSBCYXNlQW50aHJvcGljLCBfQmFzZUFudGhyb3BpY19lbmNvZGVyID0gbmV3IFdlYWtNYXAoKSwgX0Jhc2VBbnRocm9waWNfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0Jhc2VBbnRocm9waWNfYmFzZVVSTE92ZXJyaWRkZW4gPSBmdW5jdGlvbiBfQmFzZUFudGhyb3BpY19iYXNlVVJMT3ZlcnJpZGRlbigpIHtcbiAgICByZXR1cm4gdGhpcy5iYXNlVVJMICE9PSAnaHR0cHM6Ly9hcGkuYW50aHJvcGljLmNvbSc7XG59O1xuQmFzZUFudGhyb3BpYy5BbnRocm9waWMgPSBfYTtcbkJhc2VBbnRocm9waWMuSFVNQU5fUFJPTVBUID0gSFVNQU5fUFJPTVBUO1xuQmFzZUFudGhyb3BpYy5BSV9QUk9NUFQgPSBBSV9QUk9NUFQ7XG5CYXNlQW50aHJvcGljLkRFRkFVTFRfVElNRU9VVCA9IDYwMDAwMDsgLy8gMTAgbWludXRlc1xuQmFzZUFudGhyb3BpYy5BbnRocm9waWNFcnJvciA9IEVycm9ycy5BbnRocm9waWNFcnJvcjtcbkJhc2VBbnRocm9waWMuQVBJRXJyb3IgPSBFcnJvcnMuQVBJRXJyb3I7XG5CYXNlQW50aHJvcGljLkFQSUNvbm5lY3Rpb25FcnJvciA9IEVycm9ycy5BUElDb25uZWN0aW9uRXJyb3I7XG5CYXNlQW50aHJvcGljLkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvcjtcbkJhc2VBbnRocm9waWMuQVBJVXNlckFib3J0RXJyb3IgPSBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3I7XG5CYXNlQW50aHJvcGljLk5vdEZvdW5kRXJyb3IgPSBFcnJvcnMuTm90Rm91bmRFcnJvcjtcbkJhc2VBbnRocm9waWMuQ29uZmxpY3RFcnJvciA9IEVycm9ycy5Db25mbGljdEVycm9yO1xuQmFzZUFudGhyb3BpYy5SYXRlTGltaXRFcnJvciA9IEVycm9ycy5SYXRlTGltaXRFcnJvcjtcbkJhc2VBbnRocm9waWMuQmFkUmVxdWVzdEVycm9yID0gRXJyb3JzLkJhZFJlcXVlc3RFcnJvcjtcbkJhc2VBbnRocm9waWMuQXV0aGVudGljYXRpb25FcnJvciA9IEVycm9ycy5BdXRoZW50aWNhdGlvbkVycm9yO1xuQmFzZUFudGhyb3BpYy5JbnRlcm5hbFNlcnZlckVycm9yID0gRXJyb3JzLkludGVybmFsU2VydmVyRXJyb3I7XG5CYXNlQW50aHJvcGljLlBlcm1pc3Npb25EZW5pZWRFcnJvciA9IEVycm9ycy5QZXJtaXNzaW9uRGVuaWVkRXJyb3I7XG5CYXNlQW50aHJvcGljLlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciA9IEVycm9ycy5VbnByb2Nlc3NhYmxlRW50aXR5RXJyb3I7XG5CYXNlQW50aHJvcGljLnRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuLyoqXG4gKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBBbnRocm9waWMgQVBJLlxuICovXG5leHBvcnQgY2xhc3MgQW50aHJvcGljIGV4dGVuZHMgQmFzZUFudGhyb3BpYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSBuZXcgQVBJLkNvbXBsZXRpb25zKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IEFQSS5NZXNzYWdlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgQVBJLk1vZGVscyh0aGlzKTtcbiAgICAgICAgdGhpcy5iZXRhID0gbmV3IEFQSS5CZXRhKHRoaXMpO1xuICAgIH1cbn1cbkFudGhyb3BpYy5Db21wbGV0aW9ucyA9IENvbXBsZXRpb25zO1xuQW50aHJvcGljLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG5BbnRocm9waWMuTW9kZWxzID0gTW9kZWxzO1xuQW50aHJvcGljLkJldGEgPSBCZXRhO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/client.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIPromise: () => (/* binding */ APIPromise)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _internal_parse_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/parse.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/parse.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _APIPromise_client;\n\n\n/**\n * A subclass of `Promise` providing additional helper methods\n * for interacting with the SDK.\n */\nclass APIPromise extends Promise {\n    constructor(client, responsePromise, parseResponse = _internal_parse_mjs__WEBPACK_IMPORTED_MODULE_1__.defaultParseResponse) {\n        super((resolve) => {\n            // this is maybe a bit weird but this has to be a no-op to not implicitly\n            // parse the response body; instead .then, .catch, .finally are overridden\n            // to parse the response\n            resolve(null);\n        });\n        this.responsePromise = responsePromise;\n        this.parseResponse = parseResponse;\n        _APIPromise_client.set(this, void 0);\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _APIPromise_client, client, \"f\");\n    }\n    _thenUnwrap(transform) {\n        return new APIPromise((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _APIPromise_client, \"f\"), this.responsePromise, async (client, props) => (0,_internal_parse_mjs__WEBPACK_IMPORTED_MODULE_1__.addRequestID)(transform(await this.parseResponse(client, props), props), props.response));\n    }\n    /**\n     * Gets the raw `Response` instance instead of parsing the response\n     * data.\n     *\n     * If you want to parse the response body but still get the `Response`\n     * instance, you can use {@link withResponse()}.\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    asResponse() {\n        return this.responsePromise.then((p) => p.response);\n    }\n    /**\n     * Gets the parsed response data, the raw `Response` instance and the ID of the request,\n     * returned via the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * If you just want to get the raw `Response` instance without parsing it,\n     * you can use {@link asResponse()}.\n     *\n     * 👋 Getting the wrong TypeScript type for `Response`?\n     * Try setting `\"moduleResolution\": \"NodeNext\"` or add `\"lib\": [\"DOM\"]`\n     * to your `tsconfig.json`.\n     */\n    async withResponse() {\n        const [data, response] = await Promise.all([this.parse(), this.asResponse()]);\n        return { data, response, request_id: response.headers.get('request-id') };\n    }\n    parse() {\n        if (!this.parsedPromise) {\n            this.parsedPromise = this.responsePromise.then((data) => this.parseResponse((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _APIPromise_client, \"f\"), data));\n        }\n        return this.parsedPromise;\n    }\n    then(onfulfilled, onrejected) {\n        return this.parse().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.parse().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.parse().finally(onfinally);\n    }\n}\n_APIPromise_client = new WeakMap();\n//# sourceMappingURL=api-promise.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvYXBpLXByb21pc2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDdUY7QUFDWDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AseURBQXlELHFFQUFvQjtBQUM3RTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QiwyRUFBc0IsZ0ZBQWdGLGlFQUFZO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQkFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLDJFQUFzQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9jb3JlL2FwaS1wcm9taXNlLm1qcz84YzExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG52YXIgX0FQSVByb21pc2VfY2xpZW50O1xuaW1wb3J0IHsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCB9IGZyb20gXCIuLi9pbnRlcm5hbC90c2xpYi5tanNcIjtcbmltcG9ydCB7IGRlZmF1bHRQYXJzZVJlc3BvbnNlLCBhZGRSZXF1ZXN0SUQsIH0gZnJvbSBcIi4uL2ludGVybmFsL3BhcnNlLm1qc1wiO1xuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIGBQcm9taXNlYCBwcm92aWRpbmcgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuICogZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFNESy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFQSVByb21pc2UgZXh0ZW5kcyBQcm9taXNlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHJlc3BvbnNlUHJvbWlzZSwgcGFyc2VSZXNwb25zZSA9IGRlZmF1bHRQYXJzZVJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1heWJlIGEgYml0IHdlaXJkIGJ1dCB0aGlzIGhhcyB0byBiZSBhIG5vLW9wIHRvIG5vdCBpbXBsaWNpdGx5XG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keTsgaW5zdGVhZCAudGhlbiwgLmNhdGNoLCAuZmluYWxseSBhcmUgb3ZlcnJpZGRlblxuICAgICAgICAgICAgLy8gdG8gcGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVByb21pc2UgPSByZXNwb25zZVByb21pc2U7XG4gICAgICAgIHRoaXMucGFyc2VSZXNwb25zZSA9IHBhcnNlUmVzcG9uc2U7XG4gICAgICAgIF9BUElQcm9taXNlX2NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQVBJUHJvbWlzZV9jbGllbnQsIGNsaWVudCwgXCJmXCIpO1xuICAgIH1cbiAgICBfdGhlblVud3JhcCh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FQSVByb21pc2VfY2xpZW50LCBcImZcIiksIHRoaXMucmVzcG9uc2VQcm9taXNlLCBhc3luYyAoY2xpZW50LCBwcm9wcykgPT4gYWRkUmVxdWVzdElEKHRyYW5zZm9ybShhd2FpdCB0aGlzLnBhcnNlUmVzcG9uc2UoY2xpZW50LCBwcm9wcyksIHByb3BzKSwgcHJvcHMucmVzcG9uc2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgaW5zdGVhZCBvZiBwYXJzaW5nIHRoZSByZXNwb25zZVxuICAgICAqIGRhdGEuXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBidXQgc3RpbGwgZ2V0IHRoZSBgUmVzcG9uc2VgXG4gICAgICogaW5zdGFuY2UsIHlvdSBjYW4gdXNlIHtAbGluayB3aXRoUmVzcG9uc2UoKX0uXG4gICAgICpcbiAgICAgKiDwn5GLIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgb3IgYWRkIGBcImxpYlwiOiBbXCJET01cIl1gXG4gICAgICogdG8geW91ciBgdHNjb25maWcuanNvbmAuXG4gICAgICovXG4gICAgYXNSZXNwb25zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4oKHApID0+IHAucmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwYXJzZWQgcmVzcG9uc2UgZGF0YSwgdGhlIHJhdyBgUmVzcG9uc2VgIGluc3RhbmNlIGFuZCB0aGUgSUQgb2YgdGhlIHJlcXVlc3QsXG4gICAgICogcmV0dXJuZWQgdmlhIHRoZSBgcmVxdWVzdC1pZGAgaGVhZGVyIHdoaWNoIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHJlcXVlc3RzIGFuZCByZXNwb3J0aW5nXG4gICAgICogaXNzdWVzIHRvIEFudGhyb3BpYy5cbiAgICAgKlxuICAgICAqIElmIHlvdSBqdXN0IHdhbnQgdG8gZ2V0IHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSB3aXRob3V0IHBhcnNpbmcgaXQsXG4gICAgICogeW91IGNhbiB1c2Uge0BsaW5rIGFzUmVzcG9uc2UoKX0uXG4gICAgICpcbiAgICAgKiDwn5GLIEdldHRpbmcgdGhlIHdyb25nIFR5cGVTY3JpcHQgdHlwZSBmb3IgYFJlc3BvbnNlYD9cbiAgICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgb3IgYWRkIGBcImxpYlwiOiBbXCJET01cIl1gXG4gICAgICogdG8geW91ciBgdHNjb25maWcuanNvbmAuXG4gICAgICovXG4gICAgYXN5bmMgd2l0aFJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCBbZGF0YSwgcmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW3RoaXMucGFyc2UoKSwgdGhpcy5hc1Jlc3BvbnNlKCldKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UsIHJlcXVlc3RfaWQ6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdyZXF1ZXN0LWlkJykgfTtcbiAgICB9XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJzZWRQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFByb21pc2UgPSB0aGlzLnJlc3BvbnNlUHJvbWlzZS50aGVuKChkYXRhKSA9PiB0aGlzLnBhcnNlUmVzcG9uc2UoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQVBJUHJvbWlzZV9jbGllbnQsIFwiZlwiKSwgZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFByb21pc2U7XG4gICAgfVxuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgY2F0Y2gob25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmNhdGNoKG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBmaW5hbGx5KG9uZmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcbiAgICB9XG59XG5fQVBJUHJvbWlzZV9jbGllbnQgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLXByb21pc2UubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs":
/*!***********************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/error.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIConnectionError: () => (/* binding */ APIConnectionError),\n/* harmony export */   APIConnectionTimeoutError: () => (/* binding */ APIConnectionTimeoutError),\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   APIUserAbortError: () => (/* binding */ APIUserAbortError),\n/* harmony export */   AnthropicError: () => (/* binding */ AnthropicError),\n/* harmony export */   AuthenticationError: () => (/* binding */ AuthenticationError),\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   ConflictError: () => (/* binding */ ConflictError),\n/* harmony export */   InternalServerError: () => (/* binding */ InternalServerError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   PermissionDeniedError: () => (/* binding */ PermissionDeniedError),\n/* harmony export */   RateLimitError: () => (/* binding */ RateLimitError),\n/* harmony export */   UnprocessableEntityError: () => (/* binding */ UnprocessableEntityError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/errors.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nclass AnthropicError extends Error {\n}\nclass APIError extends AnthropicError {\n    constructor(status, error, message, headers) {\n        super(`${APIError.makeMessage(status, error, message)}`);\n        this.status = status;\n        this.headers = headers;\n        this.requestID = headers?.get('request-id');\n        this.error = error;\n    }\n    static makeMessage(status, error, message) {\n        const msg = error?.message ?\n            typeof error.message === 'string' ?\n                error.message\n                : JSON.stringify(error.message)\n            : error ? JSON.stringify(error)\n                : message;\n        if (status && msg) {\n            return `${status} ${msg}`;\n        }\n        if (status) {\n            return `${status} status code (no body)`;\n        }\n        if (msg) {\n            return msg;\n        }\n        return '(no status code or body)';\n    }\n    static generate(status, errorResponse, message, headers) {\n        if (!status || !headers) {\n            return new APIConnectionError({ message, cause: (0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_0__.castToError)(errorResponse) });\n        }\n        const error = errorResponse;\n        if (status === 400) {\n            return new BadRequestError(status, error, message, headers);\n        }\n        if (status === 401) {\n            return new AuthenticationError(status, error, message, headers);\n        }\n        if (status === 403) {\n            return new PermissionDeniedError(status, error, message, headers);\n        }\n        if (status === 404) {\n            return new NotFoundError(status, error, message, headers);\n        }\n        if (status === 409) {\n            return new ConflictError(status, error, message, headers);\n        }\n        if (status === 422) {\n            return new UnprocessableEntityError(status, error, message, headers);\n        }\n        if (status === 429) {\n            return new RateLimitError(status, error, message, headers);\n        }\n        if (status >= 500) {\n            return new InternalServerError(status, error, message, headers);\n        }\n        return new APIError(status, error, message, headers);\n    }\n}\nclass APIUserAbortError extends APIError {\n    constructor({ message } = {}) {\n        super(undefined, undefined, message || 'Request was aborted.', undefined);\n    }\n}\nclass APIConnectionError extends APIError {\n    constructor({ message, cause }) {\n        super(undefined, undefined, message || 'Connection error.', undefined);\n        // in some environments the 'cause' property is already declared\n        // @ts-ignore\n        if (cause)\n            this.cause = cause;\n    }\n}\nclass APIConnectionTimeoutError extends APIConnectionError {\n    constructor({ message } = {}) {\n        super({ message: message ?? 'Request timed out.' });\n    }\n}\nclass BadRequestError extends APIError {\n}\nclass AuthenticationError extends APIError {\n}\nclass PermissionDeniedError extends APIError {\n}\nclass NotFoundError extends APIError {\n}\nclass ConflictError extends APIError {\n}\nclass UnprocessableEntityError extends APIError {\n}\nclass RateLimitError extends APIError {\n}\nclass InternalServerError extends APIError {\n}\n//# sourceMappingURL=error.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvZXJyb3IubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUQ7QUFDOUM7QUFDUDtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsNkNBQTZDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVEsRUFBRSxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQixpRUFBVyxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLFVBQVUsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQixVQUFVLElBQUk7QUFDaEMsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvZXJyb3IubWpzP2I5ZmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IGNhc3RUb0Vycm9yIH0gZnJvbSBcIi4uL2ludGVybmFsL2Vycm9ycy5tanNcIjtcbmV4cG9ydCBjbGFzcyBBbnRocm9waWNFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydCBjbGFzcyBBUElFcnJvciBleHRlbmRzIEFudGhyb3BpY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gICAgICAgIHN1cGVyKGAke0FQSUVycm9yLm1ha2VNZXNzYWdlKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UpfWApO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5yZXF1ZXN0SUQgPSBoZWFkZXJzPy5nZXQoJ3JlcXVlc3QtaWQnKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZU1lc3NhZ2Uoc3RhdHVzLCBlcnJvciwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtc2cgPSBlcnJvcj8ubWVzc2FnZSA/XG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICA6IGVycm9yID8gSlNPTi5zdHJpbmdpZnkoZXJyb3IpXG4gICAgICAgICAgICAgICAgOiBtZXNzYWdlO1xuICAgICAgICBpZiAoc3RhdHVzICYmIG1zZykge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXR1c30gJHttc2d9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhdHVzfSBzdGF0dXMgY29kZSAobm8gYm9keSlgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcobm8gc3RhdHVzIGNvZGUgb3IgYm9keSknO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGUoc3RhdHVzLCBlcnJvclJlc3BvbnNlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gICAgICAgIGlmICghc3RhdHVzIHx8ICFoZWFkZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IG1lc3NhZ2UsIGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJvciA9IGVycm9yUmVzcG9uc2U7XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIodW5kZWZpbmVkLCB1bmRlZmluZWQsIG1lc3NhZ2UgfHwgJ1JlcXVlc3Qgd2FzIGFib3J0ZWQuJywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY2F1c2UgfSkge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWVzc2FnZSB8fCAnQ29ubmVjdGlvbiBlcnJvci4nLCB1bmRlZmluZWQpO1xuICAgICAgICAvLyBpbiBzb21lIGVudmlyb25tZW50cyB0aGUgJ2NhdXNlJyBwcm9wZXJ0eSBpcyBhbHJlYWR5IGRlY2xhcmVkXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGNhdXNlKVxuICAgICAgICAgICAgdGhpcy5jYXVzZSA9IGNhdXNlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yIGV4dGVuZHMgQVBJQ29ubmVjdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKHsgbWVzc2FnZTogbWVzc2FnZSA/PyAnUmVxdWVzdCB0aW1lZCBvdXQuJyB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgQ29uZmxpY3RFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydCBjbGFzcyBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgUmF0ZUxpbWl0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnQgY2xhc3MgSW50ZXJuYWxTZXJ2ZXJFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/pagination.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractPage: () => (/* binding */ AbstractPage),\n/* harmony export */   Page: () => (/* binding */ Page),\n/* harmony export */   PagePromise: () => (/* binding */ PagePromise)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n/* harmony import */ var _internal_parse_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/parse.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/parse.mjs\");\n/* harmony import */ var _api_promise_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./api-promise.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs\");\n/* harmony import */ var _internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/utils/values.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nvar _AbstractPage_client;\n\n\n\n\n\nclass AbstractPage {\n    constructor(client, response, body, options) {\n        _AbstractPage_client.set(this, void 0);\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _AbstractPage_client, client, \"f\");\n        this.options = options;\n        this.response = response;\n        this.body = body;\n    }\n    hasNextPage() {\n        const items = this.getPaginatedItems();\n        if (!items.length)\n            return false;\n        return this.nextPageRequestOptions() != null;\n    }\n    async getNextPage() {\n        const nextOptions = this.nextPageRequestOptions();\n        if (!nextOptions) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError('No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.');\n        }\n        return await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _AbstractPage_client, \"f\").requestAPIList(this.constructor, nextOptions);\n    }\n    async *iterPages() {\n        let page = this;\n        yield page;\n        while (page.hasNextPage()) {\n            page = await page.getNextPage();\n            yield page;\n        }\n    }\n    async *[(_AbstractPage_client = new WeakMap(), Symbol.asyncIterator)]() {\n        for await (const page of this.iterPages()) {\n            for (const item of page.getPaginatedItems()) {\n                yield item;\n            }\n        }\n    }\n}\n/**\n * This subclass of Promise will resolve to an instantiated Page once the request completes.\n *\n * It also implements AsyncIterable to allow auto-paginating iteration on an unawaited list call, eg:\n *\n *    for await (const item of client.items.list()) {\n *      console.log(item)\n *    }\n */\nclass PagePromise extends _api_promise_mjs__WEBPACK_IMPORTED_MODULE_3__.APIPromise {\n    constructor(client, request, Page) {\n        super(client, request, async (client, props) => new Page(client, props.response, await (0,_internal_parse_mjs__WEBPACK_IMPORTED_MODULE_2__.defaultParseResponse)(client, props), props.options));\n    }\n    /**\n     * Allow auto-paginating iteration on an unawaited list call, eg:\n     *\n     *    for await (const item of client.items.list()) {\n     *      console.log(item)\n     *    }\n     */\n    async *[Symbol.asyncIterator]() {\n        const page = await this;\n        for await (const item of page) {\n            yield item;\n        }\n    }\n}\nclass Page extends AbstractPage {\n    constructor(client, response, body, options) {\n        super(client, response, body, options);\n        this.data = body.data || [];\n        this.has_more = body.has_more || false;\n        this.first_id = body.first_id || null;\n        this.last_id = body.last_id || null;\n    }\n    getPaginatedItems() {\n        return this.data ?? [];\n    }\n    hasNextPage() {\n        if (this.has_more === false) {\n            return false;\n        }\n        return super.hasNextPage();\n    }\n    nextPageRequestOptions() {\n        if (this.options.query?.['before_id']) {\n            // in reverse\n            const first_id = this.first_id;\n            if (!first_id) {\n                return null;\n            }\n            return {\n                ...this.options,\n                query: {\n                    ...(0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_4__.maybeObj)(this.options.query),\n                    before_id: first_id,\n                },\n            };\n        }\n        const cursor = this.last_id;\n        if (!cursor) {\n            return null;\n        }\n        return {\n            ...this.options,\n            query: {\n                ...(0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_4__.maybeObj)(this.options.query),\n                after_id: cursor,\n            },\n        };\n    }\n}\n//# sourceMappingURL=pagination.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvcGFnaW5hdGlvbi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VGO0FBQzFDO0FBQ2dCO0FBQ2Q7QUFDUztBQUNqRDtBQUNQO0FBQ0E7QUFDQSxRQUFRLDJFQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYyx5QkFBeUI7QUFDN0Q7QUFDQSxxQkFBcUIsMkVBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsd0RBQVU7QUFDM0M7QUFDQSwrRkFBK0YseUVBQW9CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvRUFBUTtBQUMvQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0VBQVE7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9jb3JlL3BhZ2luYXRpb24ubWpzP2MwOWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbnZhciBfQWJzdHJhY3RQYWdlX2NsaWVudDtcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwiLi4vaW50ZXJuYWwvdHNsaWIubWpzXCI7XG5pbXBvcnQgeyBBbnRocm9waWNFcnJvciB9IGZyb20gXCIuL2Vycm9yLm1qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdFBhcnNlUmVzcG9uc2UgfSBmcm9tIFwiLi4vaW50ZXJuYWwvcGFyc2UubWpzXCI7XG5pbXBvcnQgeyBBUElQcm9taXNlIH0gZnJvbSBcIi4vYXBpLXByb21pc2UubWpzXCI7XG5pbXBvcnQgeyBtYXliZU9iaiB9IGZyb20gXCIuLi9pbnRlcm5hbC91dGlscy92YWx1ZXMubWpzXCI7XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIF9BYnN0cmFjdFBhZ2VfY2xpZW50LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9BYnN0cmFjdFBhZ2VfY2xpZW50LCBjbGllbnQsIFwiZlwiKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBoYXNOZXh0UGFnZSgpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLmdldFBhZ2luYXRlZEl0ZW1zKCk7XG4gICAgICAgIGlmICghaXRlbXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0UGFnZVJlcXVlc3RPcHRpb25zKCkgIT0gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TmV4dFBhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG5leHRPcHRpb25zID0gdGhpcy5uZXh0UGFnZVJlcXVlc3RPcHRpb25zKCk7XG4gICAgICAgIGlmICghbmV4dE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcignTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BYnN0cmFjdFBhZ2VfY2xpZW50LCBcImZcIikucmVxdWVzdEFQSUxpc3QodGhpcy5jb25zdHJ1Y3RvciwgbmV4dE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyAqaXRlclBhZ2VzKCkge1xuICAgICAgICBsZXQgcGFnZSA9IHRoaXM7XG4gICAgICAgIHlpZWxkIHBhZ2U7XG4gICAgICAgIHdoaWxlIChwYWdlLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHBhZ2UgPSBhd2FpdCBwYWdlLmdldE5leHRQYWdlKCk7XG4gICAgICAgICAgICB5aWVsZCBwYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpbKF9BYnN0cmFjdFBhZ2VfY2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlIGV4dGVuZHMgQVBJUHJvbWlzZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50LCByZXF1ZXN0LCBQYWdlKSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCwgcmVxdWVzdCwgYXN5bmMgKGNsaWVudCwgcHJvcHMpID0+IG5ldyBQYWdlKGNsaWVudCwgcHJvcHMucmVzcG9uc2UsIGF3YWl0IGRlZmF1bHRQYXJzZVJlc3BvbnNlKGNsaWVudCwgcHJvcHMpLCBwcm9wcy5vcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gICAgICpcbiAgICAgKiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgY2xpZW50Lml0ZW1zLmxpc3QoKSkge1xuICAgICAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnZSkge1xuICAgICAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBQYWdlIGV4dGVuZHMgQWJzdHJhY3RQYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHJlc3BvbnNlLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNsaWVudCwgcmVzcG9uc2UsIGJvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRhdGEgPSBib2R5LmRhdGEgfHwgW107XG4gICAgICAgIHRoaXMuaGFzX21vcmUgPSBib2R5Lmhhc19tb3JlIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLmZpcnN0X2lkID0gYm9keS5maXJzdF9pZCB8fCBudWxsO1xuICAgICAgICB0aGlzLmxhc3RfaWQgPSBib2R5Lmxhc3RfaWQgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0UGFnaW5hdGVkSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEgPz8gW107XG4gICAgfVxuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNfbW9yZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuaGFzTmV4dFBhZ2UoKTtcbiAgICB9XG4gICAgbmV4dFBhZ2VSZXF1ZXN0T3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5xdWVyeT8uWydiZWZvcmVfaWQnXSkge1xuICAgICAgICAgICAgLy8gaW4gcmV2ZXJzZVxuICAgICAgICAgICAgY29uc3QgZmlyc3RfaWQgPSB0aGlzLmZpcnN0X2lkO1xuICAgICAgICAgICAgaWYgKCFmaXJzdF9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ubWF5YmVPYmoodGhpcy5vcHRpb25zLnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlX2lkOiBmaXJzdF9pZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmxhc3RfaWQ7XG4gICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAuLi5tYXliZU9iaih0aGlzLm9wdGlvbnMucXVlcnkpLFxuICAgICAgICAgICAgICAgIGFmdGVyX2lkOiBjdXJzb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2luYXRpb24ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs":
/*!**************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/resource.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIResource: () => (/* binding */ APIResource)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nclass APIResource {\n    constructor(client) {\n        this._client = client;\n    }\n}\n//# sourceMappingURL=resource.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvcmVzb3VyY2UubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvcmVzb3VyY2UubWpzPzNiZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmV4cG9ydCBjbGFzcyBBUElSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvdXJjZS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/streaming.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/streaming.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stream: () => (/* binding */ Stream),\n/* harmony export */   _iterSSEMessages: () => (/* binding */ _iterSSEMessages)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n/* harmony import */ var _internal_shims_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/shims.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs\");\n/* harmony import */ var _internal_decoders_line_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/decoders/line.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs\");\n/* harmony import */ var _internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../internal/errors.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\");\n/* harmony import */ var _internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../internal/utils/values.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\");\n/* harmony import */ var _internal_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../internal/utils/bytes.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs\");\n/* harmony import */ var _internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../internal/utils/log.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs\");\nvar _Stream_client;\n\n\n\n\n\n\n\n\n\n\nclass Stream {\n    constructor(iterator, controller, client) {\n        this.iterator = iterator;\n        _Stream_client.set(this, void 0);\n        this.controller = controller;\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _Stream_client, client, \"f\");\n    }\n    static fromSSEResponse(response, controller, client) {\n        let consumed = false;\n        const logger = client ? (0,_internal_utils_log_mjs__WEBPACK_IMPORTED_MODULE_7__.loggerFor)(client) : console;\n        async function* iterator() {\n            if (consumed) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const sse of _iterSSEMessages(response, controller)) {\n                    if (sse.event === 'completion') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            logger.error(`Could not parse message into JSON:`, sse.data);\n                            logger.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'message_start' ||\n                        sse.event === 'message_delta' ||\n                        sse.event === 'message_stop' ||\n                        sse.event === 'content_block_start' ||\n                        sse.event === 'content_block_delta' ||\n                        sse.event === 'content_block_stop') {\n                        try {\n                            yield JSON.parse(sse.data);\n                        }\n                        catch (e) {\n                            logger.error(`Could not parse message into JSON:`, sse.data);\n                            logger.error(`From chunk:`, sse.raw);\n                            throw e;\n                        }\n                    }\n                    if (sse.event === 'ping') {\n                        continue;\n                    }\n                    if (sse.event === 'error') {\n                        throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.APIError(undefined, (0,_internal_utils_values_mjs__WEBPACK_IMPORTED_MODULE_5__.safeJSON)(sse.data) ?? sse.data, undefined, response.headers);\n                    }\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if ((0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.isAbortError)(e))\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller, client);\n    }\n    /**\n     * Generates a Stream from a newline-separated ReadableStream\n     * where each item is a JSON value.\n     */\n    static fromReadableStream(readableStream, controller, client) {\n        let consumed = false;\n        async function* iterLines() {\n            const lineDecoder = new _internal_decoders_line_mjs__WEBPACK_IMPORTED_MODULE_3__.LineDecoder();\n            const iter = (0,_internal_shims_mjs__WEBPACK_IMPORTED_MODULE_2__.ReadableStreamToAsyncIterable)(readableStream);\n            for await (const chunk of iter) {\n                for (const line of lineDecoder.decode(chunk)) {\n                    yield line;\n                }\n            }\n            for (const line of lineDecoder.flush()) {\n                yield line;\n            }\n        }\n        async function* iterator() {\n            if (consumed) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError('Cannot iterate over a consumed stream, use `.tee()` to split the stream.');\n            }\n            consumed = true;\n            let done = false;\n            try {\n                for await (const line of iterLines()) {\n                    if (done)\n                        continue;\n                    if (line)\n                        yield JSON.parse(line);\n                }\n                done = true;\n            }\n            catch (e) {\n                // If the user calls `stream.controller.abort()`, we should exit without throwing.\n                if ((0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.isAbortError)(e))\n                    return;\n                throw e;\n            }\n            finally {\n                // If the user `break`s, abort the ongoing request.\n                if (!done)\n                    controller.abort();\n            }\n        }\n        return new Stream(iterator, controller, client);\n    }\n    [(_Stream_client = new WeakMap(), Symbol.asyncIterator)]() {\n        return this.iterator();\n    }\n    /**\n     * Splits the stream into two streams which can be\n     * independently read from at different speeds.\n     */\n    tee() {\n        const left = [];\n        const right = [];\n        const iterator = this.iterator();\n        const teeIterator = (queue) => {\n            return {\n                next: () => {\n                    if (queue.length === 0) {\n                        const result = iterator.next();\n                        left.push(result);\n                        right.push(result);\n                    }\n                    return queue.shift();\n                },\n            };\n        };\n        return [\n            new Stream(() => teeIterator(left), this.controller, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Stream_client, \"f\")),\n            new Stream(() => teeIterator(right), this.controller, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _Stream_client, \"f\")),\n        ];\n    }\n    /**\n     * Converts this stream to a newline-separated ReadableStream of\n     * JSON stringified values in the stream\n     * which can be turned back into a Stream with `Stream.fromReadableStream()`.\n     */\n    toReadableStream() {\n        const self = this;\n        let iter;\n        return (0,_internal_shims_mjs__WEBPACK_IMPORTED_MODULE_2__.makeReadableStream)({\n            async start() {\n                iter = self[Symbol.asyncIterator]();\n            },\n            async pull(ctrl) {\n                try {\n                    const { value, done } = await iter.next();\n                    if (done)\n                        return ctrl.close();\n                    const bytes = (0,_internal_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_6__.encodeUTF8)(JSON.stringify(value) + '\\n');\n                    ctrl.enqueue(bytes);\n                }\n                catch (err) {\n                    ctrl.error(err);\n                }\n            },\n            async cancel() {\n                await iter.return?.();\n            },\n        });\n    }\n}\nasync function* _iterSSEMessages(response, controller) {\n    if (!response.body) {\n        controller.abort();\n        if (typeof globalThis.navigator !== 'undefined' &&\n            globalThis.navigator.product === 'ReactNative') {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n        }\n        throw new _error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError(`Attempted to iterate over a response with no body`);\n    }\n    const sseDecoder = new SSEDecoder();\n    const lineDecoder = new _internal_decoders_line_mjs__WEBPACK_IMPORTED_MODULE_3__.LineDecoder();\n    const iter = (0,_internal_shims_mjs__WEBPACK_IMPORTED_MODULE_2__.ReadableStreamToAsyncIterable)(response.body);\n    for await (const sseChunk of iterSSEChunks(iter)) {\n        for (const line of lineDecoder.decode(sseChunk)) {\n            const sse = sseDecoder.decode(line);\n            if (sse)\n                yield sse;\n        }\n    }\n    for (const line of lineDecoder.flush()) {\n        const sse = sseDecoder.decode(line);\n        if (sse)\n            yield sse;\n    }\n}\n/**\n * Given an async iterable iterator, iterates over it and yields full\n * SSE chunks, i.e. yields when a double new-line is encountered.\n */\nasync function* iterSSEChunks(iterator) {\n    let data = new Uint8Array();\n    for await (const chunk of iterator) {\n        if (chunk == null) {\n            continue;\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? (0,_internal_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_6__.encodeUTF8)(chunk)\n                : chunk;\n        let newData = new Uint8Array(data.length + binaryChunk.length);\n        newData.set(data);\n        newData.set(binaryChunk, data.length);\n        data = newData;\n        let patternIndex;\n        while ((patternIndex = (0,_internal_decoders_line_mjs__WEBPACK_IMPORTED_MODULE_3__.findDoubleNewlineIndex)(data)) !== -1) {\n            yield data.slice(0, patternIndex);\n            data = data.slice(patternIndex);\n        }\n    }\n    if (data.length > 0) {\n        yield data;\n    }\n}\nclass SSEDecoder {\n    constructor() {\n        this.event = null;\n        this.data = [];\n        this.chunks = [];\n    }\n    decode(line) {\n        if (line.endsWith('\\r')) {\n            line = line.substring(0, line.length - 1);\n        }\n        if (!line) {\n            // empty line and we didn't previously encounter any messages\n            if (!this.event && !this.data.length)\n                return null;\n            const sse = {\n                event: this.event,\n                data: this.data.join('\\n'),\n                raw: this.chunks,\n            };\n            this.event = null;\n            this.data = [];\n            this.chunks = [];\n            return sse;\n        }\n        this.chunks.push(line);\n        if (line.startsWith(':')) {\n            return null;\n        }\n        let [fieldname, _, value] = partition(line, ':');\n        if (value.startsWith(' ')) {\n            value = value.substring(1);\n        }\n        if (fieldname === 'event') {\n            this.event = value;\n        }\n        else if (fieldname === 'data') {\n            this.data.push(value);\n        }\n        return null;\n    }\n}\nfunction partition(str, delimiter) {\n    const index = str.indexOf(delimiter);\n    if (index !== -1) {\n        return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];\n    }\n    return [str, '', ''];\n}\n//# sourceMappingURL=streaming.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvc3RyZWFtaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDdUY7QUFDMUM7QUFDYztBQUN5QjtBQUNkO0FBQ2hCO0FBQ0U7QUFDQztBQUNIO0FBQ2Y7QUFDaEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkVBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrRUFBUztBQUN6QztBQUNBO0FBQ0EsMEJBQTBCLHNEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdEQUFRLFlBQVksb0VBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtFQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxvRUFBVztBQUMvQyx5QkFBeUIsa0ZBQTZCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrRUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsMkVBQXNCO0FBQ3ZGLGtFQUFrRSwyRUFBc0I7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVFQUFrQjtBQUNqQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0Esa0NBQWtDLHFFQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQSxrQkFBa0Isc0RBQWM7QUFDaEM7QUFDQTtBQUNBLDRCQUE0QixvRUFBVztBQUN2QyxpQkFBaUIsa0ZBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxRUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUZBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvc3RyZWFtaW5nLm1qcz9lZjg2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfU3RyZWFtX2NsaWVudDtcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwiLi4vaW50ZXJuYWwvdHNsaWIubWpzXCI7XG5pbXBvcnQgeyBBbnRocm9waWNFcnJvciB9IGZyb20gXCIuL2Vycm9yLm1qc1wiO1xuaW1wb3J0IHsgbWFrZVJlYWRhYmxlU3RyZWFtIH0gZnJvbSBcIi4uL2ludGVybmFsL3NoaW1zLm1qc1wiO1xuaW1wb3J0IHsgZmluZERvdWJsZU5ld2xpbmVJbmRleCwgTGluZURlY29kZXIgfSBmcm9tIFwiLi4vaW50ZXJuYWwvZGVjb2RlcnMvbGluZS5tanNcIjtcbmltcG9ydCB7IFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlIH0gZnJvbSBcIi4uL2ludGVybmFsL3NoaW1zLm1qc1wiO1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yIH0gZnJvbSBcIi4uL2ludGVybmFsL2Vycm9ycy5tanNcIjtcbmltcG9ydCB7IHNhZmVKU09OIH0gZnJvbSBcIi4uL2ludGVybmFsL3V0aWxzL3ZhbHVlcy5tanNcIjtcbmltcG9ydCB7IGVuY29kZVVURjggfSBmcm9tIFwiLi4vaW50ZXJuYWwvdXRpbHMvYnl0ZXMubWpzXCI7XG5pbXBvcnQgeyBsb2dnZXJGb3IgfSBmcm9tIFwiLi4vaW50ZXJuYWwvdXRpbHMvbG9nLm1qc1wiO1xuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tIFwiLi9lcnJvci5tanNcIjtcbmV4cG9ydCBjbGFzcyBTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yLCBjb250cm9sbGVyLCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICBfU3RyZWFtX2NsaWVudC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RyZWFtX2NsaWVudCwgY2xpZW50LCBcImZcIik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIGNvbnRyb2xsZXIsIGNsaWVudCkge1xuICAgICAgICBsZXQgY29uc3VtZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0gY2xpZW50ID8gbG9nZ2VyRm9yKGNsaWVudCkgOiBjb25zb2xlO1xuICAgICAgICBhc3luYyBmdW5jdGlvbiogaXRlcmF0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoJ0Nhbm5vdCBpdGVyYXRlIG92ZXIgYSBjb25zdW1lZCBzdHJlYW0sIHVzZSBgLnRlZSgpYCB0byBzcGxpdCB0aGUgc3RyZWFtLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBzc2Ugb2YgX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gJ2NvbXBsZXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gJ21lc3NhZ2Vfc3RhcnQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzc2UuZXZlbnQgPT09ICdtZXNzYWdlX2RlbHRhJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3NlLmV2ZW50ID09PSAnbWVzc2FnZV9zdG9wJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3NlLmV2ZW50ID09PSAnY29udGVudF9ibG9ja19zdGFydCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNzZS5ldmVudCA9PT0gJ2NvbnRlbnRfYmxvY2tfZGVsdGEnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBzc2UuZXZlbnQgPT09ICdjb250ZW50X2Jsb2NrX3N0b3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoYENvdWxkIG5vdCBwYXJzZSBtZXNzYWdlIGludG8gSlNPTjpgLCBzc2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNzZS5ldmVudCA9PT0gJ3BpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3NlLmV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IodW5kZWZpbmVkLCBzYWZlSlNPTihzc2UuZGF0YSkgPz8gc3NlLmRhdGEsIHVuZGVmaW5lZCwgcmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGBicmVha2BzLCBhYm9ydCB0aGUgb25nb2luZyByZXF1ZXN0LlxuICAgICAgICAgICAgICAgIGlmICghZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyLCBjbGllbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBTdHJlYW0gZnJvbSBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtXG4gICAgICogd2hlcmUgZWFjaCBpdGVtIGlzIGEgSlNPTiB2YWx1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtLCBjb250cm9sbGVyLCBjbGllbnQpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyTGluZXMoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuICAgICAgICAgICAgY29uc3QgaXRlciA9IFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHJlYWRhYmxlU3RyZWFtKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGxpbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmZsdXNoKCkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpIHtcbiAgICAgICAgICAgIGlmIChjb25zdW1lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcignQ2Fubm90IGl0ZXJhdGUgb3ZlciBhIGNvbnN1bWVkIHN0cmVhbSwgdXNlIGAudGVlKClgIHRvIHNwbGl0IHRoZSBzdHJlYW0uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdW1lZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxpbmUgb2YgaXRlckxpbmVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgY2FsbHMgYHN0cmVhbS5jb250cm9sbGVyLmFib3J0KClgLCB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IHRocm93aW5nLlxuICAgICAgICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW0oaXRlcmF0b3IsIGNvbnRyb2xsZXIsIGNsaWVudCk7XG4gICAgfVxuICAgIFsoX1N0cmVhbV9jbGllbnQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuYXN5bmNJdGVyYXRvcildKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgdGhlIHN0cmVhbSBpbnRvIHR3byBzdHJlYW1zIHdoaWNoIGNhbiBiZVxuICAgICAqIGluZGVwZW5kZW50bHkgcmVhZCBmcm9tIGF0IGRpZmZlcmVudCBzcGVlZHMuXG4gICAgICovXG4gICAgdGVlKCkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gW107XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gW107XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBjb25zdCB0ZWVJdGVyYXRvciA9IChxdWV1ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihsZWZ0KSwgdGhpcy5jb250cm9sbGVyLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdHJlYW1fY2xpZW50LCBcImZcIikpLFxuICAgICAgICAgICAgbmV3IFN0cmVhbSgoKSA9PiB0ZWVJdGVyYXRvcihyaWdodCksIHRoaXMuY29udHJvbGxlciwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RyZWFtX2NsaWVudCwgXCJmXCIpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBzdHJlYW0gdG8gYSBuZXdsaW5lLXNlcGFyYXRlZCBSZWFkYWJsZVN0cmVhbSBvZlxuICAgICAqIEpTT04gc3RyaW5naWZpZWQgdmFsdWVzIGluIHRoZSBzdHJlYW1cbiAgICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgICAqL1xuICAgIHRvUmVhZGFibGVTdHJlYW0oKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgaXRlcjtcbiAgICAgICAgcmV0dXJuIG1ha2VSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgICAgICAgICBpdGVyID0gc2VsZltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBwdWxsKGN0cmwpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3RybC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZVVURjgoSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjdHJsLmVucXVldWUoYnl0ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGl0ZXIucmV0dXJuPy4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogX2l0ZXJTU0VNZXNzYWdlcyhyZXNwb25zZSwgY29udHJvbGxlcikge1xuICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWxUaGlzLm5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYFRoZSBkZWZhdWx0IHJlYWN0LW5hdGl2ZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbWluZy4gUGxlYXNlIHVzZSBleHBvL2ZldGNoOiBodHRwczovL2RvY3MuZXhwby5kZXYvdmVyc2lvbnMvbGF0ZXN0L3Nkay9leHBvLyNleHBvZmV0Y2gtYXBpYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKGBBdHRlbXB0ZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcmVzcG9uc2Ugd2l0aCBubyBib2R5YCk7XG4gICAgfVxuICAgIGNvbnN0IHNzZURlY29kZXIgPSBuZXcgU1NFRGVjb2RlcigpO1xuICAgIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gICAgY29uc3QgaXRlciA9IFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHJlc3BvbnNlLmJvZHkpO1xuICAgIGZvciBhd2FpdCAoY29uc3Qgc3NlQ2h1bmsgb2YgaXRlclNTRUNodW5rcyhpdGVyKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKHNzZUNodW5rKSkge1xuICAgICAgICAgICAgY29uc3Qgc3NlID0gc3NlRGVjb2Rlci5kZWNvZGUobGluZSk7XG4gICAgICAgICAgICBpZiAoc3NlKVxuICAgICAgICAgICAgICAgIHlpZWxkIHNzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICBjb25zdCBzc2UgPSBzc2VEZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgICAgaWYgKHNzZSlcbiAgICAgICAgICAgIHlpZWxkIHNzZTtcbiAgICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGFzeW5jIGl0ZXJhYmxlIGl0ZXJhdG9yLCBpdGVyYXRlcyBvdmVyIGl0IGFuZCB5aWVsZHMgZnVsbFxuICogU1NFIGNodW5rcywgaS5lLiB5aWVsZHMgd2hlbiBhIGRvdWJsZSBuZXctbGluZSBpcyBlbmNvdW50ZXJlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24qIGl0ZXJTU0VDaHVua3MoaXRlcmF0b3IpIHtcbiAgICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyYXRvcikge1xuICAgICAgICBpZiAoY2h1bmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmluYXJ5Q2h1bmsgPSBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBlbmNvZGVVVEY4KGNodW5rKVxuICAgICAgICAgICAgICAgIDogY2h1bms7XG4gICAgICAgIGxldCBuZXdEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGggKyBiaW5hcnlDaHVuay5sZW5ndGgpO1xuICAgICAgICBuZXdEYXRhLnNldChkYXRhKTtcbiAgICAgICAgbmV3RGF0YS5zZXQoYmluYXJ5Q2h1bmssIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgICAgIHdoaWxlICgocGF0dGVybkluZGV4ID0gZmluZERvdWJsZU5ld2xpbmVJbmRleChkYXRhKSkgIT09IC0xKSB7XG4gICAgICAgICAgICB5aWVsZCBkYXRhLnNsaWNlKDAsIHBhdHRlcm5JbmRleCk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShwYXR0ZXJuSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgZGF0YTtcbiAgICB9XG59XG5jbGFzcyBTU0VEZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgIH1cbiAgICBkZWNvZGUobGluZSkge1xuICAgICAgICBpZiAobGluZS5lbmRzV2l0aCgnXFxyJykpIHtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbGluZSkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZSBhbmQgd2UgZGlkbid0IHByZXZpb3VzbHkgZW5jb3VudGVyIGFueSBtZXNzYWdlc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50ICYmICF0aGlzLmRhdGEubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc3NlID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICByYXc6IHRoaXMuY2h1bmtzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgICAgICB0aGlzLmNodW5rcyA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuIHNzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKGxpbmUpO1xuICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCc6JykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBbZmllbGRuYW1lLCBfLCB2YWx1ZV0gPSBwYXJ0aXRpb24obGluZSwgJzonKTtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkbmFtZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgICAgdGhpcy5ldmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkbmFtZSA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFydGl0aW9uKHN0ciwgZGVsaW1pdGVyKSB7XG4gICAgY29uc3QgaW5kZXggPSBzdHIuaW5kZXhPZihkZWxpbWl0ZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtzdHIuc3Vic3RyaW5nKDAsIGluZGV4KSwgZGVsaW1pdGVyLCBzdHIuc3Vic3RyaW5nKGluZGV4ICsgZGVsaW1pdGVyLmxlbmd0aCldO1xuICAgIH1cbiAgICByZXR1cm4gW3N0ciwgJycsICcnXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbWluZy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/streaming.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/core/uploads.mjs":
/*!*************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/core/uploads.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toFile: () => (/* reexport safe */ _internal_to_file_mjs__WEBPACK_IMPORTED_MODULE_0__.toFile)\n/* harmony export */ });\n/* harmony import */ var _internal_to_file_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/to-file.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/to-file.mjs\");\n\n//# sourceMappingURL=uploads.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2NvcmUvdXBsb2Fkcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDakQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9jb3JlL3VwbG9hZHMubWpzPzBhZDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgdG9GaWxlIH0gZnJvbSBcIi4uL2ludGVybmFsL3RvLWZpbGUubWpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cGxvYWRzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/core/uploads.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs":
/*!******************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/error.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIConnectionError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.APIConnectionError),\n/* harmony export */   APIConnectionTimeoutError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.APIConnectionTimeoutError),\n/* harmony export */   APIError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.APIError),\n/* harmony export */   APIUserAbortError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.APIUserAbortError),\n/* harmony export */   AnthropicError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError),\n/* harmony export */   AuthenticationError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AuthenticationError),\n/* harmony export */   BadRequestError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.BadRequestError),\n/* harmony export */   ConflictError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.ConflictError),\n/* harmony export */   InternalServerError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.InternalServerError),\n/* harmony export */   NotFoundError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.NotFoundError),\n/* harmony export */   PermissionDeniedError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.PermissionDeniedError),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.RateLimitError),\n/* harmony export */   UnprocessableEntityError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.UnprocessableEntityError)\n/* harmony export */ });\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n\n//# sourceMappingURL=error.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2Vycm9yLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFpQztBQUNqQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2Vycm9yLm1qcz8yZmZhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2NvcmUvZXJyb3IubWpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/index.mjs":
/*!******************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_PROMPT: () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.AI_PROMPT),\n/* harmony export */   APIConnectionError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.APIConnectionError),\n/* harmony export */   APIConnectionTimeoutError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.APIConnectionTimeoutError),\n/* harmony export */   APIError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.APIError),\n/* harmony export */   APIPromise: () => (/* reexport safe */ _core_api_promise_mjs__WEBPACK_IMPORTED_MODULE_2__.APIPromise),\n/* harmony export */   APIUserAbortError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.APIUserAbortError),\n/* harmony export */   Anthropic: () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.Anthropic),\n/* harmony export */   AnthropicError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.AnthropicError),\n/* harmony export */   AuthenticationError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.AuthenticationError),\n/* harmony export */   BadRequestError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.BadRequestError),\n/* harmony export */   BaseAnthropic: () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.BaseAnthropic),\n/* harmony export */   ConflictError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.ConflictError),\n/* harmony export */   HUMAN_PROMPT: () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.HUMAN_PROMPT),\n/* harmony export */   InternalServerError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.InternalServerError),\n/* harmony export */   NotFoundError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.NotFoundError),\n/* harmony export */   PagePromise: () => (/* reexport safe */ _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_3__.PagePromise),\n/* harmony export */   PermissionDeniedError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.PermissionDeniedError),\n/* harmony export */   RateLimitError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.RateLimitError),\n/* harmony export */   UnprocessableEntityError: () => (/* reexport safe */ _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__.UnprocessableEntityError),\n/* harmony export */   \"default\": () => (/* reexport safe */ _client_mjs__WEBPACK_IMPORTED_MODULE_0__.Anthropic),\n/* harmony export */   toFile: () => (/* reexport safe */ _core_uploads_mjs__WEBPACK_IMPORTED_MODULE_1__.toFile)\n/* harmony export */ });\n/* harmony import */ var _client_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/client.mjs\");\n/* harmony import */ var _core_uploads_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/uploads.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/uploads.mjs\");\n/* harmony import */ var _core_api_promise_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/api-promise.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/api-promise.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ29EO0FBQ1I7QUFDUTtBQUM2QjtBQUM3QjtBQUNxTztBQUN6UiIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2luZGV4Lm1qcz82N2RhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5leHBvcnQgeyBBbnRocm9waWMgYXMgZGVmYXVsdCB9IGZyb20gXCIuL2NsaWVudC5tanNcIjtcbmV4cG9ydCB7IHRvRmlsZSB9IGZyb20gXCIuL2NvcmUvdXBsb2Fkcy5tanNcIjtcbmV4cG9ydCB7IEFQSVByb21pc2UgfSBmcm9tIFwiLi9jb3JlL2FwaS1wcm9taXNlLm1qc1wiO1xuZXhwb3J0IHsgQmFzZUFudGhyb3BpYywgQW50aHJvcGljLCBIVU1BTl9QUk9NUFQsIEFJX1BST01QVCB9IGZyb20gXCIuL2NsaWVudC5tanNcIjtcbmV4cG9ydCB7IFBhZ2VQcm9taXNlIH0gZnJvbSBcIi4vY29yZS9wYWdpbmF0aW9uLm1qc1wiO1xuZXhwb3J0IHsgQW50aHJvcGljRXJyb3IsIEFQSUVycm9yLCBBUElDb25uZWN0aW9uRXJyb3IsIEFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IsIEFQSVVzZXJBYm9ydEVycm9yLCBOb3RGb3VuZEVycm9yLCBDb25mbGljdEVycm9yLCBSYXRlTGltaXRFcnJvciwgQmFkUmVxdWVzdEVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yLCBJbnRlcm5hbFNlcnZlckVycm9yLCBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciwgfSBmcm9tIFwiLi9jb3JlL2Vycm9yLm1qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/constants.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/constants.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MODEL_NONSTREAMING_TOKENS: () => (/* binding */ MODEL_NONSTREAMING_TOKENS)\n/* harmony export */ });\n// File containing shared constants\n/**\n * Model-specific timeout constraints for non-streaming requests\n */\nconst MODEL_NONSTREAMING_TOKENS = {\n    'claude-opus-4-20250514': 8192,\n    'claude-opus-4-0': 8192,\n    'claude-4-opus-20250514': 8192,\n    'anthropic.claude-opus-4-20250514-v1:0': 8192,\n    'claude-opus-4@20250514': 8192,\n    'claude-opus-4-1-20250805': 8192,\n    'anthropic.claude-opus-4-1-20250805-v1:0': 8192,\n    'claude-opus-4-1@20250805': 8192,\n};\n//# sourceMappingURL=constants.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2NvbnN0YW50cy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2NvbnN0YW50cy5tanM/MDRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGNvbnRhaW5pbmcgc2hhcmVkIGNvbnN0YW50c1xuLyoqXG4gKiBNb2RlbC1zcGVjaWZpYyB0aW1lb3V0IGNvbnN0cmFpbnRzIGZvciBub24tc3RyZWFtaW5nIHJlcXVlc3RzXG4gKi9cbmV4cG9ydCBjb25zdCBNT0RFTF9OT05TVFJFQU1JTkdfVE9LRU5TID0ge1xuICAgICdjbGF1ZGUtb3B1cy00LTIwMjUwNTE0JzogODE5MixcbiAgICAnY2xhdWRlLW9wdXMtNC0wJzogODE5MixcbiAgICAnY2xhdWRlLTQtb3B1cy0yMDI1MDUxNCc6IDgxOTIsXG4gICAgJ2FudGhyb3BpYy5jbGF1ZGUtb3B1cy00LTIwMjUwNTE0LXYxOjAnOiA4MTkyLFxuICAgICdjbGF1ZGUtb3B1cy00QDIwMjUwNTE0JzogODE5MixcbiAgICAnY2xhdWRlLW9wdXMtNC0xLTIwMjUwODA1JzogODE5MixcbiAgICAnYW50aHJvcGljLmNsYXVkZS1vcHVzLTQtMS0yMDI1MDgwNS12MTowJzogODE5MixcbiAgICAnY2xhdWRlLW9wdXMtNC0xQDIwMjUwODA1JzogODE5Mixcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/constants.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs":
/*!************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONLDecoder: () => (/* binding */ JSONLDecoder)\n/* harmony export */ });\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n/* harmony import */ var _shims_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shims.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs\");\n/* harmony import */ var _line_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs\");\n\n\n\nclass JSONLDecoder {\n    constructor(iterator, controller) {\n        this.iterator = iterator;\n        this.controller = controller;\n    }\n    async *decoder() {\n        const lineDecoder = new _line_mjs__WEBPACK_IMPORTED_MODULE_2__.LineDecoder();\n        for await (const chunk of this.iterator) {\n            for (const line of lineDecoder.decode(chunk)) {\n                yield JSON.parse(line);\n            }\n        }\n        for (const line of lineDecoder.flush()) {\n            yield JSON.parse(line);\n        }\n    }\n    [Symbol.asyncIterator]() {\n        return this.decoder();\n    }\n    static fromResponse(response, controller) {\n        if (!response.body) {\n            controller.abort();\n            if (typeof globalThis.navigator !== 'undefined' &&\n                globalThis.navigator.product === 'ReactNative') {\n                throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);\n            }\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`Attempted to iterate over a response with no body`);\n        }\n        return new JSONLDecoder((0,_shims_mjs__WEBPACK_IMPORTED_MODULE_1__.ReadableStreamToAsyncIterable)(response.body), controller);\n    }\n}\n//# sourceMappingURL=jsonl.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2RlY29kZXJzL2pzb25sLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNEO0FBQ087QUFDcEI7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQWM7QUFDeEM7QUFDQSxzQkFBc0IsMkRBQWM7QUFDcEM7QUFDQSxnQ0FBZ0MseUVBQTZCO0FBQzdEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2RlY29kZXJzL2pzb25sLm1qcz8zZGMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFudGhyb3BpY0Vycm9yIH0gZnJvbSBcIi4uLy4uL2NvcmUvZXJyb3IubWpzXCI7XG5pbXBvcnQgeyBSZWFkYWJsZVN0cmVhbVRvQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuLi9zaGltcy5tanNcIjtcbmltcG9ydCB7IExpbmVEZWNvZGVyIH0gZnJvbSBcIi4vbGluZS5tanNcIjtcbmV4cG9ydCBjbGFzcyBKU09OTERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGl0ZXJhdG9yLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gICAgYXN5bmMgKmRlY29kZXIoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVEZWNvZGVyID0gbmV3IExpbmVEZWNvZGVyKCk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgdGhpcy5pdGVyYXRvcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVEZWNvZGVyLmRlY29kZShjaHVuaykpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5mbHVzaCgpKSB7XG4gICAgICAgICAgICB5aWVsZCBKU09OLnBhcnNlKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZXIoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21SZXNwb25zZShyZXNwb25zZSwgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgZ2xvYmFsVGhpcy5uYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgVGhlIGRlZmF1bHQgcmVhY3QtbmF0aXZlIGZldGNoIGltcGxlbWVudGF0aW9uIGRvZXMgbm90IHN1cHBvcnQgc3RyZWFtaW5nLiBQbGVhc2UgdXNlIGV4cG8vZmV0Y2g6IGh0dHBzOi8vZG9jcy5leHBvLmRldi92ZXJzaW9ucy9sYXRlc3Qvc2RrL2V4cG8vI2V4cG9mZXRjaC1hcGlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSlNPTkxEZWNvZGVyKFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHJlc3BvbnNlLmJvZHkpLCBjb250cm9sbGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29ubC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LineDecoder: () => (/* binding */ LineDecoder),\n/* harmony export */   findDoubleNewlineIndex: () => (/* binding */ findDoubleNewlineIndex)\n/* harmony export */ });\n/* harmony import */ var _tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/bytes.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs\");\nvar _LineDecoder_buffer, _LineDecoder_carriageReturnIndex;\n\n\n/**\n * A re-implementation of httpx's `LineDecoder` in Python that handles incrementally\n * reading lines from text.\n *\n * https://github.com/encode/httpx/blob/920333ea98118e9cf617f246905d7b202510941c/httpx/_decoders.py#L258\n */\nclass LineDecoder {\n    constructor() {\n        _LineDecoder_buffer.set(this, void 0);\n        _LineDecoder_carriageReturnIndex.set(this, void 0);\n        (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_buffer, new Uint8Array(), \"f\");\n        (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n    }\n    decode(chunk) {\n        if (chunk == null) {\n            return [];\n        }\n        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk)\n            : typeof chunk === 'string' ? (0,_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_1__.encodeUTF8)(chunk)\n                : chunk;\n        (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_buffer, (0,_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_1__.concatBytes)([(0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\"), binaryChunk]), \"f\");\n        const lines = [];\n        let patternIndex;\n        while ((patternIndex = findNewlineIndex((0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\"), (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\"))) != null) {\n            if (patternIndex.carriage && (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\") == null) {\n                // skip until we either get a corresponding `\\n`, a new `\\r` or nothing\n                (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_carriageReturnIndex, patternIndex.index, \"f\");\n                continue;\n            }\n            // we got double \\r or \\rtext\\n\n            if ((0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\") != null &&\n                (patternIndex.index !== (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\") + 1 || patternIndex.carriage)) {\n                lines.push((0,_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeUTF8)((0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\").subarray(0, (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\") - 1)));\n                (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_buffer, (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\").subarray((0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\")), \"f\");\n                (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n                continue;\n            }\n            const endIndex = (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_carriageReturnIndex, \"f\") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;\n            const line = (0,_utils_bytes_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeUTF8)((0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\").subarray(0, endIndex));\n            lines.push(line);\n            (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_buffer, (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\").subarray(patternIndex.index), \"f\");\n            (0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _LineDecoder_carriageReturnIndex, null, \"f\");\n        }\n        return lines;\n    }\n    flush() {\n        if (!(0,_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _LineDecoder_buffer, \"f\").length) {\n            return [];\n        }\n        return this.decode('\\n');\n    }\n}\n_LineDecoder_buffer = new WeakMap(), _LineDecoder_carriageReturnIndex = new WeakMap();\n// prettier-ignore\nLineDecoder.NEWLINE_CHARS = new Set(['\\n', '\\r']);\nLineDecoder.NEWLINE_REGEXP = /\\r\\n|[\\n\\r]/g;\n/**\n * This function searches the buffer for the end patterns, (\\r or \\n)\n * and returns an object with the index preceding the matched newline and the\n * index after the newline char. `null` is returned if no new line is found.\n *\n * ```ts\n * findNewLineIndex('abc\\ndef') -> { preceding: 2, index: 3 }\n * ```\n */\nfunction findNewlineIndex(buffer, startIndex) {\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = startIndex ?? 0; i < buffer.length; i++) {\n        if (buffer[i] === newline) {\n            return { preceding: i, index: i + 1, carriage: false };\n        }\n        if (buffer[i] === carriage) {\n            return { preceding: i, index: i + 1, carriage: true };\n        }\n    }\n    return null;\n}\nfunction findDoubleNewlineIndex(buffer) {\n    // This function searches the buffer for the end patterns (\\r\\r, \\n\\n, \\r\\n\\r\\n)\n    // and returns the index right after the first occurrence of any pattern,\n    // or -1 if none of the patterns are found.\n    const newline = 0x0a; // \\n\n    const carriage = 0x0d; // \\r\n    for (let i = 0; i < buffer.length - 1; i++) {\n        if (buffer[i] === newline && buffer[i + 1] === newline) {\n            // \\n\\n\n            return i + 2;\n        }\n        if (buffer[i] === carriage && buffer[i + 1] === carriage) {\n            // \\r\\r\n            return i + 2;\n        }\n        if (buffer[i] === carriage &&\n            buffer[i + 1] === newline &&\n            i + 3 < buffer.length &&\n            buffer[i + 2] === carriage &&\n            buffer[i + 3] === newline) {\n            // \\r\\n\\r\\n\n            return i + 4;\n        }\n    }\n    return -1;\n}\n//# sourceMappingURL=line.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2RlY29kZXJzL2xpbmUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUM4RTtBQUNMO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRUFBc0I7QUFDOUIsUUFBUSxrRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDREQUFVO0FBQ3BEO0FBQ0EsUUFBUSxrRUFBc0IsNEJBQTRCLDZEQUFXLEVBQUUsa0VBQXNCO0FBQzdGO0FBQ0E7QUFDQSxnREFBZ0Qsa0VBQXNCLGtDQUFrQyxrRUFBc0I7QUFDOUgseUNBQXlDLGtFQUFzQjtBQUMvRDtBQUNBLGdCQUFnQixrRUFBc0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFzQjtBQUN0Qyx3Q0FBd0Msa0VBQXNCO0FBQzlELDJCQUEyQiw0REFBVSxDQUFDLGtFQUFzQiw2Q0FBNkMsa0VBQXNCO0FBQy9ILGdCQUFnQixrRUFBc0IsNEJBQTRCLGtFQUFzQiwwQ0FBMEMsa0VBQXNCO0FBQ3hKLGdCQUFnQixrRUFBc0I7QUFDdEM7QUFDQTtBQUNBLDZCQUE2QixrRUFBc0I7QUFDbkQseUJBQXlCLDREQUFVLENBQUMsa0VBQXNCO0FBQzFEO0FBQ0EsWUFBWSxrRUFBc0IsNEJBQTRCLGtFQUFzQjtBQUNwRixZQUFZLGtFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0VBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQixvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9pbnRlcm5hbC9kZWNvZGVycy9saW5lLm1qcz8zODgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfTGluZURlY29kZXJfYnVmZmVyLCBfTGluZURlY29kZXJfY2FycmlhZ2VSZXR1cm5JbmRleDtcbmltcG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRHZXQsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgfSBmcm9tIFwiLi4vdHNsaWIubWpzXCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgZGVjb2RlVVRGOCwgZW5jb2RlVVRGOCB9IGZyb20gXCIuLi91dGlscy9ieXRlcy5tanNcIjtcbi8qKlxuICogQSByZS1pbXBsZW1lbnRhdGlvbiBvZiBodHRweCdzIGBMaW5lRGVjb2RlcmAgaW4gUHl0aG9uIHRoYXQgaGFuZGxlcyBpbmNyZW1lbnRhbGx5XG4gKiByZWFkaW5nIGxpbmVzIGZyb20gdGV4dC5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZW5jb2RlL2h0dHB4L2Jsb2IvOTIwMzMzZWE5ODExOGU5Y2Y2MTdmMjQ2OTA1ZDdiMjAyNTEwOTQxYy9odHRweC9fZGVjb2RlcnMucHkjTDI1OFxuICovXG5leHBvcnQgY2xhc3MgTGluZURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfTGluZURlY29kZXJfYnVmZmVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfTGluZURlY29kZXJfY2FycmlhZ2VSZXR1cm5JbmRleC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTGluZURlY29kZXJfYnVmZmVyLCBuZXcgVWludDhBcnJheSgpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0xpbmVEZWNvZGVyX2NhcnJpYWdlUmV0dXJuSW5kZXgsIG51bGwsIFwiZlwiKTtcbiAgICB9XG4gICAgZGVjb2RlKGNodW5rKSB7XG4gICAgICAgIGlmIChjaHVuayA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmluYXJ5Q2h1bmsgPSBjaHVuayBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoY2h1bmspXG4gICAgICAgICAgICA6IHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgPyBlbmNvZGVVVEY4KGNodW5rKVxuICAgICAgICAgICAgICAgIDogY2h1bms7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0xpbmVEZWNvZGVyX2J1ZmZlciwgY29uY2F0Qnl0ZXMoW19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xpbmVEZWNvZGVyX2J1ZmZlciwgXCJmXCIpLCBiaW5hcnlDaHVua10pLCBcImZcIik7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICAgIGxldCBwYXR0ZXJuSW5kZXg7XG4gICAgICAgIHdoaWxlICgocGF0dGVybkluZGV4ID0gZmluZE5ld2xpbmVJbmRleChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9idWZmZXIsIFwiZlwiKSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTGluZURlY29kZXJfY2FycmlhZ2VSZXR1cm5JbmRleCwgXCJmXCIpKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHBhdHRlcm5JbmRleC5jYXJyaWFnZSAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9jYXJyaWFnZVJldHVybkluZGV4LCBcImZcIikgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgdW50aWwgd2UgZWl0aGVyIGdldCBhIGNvcnJlc3BvbmRpbmcgYFxcbmAsIGEgbmV3IGBcXHJgIG9yIG5vdGhpbmdcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9jYXJyaWFnZVJldHVybkluZGV4LCBwYXR0ZXJuSW5kZXguaW5kZXgsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGdvdCBkb3VibGUgXFxyIG9yIFxccnRleHRcXG5cbiAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9jYXJyaWFnZVJldHVybkluZGV4LCBcImZcIikgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIChwYXR0ZXJuSW5kZXguaW5kZXggIT09IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xpbmVEZWNvZGVyX2NhcnJpYWdlUmV0dXJuSW5kZXgsIFwiZlwiKSArIDEgfHwgcGF0dGVybkluZGV4LmNhcnJpYWdlKSkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goZGVjb2RlVVRGOChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9idWZmZXIsIFwiZlwiKS5zdWJhcnJheSgwLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9jYXJyaWFnZVJldHVybkluZGV4LCBcImZcIikgLSAxKSkpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0xpbmVEZWNvZGVyX2J1ZmZlciwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTGluZURlY29kZXJfYnVmZmVyLCBcImZcIikuc3ViYXJyYXkoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTGluZURlY29kZXJfY2FycmlhZ2VSZXR1cm5JbmRleCwgXCJmXCIpKSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0xpbmVEZWNvZGVyX2NhcnJpYWdlUmV0dXJuSW5kZXgsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTGluZURlY29kZXJfY2FycmlhZ2VSZXR1cm5JbmRleCwgXCJmXCIpICE9PSBudWxsID8gcGF0dGVybkluZGV4LnByZWNlZGluZyAtIDEgOiBwYXR0ZXJuSW5kZXgucHJlY2VkaW5nO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZVVURjgoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTGluZURlY29kZXJfYnVmZmVyLCBcImZcIikuc3ViYXJyYXkoMCwgZW5kSW5kZXgpKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9MaW5lRGVjb2Rlcl9idWZmZXIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xpbmVEZWNvZGVyX2J1ZmZlciwgXCJmXCIpLnN1YmFycmF5KHBhdHRlcm5JbmRleC5pbmRleCksIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0xpbmVEZWNvZGVyX2NhcnJpYWdlUmV0dXJuSW5kZXgsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0xpbmVEZWNvZGVyX2J1ZmZlciwgXCJmXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZSgnXFxuJyk7XG4gICAgfVxufVxuX0xpbmVEZWNvZGVyX2J1ZmZlciA9IG5ldyBXZWFrTWFwKCksIF9MaW5lRGVjb2Rlcl9jYXJyaWFnZVJldHVybkluZGV4ID0gbmV3IFdlYWtNYXAoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuTGluZURlY29kZXIuTkVXTElORV9DSEFSUyA9IG5ldyBTZXQoWydcXG4nLCAnXFxyJ10pO1xuTGluZURlY29kZXIuTkVXTElORV9SRUdFWFAgPSAvXFxyXFxufFtcXG5cXHJdL2c7XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gc2VhcmNoZXMgdGhlIGJ1ZmZlciBmb3IgdGhlIGVuZCBwYXR0ZXJucywgKFxcciBvciBcXG4pXG4gKiBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgaW5kZXggcHJlY2VkaW5nIHRoZSBtYXRjaGVkIG5ld2xpbmUgYW5kIHRoZVxuICogaW5kZXggYWZ0ZXIgdGhlIG5ld2xpbmUgY2hhci4gYG51bGxgIGlzIHJldHVybmVkIGlmIG5vIG5ldyBsaW5lIGlzIGZvdW5kLlxuICpcbiAqIGBgYHRzXG4gKiBmaW5kTmV3TGluZUluZGV4KCdhYmNcXG5kZWYnKSAtPiB7IHByZWNlZGluZzogMiwgaW5kZXg6IDMgfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbmROZXdsaW5lSW5kZXgoYnVmZmVyLCBzdGFydEluZGV4KSB7XG4gICAgY29uc3QgbmV3bGluZSA9IDB4MGE7IC8vIFxcblxuICAgIGNvbnN0IGNhcnJpYWdlID0gMHgwZDsgLy8gXFxyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXggPz8gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYnVmZmVyW2ldID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwcmVjZWRpbmc6IGksIGluZGV4OiBpICsgMSwgY2FycmlhZ2U6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByZWNlZGluZzogaSwgaW5kZXg6IGkgKyAxLCBjYXJyaWFnZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREb3VibGVOZXdsaW5lSW5kZXgoYnVmZmVyKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBzZWFyY2hlcyB0aGUgYnVmZmVyIGZvciB0aGUgZW5kIHBhdHRlcm5zIChcXHJcXHIsIFxcblxcbiwgXFxyXFxuXFxyXFxuKVxuICAgIC8vIGFuZCByZXR1cm5zIHRoZSBpbmRleCByaWdodCBhZnRlciB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbnkgcGF0dGVybixcbiAgICAvLyBvciAtMSBpZiBub25lIG9mIHRoZSBwYXR0ZXJucyBhcmUgZm91bmQuXG4gICAgY29uc3QgbmV3bGluZSA9IDB4MGE7IC8vIFxcblxuICAgIGNvbnN0IGNhcnJpYWdlID0gMHgwZDsgLy8gXFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IG5ld2xpbmUgJiYgYnVmZmVyW2kgKyAxXSA9PT0gbmV3bGluZSkge1xuICAgICAgICAgICAgLy8gXFxuXFxuXG4gICAgICAgICAgICByZXR1cm4gaSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gY2FycmlhZ2UgJiYgYnVmZmVyW2kgKyAxXSA9PT0gY2FycmlhZ2UpIHtcbiAgICAgICAgICAgIC8vIFxcclxcclxuICAgICAgICAgICAgcmV0dXJuIGkgKyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidWZmZXJbaV0gPT09IGNhcnJpYWdlICYmXG4gICAgICAgICAgICBidWZmZXJbaSArIDFdID09PSBuZXdsaW5lICYmXG4gICAgICAgICAgICBpICsgMyA8IGJ1ZmZlci5sZW5ndGggJiZcbiAgICAgICAgICAgIGJ1ZmZlcltpICsgMl0gPT09IGNhcnJpYWdlICYmXG4gICAgICAgICAgICBidWZmZXJbaSArIDNdID09PSBuZXdsaW5lKSB7XG4gICAgICAgICAgICAvLyBcXHJcXG5cXHJcXG5cbiAgICAgICAgICAgIHJldHVybiBpICsgNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5lLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getPlatformHeaders: () => (/* binding */ getPlatformHeaders),\n/* harmony export */   isRunningInBrowser: () => (/* binding */ isRunningInBrowser)\n/* harmony export */ });\n/* harmony import */ var _version_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/version.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nconst isRunningInBrowser = () => {\n    return (\n    // @ts-ignore\n    typeof window !== 'undefined' &&\n        // @ts-ignore\n        typeof window.document !== 'undefined' &&\n        // @ts-ignore\n        typeof navigator !== 'undefined');\n};\n/**\n * Note this does not detect 'browser'; for that, use getBrowserInfo().\n */\nfunction getDetectedPlatform() {\n    if (typeof Deno !== 'undefined' && Deno.build != null) {\n        return 'deno';\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return 'edge';\n    }\n    if (Object.prototype.toString.call(typeof globalThis.process !== 'undefined' ? globalThis.process : 0) === '[object process]') {\n        return 'node';\n    }\n    return 'unknown';\n}\nconst getPlatformProperties = () => {\n    const detectedPlatform = getDetectedPlatform();\n    if (detectedPlatform === 'deno') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': _version_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION,\n            'X-Stainless-OS': normalizePlatform(Deno.build.os),\n            'X-Stainless-Arch': normalizeArch(Deno.build.arch),\n            'X-Stainless-Runtime': 'deno',\n            'X-Stainless-Runtime-Version': typeof Deno.version === 'string' ? Deno.version : Deno.version?.deno ?? 'unknown',\n        };\n    }\n    if (typeof EdgeRuntime !== 'undefined') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': _version_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': `other:${EdgeRuntime}`,\n            'X-Stainless-Runtime': 'edge',\n            'X-Stainless-Runtime-Version': globalThis.process.version,\n        };\n    }\n    // Check if Node.js\n    if (detectedPlatform === 'node') {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': _version_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION,\n            'X-Stainless-OS': normalizePlatform(globalThis.process.platform ?? 'unknown'),\n            'X-Stainless-Arch': normalizeArch(globalThis.process.arch ?? 'unknown'),\n            'X-Stainless-Runtime': 'node',\n            'X-Stainless-Runtime-Version': globalThis.process.version ?? 'unknown',\n        };\n    }\n    const browserInfo = getBrowserInfo();\n    if (browserInfo) {\n        return {\n            'X-Stainless-Lang': 'js',\n            'X-Stainless-Package-Version': _version_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION,\n            'X-Stainless-OS': 'Unknown',\n            'X-Stainless-Arch': 'unknown',\n            'X-Stainless-Runtime': `browser:${browserInfo.browser}`,\n            'X-Stainless-Runtime-Version': browserInfo.version,\n        };\n    }\n    // TODO add support for Cloudflare workers, etc.\n    return {\n        'X-Stainless-Lang': 'js',\n        'X-Stainless-Package-Version': _version_mjs__WEBPACK_IMPORTED_MODULE_0__.VERSION,\n        'X-Stainless-OS': 'Unknown',\n        'X-Stainless-Arch': 'unknown',\n        'X-Stainless-Runtime': 'unknown',\n        'X-Stainless-Runtime-Version': 'unknown',\n    };\n};\n// Note: modified from https://github.com/JS-DevTools/host-environment/blob/b1ab79ecde37db5d6e163c050e54fe7d287d7c92/src/isomorphic.browser.ts\nfunction getBrowserInfo() {\n    if (typeof navigator === 'undefined' || !navigator) {\n        return null;\n    }\n    // NOTE: The order matters here!\n    const browserPatterns = [\n        { key: 'edge', pattern: /Edge(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /MSIE(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'ie', pattern: /Trident(?:.*rv\\:(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'chrome', pattern: /Chrome(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'firefox', pattern: /Firefox(?:\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?/ },\n        { key: 'safari', pattern: /(?:Version\\W+(\\d+)\\.(\\d+)(?:\\.(\\d+))?)?(?:\\W+Mobile\\S*)?\\W+Safari/ },\n    ];\n    // Find the FIRST matching browser\n    for (const { key, pattern } of browserPatterns) {\n        const match = pattern.exec(navigator.userAgent);\n        if (match) {\n            const major = match[1] || 0;\n            const minor = match[2] || 0;\n            const patch = match[3] || 0;\n            return { browser: key, version: `${major}.${minor}.${patch}` };\n        }\n    }\n    return null;\n}\nconst normalizeArch = (arch) => {\n    // Node docs:\n    // - https://nodejs.org/api/process.html#processarch\n    // Deno docs:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    if (arch === 'x32')\n        return 'x32';\n    if (arch === 'x86_64' || arch === 'x64')\n        return 'x64';\n    if (arch === 'arm')\n        return 'arm';\n    if (arch === 'aarch64' || arch === 'arm64')\n        return 'arm64';\n    if (arch)\n        return `other:${arch}`;\n    return 'unknown';\n};\nconst normalizePlatform = (platform) => {\n    // Node platforms:\n    // - https://nodejs.org/api/process.html#processplatform\n    // Deno platforms:\n    // - https://doc.deno.land/deno/stable/~/Deno.build\n    // - https://github.com/denoland/deno/issues/14799\n    platform = platform.toLowerCase();\n    // NOTE: this iOS check is untested and may not work\n    // Node does not work natively on IOS, there is a fork at\n    // https://github.com/nodejs-mobile/nodejs-mobile\n    // however it is unknown at the time of writing how to detect if it is running\n    if (platform.includes('ios'))\n        return 'iOS';\n    if (platform === 'android')\n        return 'Android';\n    if (platform === 'darwin')\n        return 'MacOS';\n    if (platform === 'win32')\n        return 'Windows';\n    if (platform === 'freebsd')\n        return 'FreeBSD';\n    if (platform === 'openbsd')\n        return 'OpenBSD';\n    if (platform === 'linux')\n        return 'Linux';\n    if (platform)\n        return `Other:${platform}`;\n    return 'Unknown';\n};\nlet _platformHeaders;\nconst getPlatformHeaders = () => {\n    return (_platformHeaders ?? (_platformHeaders = getPlatformProperties()));\n};\n//# sourceMappingURL=detect-platform.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2RldGVjdC1wbGF0Zm9ybS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDeUM7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGlEQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpREFBTztBQUNsRDtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsaURBQU87QUFDbEQ7QUFDQTtBQUNBLDhDQUE4QyxvQkFBb0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlEQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4REFBOEQ7QUFDeEUsVUFBVSw0REFBNEQ7QUFDdEUsVUFBVSxrRUFBa0U7QUFDNUUsVUFBVSxrRUFBa0U7QUFDNUUsVUFBVSxvRUFBb0U7QUFDOUUsVUFBVSw2RkFBNkY7QUFDdkc7QUFDQTtBQUNBLGlCQUFpQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCLE1BQU0sR0FBRyxNQUFNLEdBQUcsTUFBTTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvZGV0ZWN0LXBsYXRmb3JtLm1qcz85MDE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4uL3ZlcnNpb24ubWpzXCI7XG5leHBvcnQgY29uc3QgaXNSdW5uaW5nSW5Ccm93c2VyID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyk7XG59O1xuLyoqXG4gKiBOb3RlIHRoaXMgZG9lcyBub3QgZGV0ZWN0ICdicm93c2VyJzsgZm9yIHRoYXQsIHVzZSBnZXRCcm93c2VySW5mbygpLlxuICovXG5mdW5jdGlvbiBnZXREZXRlY3RlZFBsYXRmb3JtKCkge1xuICAgIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgRGVuby5idWlsZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnZGVubyc7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAnZWRnZSc7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzLnByb2Nlc3MgOiAwKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgfVxuICAgIHJldHVybiAndW5rbm93bic7XG59XG5jb25zdCBnZXRQbGF0Zm9ybVByb3BlcnRpZXMgPSAoKSA9PiB7XG4gICAgY29uc3QgZGV0ZWN0ZWRQbGF0Zm9ybSA9IGdldERldGVjdGVkUGxhdGZvcm0oKTtcbiAgICBpZiAoZGV0ZWN0ZWRQbGF0Zm9ybSA9PT0gJ2Rlbm8nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6IG5vcm1hbGl6ZVBsYXRmb3JtKERlbm8uYnVpbGQub3MpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUFyY2gnOiBub3JtYWxpemVBcmNoKERlbm8uYnVpbGQuYXJjaCksXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdkZW5vJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiB0eXBlb2YgRGVuby52ZXJzaW9uID09PSAnc3RyaW5nJyA/IERlbm8udmVyc2lvbiA6IERlbm8udmVyc2lvbj8uZGVubyA/PyAndW5rbm93bicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgRWRnZVJ1bnRpbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogYG90aGVyOiR7RWRnZVJ1bnRpbWV9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ2VkZ2UnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IGdsb2JhbFRoaXMucHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBOb2RlLmpzXG4gICAgaWYgKGRldGVjdGVkUGxhdGZvcm0gPT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gPz8gJ3Vua25vd24nKSxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChnbG9iYWxUaGlzLnByb2Nlc3MuYXJjaCA/PyAndW5rbm93bicpLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogZ2xvYmFsVGhpcy5wcm9jZXNzLnZlcnNpb24gPz8gJ3Vua25vd24nLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gICAgaWYgKGJyb3dzZXJJbmZvKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiBgYnJvd3Nlcjoke2Jyb3dzZXJJbmZvLmJyb3dzZXJ9YCxcbiAgICAgICAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBicm93c2VySW5mby52ZXJzaW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBUT0RPIGFkZCBzdXBwb3J0IGZvciBDbG91ZGZsYXJlIHdvcmtlcnMsIGV0Yy5cbiAgICByZXR1cm4ge1xuICAgICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAgICdYLVN0YWlubGVzcy1QYWNrYWdlLVZlcnNpb24nOiBWRVJTSU9OLFxuICAgICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICd1bmtub3duJyxcbiAgICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6ICd1bmtub3duJyxcbiAgICB9O1xufTtcbi8vIE5vdGU6IG1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0pTLURldlRvb2xzL2hvc3QtZW52aXJvbm1lbnQvYmxvYi9iMWFiNzllY2RlMzdkYjVkNmUxNjNjMDUwZTU0ZmU3ZDI4N2Q3YzkyL3NyYy9pc29tb3JwaGljLmJyb3dzZXIudHNcbmZ1bmN0aW9uIGdldEJyb3dzZXJJbmZvKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhbmF2aWdhdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBOT1RFOiBUaGUgb3JkZXIgbWF0dGVycyBoZXJlIVxuICAgIGNvbnN0IGJyb3dzZXJQYXR0ZXJucyA9IFtcbiAgICAgICAgeyBrZXk6ICdlZGdlJywgcGF0dGVybjogL0VkZ2UoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdpZScsIHBhdHRlcm46IC9NU0lFKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgICAgIHsga2V5OiAnaWUnLCBwYXR0ZXJuOiAvVHJpZGVudCg/Oi4qcnZcXDooXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/LyB9LFxuICAgICAgICB7IGtleTogJ2Nocm9tZScsIHBhdHRlcm46IC9DaHJvbWUoPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdmaXJlZm94JywgcGF0dGVybjogL0ZpcmVmb3goPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICAgICAgeyBrZXk6ICdzYWZhcmknLCBwYXR0ZXJuOiAvKD86VmVyc2lvblxcVysoXFxkKylcXC4oXFxkKykoPzpcXC4oXFxkKykpPyk/KD86XFxXK01vYmlsZVxcUyopP1xcVytTYWZhcmkvIH0sXG4gICAgXTtcbiAgICAvLyBGaW5kIHRoZSBGSVJTVCBtYXRjaGluZyBicm93c2VyXG4gICAgZm9yIChjb25zdCB7IGtleSwgcGF0dGVybiB9IG9mIGJyb3dzZXJQYXR0ZXJucykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYWpvciA9IG1hdGNoWzFdIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBtaW5vciA9IG1hdGNoWzJdIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBwYXRjaCA9IG1hdGNoWzNdIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4geyBicm93c2VyOiBrZXksIHZlcnNpb246IGAke21ham9yfS4ke21pbm9yfS4ke3BhdGNofWAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IG5vcm1hbGl6ZUFyY2ggPSAoYXJjaCkgPT4ge1xuICAgIC8vIE5vZGUgZG9jczpcbiAgICAvLyAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvcHJvY2Vzcy5odG1sI3Byb2Nlc3NhcmNoXG4gICAgLy8gRGVubyBkb2NzOlxuICAgIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAgIGlmIChhcmNoID09PSAneDMyJylcbiAgICAgICAgcmV0dXJuICd4MzInO1xuICAgIGlmIChhcmNoID09PSAneDg2XzY0JyB8fCBhcmNoID09PSAneDY0JylcbiAgICAgICAgcmV0dXJuICd4NjQnO1xuICAgIGlmIChhcmNoID09PSAnYXJtJylcbiAgICAgICAgcmV0dXJuICdhcm0nO1xuICAgIGlmIChhcmNoID09PSAnYWFyY2g2NCcgfHwgYXJjaCA9PT0gJ2FybTY0JylcbiAgICAgICAgcmV0dXJuICdhcm02NCc7XG4gICAgaWYgKGFyY2gpXG4gICAgICAgIHJldHVybiBgb3RoZXI6JHthcmNofWA7XG4gICAgcmV0dXJuICd1bmtub3duJztcbn07XG5jb25zdCBub3JtYWxpemVQbGF0Zm9ybSA9IChwbGF0Zm9ybSkgPT4ge1xuICAgIC8vIE5vZGUgcGxhdGZvcm1zOlxuICAgIC8vIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc3BsYXRmb3JtXG4gICAgLy8gRGVubyBwbGF0Zm9ybXM6XG4gICAgLy8gLSBodHRwczovL2RvYy5kZW5vLmxhbmQvZGVuby9zdGFibGUvfi9EZW5vLmJ1aWxkXG4gICAgLy8gLSBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVuby9pc3N1ZXMvMTQ3OTlcbiAgICBwbGF0Zm9ybSA9IHBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gTk9URTogdGhpcyBpT1MgY2hlY2sgaXMgdW50ZXN0ZWQgYW5kIG1heSBub3Qgd29ya1xuICAgIC8vIE5vZGUgZG9lcyBub3Qgd29yayBuYXRpdmVseSBvbiBJT1MsIHRoZXJlIGlzIGEgZm9yayBhdFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMtbW9iaWxlL25vZGVqcy1tb2JpbGVcbiAgICAvLyBob3dldmVyIGl0IGlzIHVua25vd24gYXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBob3cgdG8gZGV0ZWN0IGlmIGl0IGlzIHJ1bm5pbmdcbiAgICBpZiAocGxhdGZvcm0uaW5jbHVkZXMoJ2lvcycpKVxuICAgICAgICByZXR1cm4gJ2lPUyc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnYW5kcm9pZCcpXG4gICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnZGFyd2luJylcbiAgICAgICAgcmV0dXJuICdNYWNPUyc7XG4gICAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKVxuICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKVxuICAgICAgICByZXR1cm4gJ0ZyZWVCU0QnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ29wZW5ic2QnKVxuICAgICAgICByZXR1cm4gJ09wZW5CU0QnO1xuICAgIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JylcbiAgICAgICAgcmV0dXJuICdMaW51eCc7XG4gICAgaWYgKHBsYXRmb3JtKVxuICAgICAgICByZXR1cm4gYE90aGVyOiR7cGxhdGZvcm19YDtcbiAgICByZXR1cm4gJ1Vua25vd24nO1xufTtcbmxldCBfcGxhdGZvcm1IZWFkZXJzO1xuZXhwb3J0IGNvbnN0IGdldFBsYXRmb3JtSGVhZGVycyA9ICgpID0+IHtcbiAgICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgPz8gKF9wbGF0Zm9ybUhlYWRlcnMgPSBnZXRQbGF0Zm9ybVByb3BlcnRpZXMoKSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldGVjdC1wbGF0Zm9ybS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/errors.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   castToError: () => (/* binding */ castToError),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nfunction isAbortError(err) {\n    return (typeof err === 'object' &&\n        err !== null &&\n        // Spec-compliant fetch implementations\n        (('name' in err && err.name === 'AbortError') ||\n            // Expo fetch\n            ('message' in err && String(err.message).includes('FetchRequestCanceledException'))));\n}\nconst castToError = (err) => {\n    if (err instanceof Error)\n        return err;\n    if (typeof err === 'object' && err !== null) {\n        try {\n            if (Object.prototype.toString.call(err) === '[object Error]') {\n                // @ts-ignore - not all envs have native support for cause yet\n                const error = new Error(err.message, err.cause ? { cause: err.cause } : {});\n                if (err.stack)\n                    error.stack = err.stack;\n                // @ts-ignore - not all envs have native support for cause yet\n                if (err.cause && !error.cause)\n                    error.cause = err.cause;\n                if (err.name)\n                    error.name = err.name;\n                return error;\n            }\n        }\n        catch { }\n        try {\n            return new Error(JSON.stringify(err));\n        }\n        catch { }\n    }\n    return new Error(err);\n};\n//# sourceMappingURL=errors.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2Vycm9ycy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxtQkFBbUIsSUFBSTtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2Vycm9ycy5tanM/ZjBkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuZXhwb3J0IGZ1bmN0aW9uIGlzQWJvcnRFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVyciAhPT0gbnVsbCAmJlxuICAgICAgICAvLyBTcGVjLWNvbXBsaWFudCBmZXRjaCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgKCgnbmFtZScgaW4gZXJyICYmIGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHx8XG4gICAgICAgICAgICAvLyBFeHBvIGZldGNoXG4gICAgICAgICAgICAoJ21lc3NhZ2UnIGluIGVyciAmJiBTdHJpbmcoZXJyLm1lc3NhZ2UpLmluY2x1ZGVzKCdGZXRjaFJlcXVlc3RDYW5jZWxlZEV4Y2VwdGlvbicpKSkpO1xufVxuZXhwb3J0IGNvbnN0IGNhc3RUb0Vycm9yID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgZXJyICE9PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbm90IGFsbCBlbnZzIGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yIGNhdXNlIHlldFxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVyci5tZXNzYWdlLCBlcnIuY2F1c2UgPyB7IGNhdXNlOiBlcnIuY2F1c2UgfSA6IHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLnN0YWNrKVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gbm90IGFsbCBlbnZzIGhhdmUgbmF0aXZlIHN1cHBvcnQgZm9yIGNhdXNlIHlldFxuICAgICAgICAgICAgICAgIGlmIChlcnIuY2F1c2UgJiYgIWVycm9yLmNhdXNlKVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5jYXVzZSA9IGVyci5jYXVzZTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPSBlcnIubmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/headers.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildHeaders: () => (/* binding */ buildHeaders),\n/* harmony export */   isEmptyHeaders: () => (/* binding */ isEmptyHeaders)\n/* harmony export */ });\n/* harmony import */ var _utils_values_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/values.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nconst brand_privateNullableHeaders = Symbol.for('brand.privateNullableHeaders');\nfunction* iterateHeaders(headers) {\n    if (!headers)\n        return;\n    if (brand_privateNullableHeaders in headers) {\n        const { values, nulls } = headers;\n        yield* values.entries();\n        for (const name of nulls) {\n            yield [name, null];\n        }\n        return;\n    }\n    let shouldClear = false;\n    let iter;\n    if (headers instanceof Headers) {\n        iter = headers.entries();\n    }\n    else if ((0,_utils_values_mjs__WEBPACK_IMPORTED_MODULE_0__.isReadonlyArray)(headers)) {\n        iter = headers;\n    }\n    else {\n        shouldClear = true;\n        iter = Object.entries(headers ?? {});\n    }\n    for (let row of iter) {\n        const name = row[0];\n        if (typeof name !== 'string')\n            throw new TypeError('expected header name to be a string');\n        const values = (0,_utils_values_mjs__WEBPACK_IMPORTED_MODULE_0__.isReadonlyArray)(row[1]) ? row[1] : [row[1]];\n        let didClear = false;\n        for (const value of values) {\n            if (value === undefined)\n                continue;\n            // Objects keys always overwrite older headers, they never append.\n            // Yield a null to clear the header before adding the new values.\n            if (shouldClear && !didClear) {\n                didClear = true;\n                yield [name, null];\n            }\n            yield [name, value];\n        }\n    }\n}\nconst buildHeaders = (newHeaders) => {\n    const targetHeaders = new Headers();\n    const nullHeaders = new Set();\n    for (const headers of newHeaders) {\n        const seenHeaders = new Set();\n        for (const [name, value] of iterateHeaders(headers)) {\n            const lowerName = name.toLowerCase();\n            if (!seenHeaders.has(lowerName)) {\n                targetHeaders.delete(name);\n                seenHeaders.add(lowerName);\n            }\n            if (value === null) {\n                targetHeaders.delete(name);\n                nullHeaders.add(lowerName);\n            }\n            else {\n                targetHeaders.append(name, value);\n                nullHeaders.delete(lowerName);\n            }\n        }\n    }\n    return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };\n};\nconst isEmptyHeaders = (headers) => {\n    for (const _ of iterateHeaders(headers))\n        return false;\n    return true;\n};\n//# sourceMappingURL=headers.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2hlYWRlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3FEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL2hlYWRlcnMubWpzPzdkZTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IGlzUmVhZG9ubHlBcnJheSB9IGZyb20gXCIuL3V0aWxzL3ZhbHVlcy5tanNcIjtcbmNvbnN0IGJyYW5kX3ByaXZhdGVOdWxsYWJsZUhlYWRlcnMgPSBTeW1ib2wuZm9yKCdicmFuZC5wcml2YXRlTnVsbGFibGVIZWFkZXJzJyk7XG5mdW5jdGlvbiogaXRlcmF0ZUhlYWRlcnMoaGVhZGVycykge1xuICAgIGlmICghaGVhZGVycylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChicmFuZF9wcml2YXRlTnVsbGFibGVIZWFkZXJzIGluIGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZXMsIG51bGxzIH0gPSBoZWFkZXJzO1xuICAgICAgICB5aWVsZCogdmFsdWVzLmVudHJpZXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG51bGxzKSB7XG4gICAgICAgICAgICB5aWVsZCBbbmFtZSwgbnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkQ2xlYXIgPSBmYWxzZTtcbiAgICBsZXQgaXRlcjtcbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgaXRlciA9IGhlYWRlcnMuZW50cmllcygpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1JlYWRvbmx5QXJyYXkoaGVhZGVycykpIHtcbiAgICAgICAgaXRlciA9IGhlYWRlcnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgICAgIGl0ZXIgPSBPYmplY3QuZW50cmllcyhoZWFkZXJzID8/IHt9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgcm93IG9mIGl0ZXIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHJvd1swXTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGhlYWRlciBuYW1lIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzUmVhZG9ubHlBcnJheShyb3dbMV0pID8gcm93WzFdIDogW3Jvd1sxXV07XG4gICAgICAgIGxldCBkaWRDbGVhciA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBPYmplY3RzIGtleXMgYWx3YXlzIG92ZXJ3cml0ZSBvbGRlciBoZWFkZXJzLCB0aGV5IG5ldmVyIGFwcGVuZC5cbiAgICAgICAgICAgIC8vIFlpZWxkIGEgbnVsbCB0byBjbGVhciB0aGUgaGVhZGVyIGJlZm9yZSBhZGRpbmcgdGhlIG5ldyB2YWx1ZXMuXG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2xlYXIgJiYgIWRpZENsZWFyKSB7XG4gICAgICAgICAgICAgICAgZGlkQ2xlYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHlpZWxkIFtuYW1lLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIFtuYW1lLCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgYnVpbGRIZWFkZXJzID0gKG5ld0hlYWRlcnMpID0+IHtcbiAgICBjb25zdCB0YXJnZXRIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBjb25zdCBudWxsSGVhZGVycyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlcnMgb2YgbmV3SGVhZGVycykge1xuICAgICAgICBjb25zdCBzZWVuSGVhZGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIGl0ZXJhdGVIZWFkZXJzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlck5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIXNlZW5IZWFkZXJzLmhhcyhsb3dlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0SGVhZGVycy5kZWxldGUobmFtZSk7XG4gICAgICAgICAgICAgICAgc2VlbkhlYWRlcnMuYWRkKGxvd2VyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRIZWFkZXJzLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBudWxsSGVhZGVycy5hZGQobG93ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldEhlYWRlcnMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBudWxsSGVhZGVycy5kZWxldGUobG93ZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBbYnJhbmRfcHJpdmF0ZU51bGxhYmxlSGVhZGVyc106IHRydWUsIHZhbHVlczogdGFyZ2V0SGVhZGVycywgbnVsbHM6IG51bGxIZWFkZXJzIH07XG59O1xuZXhwb3J0IGNvbnN0IGlzRW1wdHlIZWFkZXJzID0gKGhlYWRlcnMpID0+IHtcbiAgICBmb3IgKGNvbnN0IF8gb2YgaXRlcmF0ZUhlYWRlcnMoaGVhZGVycykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/parse.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/parse.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRequestID: () => (/* binding */ addRequestID),\n/* harmony export */   defaultParseResponse: () => (/* binding */ defaultParseResponse)\n/* harmony export */ });\n/* harmony import */ var _core_streaming_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/streaming.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/streaming.mjs\");\n/* harmony import */ var _utils_log_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/log.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\nasync function defaultParseResponse(client, props) {\n    const { response, requestLogID, retryOfRequestLogID, startTime } = props;\n    const body = await (async () => {\n        if (props.options.stream) {\n            (0,_utils_log_mjs__WEBPACK_IMPORTED_MODULE_1__.loggerFor)(client).debug('response', response.status, response.url, response.headers, response.body);\n            // Note: there is an invariant here that isn't represented in the type system\n            // that if you set `stream: true` the response type must also be `Stream<T>`\n            if (props.options.__streamClass) {\n                return props.options.__streamClass.fromSSEResponse(response, props.controller);\n            }\n            return _core_streaming_mjs__WEBPACK_IMPORTED_MODULE_0__.Stream.fromSSEResponse(response, props.controller);\n        }\n        // fetch refuses to read the body when the status code is 204.\n        if (response.status === 204) {\n            return null;\n        }\n        if (props.options.__binaryResponse) {\n            return response;\n        }\n        const contentType = response.headers.get('content-type');\n        const mediaType = contentType?.split(';')[0]?.trim();\n        const isJSON = mediaType?.includes('application/json') || mediaType?.endsWith('+json');\n        if (isJSON) {\n            const json = await response.json();\n            return addRequestID(json, response);\n        }\n        const text = await response.text();\n        return text;\n    })();\n    (0,_utils_log_mjs__WEBPACK_IMPORTED_MODULE_1__.loggerFor)(client).debug(`[${requestLogID}] response parsed`, (0,_utils_log_mjs__WEBPACK_IMPORTED_MODULE_1__.formatRequestDetails)({\n        retryOfRequestLogID,\n        url: response.url,\n        status: response.status,\n        body,\n        durationMs: Date.now() - startTime,\n    }));\n    return body;\n}\nfunction addRequestID(value, response) {\n    if (!value || typeof value !== 'object' || Array.isArray(value)) {\n        return value;\n    }\n    return Object.defineProperty(value, '_request_id', {\n        value: response.headers.get('request-id'),\n        enumerable: false,\n    });\n}\n//# sourceMappingURL=parse.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3BhcnNlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDK0M7QUFDbUI7QUFDM0Q7QUFDUCxZQUFZLHlEQUF5RDtBQUNyRTtBQUNBO0FBQ0EsWUFBWSx5REFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHlEQUFTLG1CQUFtQixhQUFhLG9CQUFvQixvRUFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3BhcnNlLm1qcz85NDM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vY29yZS9zdHJlYW1pbmcubWpzXCI7XG5pbXBvcnQgeyBmb3JtYXRSZXF1ZXN0RGV0YWlscywgbG9nZ2VyRm9yIH0gZnJvbSBcIi4vdXRpbHMvbG9nLm1qc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlZmF1bHRQYXJzZVJlc3BvbnNlKGNsaWVudCwgcHJvcHMpIHtcbiAgICBjb25zdCB7IHJlc3BvbnNlLCByZXF1ZXN0TG9nSUQsIHJldHJ5T2ZSZXF1ZXN0TG9nSUQsIHN0YXJ0VGltZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgICAgICAgICAgbG9nZ2VyRm9yKGNsaWVudCkuZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlcmUgaXMgYW4gaW52YXJpYW50IGhlcmUgdGhhdCBpc24ndCByZXByZXNlbnRlZCBpbiB0aGUgdHlwZSBzeXN0ZW1cbiAgICAgICAgICAgIC8vIHRoYXQgaWYgeW91IHNldCBgc3RyZWFtOiB0cnVlYCB0aGUgcmVzcG9uc2UgdHlwZSBtdXN0IGFsc28gYmUgYFN0cmVhbTxUPmBcbiAgICAgICAgICAgIGlmIChwcm9wcy5vcHRpb25zLl9fc3RyZWFtQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMub3B0aW9ucy5fX3N0cmVhbUNsYXNzLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyZWFtLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMub3B0aW9ucy5fX2JpbmFyeVJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gICAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IGNvbnRlbnRUeXBlPy5zcGxpdCgnOycpWzBdPy50cmltKCk7XG4gICAgICAgIGNvbnN0IGlzSlNPTiA9IG1lZGlhVHlwZT8uaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSB8fCBtZWRpYVR5cGU/LmVuZHNXaXRoKCcranNvbicpO1xuICAgICAgICBpZiAoaXNKU09OKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGFkZFJlcXVlc3RJRChqc29uLCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSkoKTtcbiAgICBsb2dnZXJGb3IoY2xpZW50KS5kZWJ1ZyhgWyR7cmVxdWVzdExvZ0lEfV0gcmVzcG9uc2UgcGFyc2VkYCwgZm9ybWF0UmVxdWVzdERldGFpbHMoe1xuICAgICAgICByZXRyeU9mUmVxdWVzdExvZ0lELFxuICAgICAgICB1cmw6IHJlc3BvbnNlLnVybCxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGR1cmF0aW9uTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfSkpO1xuICAgIHJldHVybiBib2R5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlcXVlc3RJRCh2YWx1ZSwgcmVzcG9uc2UpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCAnX3JlcXVlc3RfaWQnLCB7XG4gICAgICAgIHZhbHVlOiByZXNwb25zZS5oZWFkZXJzLmdldCgncmVxdWVzdC1pZCcpLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/parse.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/request-options.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/request-options.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FallbackEncoder: () => (/* binding */ FallbackEncoder)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst FallbackEncoder = ({ headers, body }) => {\n    return {\n        bodyHeaders: {\n            'content-type': 'application/json',\n        },\n        body: JSON.stringify(body),\n    };\n};\n//# sourceMappingURL=request-options.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3JlcXVlc3Qtb3B0aW9ucy5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ08sMkJBQTJCLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvcmVxdWVzdC1vcHRpb25zLm1qcz81YWFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5leHBvcnQgY29uc3QgRmFsbGJhY2tFbmNvZGVyID0gKHsgaGVhZGVycywgYm9keSB9KSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYm9keUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC1vcHRpb25zLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/request-options.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/shims.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CancelReadableStream: () => (/* binding */ CancelReadableStream),\n/* harmony export */   ReadableStreamFrom: () => (/* binding */ ReadableStreamFrom),\n/* harmony export */   ReadableStreamToAsyncIterable: () => (/* binding */ ReadableStreamToAsyncIterable),\n/* harmony export */   getDefaultFetch: () => (/* binding */ getDefaultFetch),\n/* harmony export */   makeReadableStream: () => (/* binding */ makeReadableStream)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nfunction getDefaultFetch() {\n    if (typeof fetch !== 'undefined') {\n        return fetch;\n    }\n    throw new Error('`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`');\n}\nfunction makeReadableStream(...args) {\n    const ReadableStream = globalThis.ReadableStream;\n    if (typeof ReadableStream === 'undefined') {\n        // Note: All of the platforms / runtimes we officially support already define\n        // `ReadableStream` as a global, so this should only ever be hit on unsupported runtimes.\n        throw new Error('`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`');\n    }\n    return new ReadableStream(...args);\n}\nfunction ReadableStreamFrom(iterable) {\n    let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n    return makeReadableStream({\n        start() { },\n        async pull(controller) {\n            const { done, value } = await iter.next();\n            if (done) {\n                controller.close();\n            }\n            else {\n                controller.enqueue(value);\n            }\n        },\n        async cancel() {\n            await iter.return?.();\n        },\n    });\n}\n/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nfunction ReadableStreamToAsyncIterable(stream) {\n    if (stream[Symbol.asyncIterator])\n        return stream;\n    const reader = stream.getReader();\n    return {\n        async next() {\n            try {\n                const result = await reader.read();\n                if (result?.done)\n                    reader.releaseLock(); // release lock when stream becomes closed\n                return result;\n            }\n            catch (e) {\n                reader.releaseLock(); // release lock when stream becomes errored\n                throw e;\n            }\n        },\n        async return() {\n            const cancelPromise = reader.cancel();\n            reader.releaseLock();\n            await cancelPromise;\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n/**\n * Cancels a ReadableStream we don't need to consume.\n * See https://undici.nodejs.org/#/?id=garbage-collection\n */\nasync function CancelReadableStream(stream) {\n    if (stream === null || typeof stream !== 'object')\n        return;\n    if (stream[Symbol.asyncIterator]) {\n        await stream[Symbol.asyncIterator]().return?.();\n        return;\n    }\n    const reader = stream.getReader();\n    const cancelPromise = reader.cancel();\n    reader.releaseLock();\n    await cancelPromise;\n}\n//# sourceMappingURL=shims.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3NoaW1zLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0RBQW9ELE9BQU87QUFDcEg7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3NoaW1zLm1qcz9lYzlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZldGNoKCkge1xuICAgIGlmICh0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmZXRjaDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgZmV0Y2hgIGlzIG5vdCBkZWZpbmVkIGFzIGEgZ2xvYmFsOyBFaXRoZXIgcGFzcyBgZmV0Y2hgIHRvIHRoZSBjbGllbnQsIGBuZXcgQW50aHJvcGljKHsgZmV0Y2ggfSlgIG9yIHBvbHlmaWxsIHRoZSBnbG9iYWwsIGBnbG9iYWxUaGlzLmZldGNoID0gZmV0Y2hgJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlYWRhYmxlU3RyZWFtKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBSZWFkYWJsZVN0cmVhbSA9IGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW07XG4gICAgaWYgKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gTm90ZTogQWxsIG9mIHRoZSBwbGF0Zm9ybXMgLyBydW50aW1lcyB3ZSBvZmZpY2lhbGx5IHN1cHBvcnQgYWxyZWFkeSBkZWZpbmVcbiAgICAgICAgLy8gYFJlYWRhYmxlU3RyZWFtYCBhcyBhIGdsb2JhbCwgc28gdGhpcyBzaG91bGQgb25seSBldmVyIGJlIGhpdCBvbiB1bnN1cHBvcnRlZCBydW50aW1lcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgUmVhZGFibGVTdHJlYW1gIGlzIG5vdCBkZWZpbmVkIGFzIGEgZ2xvYmFsOyBZb3Ugd2lsbCBuZWVkIHRvIHBvbHlmaWxsIGl0LCBgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtYCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKC4uLmFyZ3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbShpdGVyYWJsZSkge1xuICAgIGxldCBpdGVyID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gaXRlcmFibGUgPyBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSA6IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICByZXR1cm4gbWFrZVJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgc3RhcnQoKSB7IH0sXG4gICAgICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgICAgIGF3YWl0IGl0ZXIucmV0dXJuPy4oKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogTW9zdCBicm93c2VycyBkb24ndCB5ZXQgaGF2ZSBhc3luYyBpdGVyYWJsZSBzdXBwb3J0IGZvciBSZWFkYWJsZVN0cmVhbSxcbiAqIGFuZCBOb2RlIGhhcyBhIHZlcnkgZGlmZmVyZW50IHdheSBvZiByZWFkaW5nIGJ5dGVzIGZyb20gaXRzIFwiUmVhZGFibGVTdHJlYW1cIi5cbiAqXG4gKiBUaGlzIHBvbHlmaWxsIHdhcyBwdWxsZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vTWF0dGlhc0J1ZWxlbnMvd2ViLXN0cmVhbXMtcG9seWZpbGwvcHVsbC8xMjIjaXNzdWVjb21tZW50LTE2MjczNTQ0OTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW1bU3ltYm9sLmFzeW5jSXRlcmF0b3JdKVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQ/LmRvbmUpXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBjbG9zZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgZXJyb3JlZFxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHJldHVybigpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbmNlbFByb21pc2U7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYW5jZWxzIGEgUmVhZGFibGVTdHJlYW0gd2UgZG9uJ3QgbmVlZCB0byBjb25zdW1lLlxuICogU2VlIGh0dHBzOi8vdW5kaWNpLm5vZGVqcy5vcmcvIy8/aWQ9Z2FyYmFnZS1jb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBDYW5jZWxSZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtID09PSBudWxsIHx8IHR5cGVvZiBzdHJlYW0gIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICAgICAgYXdhaXQgc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpLnJldHVybj8uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSByZWFkZXIuY2FuY2VsKCk7XG4gICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgYXdhaXQgY2FuY2VsUHJvbWlzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoaW1zLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/to-file.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/to-file.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toFile: () => (/* binding */ toFile)\n/* harmony export */ });\n/* harmony import */ var _uploads_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uploads.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/uploads.mjs\");\n\n\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isBlobLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.size === 'number' &&\n    typeof value.type === 'string' &&\n    typeof value.text === 'function' &&\n    typeof value.slice === 'function' &&\n    typeof value.arrayBuffer === 'function';\n/**\n * This check adds the arrayBuffer() method type because it is available and used at runtime\n */\nconst isFileLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.name === 'string' &&\n    typeof value.lastModified === 'number' &&\n    isBlobLike(value);\nconst isResponseLike = (value) => value != null &&\n    typeof value === 'object' &&\n    typeof value.url === 'string' &&\n    typeof value.blob === 'function';\n/**\n * Helper for creating a {@link File} to pass to an SDK upload method from a variety of different data formats\n * @param value the raw content of the file.  Can be an {@link Uploadable}, {@link BlobLikePart}, or {@link AsyncIterable} of {@link BlobLikePart}s\n * @param {string=} name the name of the file. If omitted, toFile will try to determine a file name from bits if possible\n * @param {Object=} options additional properties\n * @param {string=} options.type the MIME type of the content\n * @param {number=} options.lastModified the last modified timestamp\n * @returns a {@link File} with the given properties\n */\nasync function toFile(value, name, options) {\n    (0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.checkFileSupport)();\n    // If it's a promise, resolve it.\n    value = await value;\n    name || (name = (0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.getName)(value));\n    // If we've been given a `File` we don't need to do anything if the name / options\n    // have not been customised.\n    if (isFileLike(value)) {\n        if (value instanceof File && name == null && options == null) {\n            return value;\n        }\n        return (0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.makeFile)([await value.arrayBuffer()], name ?? value.name, {\n            type: value.type,\n            lastModified: value.lastModified,\n            ...options,\n        });\n    }\n    if (isResponseLike(value)) {\n        const blob = await value.blob();\n        name || (name = new URL(value.url).pathname.split(/[\\\\/]/).pop());\n        return (0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.makeFile)(await getBytes(blob), name, options);\n    }\n    const parts = await getBytes(value);\n    if (!options?.type) {\n        const type = parts.find((part) => typeof part === 'object' && 'type' in part && part.type);\n        if (typeof type === 'string') {\n            options = { ...options, type };\n        }\n    }\n    return (0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.makeFile)(parts, name, options);\n}\nasync function getBytes(value) {\n    let parts = [];\n    if (typeof value === 'string' ||\n        ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.\n        value instanceof ArrayBuffer) {\n        parts.push(value);\n    }\n    else if (isBlobLike(value)) {\n        parts.push(value instanceof Blob ? value : await value.arrayBuffer());\n    }\n    else if ((0,_uploads_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value) // includes Readable, ReadableStream, etc.\n    ) {\n        for await (const chunk of value) {\n            parts.push(...(await getBytes(chunk))); // TODO, consider validating?\n        }\n    }\n    else {\n        const constructor = value?.constructor?.name;\n        throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ''}${propsForError(value)}`);\n    }\n    return parts;\n}\nfunction propsForError(value) {\n    if (typeof value !== 'object' || value === null)\n        return '';\n    const props = Object.getOwnPropertyNames(value);\n    return `; props: [${props.map((p) => `\"${p}\"`).join(', ')}]`;\n}\n//# sourceMappingURL=to-file.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3RvLWZpbGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1FO0FBQ2xCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWTtBQUN0Qyx5REFBeUQsaUJBQWlCLEdBQUcsbUJBQW1CLE1BQU0scUJBQXFCLElBQUksbUJBQW1CO0FBQ2xKLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixlQUFlLFlBQVk7QUFDM0I7QUFDTztBQUNQLElBQUksOERBQWdCO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IscURBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFdBQVcsc0RBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkRBQWU7QUFDNUI7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhLEVBQUUsaUJBQWlCLGVBQWUsWUFBWSxPQUFPLEVBQUUscUJBQXFCO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLHFCQUFxQixFQUFFLGVBQWU7QUFDOUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3RvLWZpbGUubWpzPzQ4NzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0TmFtZSwgbWFrZUZpbGUsIGlzQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuL3VwbG9hZHMubWpzXCI7XG5pbXBvcnQgeyBjaGVja0ZpbGVTdXBwb3J0IH0gZnJvbSBcIi4vdXBsb2Fkcy5tanNcIjtcbi8qKlxuICogVGhpcyBjaGVjayBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuY29uc3QgaXNCbG9iTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuc2l6ZSA9PT0gJ251bWJlcicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogVGhpcyBjaGVjayBhZGRzIHRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCB0eXBlIGJlY2F1c2UgaXQgaXMgYXZhaWxhYmxlIGFuZCB1c2VkIGF0IHJ1bnRpbWVcbiAqL1xuY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUubmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICAgIGlzQmxvYkxpa2UodmFsdWUpO1xuY29uc3QgaXNSZXNwb25zZUxpa2UgPSAodmFsdWUpID0+IHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLnVybCA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuYmxvYiA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogSGVscGVyIGZvciBjcmVhdGluZyBhIHtAbGluayBGaWxlfSB0byBwYXNzIHRvIGFuIFNESyB1cGxvYWQgbWV0aG9kIGZyb20gYSB2YXJpZXR5IG9mIGRpZmZlcmVudCBkYXRhIGZvcm1hdHNcbiAqIEBwYXJhbSB2YWx1ZSB0aGUgcmF3IGNvbnRlbnQgb2YgdGhlIGZpbGUuICBDYW4gYmUgYW4ge0BsaW5rIFVwbG9hZGFibGV9LCB7QGxpbmsgQmxvYkxpa2VQYXJ0fSwgb3Ige0BsaW5rIEFzeW5jSXRlcmFibGV9IG9mIHtAbGluayBCbG9iTGlrZVBhcnR9c1xuICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlLiBJZiBvbWl0dGVkLCB0b0ZpbGUgd2lsbCB0cnkgdG8gZGV0ZXJtaW5lIGEgZmlsZSBuYW1lIGZyb20gYml0cyBpZiBwb3NzaWJsZVxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnR5cGUgdGhlIE1JTUUgdHlwZSBvZiB0aGUgY29udGVudFxuICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmxhc3RNb2RpZmllZCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lc3RhbXBcbiAqIEByZXR1cm5zIGEge0BsaW5rIEZpbGV9IHdpdGggdGhlIGdpdmVuIHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRvRmlsZSh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNoZWNrRmlsZVN1cHBvcnQoKTtcbiAgICAvLyBJZiBpdCdzIGEgcHJvbWlzZSwgcmVzb2x2ZSBpdC5cbiAgICB2YWx1ZSA9IGF3YWl0IHZhbHVlO1xuICAgIG5hbWUgfHwgKG5hbWUgPSBnZXROYW1lKHZhbHVlKSk7XG4gICAgLy8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGBGaWxlYCB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGlmIHRoZSBuYW1lIC8gb3B0aW9uc1xuICAgIC8vIGhhdmUgbm90IGJlZW4gY3VzdG9taXNlZC5cbiAgICBpZiAoaXNGaWxlTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSAmJiBuYW1lID09IG51bGwgJiYgb3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ha2VGaWxlKFthd2FpdCB2YWx1ZS5hcnJheUJ1ZmZlcigpXSwgbmFtZSA/PyB2YWx1ZS5uYW1lLCB7XG4gICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiB2YWx1ZS5sYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBibG9iID0gYXdhaXQgdmFsdWUuYmxvYigpO1xuICAgICAgICBuYW1lIHx8IChuYW1lID0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkpO1xuICAgICAgICByZXR1cm4gbWFrZUZpbGUoYXdhaXQgZ2V0Qnl0ZXMoYmxvYiksIG5hbWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IGF3YWl0IGdldEJ5dGVzKHZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbnM/LnR5cGUpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcnRzLmZpbmQoKHBhcnQpID0+IHR5cGVvZiBwYXJ0ID09PSAnb2JqZWN0JyAmJiAndHlwZScgaW4gcGFydCAmJiBwYXJ0LnR5cGUpO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyAuLi5vcHRpb25zLCB0eXBlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1ha2VGaWxlKHBhcnRzLCBuYW1lLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJ5dGVzKHZhbHVlKSB7XG4gICAgbGV0IHBhcnRzID0gW107XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fCAvLyBpbmNsdWRlcyBVaW50OEFycmF5LCBCdWZmZXIsIGV0Yy5cbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcGFydHMucHVzaCh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgPyB2YWx1ZSA6IGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FzeW5jSXRlcmFibGUodmFsdWUpIC8vIGluY2x1ZGVzIFJlYWRhYmxlLCBSZWFkYWJsZVN0cmVhbSwgZXRjLlxuICAgICkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKC4uLihhd2FpdCBnZXRCeXRlcyhjaHVuaykpKTsgLy8gVE9ETywgY29uc2lkZXIgdmFsaWRhdGluZz9cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB2YWx1ZT8uY29uc3RydWN0b3I/Lm5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBkYXRhIHR5cGU6ICR7dHlwZW9mIHZhbHVlfSR7Y29uc3RydWN0b3IgPyBgOyBjb25zdHJ1Y3RvcjogJHtjb25zdHJ1Y3Rvcn1gIDogJyd9JHtwcm9wc0ZvckVycm9yKHZhbHVlKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xufVxuZnVuY3Rpb24gcHJvcHNGb3JFcnJvcih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gICAgcmV0dXJuIGA7IHByb3BzOiBbJHtwcm9wcy5tYXAoKHApID0+IGBcIiR7cH1cImApLmpvaW4oJywgJyl9XWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10by1maWxlLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/to-file.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs":
/*!***************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet)\n/* harmony export */ });\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\")\n        throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f)\n        throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value), value;\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f)\n        throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver))\n        throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3RzbGliLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvdHNsaWIubWpzPzU4ODEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IChmLnZhbHVlID0gdmFsdWUpIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSksIHZhbHVlO1xufVxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cbmV4cG9ydCB7IF9fY2xhc3NQcml2YXRlRmllbGRTZXQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/uploads.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/uploads.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkFileSupport: () => (/* binding */ checkFileSupport),\n/* harmony export */   createForm: () => (/* binding */ createForm),\n/* harmony export */   getName: () => (/* binding */ getName),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   makeFile: () => (/* binding */ makeFile),\n/* harmony export */   maybeMultipartFormRequestOptions: () => (/* binding */ maybeMultipartFormRequestOptions),\n/* harmony export */   multipartFormRequestOptions: () => (/* binding */ multipartFormRequestOptions)\n/* harmony export */ });\n/* harmony import */ var _shims_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shims.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/shims.mjs\");\n\nconst checkFileSupport = () => {\n    if (typeof File === 'undefined') {\n        const { process } = globalThis;\n        const isOldNode = typeof process?.versions?.node === 'string' && parseInt(process.versions.node.split('.')) < 20;\n        throw new Error('`File` is not defined as a global, which is required for file uploads.' +\n            (isOldNode ?\n                \" Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`.\"\n                : ''));\n    }\n};\n/**\n * Construct a `File` instance. This is used to ensure a helpful error is thrown\n * for environments that don't define a global `File` yet.\n */\nfunction makeFile(fileBits, fileName, options) {\n    checkFileSupport();\n    return new File(fileBits, fileName ?? 'unknown_file', options);\n}\nfunction getName(value) {\n    return (((typeof value === 'object' &&\n        value !== null &&\n        (('name' in value && value.name && String(value.name)) ||\n            ('url' in value && value.url && String(value.url)) ||\n            ('filename' in value && value.filename && String(value.filename)) ||\n            ('path' in value && value.path && String(value.path)))) ||\n        '')\n        .split(/[\\\\/]/)\n        .pop() || undefined);\n}\nconst isAsyncIterable = (value) => value != null && typeof value === 'object' && typeof value[Symbol.asyncIterator] === 'function';\n/**\n * Returns a multipart/form-data request if any part of the given request body contains a File / Blob value.\n * Otherwise returns the request as is.\n */\nconst maybeMultipartFormRequestOptions = async (opts, fetch) => {\n    if (!hasUploadableValue(opts.body))\n        return opts;\n    return { ...opts, body: await createForm(opts.body, fetch) };\n};\nconst multipartFormRequestOptions = async (opts, fetch) => {\n    return { ...opts, body: await createForm(opts.body, fetch) };\n};\nconst supportsFormDataMap = /* @__PURE__ */ new WeakMap();\n/**\n * node-fetch doesn't support the global FormData object in recent node versions. Instead of sending\n * properly-encoded form data, it just stringifies the object, resulting in a request body of \"[object FormData]\".\n * This function detects if the fetch function provided supports the global FormData object to avoid\n * confusing error messages later on.\n */\nfunction supportsFormData(fetchObject) {\n    const fetch = typeof fetchObject === 'function' ? fetchObject : fetchObject.fetch;\n    const cached = supportsFormDataMap.get(fetch);\n    if (cached)\n        return cached;\n    const promise = (async () => {\n        try {\n            const FetchResponse = ('Response' in fetch ?\n                fetch.Response\n                : (await fetch('data:,')).constructor);\n            const data = new FormData();\n            if (data.toString() === (await new FetchResponse(data).text())) {\n                return false;\n            }\n            return true;\n        }\n        catch {\n            // avoid false negatives\n            return true;\n        }\n    })();\n    supportsFormDataMap.set(fetch, promise);\n    return promise;\n}\nconst createForm = async (body, fetch) => {\n    if (!(await supportsFormData(fetch))) {\n        throw new TypeError('The provided fetch function does not support file uploads with the current global FormData class.');\n    }\n    const form = new FormData();\n    await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));\n    return form;\n};\n// We check for Blob not File because Bun.File doesn't inherit from File,\n// but they both inherit from Blob and have a `name` property at runtime.\nconst isNamedBlob = (value) => value instanceof Blob && 'name' in value;\nconst isUploadable = (value) => typeof value === 'object' &&\n    value !== null &&\n    (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));\nconst hasUploadableValue = (value) => {\n    if (isUploadable(value))\n        return true;\n    if (Array.isArray(value))\n        return value.some(hasUploadableValue);\n    if (value && typeof value === 'object') {\n        for (const k in value) {\n            if (hasUploadableValue(value[k]))\n                return true;\n        }\n    }\n    return false;\n};\nconst addFormValue = async (form, key, value) => {\n    if (value === undefined)\n        return;\n    if (value == null) {\n        throw new TypeError(`Received null for \"${key}\"; to pass null in FormData, you must use the string 'null'`);\n    }\n    // TODO: make nested formats configurable\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        form.append(key, String(value));\n    }\n    else if (value instanceof Response) {\n        let options = {};\n        const contentType = value.headers.get('Content-Type');\n        if (contentType) {\n            options = { type: contentType };\n        }\n        form.append(key, makeFile([await value.blob()], getName(value), options));\n    }\n    else if (isAsyncIterable(value)) {\n        form.append(key, makeFile([await new Response((0,_shims_mjs__WEBPACK_IMPORTED_MODULE_0__.ReadableStreamFrom)(value)).blob()], getName(value)));\n    }\n    else if (isNamedBlob(value)) {\n        form.append(key, makeFile([value], getName(value), { type: value.type }));\n    }\n    else if (Array.isArray(value)) {\n        await Promise.all(value.map((entry) => addFormValue(form, key + '[]', entry)));\n    }\n    else if (typeof value === 'object') {\n        await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));\n    }\n    else {\n        throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);\n    }\n};\n//# sourceMappingURL=uploads.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3VwbG9hZHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWlEO0FBQzFDO0FBQ1A7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsSUFBSSxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw4REFBa0I7QUFDeEU7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixJQUFJLEdBQUcsS0FBSztBQUN4RztBQUNBO0FBQ0Esb0lBQW9JLE9BQU87QUFDM0k7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvdXBsb2Fkcy5tanM/ZDJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbUZyb20gfSBmcm9tIFwiLi9zaGltcy5tanNcIjtcbmV4cG9ydCBjb25zdCBjaGVja0ZpbGVTdXBwb3J0ID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgRmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgeyBwcm9jZXNzIH0gPSBnbG9iYWxUaGlzO1xuICAgICAgICBjb25zdCBpc09sZE5vZGUgPSB0eXBlb2YgcHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGUgPT09ICdzdHJpbmcnICYmIHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZS5zcGxpdCgnLicpKSA8IDIwO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BGaWxlYCBpcyBub3QgZGVmaW5lZCBhcyBhIGdsb2JhbCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yIGZpbGUgdXBsb2Fkcy4nICtcbiAgICAgICAgICAgIChpc09sZE5vZGUgP1xuICAgICAgICAgICAgICAgIFwiIFVwZGF0ZSB0byBOb2RlIDIwIExUUyBvciBuZXdlciwgb3Igc2V0IGBnbG9iYWxUaGlzLkZpbGVgIHRvIGBpbXBvcnQoJ25vZGU6YnVmZmVyJykuRmlsZWAuXCJcbiAgICAgICAgICAgICAgICA6ICcnKSk7XG4gICAgfVxufTtcbi8qKlxuICogQ29uc3RydWN0IGEgYEZpbGVgIGluc3RhbmNlLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIGEgaGVscGZ1bCBlcnJvciBpcyB0aHJvd25cbiAqIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBkZWZpbmUgYSBnbG9iYWwgYEZpbGVgIHlldC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VGaWxlKGZpbGVCaXRzLCBmaWxlTmFtZSwgb3B0aW9ucykge1xuICAgIGNoZWNrRmlsZVN1cHBvcnQoKTtcbiAgICByZXR1cm4gbmV3IEZpbGUoZmlsZUJpdHMsIGZpbGVOYW1lID8/ICd1bmtub3duX2ZpbGUnLCBvcHRpb25zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROYW1lKHZhbHVlKSB7XG4gICAgcmV0dXJuICgoKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgKCgnbmFtZScgaW4gdmFsdWUgJiYgdmFsdWUubmFtZSAmJiBTdHJpbmcodmFsdWUubmFtZSkpIHx8XG4gICAgICAgICAgICAoJ3VybCcgaW4gdmFsdWUgJiYgdmFsdWUudXJsICYmIFN0cmluZyh2YWx1ZS51cmwpKSB8fFxuICAgICAgICAgICAgKCdmaWxlbmFtZScgaW4gdmFsdWUgJiYgdmFsdWUuZmlsZW5hbWUgJiYgU3RyaW5nKHZhbHVlLmZpbGVuYW1lKSkgfHxcbiAgICAgICAgICAgICgncGF0aCcgaW4gdmFsdWUgJiYgdmFsdWUucGF0aCAmJiBTdHJpbmcodmFsdWUucGF0aCkpKSkgfHxcbiAgICAgICAgJycpXG4gICAgICAgIC5zcGxpdCgvW1xcXFwvXS8pXG4gICAgICAgIC5wb3AoKSB8fCB1bmRlZmluZWQpO1xufVxuZXhwb3J0IGNvbnN0IGlzQXN5bmNJdGVyYWJsZSA9ICh2YWx1ZSkgPT4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG4vKipcbiAqIFJldHVybnMgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3QgaWYgYW55IHBhcnQgb2YgdGhlIGdpdmVuIHJlcXVlc3QgYm9keSBjb250YWlucyBhIEZpbGUgLyBCbG9iIHZhbHVlLlxuICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlcXVlc3QgYXMgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIChvcHRzLCBmZXRjaCkgPT4ge1xuICAgIGlmICghaGFzVXBsb2FkYWJsZVZhbHVlKG9wdHMuYm9keSkpXG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgIHJldHVybiB7IC4uLm9wdHMsIGJvZHk6IGF3YWl0IGNyZWF0ZUZvcm0ob3B0cy5ib2R5LCBmZXRjaCkgfTtcbn07XG5leHBvcnQgY29uc3QgbXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zID0gYXN5bmMgKG9wdHMsIGZldGNoKSA9PiB7XG4gICAgcmV0dXJuIHsgLi4ub3B0cywgYm9keTogYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHksIGZldGNoKSB9O1xufTtcbmNvbnN0IHN1cHBvcnRzRm9ybURhdGFNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogbm9kZS1mZXRjaCBkb2Vzbid0IHN1cHBvcnQgdGhlIGdsb2JhbCBGb3JtRGF0YSBvYmplY3QgaW4gcmVjZW50IG5vZGUgdmVyc2lvbnMuIEluc3RlYWQgb2Ygc2VuZGluZ1xuICogcHJvcGVybHktZW5jb2RlZCBmb3JtIGRhdGEsIGl0IGp1c3Qgc3RyaW5naWZpZXMgdGhlIG9iamVjdCwgcmVzdWx0aW5nIGluIGEgcmVxdWVzdCBib2R5IG9mIFwiW29iamVjdCBGb3JtRGF0YV1cIi5cbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyBpZiB0aGUgZmV0Y2ggZnVuY3Rpb24gcHJvdmlkZWQgc3VwcG9ydHMgdGhlIGdsb2JhbCBGb3JtRGF0YSBvYmplY3QgdG8gYXZvaWRcbiAqIGNvbmZ1c2luZyBlcnJvciBtZXNzYWdlcyBsYXRlciBvbi5cbiAqL1xuZnVuY3Rpb24gc3VwcG9ydHNGb3JtRGF0YShmZXRjaE9iamVjdCkge1xuICAgIGNvbnN0IGZldGNoID0gdHlwZW9mIGZldGNoT2JqZWN0ID09PSAnZnVuY3Rpb24nID8gZmV0Y2hPYmplY3QgOiBmZXRjaE9iamVjdC5mZXRjaDtcbiAgICBjb25zdCBjYWNoZWQgPSBzdXBwb3J0c0Zvcm1EYXRhTWFwLmdldChmZXRjaCk7XG4gICAgaWYgKGNhY2hlZClcbiAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICBjb25zdCBwcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IEZldGNoUmVzcG9uc2UgPSAoJ1Jlc3BvbnNlJyBpbiBmZXRjaCA/XG4gICAgICAgICAgICAgICAgZmV0Y2guUmVzcG9uc2VcbiAgICAgICAgICAgICAgICA6IChhd2FpdCBmZXRjaCgnZGF0YTosJykpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnRvU3RyaW5nKCkgPT09IChhd2FpdCBuZXcgRmV0Y2hSZXNwb25zZShkYXRhKS50ZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgc3VwcG9ydHNGb3JtRGF0YU1hcC5zZXQoZmV0Y2gsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZXhwb3J0IGNvbnN0IGNyZWF0ZUZvcm0gPSBhc3luYyAoYm9keSwgZmV0Y2gpID0+IHtcbiAgICBpZiAoIShhd2FpdCBzdXBwb3J0c0Zvcm1EYXRhKGZldGNoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb3ZpZGVkIGZldGNoIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgZmlsZSB1cGxvYWRzIHdpdGggdGhlIGN1cnJlbnQgZ2xvYmFsIEZvcm1EYXRhIGNsYXNzLicpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoYm9keSB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXksIHZhbHVlKSkpO1xuICAgIHJldHVybiBmb3JtO1xufTtcbi8vIFdlIGNoZWNrIGZvciBCbG9iIG5vdCBGaWxlIGJlY2F1c2UgQnVuLkZpbGUgZG9lc24ndCBpbmhlcml0IGZyb20gRmlsZSxcbi8vIGJ1dCB0aGV5IGJvdGggaW5oZXJpdCBmcm9tIEJsb2IgYW5kIGhhdmUgYSBgbmFtZWAgcHJvcGVydHkgYXQgcnVudGltZS5cbmNvbnN0IGlzTmFtZWRCbG9iID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEJsb2IgJiYgJ25hbWUnIGluIHZhbHVlO1xuY29uc3QgaXNVcGxvYWRhYmxlID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAodmFsdWUgaW5zdGFuY2VvZiBSZXNwb25zZSB8fCBpc0FzeW5jSXRlcmFibGUodmFsdWUpIHx8IGlzTmFtZWRCbG9iKHZhbHVlKSk7XG5jb25zdCBoYXNVcGxvYWRhYmxlVmFsdWUgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWUuc29tZShoYXNVcGxvYWRhYmxlVmFsdWUpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc1VwbG9hZGFibGVWYWx1ZSh2YWx1ZVtrXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbmNvbnN0IGFkZEZvcm1WYWx1ZSA9IGFzeW5jIChmb3JtLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBSZWNlaXZlZCBudWxsIGZvciBcIiR7a2V5fVwiOyB0byBwYXNzIG51bGwgaW4gRm9ybURhdGEsIHlvdSBtdXN0IHVzZSB0aGUgc3RyaW5nICdudWxsJ2ApO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtYWtlIG5lc3RlZCBmb3JtYXRzIGNvbmZpZ3VyYWJsZVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IHZhbHVlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zID0geyB0eXBlOiBjb250ZW50VHlwZSB9O1xuICAgICAgICB9XG4gICAgICAgIGZvcm0uYXBwZW5kKGtleSwgbWFrZUZpbGUoW2F3YWl0IHZhbHVlLmJsb2IoKV0sIGdldE5hbWUodmFsdWUpLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXN5bmNJdGVyYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZm9ybS5hcHBlbmQoa2V5LCBtYWtlRmlsZShbYXdhaXQgbmV3IFJlc3BvbnNlKFJlYWRhYmxlU3RyZWFtRnJvbSh2YWx1ZSkpLmJsb2IoKV0sIGdldE5hbWUodmFsdWUpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmFtZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICBmb3JtLmFwcGVuZChrZXksIG1ha2VGaWxlKFt2YWx1ZV0sIGdldE5hbWUodmFsdWUpLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh2YWx1ZS5tYXAoKGVudHJ5KSA9PiBhZGRGb3JtVmFsdWUoZm9ybSwga2V5ICsgJ1tdJywgZW50cnkpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXModmFsdWUpLm1hcCgoW25hbWUsIHByb3BdKSA9PiBhZGRGb3JtVmFsdWUoZm9ybSwgYCR7a2V5fVske25hbWV9XWAsIHByb3ApKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHZhbHVlIGdpdmVuIHRvIGZvcm0sIGV4cGVjdGVkIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCwgQXJyYXksIEZpbGUgb3IgQmxvYiBidXQgZ290ICR7dmFsdWV9IGluc3RlYWRgKTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBsb2Fkcy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/uploads.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   decodeUTF8: () => (/* binding */ decodeUTF8),\n/* harmony export */   encodeUTF8: () => (/* binding */ encodeUTF8)\n/* harmony export */ });\nfunction concatBytes(buffers) {\n    let length = 0;\n    for (const buffer of buffers) {\n        length += buffer.length;\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const buffer of buffers) {\n        output.set(buffer, index);\n        index += buffer.length;\n    }\n    return output;\n}\nlet encodeUTF8_;\nfunction encodeUTF8(str) {\n    let encoder;\n    return (encodeUTF8_ ??\n        ((encoder = new globalThis.TextEncoder()), (encodeUTF8_ = encoder.encode.bind(encoder))))(str);\n}\nlet decodeUTF8_;\nfunction decodeUTF8(bytes) {\n    let decoder;\n    return (decodeUTF8_ ??\n        ((decoder = new globalThis.TextDecoder()), (decodeUTF8_ = decoder.decode.bind(decoder))))(bytes);\n}\n//# sourceMappingURL=bytes.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL2J5dGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvdXRpbHMvYnl0ZXMubWpzP2YzNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKGJ1ZmZlcnMpIHtcbiAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XG4gICAgICAgIGxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgICAgICBvdXRwdXQuc2V0KGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxubGV0IGVuY29kZVVURjhfO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVVURjgoc3RyKSB7XG4gICAgbGV0IGVuY29kZXI7XG4gICAgcmV0dXJuIChlbmNvZGVVVEY4XyA/P1xuICAgICAgICAoKGVuY29kZXIgPSBuZXcgZ2xvYmFsVGhpcy5UZXh0RW5jb2RlcigpKSwgKGVuY29kZVVURjhfID0gZW5jb2Rlci5lbmNvZGUuYmluZChlbmNvZGVyKSkpKShzdHIpO1xufVxubGV0IGRlY29kZVVURjhfO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVVURjgoYnl0ZXMpIHtcbiAgICBsZXQgZGVjb2RlcjtcbiAgICByZXR1cm4gKGRlY29kZVVURjhfID8/XG4gICAgICAgICgoZGVjb2RlciA9IG5ldyBnbG9iYWxUaGlzLlRleHREZWNvZGVyKCkpLCAoZGVjb2RlVVRGOF8gPSBkZWNvZGVyLmRlY29kZS5iaW5kKGRlY29kZXIpKSkpKGJ5dGVzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/env.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/env.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   readEnv: () => (/* binding */ readEnv)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * Read an environment variable.\n *\n * Trims beginning and trailing whitespace.\n *\n * Will return undefined if the environment variable doesn't exist or cannot be accessed.\n */\nconst readEnv = (env) => {\n    if (typeof globalThis.process !== 'undefined') {\n        return globalThis.process.env?.[env]?.trim() ?? undefined;\n    }\n    if (typeof globalThis.Deno !== 'undefined') {\n        return globalThis.Deno.env?.get?.(env)?.trim();\n    }\n    return undefined;\n};\n//# sourceMappingURL=env.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL2Vudi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL2Vudi5tanM/NTA1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuLyoqXG4gKiBSZWFkIGFuIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIFRyaW1zIGJlZ2lubmluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAqXG4gKiBXaWxsIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIGRvZXNuJ3QgZXhpc3Qgb3IgY2Fubm90IGJlIGFjY2Vzc2VkLlxuICovXG5leHBvcnQgY29uc3QgcmVhZEVudiA9IChlbnYpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucHJvY2Vzcy5lbnY/LltlbnZdPy50cmltKCkgPz8gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMuRGVubyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXMuRGVuby5lbnY/LmdldD8uKGVudik/LnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnYubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/env.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatRequestDetails: () => (/* binding */ formatRequestDetails),\n/* harmony export */   loggerFor: () => (/* binding */ loggerFor),\n/* harmony export */   parseLogLevel: () => (/* binding */ parseLogLevel)\n/* harmony export */ });\n/* harmony import */ var _values_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./values.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\nconst levelNumbers = {\n    off: 0,\n    error: 200,\n    warn: 300,\n    info: 400,\n    debug: 500,\n};\nconst parseLogLevel = (maybeLevel, sourceName, client) => {\n    if (!maybeLevel) {\n        return undefined;\n    }\n    if ((0,_values_mjs__WEBPACK_IMPORTED_MODULE_0__.hasOwn)(levelNumbers, maybeLevel)) {\n        return maybeLevel;\n    }\n    loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);\n    return undefined;\n};\nfunction noop() { }\nfunction makeLogFn(fnLevel, logger, logLevel) {\n    if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {\n        return noop;\n    }\n    else {\n        // Don't wrap logger functions, we want the stacktrace intact!\n        return logger[fnLevel].bind(logger);\n    }\n}\nconst noopLogger = {\n    error: noop,\n    warn: noop,\n    info: noop,\n    debug: noop,\n};\nlet cachedLoggers = /* @__PURE__ */ new WeakMap();\nfunction loggerFor(client) {\n    const logger = client.logger;\n    const logLevel = client.logLevel ?? 'off';\n    if (!logger) {\n        return noopLogger;\n    }\n    const cachedLogger = cachedLoggers.get(logger);\n    if (cachedLogger && cachedLogger[0] === logLevel) {\n        return cachedLogger[1];\n    }\n    const levelLogger = {\n        error: makeLogFn('error', logger, logLevel),\n        warn: makeLogFn('warn', logger, logLevel),\n        info: makeLogFn('info', logger, logLevel),\n        debug: makeLogFn('debug', logger, logLevel),\n    };\n    cachedLoggers.set(logger, [logLevel, levelLogger]);\n    return levelLogger;\n}\nconst formatRequestDetails = (details) => {\n    if (details.options) {\n        details.options = { ...details.options };\n        delete details.options['headers']; // redundant + leaks internals\n    }\n    if (details.headers) {\n        details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [\n            name,\n            (name.toLowerCase() === 'x-api-key' ||\n                name.toLowerCase() === 'authorization' ||\n                name.toLowerCase() === 'cookie' ||\n                name.toLowerCase() === 'set-cookie') ?\n                '***'\n                : value,\n        ]));\n    }\n    if ('retryOfRequestLogID' in details) {\n        if (details.retryOfRequestLogID) {\n            details.retryOf = details.retryOfRequestLogID;\n        }\n        delete details.retryOfRequestLogID;\n    }\n    return details;\n};\n//# sourceMappingURL=log.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL2xvZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ3NDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLG1EQUFNO0FBQ2Q7QUFDQTtBQUNBLDhCQUE4QixZQUFZLGFBQWEsMkJBQTJCLG9CQUFvQiwwQ0FBMEM7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0QkFBNEI7QUFDNUIsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL2xvZy5tanM/MDVkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgaGFzT3duIH0gZnJvbSBcIi4vdmFsdWVzLm1qc1wiO1xuY29uc3QgbGV2ZWxOdW1iZXJzID0ge1xuICAgIG9mZjogMCxcbiAgICBlcnJvcjogMjAwLFxuICAgIHdhcm46IDMwMCxcbiAgICBpbmZvOiA0MDAsXG4gICAgZGVidWc6IDUwMCxcbn07XG5leHBvcnQgY29uc3QgcGFyc2VMb2dMZXZlbCA9IChtYXliZUxldmVsLCBzb3VyY2VOYW1lLCBjbGllbnQpID0+IHtcbiAgICBpZiAoIW1heWJlTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGhhc093bihsZXZlbE51bWJlcnMsIG1heWJlTGV2ZWwpKSB7XG4gICAgICAgIHJldHVybiBtYXliZUxldmVsO1xuICAgIH1cbiAgICBsb2dnZXJGb3IoY2xpZW50KS53YXJuKGAke3NvdXJjZU5hbWV9IHdhcyBzZXQgdG8gJHtKU09OLnN0cmluZ2lmeShtYXliZUxldmVsKX0sIGV4cGVjdGVkIG9uZSBvZiAke0pTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKGxldmVsTnVtYmVycykpfWApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gbWFrZUxvZ0ZuKGZuTGV2ZWwsIGxvZ2dlciwgbG9nTGV2ZWwpIHtcbiAgICBpZiAoIWxvZ2dlciB8fCBsZXZlbE51bWJlcnNbZm5MZXZlbF0gPiBsZXZlbE51bWJlcnNbbG9nTGV2ZWxdKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRG9uJ3Qgd3JhcCBsb2dnZXIgZnVuY3Rpb25zLCB3ZSB3YW50IHRoZSBzdGFja3RyYWNlIGludGFjdCFcbiAgICAgICAgcmV0dXJuIGxvZ2dlcltmbkxldmVsXS5iaW5kKGxvZ2dlcik7XG4gICAgfVxufVxuY29uc3Qgbm9vcExvZ2dlciA9IHtcbiAgICBlcnJvcjogbm9vcCxcbiAgICB3YXJuOiBub29wLFxuICAgIGluZm86IG5vb3AsXG4gICAgZGVidWc6IG5vb3AsXG59O1xubGV0IGNhY2hlZExvZ2dlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydCBmdW5jdGlvbiBsb2dnZXJGb3IoY2xpZW50KSB7XG4gICAgY29uc3QgbG9nZ2VyID0gY2xpZW50LmxvZ2dlcjtcbiAgICBjb25zdCBsb2dMZXZlbCA9IGNsaWVudC5sb2dMZXZlbCA/PyAnb2ZmJztcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICByZXR1cm4gbm9vcExvZ2dlcjtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVkTG9nZ2VyID0gY2FjaGVkTG9nZ2Vycy5nZXQobG9nZ2VyKTtcbiAgICBpZiAoY2FjaGVkTG9nZ2VyICYmIGNhY2hlZExvZ2dlclswXSA9PT0gbG9nTGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZExvZ2dlclsxXTtcbiAgICB9XG4gICAgY29uc3QgbGV2ZWxMb2dnZXIgPSB7XG4gICAgICAgIGVycm9yOiBtYWtlTG9nRm4oJ2Vycm9yJywgbG9nZ2VyLCBsb2dMZXZlbCksXG4gICAgICAgIHdhcm46IG1ha2VMb2dGbignd2FybicsIGxvZ2dlciwgbG9nTGV2ZWwpLFxuICAgICAgICBpbmZvOiBtYWtlTG9nRm4oJ2luZm8nLCBsb2dnZXIsIGxvZ0xldmVsKSxcbiAgICAgICAgZGVidWc6IG1ha2VMb2dGbignZGVidWcnLCBsb2dnZXIsIGxvZ0xldmVsKSxcbiAgICB9O1xuICAgIGNhY2hlZExvZ2dlcnMuc2V0KGxvZ2dlciwgW2xvZ0xldmVsLCBsZXZlbExvZ2dlcl0pO1xuICAgIHJldHVybiBsZXZlbExvZ2dlcjtcbn1cbmV4cG9ydCBjb25zdCBmb3JtYXRSZXF1ZXN0RGV0YWlscyA9IChkZXRhaWxzKSA9PiB7XG4gICAgaWYgKGRldGFpbHMub3B0aW9ucykge1xuICAgICAgICBkZXRhaWxzLm9wdGlvbnMgPSB7IC4uLmRldGFpbHMub3B0aW9ucyB9O1xuICAgICAgICBkZWxldGUgZGV0YWlscy5vcHRpb25zWydoZWFkZXJzJ107IC8vIHJlZHVuZGFudCArIGxlYWtzIGludGVybmFsc1xuICAgIH1cbiAgICBpZiAoZGV0YWlscy5oZWFkZXJzKSB7XG4gICAgICAgIGRldGFpbHMuaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcygoZGV0YWlscy5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycyA/IFsuLi5kZXRhaWxzLmhlYWRlcnNdIDogT2JqZWN0LmVudHJpZXMoZGV0YWlscy5oZWFkZXJzKSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3gtYXBpLWtleScgfHxcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Nvb2tpZScgfHxcbiAgICAgICAgICAgICAgICBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZXQtY29va2llJykgP1xuICAgICAgICAgICAgICAgICcqKionXG4gICAgICAgICAgICAgICAgOiB2YWx1ZSxcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBpZiAoJ3JldHJ5T2ZSZXF1ZXN0TG9nSUQnIGluIGRldGFpbHMpIHtcbiAgICAgICAgaWYgKGRldGFpbHMucmV0cnlPZlJlcXVlc3RMb2dJRCkge1xuICAgICAgICAgICAgZGV0YWlscy5yZXRyeU9mID0gZGV0YWlscy5yZXRyeU9mUmVxdWVzdExvZ0lEO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBkZXRhaWxzLnJldHJ5T2ZSZXF1ZXN0TG9nSUQ7XG4gICAgfVxuICAgIHJldHVybiBkZXRhaWxzO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/log.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPathTagFunction: () => (/* binding */ createPathTagFunction),\n/* harmony export */   encodeURIPath: () => (/* binding */ encodeURIPath),\n/* harmony export */   path: () => (/* binding */ path)\n/* harmony export */ });\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nfunction encodeURIPath(str) {\n    return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nconst EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));\nconst createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {\n    // If there are no params, no processing is needed.\n    if (statics.length === 1)\n        return statics[0];\n    let postPath = false;\n    const invalidSegments = [];\n    const path = statics.reduce((previousValue, currentValue, index) => {\n        if (/[?#]/.test(currentValue)) {\n            postPath = true;\n        }\n        const value = params[index];\n        let encoded = (postPath ? encodeURIComponent : pathEncoder)('' + value);\n        if (index !== params.length &&\n            (value == null ||\n                (typeof value === 'object' &&\n                    // handle values from other realms\n                    value.toString ===\n                        Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)\n                            ?.toString))) {\n            encoded = value + '';\n            invalidSegments.push({\n                start: previousValue.length + currentValue.length,\n                length: encoded.length,\n                error: `Value of type ${Object.prototype.toString\n                    .call(value)\n                    .slice(8, -1)} is not a valid path parameter`,\n            });\n        }\n        return previousValue + currentValue + (index === params.length ? '' : encoded);\n    }, '');\n    const pathOnly = path.split(/[?#]/, 1)[0];\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n    let match;\n    // Find all invalid segments\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n        invalidSegments.push({\n            start: match.index,\n            length: match[0].length,\n            error: `Value \"${match[0]}\" can\\'t be safely passed as a path parameter`,\n        });\n    }\n    invalidSegments.sort((a, b) => a.start - b.start);\n    if (invalidSegments.length > 0) {\n        let lastEnd = 0;\n        const underline = invalidSegments.reduce((acc, segment) => {\n            const spaces = ' '.repeat(segment.start - lastEnd);\n            const arrows = '^'.repeat(segment.length);\n            lastEnd = segment.start + segment.length;\n            return acc + spaces + arrows;\n        }, '');\n        throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`Path parameters result in path with invalid segments:\\n${invalidSegments\n            .map((e) => e.error)\n            .join('\\n')}\\n${path}\\n${underline}`);\n    }\n    return path;\n};\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nconst path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\n//# sourceMappingURL=path.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3BhdGgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ087QUFDUCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSxtQ0FBbUM7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtCQUFrQiwyREFBYywyREFBMkQ7QUFDM0Y7QUFDQSx3QkFBd0IsSUFBSSxLQUFLLElBQUksVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvdXRpbHMvcGF0aC5tanM/YTIwMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBbnRocm9waWNFcnJvciB9IGZyb20gXCIuLi8uLi9jb3JlL2Vycm9yLm1qc1wiO1xuLyoqXG4gKiBQZXJjZW50LWVuY29kZSBldmVyeXRoaW5nIHRoYXQgaXNuJ3Qgc2FmZSB0byBoYXZlIGluIGEgcGF0aCB3aXRob3V0IGVuY29kaW5nIHNhZmUgY2hhcnMuXG4gKlxuICogVGFrZW4gZnJvbSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjM6XG4gKiA+IHVucmVzZXJ2ZWQgID0gQUxQSEEgLyBESUdJVCAvIFwiLVwiIC8gXCIuXCIgLyBcIl9cIiAvIFwiflwiXG4gKiA+IHN1Yi1kZWxpbXMgID0gXCIhXCIgLyBcIiRcIiAvIFwiJlwiIC8gXCInXCIgLyBcIihcIiAvIFwiKVwiIC8gXCIqXCIgLyBcIitcIiAvIFwiLFwiIC8gXCI7XCIgLyBcIj1cIlxuICogPiBwY2hhciAgICAgICA9IHVucmVzZXJ2ZWQgLyBwY3QtZW5jb2RlZCAvIHN1Yi1kZWxpbXMgLyBcIjpcIiAvIFwiQFwiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVVUklQYXRoKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW15BLVphLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXSsvZywgZW5jb2RlVVJJQ29tcG9uZW50KTtcbn1cbmNvbnN0IEVNUFRZID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVBhdGhUYWdGdW5jdGlvbiA9IChwYXRoRW5jb2RlciA9IGVuY29kZVVSSVBhdGgpID0+IGZ1bmN0aW9uIHBhdGgoc3RhdGljcywgLi4ucGFyYW1zKSB7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFtcywgbm8gcHJvY2Vzc2luZyBpcyBuZWVkZWQuXG4gICAgaWYgKHN0YXRpY3MubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gc3RhdGljc1swXTtcbiAgICBsZXQgcG9zdFBhdGggPSBmYWxzZTtcbiAgICBjb25zdCBpbnZhbGlkU2VnbWVudHMgPSBbXTtcbiAgICBjb25zdCBwYXRoID0gc3RhdGljcy5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKC9bPyNdLy50ZXN0KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHBvc3RQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtc1tpbmRleF07XG4gICAgICAgIGxldCBlbmNvZGVkID0gKHBvc3RQYXRoID8gZW5jb2RlVVJJQ29tcG9uZW50IDogcGF0aEVuY29kZXIpKCcnICsgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHBhcmFtcy5sZW5ndGggJiZcbiAgICAgICAgICAgICh2YWx1ZSA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHZhbHVlcyBmcm9tIG90aGVyIHJlYWxtc1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS50b1N0cmluZyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUuaGFzT3duUHJvcGVydHkgPz8gRU1QVFkpID8/IEVNUFRZKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8udG9TdHJpbmcpKSkge1xuICAgICAgICAgICAgZW5jb2RlZCA9IHZhbHVlICsgJyc7XG4gICAgICAgICAgICBpbnZhbGlkU2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHByZXZpb3VzVmFsdWUubGVuZ3RoICsgY3VycmVudFZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuY29kZWQubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgVmFsdWUgb2YgdHlwZSAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSg4LCAtMSl9IGlzIG5vdCBhIHZhbGlkIHBhdGggcGFyYW1ldGVyYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlICsgKGluZGV4ID09PSBwYXJhbXMubGVuZ3RoID8gJycgOiBlbmNvZGVkKTtcbiAgICB9LCAnJyk7XG4gICAgY29uc3QgcGF0aE9ubHkgPSBwYXRoLnNwbGl0KC9bPyNdLywgMSlbMF07XG4gICAgY29uc3QgaW52YWxpZFNlZ21lbnRQYXR0ZXJuID0gLyg/PD1efFxcLykoPzpcXC58JTJlKXsxLDJ9KD89XFwvfCQpL2dpO1xuICAgIGxldCBtYXRjaDtcbiAgICAvLyBGaW5kIGFsbCBpbnZhbGlkIHNlZ21lbnRzXG4gICAgd2hpbGUgKChtYXRjaCA9IGludmFsaWRTZWdtZW50UGF0dGVybi5leGVjKHBhdGhPbmx5KSkgIT09IG51bGwpIHtcbiAgICAgICAgaW52YWxpZFNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IG1hdGNoLmluZGV4LFxuICAgICAgICAgICAgbGVuZ3RoOiBtYXRjaFswXS5sZW5ndGgsXG4gICAgICAgICAgICBlcnJvcjogYFZhbHVlIFwiJHttYXRjaFswXX1cIiBjYW5cXCd0IGJlIHNhZmVseSBwYXNzZWQgYXMgYSBwYXRoIHBhcmFtZXRlcmAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnZhbGlkU2VnbWVudHMuc29ydCgoYSwgYikgPT4gYS5zdGFydCAtIGIuc3RhcnQpO1xuICAgIGlmIChpbnZhbGlkU2VnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgbGFzdEVuZCA9IDA7XG4gICAgICAgIGNvbnN0IHVuZGVybGluZSA9IGludmFsaWRTZWdtZW50cy5yZWR1Y2UoKGFjYywgc2VnbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VzID0gJyAnLnJlcGVhdChzZWdtZW50LnN0YXJ0IC0gbGFzdEVuZCk7XG4gICAgICAgICAgICBjb25zdCBhcnJvd3MgPSAnXicucmVwZWF0KHNlZ21lbnQubGVuZ3RoKTtcbiAgICAgICAgICAgIGxhc3RFbmQgPSBzZWdtZW50LnN0YXJ0ICsgc2VnbWVudC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgc3BhY2VzICsgYXJyb3dzO1xuICAgICAgICB9LCAnJyk7XG4gICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgUGF0aCBwYXJhbWV0ZXJzIHJlc3VsdCBpbiBwYXRoIHdpdGggaW52YWxpZCBzZWdtZW50czpcXG4ke2ludmFsaWRTZWdtZW50c1xuICAgICAgICAgICAgLm1hcCgoZSkgPT4gZS5lcnJvcilcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKX1cXG4ke3BhdGh9XFxuJHt1bmRlcmxpbmV9YCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcbi8qKlxuICogVVJJLWVuY29kZXMgcGF0aCBwYXJhbXMgYW5kIGVuc3VyZXMgbm8gdW5zYWZlIC8uLyBvciAvLi4vIHBhdGggc2VnbWVudHMgYXJlIGludHJvZHVjZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXRoID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZVBhdGhUYWdGdW5jdGlvbihlbmNvZGVVUklQYXRoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\nconst sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n//# sourceMappingURL=sleep.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3NsZWVwLm1qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvaW50ZXJuYWwvdXRpbHMvc2xlZXAubWpzP2VlNGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmV4cG9ydCBjb25zdCBzbGVlcCA9IChtcykgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsZWVwLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid4: () => (/* binding */ uuid4)\n/* harmony export */ });\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n/**\n * https://stackoverflow.com/a/2117523\n */\nlet uuid4 = function () {\n    const { crypto } = globalThis;\n    if (crypto?.randomUUID) {\n        uuid4 = crypto.randomUUID.bind(crypto);\n        return crypto.randomUUID();\n    }\n    const u8 = new Uint8Array(1);\n    const randomByte = crypto ? () => crypto.getRandomValues(u8)[0] : () => (Math.random() * 0xff) & 0xff;\n    return '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, (c) => (+c ^ (randomByte() & (15 >> (+c / 4)))).toString(16));\n};\n//# sourceMappingURL=uuid.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3V1aWQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3V1aWQubWpzPzJlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbi8qKlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIxMTc1MjNcbiAqL1xuZXhwb3J0IGxldCB1dWlkNCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCB7IGNyeXB0byB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoY3J5cHRvPy5yYW5kb21VVUlEKSB7XG4gICAgICAgIHV1aWQ0ID0gY3J5cHRvLnJhbmRvbVVVSUQuYmluZChjcnlwdG8pO1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgdTggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBjb25zdCByYW5kb21CeXRlID0gY3J5cHRvID8gKCkgPT4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh1OClbMF0gOiAoKSA9PiAoTWF0aC5yYW5kb20oKSAqIDB4ZmYpICYgMHhmZjtcbiAgICByZXR1cm4gJzEwMDAwMDAwLTEwMDAtNDAwMC04MDAwLTEwMDAwMDAwMDAwMCcucmVwbGFjZSgvWzAxOF0vZywgKGMpID0+ICgrYyBeIChyYW5kb21CeXRlKCkgJiAoMTUgPj4gKCtjIC8gNCkpKSkudG9TdHJpbmcoMTYpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dWlkLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coerceBoolean: () => (/* binding */ coerceBoolean),\n/* harmony export */   coerceFloat: () => (/* binding */ coerceFloat),\n/* harmony export */   coerceInteger: () => (/* binding */ coerceInteger),\n/* harmony export */   ensurePresent: () => (/* binding */ ensurePresent),\n/* harmony export */   hasOwn: () => (/* binding */ hasOwn),\n/* harmony export */   isAbsoluteURL: () => (/* binding */ isAbsoluteURL),\n/* harmony export */   isArray: () => (/* binding */ isArray),\n/* harmony export */   isEmptyObj: () => (/* binding */ isEmptyObj),\n/* harmony export */   isObj: () => (/* binding */ isObj),\n/* harmony export */   isReadonlyArray: () => (/* binding */ isReadonlyArray),\n/* harmony export */   maybeCoerceBoolean: () => (/* binding */ maybeCoerceBoolean),\n/* harmony export */   maybeCoerceFloat: () => (/* binding */ maybeCoerceFloat),\n/* harmony export */   maybeCoerceInteger: () => (/* binding */ maybeCoerceInteger),\n/* harmony export */   maybeObj: () => (/* binding */ maybeObj),\n/* harmony export */   safeJSON: () => (/* binding */ safeJSON),\n/* harmony export */   validatePositiveInteger: () => (/* binding */ validatePositiveInteger)\n/* harmony export */ });\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n// https://url.spec.whatwg.org/#url-scheme-string\nconst startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;\nconst isAbsoluteURL = (url) => {\n    return startsWithSchemeRegexp.test(url);\n};\nlet isArray = (val) => ((isArray = Array.isArray), isArray(val));\nlet isReadonlyArray = isArray;\n/** Returns an object if the given value isn't an object, otherwise returns as-is */\nfunction maybeObj(x) {\n    if (typeof x !== 'object') {\n        return {};\n    }\n    return x ?? {};\n}\n// https://stackoverflow.com/a/34491287\nfunction isEmptyObj(obj) {\n    if (!obj)\n        return true;\n    for (const _k in obj)\n        return false;\n    return true;\n}\n// https://eslint.org/docs/latest/rules/no-prototype-builtins\nfunction hasOwn(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction isObj(obj) {\n    return obj != null && typeof obj === 'object' && !Array.isArray(obj);\n}\nconst ensurePresent = (value) => {\n    if (value == null) {\n        throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`Expected a value to be given but received ${value} instead.`);\n    }\n    return value;\n};\nconst validatePositiveInteger = (name, n) => {\n    if (typeof n !== 'number' || !Number.isInteger(n)) {\n        throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`${name} must be an integer`);\n    }\n    if (n < 0) {\n        throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`${name} must be a positive integer`);\n    }\n    return n;\n};\nconst coerceInteger = (value) => {\n    if (typeof value === 'number')\n        return Math.round(value);\n    if (typeof value === 'string')\n        return parseInt(value, 10);\n    throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nconst coerceFloat = (value) => {\n    if (typeof value === 'number')\n        return value;\n    if (typeof value === 'string')\n        return parseFloat(value);\n    throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_0__.AnthropicError(`Could not coerce ${value} (type: ${typeof value}) into a number`);\n};\nconst coerceBoolean = (value) => {\n    if (typeof value === 'boolean')\n        return value;\n    if (typeof value === 'string')\n        return value === 'true';\n    return Boolean(value);\n};\nconst maybeCoerceInteger = (value) => {\n    if (value == null) {\n        return undefined;\n    }\n    return coerceInteger(value);\n};\nconst maybeCoerceFloat = (value) => {\n    if (value == null) {\n        return undefined;\n    }\n    return coerceFloat(value);\n};\nconst maybeCoerceBoolean = (value) => {\n    if (value == null) {\n        return undefined;\n    }\n    return coerceBoolean(value);\n};\nconst safeJSON = (text) => {\n    try {\n        return JSON.parse(text);\n    }\n    catch (err) {\n        return undefined;\n    }\n};\n//# sourceMappingURL=values.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3ZhbHVlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNzRDtBQUN0RDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQiwyREFBYyw4Q0FBOEMsT0FBTztBQUNyRjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLDJEQUFjLElBQUksTUFBTTtBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLDJEQUFjLElBQUksTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyREFBYyxxQkFBcUIsT0FBTyxTQUFTLGFBQWE7QUFDOUU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyREFBYyxxQkFBcUIsT0FBTyxTQUFTLGFBQWE7QUFDOUU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2ludGVybmFsL3V0aWxzL3ZhbHVlcy5tanM/NmM2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQW50aHJvcGljRXJyb3IgfSBmcm9tIFwiLi4vLi4vY29yZS9lcnJvci5tanNcIjtcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsLXNjaGVtZS1zdHJpbmdcbmNvbnN0IHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAgPSAvXlthLXpdW2EtejAtOSsuLV0qOi9pO1xuZXhwb3J0IGNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsKSA9PiB7XG4gICAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcbmV4cG9ydCBsZXQgaXNBcnJheSA9ICh2YWwpID0+ICgoaXNBcnJheSA9IEFycmF5LmlzQXJyYXkpLCBpc0FycmF5KHZhbCkpO1xuZXhwb3J0IGxldCBpc1JlYWRvbmx5QXJyYXkgPSBpc0FycmF5O1xuLyoqIFJldHVybnMgYW4gb2JqZWN0IGlmIHRoZSBnaXZlbiB2YWx1ZSBpc24ndCBhbiBvYmplY3QsIG90aGVyd2lzZSByZXR1cm5zIGFzLWlzICovXG5leHBvcnQgZnVuY3Rpb24gbWF5YmVPYmooeCkge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICByZXR1cm4geCA/PyB7fTtcbn1cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4N1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgaWYgKCFvYmopXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAoY29uc3QgX2sgaW4gb2JqKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBodHRwczovL2VzbGludC5vcmcvZG9jcy9sYXRlc3QvcnVsZXMvbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYmoob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgRXhwZWN0ZWQgYSB2YWx1ZSB0byBiZSBnaXZlbiBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0gaW5zdGVhZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlciA9IChuYW1lLCBuKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihuKSkge1xuICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhbiBpbnRlZ2VyYCk7XG4gICAgfVxuICAgIGlmIChuIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59O1xuZXhwb3J0IGNvbnN0IGNvZXJjZUludGVnZXIgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJylcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcbmV4cG9ydCBjb25zdCBjb2VyY2VGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcbmV4cG9ydCBjb25zdCBjb2VyY2VCb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn07XG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VJbnRlZ2VyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZXJjZUludGVnZXIodmFsdWUpO1xufTtcbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUZsb2F0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZXJjZUZsb2F0KHZhbHVlKTtcbn07XG5leHBvcnQgY29uc3QgbWF5YmVDb2VyY2VCb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGNvZXJjZUJvb2xlYW4odmFsdWUpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlSlNPTiA9ICh0ZXh0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsdWVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/values.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BetaMessageStream: () => (/* binding */ BetaMessageStream)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _internal_errors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/errors.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs\");\n/* harmony import */ var _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../streaming.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/streaming.mjs\");\n/* harmony import */ var _vendor_partial_json_parser_parser_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_vendor/partial-json-parser/parser.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs\");\nvar _BetaMessageStream_instances, _BetaMessageStream_currentMessageSnapshot, _BetaMessageStream_connectedPromise, _BetaMessageStream_resolveConnectedPromise, _BetaMessageStream_rejectConnectedPromise, _BetaMessageStream_endPromise, _BetaMessageStream_resolveEndPromise, _BetaMessageStream_rejectEndPromise, _BetaMessageStream_listeners, _BetaMessageStream_ended, _BetaMessageStream_errored, _BetaMessageStream_aborted, _BetaMessageStream_catchingPromiseCreated, _BetaMessageStream_response, _BetaMessageStream_request_id, _BetaMessageStream_getFinalMessage, _BetaMessageStream_getFinalText, _BetaMessageStream_handleError, _BetaMessageStream_beginRequest, _BetaMessageStream_addStreamEvent, _BetaMessageStream_endRequest, _BetaMessageStream_accumulateMessage;\n\n\n\n\n\nconst JSON_BUF_PROPERTY = '__json_buf';\nfunction tracksToolInput(content) {\n    return content.type === 'tool_use' || content.type === 'server_tool_use' || content.type === 'mcp_tool_use';\n}\nclass BetaMessageStream {\n    constructor() {\n        _BetaMessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _BetaMessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _BetaMessageStream_connectedPromise.set(this, void 0);\n        _BetaMessageStream_resolveConnectedPromise.set(this, () => { });\n        _BetaMessageStream_rejectConnectedPromise.set(this, () => { });\n        _BetaMessageStream_endPromise.set(this, void 0);\n        _BetaMessageStream_resolveEndPromise.set(this, () => { });\n        _BetaMessageStream_rejectEndPromise.set(this, () => { });\n        _BetaMessageStream_listeners.set(this, {});\n        _BetaMessageStream_ended.set(this, false);\n        _BetaMessageStream_errored.set(this, false);\n        _BetaMessageStream_aborted.set(this, false);\n        _BetaMessageStream_catchingPromiseCreated.set(this, false);\n        _BetaMessageStream_response.set(this, void 0);\n        _BetaMessageStream_request_id.set(this, void 0);\n        _BetaMessageStream_handleError.set(this, (error) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_errored, true, \"f\");\n            if ((0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n                error = new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            if (error instanceof _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(String(error)));\n        });\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_resolveConnectedPromise, resolve, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_resolveEndPromise, resolve, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_connectedPromise, \"f\").catch(() => { });\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_response, \"f\");\n    }\n    get request_id() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new BetaMessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new BetaMessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        let abortHandler;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            abortHandler = this.controller.abort.bind(this.controller);\n            signal.addEventListener('abort', abortHandler);\n        }\n        try {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n            const { response, data: stream } = await messages\n                .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n                .withResponse();\n            this._connected(response);\n            for await (const event of stream) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n            }\n            if (stream.controller.signal?.aborted) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n        }\n        finally {\n            if (signal && abortHandler) {\n                signal.removeEventListener('abort', abortHandler);\n            }\n        }\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_response, response, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_ended, \"f\");\n    }\n    get errored() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event] || ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event] || ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_catchingPromiseCreated, true, \"f\");\n        await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_ended, true, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        let abortHandler;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            abortHandler = this.controller.abort.bind(this.controller);\n            signal.addEventListener('abort', abortHandler);\n        }\n        try {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_beginRequest).call(this);\n            this._connected(null);\n            const stream = _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__.Stream.fromReadableStream(readableStream, this.controller);\n            for await (const event of stream) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_addStreamEvent).call(this, event);\n            }\n            if (stream.controller.signal?.aborted) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_endRequest).call(this);\n        }\n        finally {\n            if (signal && abortHandler) {\n                signal.removeEventListener('abort', abortHandler);\n            }\n        }\n    }\n    [(_BetaMessageStream_currentMessageSnapshot = new WeakMap(), _BetaMessageStream_connectedPromise = new WeakMap(), _BetaMessageStream_resolveConnectedPromise = new WeakMap(), _BetaMessageStream_rejectConnectedPromise = new WeakMap(), _BetaMessageStream_endPromise = new WeakMap(), _BetaMessageStream_resolveEndPromise = new WeakMap(), _BetaMessageStream_rejectEndPromise = new WeakMap(), _BetaMessageStream_listeners = new WeakMap(), _BetaMessageStream_ended = new WeakMap(), _BetaMessageStream_errored = new WeakMap(), _BetaMessageStream_aborted = new WeakMap(), _BetaMessageStream_catchingPromiseCreated = new WeakMap(), _BetaMessageStream_response = new WeakMap(), _BetaMessageStream_request_id = new WeakMap(), _BetaMessageStream_handleError = new WeakMap(), _BetaMessageStream_instances = new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_instances, \"m\", _BetaMessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (tracksToolInput(content) && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest() {\n        if (this.ended) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`request ended without sending any chunks`);\n        }\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaMessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage(event) {\n        let snapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.container = event.delta.container;\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                snapshot.context_management = event.context_management;\n                if (event.usage.input_tokens != null) {\n                    snapshot.usage.input_tokens = event.usage.input_tokens;\n                }\n                if (event.usage.cache_creation_input_tokens != null) {\n                    snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;\n                }\n                if (event.usage.cache_read_input_tokens != null) {\n                    snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;\n                }\n                if (event.usage.server_tool_use != null) {\n                    snapshot.usage.server_tool_use = event.usage.server_tool_use;\n                }\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push(event.content_block);\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                text: (snapshotContent.text || '') + event.delta.text,\n                            };\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                citations: [...(snapshotContent.citations ?? []), event.delta.citation],\n                            };\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent && tracksToolInput(snapshotContent)) {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            const newContent = { ...snapshotContent };\n                            Object.defineProperty(newContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                try {\n                                    newContent.input = (0,_vendor_partial_json_parser_parser_mjs__WEBPACK_IMPORTED_MODULE_4__.partialParse)(jsonBuf);\n                                }\n                                catch (err) {\n                                    const error = new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${err}. JSON: ${jsonBuf}`);\n                                    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaMessageStream_handleError, \"f\").call(this, error);\n                                }\n                            }\n                            snapshot.content[event.index] = newContent;\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                thinking: snapshotContent.thinking + event.delta.thinking,\n                            };\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                signature: event.delta.signature,\n                            };\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=BetaMessageStream.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2xpYi9CZXRhTWVzc2FnZVN0cmVhbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDdUY7QUFDakM7QUFDVztBQUN2QjtBQUMrQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUscUVBQXFFO0FBQ3JFO0FBQ0EsZ0VBQWdFO0FBQ2hFLCtEQUErRDtBQUMvRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQyxnQkFBZ0Isa0VBQVk7QUFDNUIsNEJBQTRCLHlEQUFpQjtBQUM3QztBQUNBLGlDQUFpQyx5REFBaUI7QUFDbEQsZ0JBQWdCLDJFQUFzQjtBQUN0QztBQUNBO0FBQ0EsaUNBQWlDLHNEQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzREFBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzREFBYztBQUN6RCxTQUFTO0FBQ1QsUUFBUSwyRUFBc0I7QUFDOUIsWUFBWSwyRUFBc0I7QUFDbEMsWUFBWSwyRUFBc0I7QUFDbEMsU0FBUztBQUNULFFBQVEsMkVBQXNCO0FBQzlCLFlBQVksMkVBQXNCO0FBQ2xDLFlBQVksMkVBQXNCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkVBQXNCLGdFQUFnRTtBQUM5RixRQUFRLDJFQUFzQiwwREFBMEQ7QUFDeEY7QUFDQTtBQUNBLGVBQWUsMkVBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxlQUFlLDJFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkVBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Y2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9saWIvQmV0YU1lc3NhZ2VTdHJlYW0ubWpzP2I3MzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9CZXRhTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCBfQmV0YU1lc3NhZ2VTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgX0JldGFNZXNzYWdlU3RyZWFtX2VuZFByb21pc2UsIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgX0JldGFNZXNzYWdlU3RyZWFtX3JlamVjdEVuZFByb21pc2UsIF9CZXRhTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRlZCwgX0JldGFNZXNzYWdlU3RyZWFtX2Vycm9yZWQsIF9CZXRhTWVzc2FnZVN0cmVhbV9hYm9ydGVkLCBfQmV0YU1lc3NhZ2VTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc3BvbnNlLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVxdWVzdF9pZCwgX0JldGFNZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSwgX0JldGFNZXNzYWdlU3RyZWFtX2dldEZpbmFsVGV4dCwgX0JldGFNZXNzYWdlU3RyZWFtX2hhbmRsZUVycm9yLCBfQmV0YU1lc3NhZ2VTdHJlYW1fYmVnaW5SZXF1ZXN0LCBfQmV0YU1lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRSZXF1ZXN0LCBfQmV0YU1lc3NhZ2VTdHJlYW1fYWNjdW11bGF0ZU1lc3NhZ2U7XG5pbXBvcnQgeyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IH0gZnJvbSBcIi4uL2ludGVybmFsL3RzbGliLm1qc1wiO1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yIH0gZnJvbSBcIi4uL2ludGVybmFsL2Vycm9ycy5tanNcIjtcbmltcG9ydCB7IEFudGhyb3BpY0Vycm9yLCBBUElVc2VyQWJvcnRFcnJvciB9IGZyb20gXCIuLi9lcnJvci5tanNcIjtcbmltcG9ydCB7IFN0cmVhbSB9IGZyb20gXCIuLi9zdHJlYW1pbmcubWpzXCI7XG5pbXBvcnQgeyBwYXJ0aWFsUGFyc2UgfSBmcm9tIFwiLi4vX3ZlbmRvci9wYXJ0aWFsLWpzb24tcGFyc2VyL3BhcnNlci5tanNcIjtcbmNvbnN0IEpTT05fQlVGX1BST1BFUlRZID0gJ19fanNvbl9idWYnO1xuZnVuY3Rpb24gdHJhY2tzVG9vbElucHV0KGNvbnRlbnQpIHtcbiAgICByZXR1cm4gY29udGVudC50eXBlID09PSAndG9vbF91c2UnIHx8IGNvbnRlbnQudHlwZSA9PT0gJ3NlcnZlcl90b29sX3VzZScgfHwgY29udGVudC50eXBlID09PSAnbWNwX3Rvb2xfdXNlJztcbn1cbmV4cG9ydCBjbGFzcyBCZXRhTWVzc2FnZVN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMucmVjZWl2ZWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICBfQmV0YU1lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBfQmV0YU1lc3NhZ2VTdHJlYW1fY29ubmVjdGVkUHJvbWlzZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX0JldGFNZXNzYWdlU3RyZWFtX2VuZFByb21pc2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX0JldGFNZXNzYWdlU3RyZWFtX3JlamVjdEVuZFByb21pc2Uuc2V0KHRoaXMsICgpID0+IHsgfSk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMuc2V0KHRoaXMsIHt9KTtcbiAgICAgICAgX0JldGFNZXNzYWdlU3RyZWFtX2VuZGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9lcnJvcmVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9hYm9ydGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXNwb25zZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0JldGFNZXNzYWdlU3RyZWFtX3JlcXVlc3RfaWQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9CZXRhTWVzc2FnZVN0cmVhbV9oYW5kbGVFcnJvci5zZXQodGhpcywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9lcnJvcmVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIGVycm9yID0gbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBUElVc2VyQWJvcnRFcnJvcikge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2Fib3J0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW1pdCgnYWJvcnQnLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBbnRocm9waWNFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW50aHJvcGljRXJyb3IgPSBuZXcgQW50aHJvcGljRXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGFudGhyb3BpY0Vycm9yLmNhdXNlID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgYW50aHJvcGljRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Vycm9yJywgbmV3IEFudGhyb3BpY0Vycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UsIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLCByZXNvbHZlLCBcImZcIik7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLCByZWplY3QsIFwiZlwiKTtcbiAgICAgICAgfSksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZW5kUHJvbWlzZSwgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UsIHJlc29sdmUsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX3JlamVjdEVuZFByb21pc2UsIHJlamVjdCwgXCJmXCIpO1xuICAgICAgICB9KSwgXCJmXCIpO1xuICAgICAgICAvLyBEb24ndCBsZXQgdGhlc2UgcHJvbWlzZXMgY2F1c2UgdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvcnMuXG4gICAgICAgIC8vIHdlIHdpbGwgbWFudWFsbHkgY2F1c2UgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvciBsYXRlclxuICAgICAgICAvLyBpZiB0aGUgdXNlciBoYXNuJ3QgcmVnaXN0ZXJlZCBhbnkgZXJyb3IgbGlzdGVuZXIgb3IgY2FsbGVkXG4gICAgICAgIC8vIGFueSBwcm9taXNlLXJldHVybmluZyBtZXRob2QuXG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UsIFwiZlwiKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRQcm9taXNlLCBcImZcIikuY2F0Y2goKCkgPT4geyB9KTtcbiAgICB9XG4gICAgZ2V0IHJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVzcG9uc2UsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHJlcXVlc3RfaWQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBNZXNzYWdlU3RyZWFtYCBkYXRhLCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgYW5kIHRoZSBJRCBvZiB0aGUgcmVxdWVzdCxcbiAgICAgKiByZXR1cm5lZCB2aWUgdGhlIGByZXF1ZXN0LWlkYCBoZWFkZXIgd2hpY2ggaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcmVxdWVzdHMgYW5kIHJlc3BvcnRpbmdcbiAgICAgKiBpc3N1ZXMgdG8gQW50aHJvcGljLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgYEFQSVByb21pc2Uud2l0aFJlc3BvbnNlKClgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmFpc2UgYW4gZXJyb3IgaWYgeW91IGNyZWF0ZWQgdGhlIHN0cmVhbSB1c2luZyBgTWVzc2FnZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW1gXG4gICAgICogYXMgbm8gYFJlc3BvbnNlYCBpcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgYXN5bmMgd2l0aFJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UsIFwiZlwiKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSBhIGBSZXNwb25zZWAgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIHJlcXVlc3RfaWQ6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdyZXF1ZXN0LWlkJyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVuZGVkIGZvciB1c2Ugb24gdGhlIGZyb250ZW5kLCBjb25zdW1pbmcgYSBzdHJlYW0gcHJvZHVjZWQgd2l0aFxuICAgICAqIGAudG9SZWFkYWJsZVN0cmVhbSgpYCBvbiB0aGUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCBtZXNzYWdlcyBzZW50IHRvIHRoZSBtb2RlbCBkbyBub3QgYXBwZWFyIGluIGAub24oJ21lc3NhZ2UnKWBcbiAgICAgKiBpbiB0aGlzIGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgY29uc3QgcnVubmVyID0gbmV3IEJldGFNZXNzYWdlU3RyZWFtKCk7XG4gICAgICAgIHJ1bm5lci5fcnVuKCgpID0+IHJ1bm5lci5fZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkpO1xuICAgICAgICByZXR1cm4gcnVubmVyO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlTWVzc2FnZShtZXNzYWdlcywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBCZXRhTWVzc2FnZVN0cmVhbSgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyYW1zLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBydW5uZXIuX2FkZE1lc3NhZ2VQYXJhbShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2NyZWF0ZU1lc3NhZ2UobWVzc2FnZXMsIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSwgeyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIF9ydW4oZXhlY3V0b3IpIHtcbiAgICAgICAgZXhlY3V0b3IoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRGaW5hbCgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICAgIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2hhbmRsZUVycm9yLCBcImZcIikpO1xuICAgIH1cbiAgICBfYWRkTWVzc2FnZVBhcmFtKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgICBfYWRkTWVzc2FnZShtZXNzYWdlLCBlbWl0ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlY2VpdmVkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlTWVzc2FnZShtZXNzYWdlcywgcGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnM/LnNpZ25hbDtcbiAgICAgICAgbGV0IGFib3J0SGFuZGxlcjtcbiAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgYWJvcnRIYW5kbGVyID0gdGhpcy5jb250cm9sbGVyLmFib3J0LmJpbmQodGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9iZWdpblJlcXVlc3QpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlLCBkYXRhOiBzdHJlYW0gfSA9IGF3YWl0IG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pXG4gICAgICAgICAgICAgICAgLndpdGhSZXNwb25zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0JldGFNZXNzYWdlU3RyZWFtX2FkZFN0cmVhbUV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbCAmJiBhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25uZWN0ZWQocmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc3BvbnNlLCByZXNwb25zZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLCByZXNwb25zZT8uaGVhZGVycy5nZXQoJ3JlcXVlc3QtaWQnKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgcmVzcG9uc2UpO1xuICAgICAgICB0aGlzLl9lbWl0KCdjb25uZWN0Jyk7XG4gICAgfVxuICAgIGdldCBlbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2VuZGVkLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBlcnJvcmVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZXJyb3JlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2Fib3J0ZWQsIFwiZlwiKTtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICAgKiBObyBjaGVja3MgYXJlIG1hZGUgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkLiBNdWx0aXBsZSBjYWxscyBwYXNzaW5nXG4gICAgICogdGhlIHNhbWUgY29tYmluYXRpb24gb2YgZXZlbnQgYW5kIGxpc3RlbmVyIHdpbGwgcmVzdWx0IGluIHRoZSBsaXN0ZW5lciBiZWluZyBhZGRlZCwgYW5kXG4gICAgICogY2FsbGVkLCBtdWx0aXBsZSB0aW1lcy5cbiAgICAgKiBAcmV0dXJucyB0aGlzIE1lc3NhZ2VTdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICAgKi9cbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdIHx8IChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICAgKiBvZmYoKSB3aWxsIHJlbW92ZSwgYXQgbW9zdCwgb25lIGluc3RhbmNlIG9mIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkuIElmIGFueSBzaW5nbGVcbiAgICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICAgKiBvZmYoKSBtdXN0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgZWFjaCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB0aGlzIE1lc3NhZ2VTdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICAgKi9cbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsKSA9PiBsLmxpc3RlbmVyID09PSBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKVxuICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lLXRpbWUgbGlzdGVuZXIgZnVuY3Rpb24gZm9yIHRoZSBldmVudC4gVGhlIG5leHQgdGltZSB0aGUgZXZlbnQgaXMgdHJpZ2dlcmVkLFxuICAgICAqIHRoaXMgbGlzdGVuZXIgaXMgcmVtb3ZlZCBhbmQgdGhlbiBpbnZva2VkLlxuICAgICAqIEByZXR1cm5zIHRoaXMgTWVzc2FnZVN0cmVhbSwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZFxuICAgICAqL1xuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSB8fCAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gW10pO1xuICAgICAgICBsaXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvIGAub25jZSgpYCwgYnV0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZVxuICAgICAqIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsIGluc3RlYWQgb2YgY2FsbGluZyBhIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBuZXh0IHRpbWUgZ2l2ZW4gZXZlbnQgaXMgdHJpZ2dlcmVkLFxuICAgICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW1pdHRlZC4gIChJZiB5b3UgcmVxdWVzdCB0aGUgJ2Vycm9yJyBldmVudCxcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGVycm9yKS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBzdHJlYW0uZW1pdHRlZCgnbWVzc2FnZScpIC8vIHJlamVjdHMgaWYgdGhlIHN0cmVhbSBlcnJvcnNcbiAgICAgKi9cbiAgICBlbWl0dGVkKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICBpZiAoZXZlbnQgIT09ICdlcnJvcicpXG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICAgICAgICB0aGlzLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZG9uZSgpIHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRQcm9taXNlLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBjdXJyZW50TWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2N1cnJlbnRNZXNzYWdlU25hcHNob3QsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgdGhlIGZpbmFsIGFzc2lzdGFudCBNZXNzYWdlIHJlc3BvbnNlLFxuICAgICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIE1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxNZXNzYWdlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9nZXRGaW5hbE1lc3NhZ2UpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRoZSBmaW5hbCBhc3Npc3RhbnQgTWVzc2FnZSdzIHRleHQgcmVzcG9uc2UsIGNvbmNhdGVuYXRlZFxuICAgICAqIHRvZ2V0aGVyIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHRleHQgYmxvY2tzLlxuICAgICAqIFJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIE1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxUZXh0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9nZXRGaW5hbFRleHQpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIF9lbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkb24ndCBlbWl0IGFueSBNZXNzYWdlU3RyZWFtRXZlbnRzIGFmdGVyIGVuZFxuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZW5kZWQsIFwiZlwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnZW5kJykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZW5kZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX3Jlc29sdmVFbmRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+ICFsLm9uY2UpO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goKHsgbGlzdGVuZXIgfSkgPT4gbGlzdGVuZXIoLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2Fib3J0Jykge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLCBcImZcIikgJiYgIWxpc3RlbmVycz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBfZW1pdCgnZXJyb3InLCBlcnJvcikgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGZyb20gI2hhbmRsZUVycm9yKCkuXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIFwiZlwiKSAmJiAhbGlzdGVuZXJzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gaWYgdGhlIHVzZXIgaGFzbid0IHJlZ2lzdGVyZWQgYW55IGVycm9yIGhhbmRsZXJzLlxuICAgICAgICAgICAgICAgIC8vIElmIHlvdSBhcmUgc2VlaW5nIHN0YWNrIHRyYWNlcyBoZXJlLCBtYWtlIHN1cmUgdG8gaGFuZGxlIGVycm9ycyB2aWEgZWl0aGVyOlxuICAgICAgICAgICAgICAgIC8vIC0gcnVubmVyLm9uKCdlcnJvcicsICgpID0+IC4uLilcbiAgICAgICAgICAgICAgICAvLyAtIGF3YWl0IHJ1bm5lci5kb25lKClcbiAgICAgICAgICAgICAgICAvLyAtIGF3YWl0IHJ1bm5lci5maW5hbC4uLigpXG4gICAgICAgICAgICAgICAgLy8gLSBldGMuXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2VtaXRGaW5hbCgpIHtcbiAgICAgICAgY29uc3QgZmluYWxNZXNzYWdlID0gdGhpcy5yZWNlaXZlZE1lc3NhZ2VzLmF0KC0xKTtcbiAgICAgICAgaWYgKGZpbmFsTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZmluYWxNZXNzYWdlJywgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0JldGFNZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSkuY2FsbCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGxldCBhYm9ydEhhbmRsZXI7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGFib3J0SGFuZGxlciA9IHRoaXMuY29udHJvbGxlci5hYm9ydC5iaW5kKHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfQmV0YU1lc3NhZ2VTdHJlYW1fYmVnaW5SZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkKG51bGwpO1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gU3RyZWFtLmZyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgdGhpcy5jb250cm9sbGVyKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX0JldGFNZXNzYWdlU3RyZWFtX2FkZFN0cmVhbUV2ZW50KS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJlYW0uY29udHJvbGxlci5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbCAmJiBhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFsoX0JldGFNZXNzYWdlU3RyZWFtX2N1cnJlbnRNZXNzYWdlU25hcHNob3QgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX0JldGFNZXNzYWdlU3RyZWFtX2VuZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZW5kZWQgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZXJyb3JlZCA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9hYm9ydGVkID0gbmV3IFdlYWtNYXAoKSwgX0JldGFNZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVzcG9uc2UgPSBuZXcgV2Vha01hcCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fcmVxdWVzdF9pZCA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9oYW5kbGVFcnJvciA9IG5ldyBXZWFrTWFwKCksIF9CZXRhTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMgPSBuZXcgV2Vha1NldCgpLCBfQmV0YU1lc3NhZ2VTdHJlYW1fZ2V0RmluYWxNZXNzYWdlID0gZnVuY3Rpb24gX0JldGFNZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgTWVzc2FnZSB3aXRoIHJvbGU9YXNzaXN0YW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5hdCgtMSk7XG4gICAgfSwgX0JldGFNZXNzYWdlU3RyZWFtX2dldEZpbmFsVGV4dCA9IGZ1bmN0aW9uIF9CZXRhTWVzc2FnZVN0cmVhbV9nZXRGaW5hbFRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2VpdmVkTWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoJ3N0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIE1lc3NhZ2Ugd2l0aCByb2xlPWFzc2lzdGFudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSB0aGlzLnJlY2VpdmVkTWVzc2FnZXNcbiAgICAgICAgICAgIC5hdCgtMSlcbiAgICAgICAgICAgIC5jb250ZW50LmZpbHRlcigoYmxvY2spID0+IGJsb2NrLnR5cGUgPT09ICd0ZXh0JylcbiAgICAgICAgICAgIC5tYXAoKGJsb2NrKSA9PiBibG9jay50ZXh0KTtcbiAgICAgICAgaWYgKHRleHRCbG9ja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoJ3N0cmVhbSBlbmRlZCB3aXRob3V0IHByb2R1Y2luZyBhIGNvbnRlbnQgYmxvY2sgd2l0aCB0eXBlPXRleHQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dEJsb2Nrcy5qb2luKCcgJyk7XG4gICAgfSwgX0JldGFNZXNzYWdlU3RyZWFtX2JlZ2luUmVxdWVzdCA9IGZ1bmN0aW9uIF9CZXRhTWVzc2FnZVN0cmVhbV9iZWdpblJlcXVlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICB9LCBfQmV0YU1lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQgPSBmdW5jdGlvbiBfQmV0YU1lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VTbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhTWVzc2FnZVN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSkuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3N0cmVhbUV2ZW50JywgZXZlbnQsIG1lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19kZWx0YSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZVNuYXBzaG90LmNvbnRlbnQuYXQoLTEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0X2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dCcsIGV2ZW50LmRlbHRhLnRleHQsIGNvbnRlbnQudGV4dCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaXRhdGlvbnNfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdjaXRhdGlvbicsIGV2ZW50LmRlbHRhLmNpdGF0aW9uLCBjb250ZW50LmNpdGF0aW9ucyA/PyBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dF9qc29uX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrc1Rvb2xJbnB1dChjb250ZW50KSAmJiBjb250ZW50LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW5wdXRKc29uJywgZXZlbnQuZGVsdGEucGFydGlhbF9qc29uLCBjb250ZW50LmlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RoaW5raW5nX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RoaW5raW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RoaW5raW5nJywgZXZlbnQuZGVsdGEudGhpbmtpbmcsIGNvbnRlbnQudGhpbmtpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbmF0dXJlX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RoaW5raW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3NpZ25hdHVyZScsIGNvbnRlbnQuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja05ldmVyKGV2ZW50LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX3N0b3AnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZVBhcmFtKG1lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlU25hcHNob3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdG9wJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnRCbG9jaycsIG1lc3NhZ2VTbmFwc2hvdC5jb250ZW50LmF0KC0xKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX3N0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2N1cnJlbnRNZXNzYWdlU25hcHNob3QsIG1lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX2RlbHRhJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIF9CZXRhTWVzc2FnZVN0cmVhbV9lbmRSZXF1ZXN0ID0gZnVuY3Rpb24gX0JldGFNZXNzYWdlU3RyZWFtX2VuZFJlcXVlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYHN0cmVhbSBoYXMgZW5kZWQsIHRoaXMgc2hvdWxkbid0IGhhcHBlbmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YU1lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpO1xuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYHJlcXVlc3QgZW5kZWQgd2l0aG91dCBzZW5kaW5nIGFueSBjaHVua3NgKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCB1bmRlZmluZWQsIFwiZlwiKTtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgIH0sIF9CZXRhTWVzc2FnZVN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSA9IGZ1bmN0aW9uIF9CZXRhTWVzc2FnZVN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZShldmVudCkge1xuICAgICAgICBsZXQgc25hcHNob3QgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCBcImZcIik7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnbWVzc2FnZV9zdGFydCcpIHtcbiAgICAgICAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgVW5leHBlY3RlZCBldmVudCBvcmRlciwgZ290ICR7ZXZlbnQudHlwZX0gYmVmb3JlIHJlY2VpdmluZyBcIm1lc3NhZ2Vfc3RvcFwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYFVuZXhwZWN0ZWQgZXZlbnQgb3JkZXIsIGdvdCAke2V2ZW50LnR5cGV9IGJlZm9yZSBcIm1lc3NhZ2Vfc3RhcnRcImApO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbWVzc2FnZV9zdG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX2RlbHRhJzpcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC5jb250YWluZXIgPSBldmVudC5kZWx0YS5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgc25hcHNob3Quc3RvcF9yZWFzb24gPSBldmVudC5kZWx0YS5zdG9wX3JlYXNvbjtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC5zdG9wX3NlcXVlbmNlID0gZXZlbnQuZGVsdGEuc3RvcF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC51c2FnZS5vdXRwdXRfdG9rZW5zID0gZXZlbnQudXNhZ2Uub3V0cHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC5jb250ZXh0X21hbmFnZW1lbnQgPSBldmVudC5jb250ZXh0X21hbmFnZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmlucHV0X3Rva2VucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLmlucHV0X3Rva2VucyA9IGV2ZW50LnVzYWdlLmlucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucyA9IGV2ZW50LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmNhY2hlX3JlYWRfaW5wdXRfdG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3QudXNhZ2UuY2FjaGVfcmVhZF9pbnB1dF90b2tlbnMgPSBldmVudC51c2FnZS5jYWNoZV9yZWFkX2lucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLnNlcnZlcl90b29sX3VzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLnNlcnZlcl90b29sX3VzZSA9IGV2ZW50LnVzYWdlLnNlcnZlcl90b29sX3VzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdGFydCc6XG4gICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudC5wdXNoKGV2ZW50LmNvbnRlbnRfYmxvY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRlbnRfYmxvY2tfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc25hcHNob3RDb250ZW50ID0gc25hcHNob3QuY29udGVudC5hdChldmVudC5pbmRleCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC5kZWx0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RleHRfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdC5jb250ZW50W2V2ZW50LmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc25hcHNob3RDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAoc25hcHNob3RDb250ZW50LnRleHQgfHwgJycpICsgZXZlbnQuZGVsdGEudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2l0YXRpb25zX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90Q29udGVudD8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2l0YXRpb25zOiBbLi4uKHNuYXBzaG90Q29udGVudC5jaXRhdGlvbnMgPz8gW10pLCBldmVudC5kZWx0YS5jaXRhdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2lucHV0X2pzb25fZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50ICYmIHRyYWNrc1Rvb2xJbnB1dChzbmFwc2hvdENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSByYXcgSlNPTiBzdHJpbmcgYXMgd2VsbCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlLXBhcnNlIGl0IGZvciBlYWNoIGRlbHRhLCBmb3Igbm93IHdlIGp1c3Qgc3RvcmUgaXQgYXMgYW4gdW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5IG9uIHRoZSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBqc29uQnVmID0gc25hcHNob3RDb250ZW50W0pTT05fQlVGX1BST1BFUlRZXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uQnVmICs9IGV2ZW50LmRlbHRhLnBhcnRpYWxfanNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZW50ID0geyAuLi5zbmFwc2hvdENvbnRlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3Q29udGVudCwgSlNPTl9CVUZfUFJPUEVSVFksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzb25CdWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkJ1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudC5pbnB1dCA9IHBhcnRpYWxQYXJzZShqc29uQnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBBbnRocm9waWNFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHRvb2wgcGFyYW1ldGVyIEpTT04gZnJvbSBtb2RlbC4gUGxlYXNlIHJldHJ5IHlvdXIgcmVxdWVzdCBvciBhZGp1c3QgeW91ciBwcm9tcHQuIEVycm9yOiAke2Vycn0uIEpTT046ICR7anNvbkJ1Zn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFNZXNzYWdlU3RyZWFtX2hhbmRsZUVycm9yLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhpbmtpbmdfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09PSAndGhpbmtpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpbmtpbmc6IHNuYXBzaG90Q29udGVudC50aGlua2luZyArIGV2ZW50LmRlbHRhLnRoaW5raW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduYXR1cmVfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09PSAndGhpbmtpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBldmVudC5kZWx0YS5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja05ldmVyKGV2ZW50LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICB9LCBTeW1ib2wuYXN5bmNJdGVyYXRvcildKCkge1xuICAgICAgICBjb25zdCBwdXNoUXVldWUgPSBbXTtcbiAgICAgICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMub24oJ3N0cmVhbUV2ZW50JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9SZWFkYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSh0aGlzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXS5iaW5kKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gc3RyZWFtLnRvUmVhZGFibGVTdHJlYW0oKTtcbiAgICB9XG59XG4vLyB1c2VkIHRvIGVuc3VyZSBleGhhdXN0aXZlIGNhc2UgbWF0Y2hpbmcgd2l0aG91dCB0aHJvd2luZyBhIHJ1bnRpbWUgZXJyb3JcbmZ1bmN0aW9uIGNoZWNrTmV2ZXIoeCkgeyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CZXRhTWVzc2FnZVN0cmVhbS5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs":
/*!******************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageStream: () => (/* binding */ MessageStream)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _internal_errors_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/errors.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/errors.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs\");\n/* harmony import */ var _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../streaming.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/streaming.mjs\");\n/* harmony import */ var _vendor_partial_json_parser_parser_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_vendor/partial-json-parser/parser.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs\");\nvar _MessageStream_instances, _MessageStream_currentMessageSnapshot, _MessageStream_connectedPromise, _MessageStream_resolveConnectedPromise, _MessageStream_rejectConnectedPromise, _MessageStream_endPromise, _MessageStream_resolveEndPromise, _MessageStream_rejectEndPromise, _MessageStream_listeners, _MessageStream_ended, _MessageStream_errored, _MessageStream_aborted, _MessageStream_catchingPromiseCreated, _MessageStream_response, _MessageStream_request_id, _MessageStream_getFinalMessage, _MessageStream_getFinalText, _MessageStream_handleError, _MessageStream_beginRequest, _MessageStream_addStreamEvent, _MessageStream_endRequest, _MessageStream_accumulateMessage;\n\n\n\n\n\nconst JSON_BUF_PROPERTY = '__json_buf';\nfunction tracksToolInput(content) {\n    return content.type === 'tool_use' || content.type === 'server_tool_use';\n}\nclass MessageStream {\n    constructor() {\n        _MessageStream_instances.add(this);\n        this.messages = [];\n        this.receivedMessages = [];\n        _MessageStream_currentMessageSnapshot.set(this, void 0);\n        this.controller = new AbortController();\n        _MessageStream_connectedPromise.set(this, void 0);\n        _MessageStream_resolveConnectedPromise.set(this, () => { });\n        _MessageStream_rejectConnectedPromise.set(this, () => { });\n        _MessageStream_endPromise.set(this, void 0);\n        _MessageStream_resolveEndPromise.set(this, () => { });\n        _MessageStream_rejectEndPromise.set(this, () => { });\n        _MessageStream_listeners.set(this, {});\n        _MessageStream_ended.set(this, false);\n        _MessageStream_errored.set(this, false);\n        _MessageStream_aborted.set(this, false);\n        _MessageStream_catchingPromiseCreated.set(this, false);\n        _MessageStream_response.set(this, void 0);\n        _MessageStream_request_id.set(this, void 0);\n        _MessageStream_handleError.set(this, (error) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_errored, true, \"f\");\n            if ((0,_internal_errors_mjs__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n                error = new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            if (error instanceof _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_aborted, true, \"f\");\n                return this._emit('abort', error);\n            }\n            if (error instanceof _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError) {\n                return this._emit('error', error);\n            }\n            if (error instanceof Error) {\n                const anthropicError = new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(error.message);\n                // @ts-ignore\n                anthropicError.cause = error;\n                return this._emit('error', anthropicError);\n            }\n            return this._emit('error', new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(String(error)));\n        });\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_resolveConnectedPromise, resolve, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_rejectConnectedPromise, reject, \"f\");\n        }), \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_endPromise, new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_resolveEndPromise, resolve, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_rejectEndPromise, reject, \"f\");\n        }), \"f\");\n        // Don't let these promises cause unhandled rejection errors.\n        // we will manually cause an unhandled rejection error later\n        // if the user hasn't registered any error listener or called\n        // any promise-returning method.\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_connectedPromise, \"f\").catch(() => { });\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_endPromise, \"f\").catch(() => { });\n    }\n    get response() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_response, \"f\");\n    }\n    get request_id() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_request_id, \"f\");\n    }\n    /**\n     * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,\n     * returned vie the `request-id` header which is useful for debugging requests and resporting\n     * issues to Anthropic.\n     *\n     * This is the same as the `APIPromise.withResponse()` method.\n     *\n     * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`\n     * as no `Response` is available.\n     */\n    async withResponse() {\n        const response = await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_connectedPromise, \"f\");\n        if (!response) {\n            throw new Error('Could not resolve a `Response` object');\n        }\n        return {\n            data: this,\n            response,\n            request_id: response.headers.get('request-id'),\n        };\n    }\n    /**\n     * Intended for use on the frontend, consuming a stream produced with\n     * `.toReadableStream()` on the backend.\n     *\n     * Note that messages sent to the model do not appear in `.on('message')`\n     * in this context.\n     */\n    static fromReadableStream(stream) {\n        const runner = new MessageStream();\n        runner._run(() => runner._fromReadableStream(stream));\n        return runner;\n    }\n    static createMessage(messages, params, options) {\n        const runner = new MessageStream();\n        for (const message of params.messages) {\n            runner._addMessageParam(message);\n        }\n        runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, 'X-Stainless-Helper-Method': 'stream' } }));\n        return runner;\n    }\n    _run(executor) {\n        executor().then(() => {\n            this._emitFinal();\n            this._emit('end');\n        }, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_handleError, \"f\"));\n    }\n    _addMessageParam(message) {\n        this.messages.push(message);\n    }\n    _addMessage(message, emit = true) {\n        this.receivedMessages.push(message);\n        if (emit) {\n            this._emit('message', message);\n        }\n    }\n    async _createMessage(messages, params, options) {\n        const signal = options?.signal;\n        let abortHandler;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            abortHandler = this.controller.abort.bind(this.controller);\n            signal.addEventListener('abort', abortHandler);\n        }\n        try {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n            const { response, data: stream } = await messages\n                .create({ ...params, stream: true }, { ...options, signal: this.controller.signal })\n                .withResponse();\n            this._connected(response);\n            for await (const event of stream) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n            }\n            if (stream.controller.signal?.aborted) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n        }\n        finally {\n            if (signal && abortHandler) {\n                signal.removeEventListener('abort', abortHandler);\n            }\n        }\n    }\n    _connected(response) {\n        if (this.ended)\n            return;\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_response, response, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_request_id, response?.headers.get('request-id'), \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_resolveConnectedPromise, \"f\").call(this, response);\n        this._emit('connect');\n    }\n    get ended() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_ended, \"f\");\n    }\n    get errored() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_errored, \"f\");\n    }\n    get aborted() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_aborted, \"f\");\n    }\n    abort() {\n        this.controller.abort();\n    }\n    /**\n     * Adds the listener function to the end of the listeners array for the event.\n     * No checks are made to see if the listener has already been added. Multiple calls passing\n     * the same combination of event and listener will result in the listener being added, and\n     * called, multiple times.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    on(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event] || ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener });\n        return this;\n    }\n    /**\n     * Removes the specified listener from the listener array for the event.\n     * off() will remove, at most, one instance of a listener from the listener array. If any single\n     * listener has been added multiple times to the listener array for the specified event, then\n     * off() must be called multiple times to remove each instance.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    off(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event];\n        if (!listeners)\n            return this;\n        const index = listeners.findIndex((l) => l.listener === listener);\n        if (index >= 0)\n            listeners.splice(index, 1);\n        return this;\n    }\n    /**\n     * Adds a one-time listener function for the event. The next time the event is triggered,\n     * this listener is removed and then invoked.\n     * @returns this MessageStream, so that calls can be chained\n     */\n    once(event, listener) {\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event] || ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event] = []);\n        listeners.push({ listener, once: true });\n        return this;\n    }\n    /**\n     * This is similar to `.once()`, but returns a Promise that resolves the next time\n     * the event is triggered, instead of calling a listener callback.\n     * @returns a Promise that resolves the next time given event is triggered,\n     * or rejects if an error is emitted.  (If you request the 'error' event,\n     * returns a promise that resolves with the error).\n     *\n     * Example:\n     *\n     *   const message = await stream.emitted('message') // rejects if the stream errors\n     */\n    emitted(event) {\n        return new Promise((resolve, reject) => {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n            if (event !== 'error')\n                this.once('error', reject);\n            this.once(event, resolve);\n        });\n    }\n    async done() {\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_catchingPromiseCreated, true, \"f\");\n        await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_endPromise, \"f\");\n    }\n    get currentMessage() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_currentMessageSnapshot, \"f\");\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message response,\n     * or rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalMessage() {\n        await this.done();\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this);\n    }\n    /**\n     * @returns a promise that resolves with the the final assistant Message's text response, concatenated\n     * together if there are more than one text blocks.\n     * Rejects if an error occurred or the stream ended prematurely without producing a Message.\n     */\n    async finalText() {\n        await this.done();\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_getFinalText).call(this);\n    }\n    _emit(event, ...args) {\n        // make sure we don't emit any MessageStreamEvents after end\n        if ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_ended, \"f\"))\n            return;\n        if (event === 'end') {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_ended, true, \"f\");\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_resolveEndPromise, \"f\").call(this);\n        }\n        const listeners = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event];\n        if (listeners) {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_listeners, \"f\")[event] = listeners.filter((l) => !l.once);\n            listeners.forEach(({ listener }) => listener(...args));\n        }\n        if (event === 'abort') {\n            const error = args[0];\n            if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                Promise.reject(error);\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n            return;\n        }\n        if (event === 'error') {\n            // NOTE: _emit('error', error) should only be called from #handleError().\n            const error = args[0];\n            if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_catchingPromiseCreated, \"f\") && !listeners?.length) {\n                // Trigger an unhandled rejection if the user hasn't registered any error handlers.\n                // If you are seeing stack traces here, make sure to handle errors via either:\n                // - runner.on('error', () => ...)\n                // - await runner.done()\n                // - await runner.final...()\n                // - etc.\n                Promise.reject(error);\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_rejectConnectedPromise, \"f\").call(this, error);\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_rejectEndPromise, \"f\").call(this, error);\n            this._emit('end');\n        }\n    }\n    _emitFinal() {\n        const finalMessage = this.receivedMessages.at(-1);\n        if (finalMessage) {\n            this._emit('finalMessage', (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_getFinalMessage).call(this));\n        }\n    }\n    async _fromReadableStream(readableStream, options) {\n        const signal = options?.signal;\n        let abortHandler;\n        if (signal) {\n            if (signal.aborted)\n                this.controller.abort();\n            abortHandler = this.controller.abort.bind(this.controller);\n            signal.addEventListener('abort', abortHandler);\n        }\n        try {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_beginRequest).call(this);\n            this._connected(null);\n            const stream = _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__.Stream.fromReadableStream(readableStream, this.controller);\n            for await (const event of stream) {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_addStreamEvent).call(this, event);\n            }\n            if (stream.controller.signal?.aborted) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.APIUserAbortError();\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_endRequest).call(this);\n        }\n        finally {\n            if (signal && abortHandler) {\n                signal.removeEventListener('abort', abortHandler);\n            }\n        }\n    }\n    [(_MessageStream_currentMessageSnapshot = new WeakMap(), _MessageStream_connectedPromise = new WeakMap(), _MessageStream_resolveConnectedPromise = new WeakMap(), _MessageStream_rejectConnectedPromise = new WeakMap(), _MessageStream_endPromise = new WeakMap(), _MessageStream_resolveEndPromise = new WeakMap(), _MessageStream_rejectEndPromise = new WeakMap(), _MessageStream_listeners = new WeakMap(), _MessageStream_ended = new WeakMap(), _MessageStream_errored = new WeakMap(), _MessageStream_aborted = new WeakMap(), _MessageStream_catchingPromiseCreated = new WeakMap(), _MessageStream_response = new WeakMap(), _MessageStream_request_id = new WeakMap(), _MessageStream_handleError = new WeakMap(), _MessageStream_instances = new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage() {\n        if (this.receivedMessages.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        return this.receivedMessages.at(-1);\n    }, _MessageStream_getFinalText = function _MessageStream_getFinalText() {\n        if (this.receivedMessages.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a Message with role=assistant');\n        }\n        const textBlocks = this.receivedMessages\n            .at(-1)\n            .content.filter((block) => block.type === 'text')\n            .map((block) => block.text);\n        if (textBlocks.length === 0) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError('stream ended without producing a content block with type=text');\n        }\n        return textBlocks.join(' ');\n    }, _MessageStream_beginRequest = function _MessageStream_beginRequest() {\n        if (this.ended)\n            return;\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n    }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent(event) {\n        if (this.ended)\n            return;\n        const messageSnapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_instances, \"m\", _MessageStream_accumulateMessage).call(this, event);\n        this._emit('streamEvent', event, messageSnapshot);\n        switch (event.type) {\n            case 'content_block_delta': {\n                const content = messageSnapshot.content.at(-1);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (content.type === 'text') {\n                            this._emit('text', event.delta.text, content.text || '');\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (content.type === 'text') {\n                            this._emit('citation', event.delta.citation, content.citations ?? []);\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (tracksToolInput(content) && content.input) {\n                            this._emit('inputJson', event.delta.partial_json, content.input);\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('thinking', event.delta.thinking, content.thinking);\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (content.type === 'thinking') {\n                            this._emit('signature', content.signature);\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                break;\n            }\n            case 'message_stop': {\n                this._addMessageParam(messageSnapshot);\n                this._addMessage(messageSnapshot, true);\n                break;\n            }\n            case 'content_block_stop': {\n                this._emit('contentBlock', messageSnapshot.content.at(-1));\n                break;\n            }\n            case 'message_start': {\n                (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_currentMessageSnapshot, messageSnapshot, \"f\");\n                break;\n            }\n            case 'content_block_start':\n            case 'message_delta':\n                break;\n        }\n    }, _MessageStream_endRequest = function _MessageStream_endRequest() {\n        if (this.ended) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`stream has ended, this shouldn't happen`);\n        }\n        const snapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (!snapshot) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`request ended without sending any chunks`);\n        }\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _MessageStream_currentMessageSnapshot, undefined, \"f\");\n        return snapshot;\n    }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage(event) {\n        let snapshot = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _MessageStream_currentMessageSnapshot, \"f\");\n        if (event.type === 'message_start') {\n            if (snapshot) {\n                throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`Unexpected event order, got ${event.type} before receiving \"message_stop\"`);\n            }\n            return event.message;\n        }\n        if (!snapshot) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_2__.AnthropicError(`Unexpected event order, got ${event.type} before \"message_start\"`);\n        }\n        switch (event.type) {\n            case 'message_stop':\n                return snapshot;\n            case 'message_delta':\n                snapshot.stop_reason = event.delta.stop_reason;\n                snapshot.stop_sequence = event.delta.stop_sequence;\n                snapshot.usage.output_tokens = event.usage.output_tokens;\n                // Update other usage fields if they exist in the event\n                if (event.usage.input_tokens != null) {\n                    snapshot.usage.input_tokens = event.usage.input_tokens;\n                }\n                if (event.usage.cache_creation_input_tokens != null) {\n                    snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;\n                }\n                if (event.usage.cache_read_input_tokens != null) {\n                    snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;\n                }\n                if (event.usage.server_tool_use != null) {\n                    snapshot.usage.server_tool_use = event.usage.server_tool_use;\n                }\n                return snapshot;\n            case 'content_block_start':\n                snapshot.content.push({ ...event.content_block });\n                return snapshot;\n            case 'content_block_delta': {\n                const snapshotContent = snapshot.content.at(event.index);\n                switch (event.delta.type) {\n                    case 'text_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                text: (snapshotContent.text || '') + event.delta.text,\n                            };\n                        }\n                        break;\n                    }\n                    case 'citations_delta': {\n                        if (snapshotContent?.type === 'text') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                citations: [...(snapshotContent.citations ?? []), event.delta.citation],\n                            };\n                        }\n                        break;\n                    }\n                    case 'input_json_delta': {\n                        if (snapshotContent && tracksToolInput(snapshotContent)) {\n                            // we need to keep track of the raw JSON string as well so that we can\n                            // re-parse it for each delta, for now we just store it as an untyped\n                            // non-enumerable property on the snapshot\n                            let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || '';\n                            jsonBuf += event.delta.partial_json;\n                            const newContent = { ...snapshotContent };\n                            Object.defineProperty(newContent, JSON_BUF_PROPERTY, {\n                                value: jsonBuf,\n                                enumerable: false,\n                                writable: true,\n                            });\n                            if (jsonBuf) {\n                                newContent.input = (0,_vendor_partial_json_parser_parser_mjs__WEBPACK_IMPORTED_MODULE_4__.partialParse)(jsonBuf);\n                            }\n                            snapshot.content[event.index] = newContent;\n                        }\n                        break;\n                    }\n                    case 'thinking_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                thinking: snapshotContent.thinking + event.delta.thinking,\n                            };\n                        }\n                        break;\n                    }\n                    case 'signature_delta': {\n                        if (snapshotContent?.type === 'thinking') {\n                            snapshot.content[event.index] = {\n                                ...snapshotContent,\n                                signature: event.delta.signature,\n                            };\n                        }\n                        break;\n                    }\n                    default:\n                        checkNever(event.delta);\n                }\n                return snapshot;\n            }\n            case 'content_block_stop':\n                return snapshot;\n        }\n    }, Symbol.asyncIterator)]() {\n        const pushQueue = [];\n        const readQueue = [];\n        let done = false;\n        this.on('streamEvent', (event) => {\n            const reader = readQueue.shift();\n            if (reader) {\n                reader.resolve(event);\n            }\n            else {\n                pushQueue.push(event);\n            }\n        });\n        this.on('end', () => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.resolve(undefined);\n            }\n            readQueue.length = 0;\n        });\n        this.on('abort', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        this.on('error', (err) => {\n            done = true;\n            for (const reader of readQueue) {\n                reader.reject(err);\n            }\n            readQueue.length = 0;\n        });\n        return {\n            next: async () => {\n                if (!pushQueue.length) {\n                    if (done) {\n                        return { value: undefined, done: true };\n                    }\n                    return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk) => (chunk ? { value: chunk, done: false } : { value: undefined, done: true }));\n                }\n                const chunk = pushQueue.shift();\n                return { value: chunk, done: false };\n            },\n            return: async () => {\n                this.abort();\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    toReadableStream() {\n        const stream = new _streaming_mjs__WEBPACK_IMPORTED_MODULE_3__.Stream(this[Symbol.asyncIterator].bind(this), this.controller);\n        return stream.toReadableStream();\n    }\n}\n// used to ensure exhaustive case matching without throwing a runtime error\nfunction checkNever(x) { }\n//# sourceMappingURL=MessageStream.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2xpYi9NZXNzYWdlU3RyZWFtLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUN1RjtBQUNqQztBQUNXO0FBQ3ZCO0FBQytCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxpRUFBaUU7QUFDakU7QUFDQSw0REFBNEQ7QUFDNUQsMkRBQTJEO0FBQzNELDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQXNCO0FBQ2xDLGdCQUFnQixrRUFBWTtBQUM1Qiw0QkFBNEIseURBQWlCO0FBQzdDO0FBQ0EsaUNBQWlDLHlEQUFpQjtBQUNsRCxnQkFBZ0IsMkVBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQ0FBaUMsc0RBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNEQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHNEQUFjO0FBQ3pELFNBQVM7QUFDVCxRQUFRLDJFQUFzQjtBQUM5QixZQUFZLDJFQUFzQjtBQUNsQyxZQUFZLDJFQUFzQjtBQUNsQyxTQUFTO0FBQ1QsUUFBUSwyRUFBc0I7QUFDOUIsWUFBWSwyRUFBc0I7QUFDbEMsWUFBWSwyRUFBc0I7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBc0IsNERBQTREO0FBQzFGLFFBQVEsMkVBQXNCLHNEQUFzRDtBQUNwRjtBQUNBO0FBQ0EsZUFBZSwyRUFBc0I7QUFDckM7QUFDQTtBQUNBLGVBQWUsMkVBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyRUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCx5QkFBeUIsSUFBSSx1QkFBdUIsOERBQThEO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRSwyRUFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkVBQXNCO0FBQ2xDLG9CQUFvQix5QkFBeUI7QUFDN0MsMEJBQTBCLHlCQUF5QixJQUFJLDRDQUE0QztBQUNuRztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQXNCO0FBQ3RDO0FBQ0E7QUFDQSwwQkFBMEIseURBQWlCO0FBQzNDO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJFQUFzQjtBQUM5QixRQUFRLDJFQUFzQjtBQUM5QixRQUFRLDJFQUFzQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJFQUFzQjtBQUNyQztBQUNBO0FBQ0EsZUFBZSwyRUFBc0I7QUFDckM7QUFDQTtBQUNBLGVBQWUsMkVBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyRUFBc0IsaURBQWlELDJFQUFzQjtBQUN2SCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwyRUFBc0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQXNCLGlEQUFpRCwyRUFBc0I7QUFDdkgseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVEsMkVBQXNCO0FBQzlCLGNBQWMsMkVBQXNCO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLDJFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkVBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQztBQUNBO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEMsWUFBWSwyRUFBc0I7QUFDbEM7QUFDQSwwQkFBMEIsMkVBQXNCO0FBQ2hEO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEMsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJFQUFzQjtBQUN2QztBQUNBO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEMsWUFBWSwyRUFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJFQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEMsWUFBWSwyRUFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJFQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQztBQUNBLDJCQUEyQixrREFBTTtBQUNqQztBQUNBLGdCQUFnQiwyRUFBc0I7QUFDdEM7QUFDQTtBQUNBLDBCQUEwQix5REFBaUI7QUFDM0M7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixzREFBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsMkVBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkVBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHNCQUFzQixzREFBYztBQUNwQztBQUNBLHlCQUF5QiwyRUFBc0I7QUFDL0M7QUFDQSxzQkFBc0Isc0RBQWM7QUFDcEM7QUFDQSxRQUFRLDJFQUFzQjtBQUM5QjtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsMkVBQXNCO0FBQzdDO0FBQ0E7QUFDQSwwQkFBMEIsc0RBQWMsZ0NBQWdDLFlBQVk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWMsZ0NBQWdDLFlBQVk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx3QkFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG1EQUFtRCxvRkFBWTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNkVBQTZFLGlCQUFpQiw4QkFBOEIsNEJBQTRCLElBQUksOEJBQThCO0FBQzFMO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9saWIvTWVzc2FnZVN0cmVhbS5tanM/YzExMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX01lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBfTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCBfTWVzc2FnZVN0cmVhbV9jb25uZWN0ZWRQcm9taXNlLCBfTWVzc2FnZVN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSwgX01lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgX01lc3NhZ2VTdHJlYW1fZW5kUHJvbWlzZSwgX01lc3NhZ2VTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UsIF9NZXNzYWdlU3RyZWFtX3JlamVjdEVuZFByb21pc2UsIF9NZXNzYWdlU3RyZWFtX2xpc3RlbmVycywgX01lc3NhZ2VTdHJlYW1fZW5kZWQsIF9NZXNzYWdlU3RyZWFtX2Vycm9yZWQsIF9NZXNzYWdlU3RyZWFtX2Fib3J0ZWQsIF9NZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIF9NZXNzYWdlU3RyZWFtX3Jlc3BvbnNlLCBfTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLCBfTWVzc2FnZVN0cmVhbV9nZXRGaW5hbE1lc3NhZ2UsIF9NZXNzYWdlU3RyZWFtX2dldEZpbmFsVGV4dCwgX01lc3NhZ2VTdHJlYW1faGFuZGxlRXJyb3IsIF9NZXNzYWdlU3RyZWFtX2JlZ2luUmVxdWVzdCwgX01lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQsIF9NZXNzYWdlU3RyZWFtX2VuZFJlcXVlc3QsIF9NZXNzYWdlU3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlO1xuaW1wb3J0IHsgX19jbGFzc1ByaXZhdGVGaWVsZEdldCwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCB9IGZyb20gXCIuLi9pbnRlcm5hbC90c2xpYi5tanNcIjtcbmltcG9ydCB7IGlzQWJvcnRFcnJvciB9IGZyb20gXCIuLi9pbnRlcm5hbC9lcnJvcnMubWpzXCI7XG5pbXBvcnQgeyBBbnRocm9waWNFcnJvciwgQVBJVXNlckFib3J0RXJyb3IgfSBmcm9tIFwiLi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tIFwiLi4vc3RyZWFtaW5nLm1qc1wiO1xuaW1wb3J0IHsgcGFydGlhbFBhcnNlIH0gZnJvbSBcIi4uL192ZW5kb3IvcGFydGlhbC1qc29uLXBhcnNlci9wYXJzZXIubWpzXCI7XG5jb25zdCBKU09OX0JVRl9QUk9QRVJUWSA9ICdfX2pzb25fYnVmJztcbmZ1bmN0aW9uIHRyYWNrc1Rvb2xJbnB1dChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQudHlwZSA9PT0gJ3Rvb2xfdXNlJyB8fCBjb250ZW50LnR5cGUgPT09ICdzZXJ2ZXJfdG9vbF91c2UnO1xufVxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VTdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMucmVjZWl2ZWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIF9NZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2Uuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9NZXNzYWdlU3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9yZWplY3RDb25uZWN0ZWRQcm9taXNlLnNldCh0aGlzLCAoKSA9PiB7IH0pO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9lbmRQcm9taXNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX01lc3NhZ2VTdHJlYW1fcmVqZWN0RW5kUHJvbWlzZS5zZXQodGhpcywgKCkgPT4geyB9KTtcbiAgICAgICAgX01lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLnNldCh0aGlzLCB7fSk7XG4gICAgICAgIF9NZXNzYWdlU3RyZWFtX2VuZGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9NZXNzYWdlU3RyZWFtX2Vycm9yZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX01lc3NhZ2VTdHJlYW1fYWJvcnRlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIF9NZXNzYWdlU3RyZWFtX3Jlc3BvbnNlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfTWVzc2FnZVN0cmVhbV9oYW5kbGVFcnJvci5zZXQodGhpcywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2Vycm9yZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgQVBJVXNlckFib3J0RXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFQSVVzZXJBYm9ydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9hYm9ydGVkLCB0cnVlLCBcImZcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VtaXQoJ2Fib3J0JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQW50aHJvcGljRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFudGhyb3BpY0Vycm9yID0gbmV3IEFudGhyb3BpY0Vycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBhbnRocm9waWNFcnJvci5jYXVzZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIGFudGhyb3BpY0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbWl0KCdlcnJvcicsIG5ldyBBbnRocm9waWNFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UsIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fcmVzb2x2ZUNvbm5lY3RlZFByb21pc2UsIHJlc29sdmUsIFwiZlwiKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgcmVqZWN0LCBcImZcIik7XG4gICAgICAgIH0pLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fZW5kUHJvbWlzZSwgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgcmVzb2x2ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZWplY3RFbmRQcm9taXNlLCByZWplY3QsIFwiZlwiKTtcbiAgICAgICAgfSksIFwiZlwiKTtcbiAgICAgICAgLy8gRG9uJ3QgbGV0IHRoZXNlIHByb21pc2VzIGNhdXNlIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzLlxuICAgICAgICAvLyB3ZSB3aWxsIG1hbnVhbGx5IGNhdXNlIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3IgbGF0ZXJcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgaGFzbid0IHJlZ2lzdGVyZWQgYW55IGVycm9yIGxpc3RlbmVyIG9yIGNhbGxlZFxuICAgICAgICAvLyBhbnkgcHJvbWlzZS1yZXR1cm5pbmcgbWV0aG9kLlxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UsIFwiZlwiKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2VuZFByb21pc2UsIFwiZlwiKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgIH1cbiAgICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX3Jlc3BvbnNlLCBcImZcIik7XG4gICAgfVxuICAgIGdldCByZXF1ZXN0X2lkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBNZXNzYWdlU3RyZWFtYCBkYXRhLCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgYW5kIHRoZSBJRCBvZiB0aGUgcmVxdWVzdCxcbiAgICAgKiByZXR1cm5lZCB2aWUgdGhlIGByZXF1ZXN0LWlkYCBoZWFkZXIgd2hpY2ggaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgcmVxdWVzdHMgYW5kIHJlc3BvcnRpbmdcbiAgICAgKiBpc3N1ZXMgdG8gQW50aHJvcGljLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgYEFQSVByb21pc2Uud2l0aFJlc3BvbnNlKClgIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcmFpc2UgYW4gZXJyb3IgaWYgeW91IGNyZWF0ZWQgdGhlIHN0cmVhbSB1c2luZyBgTWVzc2FnZVN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW1gXG4gICAgICogYXMgbm8gYFJlc3BvbnNlYCBpcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgYXN5bmMgd2l0aFJlc3BvbnNlKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIGEgYFJlc3BvbnNlYCBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdGhpcyxcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgcmVxdWVzdF9pZDogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3JlcXVlc3QtaWQnKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZW5kZWQgZm9yIHVzZSBvbiB0aGUgZnJvbnRlbmQsIGNvbnN1bWluZyBhIHN0cmVhbSBwcm9kdWNlZCB3aXRoXG4gICAgICogYC50b1JlYWRhYmxlU3RyZWFtKClgIG9uIHRoZSBiYWNrZW5kLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IG1lc3NhZ2VzIHNlbnQgdG8gdGhlIG1vZGVsIGRvIG5vdCBhcHBlYXIgaW4gYC5vbignbWVzc2FnZScpYFxuICAgICAqIGluIHRoaXMgY29udGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgTWVzc2FnZVN0cmVhbSgpO1xuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2Zyb21SZWFkYWJsZVN0cmVhbShzdHJlYW0pKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZU1lc3NhZ2UobWVzc2FnZXMsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBuZXcgTWVzc2FnZVN0cmVhbSgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyYW1zLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBydW5uZXIuX2FkZE1lc3NhZ2VQYXJhbShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBydW5uZXIuX3J1bigoKSA9PiBydW5uZXIuX2NyZWF0ZU1lc3NhZ2UobWVzc2FnZXMsIHsgLi4ucGFyYW1zLCBzdHJlYW06IHRydWUgfSwgeyAuLi5vcHRpb25zLCBoZWFkZXJzOiB7IC4uLm9wdGlvbnM/LmhlYWRlcnMsICdYLVN0YWlubGVzcy1IZWxwZXItTWV0aG9kJzogJ3N0cmVhbScgfSB9KSk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgfVxuICAgIF9ydW4oZXhlY3V0b3IpIHtcbiAgICAgICAgZXhlY3V0b3IoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXRGaW5hbCgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnZW5kJyk7XG4gICAgICAgIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1faGFuZGxlRXJyb3IsIFwiZlwiKSk7XG4gICAgfVxuICAgIF9hZGRNZXNzYWdlUGFyYW0obWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgfVxuICAgIF9hZGRNZXNzYWdlKG1lc3NhZ2UsIGVtaXQgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgdGhpcy5fZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9jcmVhdGVNZXNzYWdlKG1lc3NhZ2VzLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucz8uc2lnbmFsO1xuICAgICAgICBsZXQgYWJvcnRIYW5kbGVyO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICBhYm9ydEhhbmRsZXIgPSB0aGlzLmNvbnRyb2xsZXIuYWJvcnQuYmluZCh0aGlzLmNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfTWVzc2FnZVN0cmVhbV9iZWdpblJlcXVlc3QpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3BvbnNlLCBkYXRhOiBzdHJlYW0gfSA9IGF3YWl0IG1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgLmNyZWF0ZSh7IC4uLnBhcmFtcywgc3RyZWFtOiB0cnVlIH0sIHsgLi4ub3B0aW9ucywgc2lnbmFsOiB0aGlzLmNvbnRyb2xsZXIuc2lnbmFsIH0pXG4gICAgICAgICAgICAgICAgLndpdGhSZXNwb25zZSgpO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgZXZlbnQgb2Ygc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfTWVzc2FnZVN0cmVhbV9hZGRTdHJlYW1FdmVudCkuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtLmNvbnRyb2xsZXIuc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9NZXNzYWdlU3RyZWFtX2VuZFJlcXVlc3QpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoc2lnbmFsICYmIGFib3J0SGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nvbm5lY3RlZChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZXNwb25zZSwgcmVzcG9uc2UsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZXF1ZXN0X2lkLCByZXNwb25zZT8uaGVhZGVycy5nZXQoJ3JlcXVlc3QtaWQnKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX3Jlc29sdmVDb25uZWN0ZWRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCByZXNwb25zZSk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ2Nvbm5lY3QnKTtcbiAgICB9XG4gICAgZ2V0IGVuZGVkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9lbmRlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgZXJyb3JlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fZXJyb3JlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgYWJvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fYWJvcnRlZCwgXCJmXCIpO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIGV2ZW50LlxuICAgICAqIE5vIGNoZWNrcyBhcmUgbWFkZSB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuIE11bHRpcGxlIGNhbGxzIHBhc3NpbmdcbiAgICAgKiB0aGUgc2FtZSBjb21iaW5hdGlvbiBvZiBldmVudCBhbmQgbGlzdGVuZXIgd2lsbCByZXN1bHQgaW4gdGhlIGxpc3RlbmVyIGJlaW5nIGFkZGVkLCBhbmRcbiAgICAgKiBjYWxsZWQsIG11bHRpcGxlIHRpbWVzLlxuICAgICAqIEByZXR1cm5zIHRoaXMgTWVzc2FnZVN0cmVhbSwgc28gdGhhdCBjYWxscyBjYW4gYmUgY2hhaW5lZFxuICAgICAqL1xuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2xpc3RlbmVycywgXCJmXCIpW2V2ZW50XSB8fCAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gPSBbXSk7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHsgbGlzdGVuZXIgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBldmVudC5cbiAgICAgKiBvZmYoKSB3aWxsIHJlbW92ZSwgYXQgbW9zdCwgb25lIGluc3RhbmNlIG9mIGEgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdGVuZXIgYXJyYXkuIElmIGFueSBzaW5nbGVcbiAgICAgKiBsaXN0ZW5lciBoYXMgYmVlbiBhZGRlZCBtdWx0aXBsZSB0aW1lcyB0byB0aGUgbGlzdGVuZXIgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHRoZW5cbiAgICAgKiBvZmYoKSBtdXN0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byByZW1vdmUgZWFjaCBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJucyB0aGlzIE1lc3NhZ2VTdHJlYW0sIHNvIHRoYXQgY2FsbHMgY2FuIGJlIGNoYWluZWRcbiAgICAgKi9cbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5maW5kSW5kZXgoKGwpID0+IGwubGlzdGVuZXIgPT09IGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBvbmUtdGltZSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgdGhlIGV2ZW50LiBUaGUgbmV4dCB0aW1lIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsXG4gICAgICogdGhpcyBsaXN0ZW5lciBpcyByZW1vdmVkIGFuZCB0aGVuIGludm9rZWQuXG4gICAgICogQHJldHVybnMgdGhpcyBNZXNzYWdlU3RyZWFtLCBzbyB0aGF0IGNhbGxzIGNhbiBiZSBjaGFpbmVkXG4gICAgICovXG4gICAgb25jZShldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF0gfHwgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gW10pO1xuICAgICAgICBsaXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyLCBvbmNlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzaW1pbGFyIHRvIGAub25jZSgpYCwgYnV0IHJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdGhlIG5leHQgdGltZVxuICAgICAqIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQsIGluc3RlYWQgb2YgY2FsbGluZyBhIGxpc3RlbmVyIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRoZSBuZXh0IHRpbWUgZ2l2ZW4gZXZlbnQgaXMgdHJpZ2dlcmVkLFxuICAgICAqIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW1pdHRlZC4gIChJZiB5b3UgcmVxdWVzdCB0aGUgJ2Vycm9yJyBldmVudCxcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGVycm9yKS5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgIGNvbnN0IG1lc3NhZ2UgPSBhd2FpdCBzdHJlYW0uZW1pdHRlZCgnbWVzc2FnZScpIC8vIHJlamVjdHMgaWYgdGhlIHN0cmVhbSBlcnJvcnNcbiAgICAgKi9cbiAgICBlbWl0dGVkKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgICAgIGlmIChldmVudCAhPT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgICAgIHRoaXMub25jZShldmVudCwgcmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkb25lKCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9lbmRQcm9taXNlLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBjdXJyZW50TWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSB0aGUgZmluYWwgYXNzaXN0YW50IE1lc3NhZ2UgcmVzcG9uc2UsXG4gICAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBvY2N1cnJlZCBvciB0aGUgc3RyZWFtIGVuZGVkIHByZW1hdHVyZWx5IHdpdGhvdXQgcHJvZHVjaW5nIGEgTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhc3luYyBmaW5hbE1lc3NhZ2UoKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9uZSgpO1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfTWVzc2FnZVN0cmVhbV9nZXRGaW5hbE1lc3NhZ2UpLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHRoZSBmaW5hbCBhc3Npc3RhbnQgTWVzc2FnZSdzIHRleHQgcmVzcG9uc2UsIGNvbmNhdGVuYXRlZFxuICAgICAqIHRvZ2V0aGVyIGlmIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHRleHQgYmxvY2tzLlxuICAgICAqIFJlamVjdHMgaWYgYW4gZXJyb3Igb2NjdXJyZWQgb3IgdGhlIHN0cmVhbSBlbmRlZCBwcmVtYXR1cmVseSB3aXRob3V0IHByb2R1Y2luZyBhIE1lc3NhZ2UuXG4gICAgICovXG4gICAgYXN5bmMgZmluYWxUZXh0KCkge1xuICAgICAgICBhd2FpdCB0aGlzLmRvbmUoKTtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX01lc3NhZ2VTdHJlYW1fZ2V0RmluYWxUZXh0KS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBfZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZG9uJ3QgZW1pdCBhbnkgTWVzc2FnZVN0cmVhbUV2ZW50cyBhZnRlciBlbmRcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fZW5kZWQsIFwiZlwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKGV2ZW50ID09PSAnZW5kJykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9lbmRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZXNvbHZlRW5kUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9saXN0ZW5lcnMsIFwiZlwiKVtldmVudF07XG4gICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzLCBcImZcIilbZXZlbnRdID0gbGlzdGVuZXJzLmZpbHRlcigobCkgPT4gIWwub25jZSk7XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoeyBsaXN0ZW5lciB9KSA9PiBsaXN0ZW5lciguLi5hcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50ID09PSAnYWJvcnQnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY2F0Y2hpbmdQcm9taXNlQ3JlYXRlZCwgXCJmXCIpICYmICFsaXN0ZW5lcnM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZWplY3RFbmRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IF9lbWl0KCdlcnJvcicsIGVycm9yKSBzaG91bGQgb25seSBiZSBjYWxsZWQgZnJvbSAjaGFuZGxlRXJyb3IoKS5cbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9jYXRjaGluZ1Byb21pc2VDcmVhdGVkLCBcImZcIikgJiYgIWxpc3RlbmVycz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uIGlmIHRoZSB1c2VyIGhhc24ndCByZWdpc3RlcmVkIGFueSBlcnJvciBoYW5kbGVycy5cbiAgICAgICAgICAgICAgICAvLyBJZiB5b3UgYXJlIHNlZWluZyBzdGFjayB0cmFjZXMgaGVyZSwgbWFrZSBzdXJlIHRvIGhhbmRsZSBlcnJvcnMgdmlhIGVpdGhlcjpcbiAgICAgICAgICAgICAgICAvLyAtIHJ1bm5lci5vbignZXJyb3InLCAoKSA9PiAuLi4pXG4gICAgICAgICAgICAgICAgLy8gLSBhd2FpdCBydW5uZXIuZG9uZSgpXG4gICAgICAgICAgICAgICAgLy8gLSBhd2FpdCBydW5uZXIuZmluYWwuLi4oKVxuICAgICAgICAgICAgICAgIC8vIC0gZXRjLlxuICAgICAgICAgICAgICAgIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fcmVqZWN0Q29ubmVjdGVkUHJvbWlzZSwgXCJmXCIpLmNhbGwodGhpcywgZXJyb3IpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9yZWplY3RFbmRQcm9taXNlLCBcImZcIikuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW1pdEZpbmFsKCkge1xuICAgICAgICBjb25zdCBmaW5hbE1lc3NhZ2UgPSB0aGlzLnJlY2VpdmVkTWVzc2FnZXMuYXQoLTEpO1xuICAgICAgICBpZiAoZmluYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KCdmaW5hbE1lc3NhZ2UnLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9NZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSkuY2FsbCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2Zyb21SZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zPy5zaWduYWw7XG4gICAgICAgIGxldCBhYm9ydEhhbmRsZXI7XG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGFib3J0SGFuZGxlciA9IHRoaXMuY29udHJvbGxlci5hYm9ydC5iaW5kKHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9NZXNzYWdlU3RyZWFtX2luc3RhbmNlcywgXCJtXCIsIF9NZXNzYWdlU3RyZWFtX2JlZ2luUmVxdWVzdCkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZChudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IFN0cmVhbS5mcm9tUmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0sIHRoaXMuY29udHJvbGxlcik7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1faW5zdGFuY2VzLCBcIm1cIiwgX01lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQpLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0cmVhbS5jb250cm9sbGVyLnNpZ25hbD8uYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfTWVzc2FnZVN0cmVhbV9lbmRSZXF1ZXN0KS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbCAmJiBhYm9ydEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFsoX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCA9IG5ldyBXZWFrTWFwKCksIF9NZXNzYWdlU3RyZWFtX2Nvbm5lY3RlZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9yZXNvbHZlQ29ubmVjdGVkUHJvbWlzZSA9IG5ldyBXZWFrTWFwKCksIF9NZXNzYWdlU3RyZWFtX3JlamVjdENvbm5lY3RlZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9lbmRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX01lc3NhZ2VTdHJlYW1fcmVzb2x2ZUVuZFByb21pc2UgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9yZWplY3RFbmRQcm9taXNlID0gbmV3IFdlYWtNYXAoKSwgX01lc3NhZ2VTdHJlYW1fbGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSwgX01lc3NhZ2VTdHJlYW1fZW5kZWQgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9lcnJvcmVkID0gbmV3IFdlYWtNYXAoKSwgX01lc3NhZ2VTdHJlYW1fYWJvcnRlZCA9IG5ldyBXZWFrTWFwKCksIF9NZXNzYWdlU3RyZWFtX2NhdGNoaW5nUHJvbWlzZUNyZWF0ZWQgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9yZXNwb25zZSA9IG5ldyBXZWFrTWFwKCksIF9NZXNzYWdlU3RyZWFtX3JlcXVlc3RfaWQgPSBuZXcgV2Vha01hcCgpLCBfTWVzc2FnZVN0cmVhbV9oYW5kbGVFcnJvciA9IG5ldyBXZWFrTWFwKCksIF9NZXNzYWdlU3RyZWFtX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9NZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIF9NZXNzYWdlU3RyZWFtX2dldEZpbmFsTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcignc3RyZWFtIGVuZGVkIHdpdGhvdXQgcHJvZHVjaW5nIGEgTWVzc2FnZSB3aXRoIHJvbGU9YXNzaXN0YW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWRNZXNzYWdlcy5hdCgtMSk7XG4gICAgfSwgX01lc3NhZ2VTdHJlYW1fZ2V0RmluYWxUZXh0ID0gZnVuY3Rpb24gX01lc3NhZ2VTdHJlYW1fZ2V0RmluYWxUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNlaXZlZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBNZXNzYWdlIHdpdGggcm9sZT1hc3Npc3RhbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0QmxvY2tzID0gdGhpcy5yZWNlaXZlZE1lc3NhZ2VzXG4gICAgICAgICAgICAuYXQoLTEpXG4gICAgICAgICAgICAuY29udGVudC5maWx0ZXIoKGJsb2NrKSA9PiBibG9jay50eXBlID09PSAndGV4dCcpXG4gICAgICAgICAgICAubWFwKChibG9jaykgPT4gYmxvY2sudGV4dCk7XG4gICAgICAgIGlmICh0ZXh0QmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKCdzdHJlYW0gZW5kZWQgd2l0aG91dCBwcm9kdWNpbmcgYSBjb250ZW50IGJsb2NrIHdpdGggdHlwZT10ZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRCbG9ja3Muam9pbignICcpO1xuICAgIH0sIF9NZXNzYWdlU3RyZWFtX2JlZ2luUmVxdWVzdCA9IGZ1bmN0aW9uIF9NZXNzYWdlU3RyZWFtX2JlZ2luUmVxdWVzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgfSwgX01lc3NhZ2VTdHJlYW1fYWRkU3RyZWFtRXZlbnQgPSBmdW5jdGlvbiBfTWVzc2FnZVN0cmVhbV9hZGRTdHJlYW1FdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbWVzc2FnZVNuYXBzaG90ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9pbnN0YW5jZXMsIFwibVwiLCBfTWVzc2FnZVN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSkuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIHRoaXMuX2VtaXQoJ3N0cmVhbUV2ZW50JywgZXZlbnQsIG1lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19kZWx0YSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZVNuYXBzaG90LmNvbnRlbnQuYXQoLTEpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0X2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgndGV4dCcsIGV2ZW50LmRlbHRhLnRleHQsIGNvbnRlbnQudGV4dCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdjaXRhdGlvbnNfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbWl0KCdjaXRhdGlvbicsIGV2ZW50LmRlbHRhLmNpdGF0aW9uLCBjb250ZW50LmNpdGF0aW9ucyA/PyBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dF9qc29uX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrc1Rvb2xJbnB1dChjb250ZW50KSAmJiBjb250ZW50LmlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdCgnaW5wdXRKc29uJywgZXZlbnQuZGVsdGEucGFydGlhbF9qc29uLCBjb250ZW50LmlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RoaW5raW5nX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RoaW5raW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3RoaW5raW5nJywgZXZlbnQuZGVsdGEudGhpbmtpbmcsIGNvbnRlbnQudGhpbmtpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnbmF0dXJlX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gJ3RoaW5raW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ3NpZ25hdHVyZScsIGNvbnRlbnQuc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja05ldmVyKGV2ZW50LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX3N0b3AnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZVBhcmFtKG1lc3NhZ2VTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVzc2FnZShtZXNzYWdlU25hcHNob3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdG9wJzoge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXQoJ2NvbnRlbnRCbG9jaycsIG1lc3NhZ2VTbmFwc2hvdC5jb250ZW50LmF0KC0xKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtZXNzYWdlX3N0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgbWVzc2FnZVNuYXBzaG90LCBcImZcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb250ZW50X2Jsb2NrX3N0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2VfZGVsdGEnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSwgX01lc3NhZ2VTdHJlYW1fZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIF9NZXNzYWdlU3RyZWFtX2VuZFJlcXVlc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYHN0cmVhbSBoYXMgZW5kZWQsIHRoaXMgc2hvdWxkbid0IGhhcHBlbmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfTWVzc2FnZVN0cmVhbV9jdXJyZW50TWVzc2FnZVNuYXBzaG90LCBcImZcIik7XG4gICAgICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgcmVxdWVzdCBlbmRlZCB3aXRob3V0IHNlbmRpbmcgYW55IGNodW5rc2ApO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICB9LCBfTWVzc2FnZVN0cmVhbV9hY2N1bXVsYXRlTWVzc2FnZSA9IGZ1bmN0aW9uIF9NZXNzYWdlU3RyZWFtX2FjY3VtdWxhdGVNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGxldCBzbmFwc2hvdCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX01lc3NhZ2VTdHJlYW1fY3VycmVudE1lc3NhZ2VTbmFwc2hvdCwgXCJmXCIpO1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21lc3NhZ2Vfc3RhcnQnKSB7XG4gICAgICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoYFVuZXhwZWN0ZWQgZXZlbnQgb3JkZXIsIGdvdCAke2V2ZW50LnR5cGV9IGJlZm9yZSByZWNlaXZpbmcgXCJtZXNzYWdlX3N0b3BcImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50Lm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKGBVbmV4cGVjdGVkIGV2ZW50IG9yZGVyLCBnb3QgJHtldmVudC50eXBlfSBiZWZvcmUgXCJtZXNzYWdlX3N0YXJ0XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ21lc3NhZ2Vfc3RvcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgY2FzZSAnbWVzc2FnZV9kZWx0YSc6XG4gICAgICAgICAgICAgICAgc25hcHNob3Quc3RvcF9yZWFzb24gPSBldmVudC5kZWx0YS5zdG9wX3JlYXNvbjtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC5zdG9wX3NlcXVlbmNlID0gZXZlbnQuZGVsdGEuc3RvcF9zZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICBzbmFwc2hvdC51c2FnZS5vdXRwdXRfdG9rZW5zID0gZXZlbnQudXNhZ2Uub3V0cHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgb3RoZXIgdXNhZ2UgZmllbGRzIGlmIHRoZXkgZXhpc3QgaW4gdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmlucHV0X3Rva2VucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLmlucHV0X3Rva2VucyA9IGV2ZW50LnVzYWdlLmlucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucyA9IGV2ZW50LnVzYWdlLmNhY2hlX2NyZWF0aW9uX2lucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLmNhY2hlX3JlYWRfaW5wdXRfdG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc25hcHNob3QudXNhZ2UuY2FjaGVfcmVhZF9pbnB1dF90b2tlbnMgPSBldmVudC51c2FnZS5jYWNoZV9yZWFkX2lucHV0X3Rva2VucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnVzYWdlLnNlcnZlcl90b29sX3VzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LnVzYWdlLnNlcnZlcl90b29sX3VzZSA9IGV2ZW50LnVzYWdlLnNlcnZlcl90b29sX3VzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdGFydCc6XG4gICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudC5wdXNoKHsgLi4uZXZlbnQuY29udGVudF9ibG9jayB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgICAgICBjYXNlICdjb250ZW50X2Jsb2NrX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90Q29udGVudCA9IHNuYXBzaG90LmNvbnRlbnQuYXQoZXZlbnQuaW5kZXgpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuZGVsdGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0X2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90Q29udGVudD8udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogKHNuYXBzaG90Q29udGVudC50ZXh0IHx8ICcnKSArIGV2ZW50LmRlbHRhLnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NpdGF0aW9uc19kZWx0YSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdENvbnRlbnQ/LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBzaG90LmNvbnRlbnRbZXZlbnQuaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5zbmFwc2hvdENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpdGF0aW9uczogWy4uLihzbmFwc2hvdENvbnRlbnQuY2l0YXRpb25zID8/IFtdKSwgZXZlbnQuZGVsdGEuY2l0YXRpb25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbnB1dF9qc29uX2RlbHRhJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNuYXBzaG90Q29udGVudCAmJiB0cmFja3NUb29sSW5wdXQoc25hcHNob3RDb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcmF3IEpTT04gc3RyaW5nIGFzIHdlbGwgc28gdGhhdCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS1wYXJzZSBpdCBmb3IgZWFjaCBkZWx0YSwgZm9yIG5vdyB3ZSBqdXN0IHN0b3JlIGl0IGFzIGFuIHVudHlwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBub24tZW51bWVyYWJsZSBwcm9wZXJ0eSBvbiB0aGUgc25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQganNvbkJ1ZiA9IHNuYXBzaG90Q29udGVudFtKU09OX0JVRl9QUk9QRVJUWV0gfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbkJ1ZiArPSBldmVudC5kZWx0YS5wYXJ0aWFsX2pzb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGVudCA9IHsgLi4uc25hcHNob3RDb250ZW50IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld0NvbnRlbnQsIEpTT05fQlVGX1BST1BFUlRZLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqc29uQnVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25CdWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudC5pbnB1dCA9IHBhcnRpYWxQYXJzZShqc29uQnVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSBuZXdDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGhpbmtpbmdfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09PSAndGhpbmtpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpbmtpbmc6IHNuYXBzaG90Q29udGVudC50aGlua2luZyArIGV2ZW50LmRlbHRhLnRoaW5raW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduYXR1cmVfZGVsdGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RDb250ZW50Py50eXBlID09PSAndGhpbmtpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc25hcHNob3QuY29udGVudFtldmVudC5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnNuYXBzaG90Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBldmVudC5kZWx0YS5zaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja05ldmVyKGV2ZW50LmRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXBzaG90O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29udGVudF9ibG9ja19zdG9wJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgIH1cbiAgICB9LCBTeW1ib2wuYXN5bmNJdGVyYXRvcildKCkge1xuICAgICAgICBjb25zdCBwdXNoUXVldWUgPSBbXTtcbiAgICAgICAgY29uc3QgcmVhZFF1ZXVlID0gW107XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMub24oJ3N0cmVhbUV2ZW50JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZWFkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVzb2x2ZShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoUXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHJlYWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Fib3J0JywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiByZWFkUXVldWUpIHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkUXVldWUubGVuZ3RoID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0OiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwdXNoUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHJlYWRRdWV1ZS5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pKS50aGVuKChjaHVuaykgPT4gKGNodW5rID8geyB2YWx1ZTogY2h1bmssIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHB1c2hRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXR1cm46IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9SZWFkYWJsZVN0cmVhbSgpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSh0aGlzW1N5bWJvbC5hc3luY0l0ZXJhdG9yXS5iaW5kKHRoaXMpLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gc3RyZWFtLnRvUmVhZGFibGVTdHJlYW0oKTtcbiAgICB9XG59XG4vLyB1c2VkIHRvIGVuc3VyZSBleGhhdXN0aXZlIGNhc2UgbWF0Y2hpbmcgd2l0aG91dCB0aHJvd2luZyBhIHJ1bnRpbWUgZXJyb3JcbmZ1bmN0aW9uIGNoZWNrTmV2ZXIoeCkgeyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXNzYWdlU3RyZWFtLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs":
/*!*************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BetaToolRunner: () => (/* binding */ BetaToolRunner)\n/* harmony export */ });\n/* harmony import */ var _internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal/tslib.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/tslib.mjs\");\n/* harmony import */ var _core_error_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/error.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\nvar _BetaToolRunner_instances, _BetaToolRunner_consumed, _BetaToolRunner_mutated, _BetaToolRunner_state, _BetaToolRunner_options, _BetaToolRunner_message, _BetaToolRunner_toolResponse, _BetaToolRunner_completion, _BetaToolRunner_iterationCount, _BetaToolRunner_generateToolResponse;\n\n\n\n/**\n * Just Promise.withResolvers(), which is not available in all environments.\n */\nfunction promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n}\n/**\n * A ToolRunner handles the automatic conversation loop between the assistant and tools.\n *\n * A ToolRunner is an async iterable that yields either BetaMessage or BetaMessageStream objects\n * depending on the streaming configuration.\n */\nclass BetaToolRunner {\n    constructor(client, params, options) {\n        _BetaToolRunner_instances.add(this);\n        this.client = client;\n        /** Whether the async iterator has been consumed */\n        _BetaToolRunner_consumed.set(this, false);\n        /** Whether parameters have been mutated since the last API call */\n        _BetaToolRunner_mutated.set(this, false);\n        /** Current state containing the request parameters */\n        _BetaToolRunner_state.set(this, void 0);\n        _BetaToolRunner_options.set(this, void 0);\n        /** Promise for the last message received from the assistant */\n        _BetaToolRunner_message.set(this, void 0);\n        /** Cached tool response to avoid redundant executions */\n        _BetaToolRunner_toolResponse.set(this, void 0);\n        /** Promise resolvers for waiting on completion */\n        _BetaToolRunner_completion.set(this, void 0);\n        /** Number of iterations (API requests) made so far */\n        _BetaToolRunner_iterationCount.set(this, 0);\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_state, {\n            params: {\n                // You can't clone the entire params since there are functions as handlers.\n                // You also don't really need to clone params.messages, but it probably will prevent a foot gun\n                // somewhere.\n                ...params,\n                messages: structuredClone(params.messages),\n            },\n        }, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_options, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([{ 'x-stainless-helper': 'BetaToolRunner' }, options?.headers]),\n        }, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_completion, promiseWithResolvers(), \"f\");\n    }\n    async *[(_BetaToolRunner_consumed = new WeakMap(), _BetaToolRunner_mutated = new WeakMap(), _BetaToolRunner_state = new WeakMap(), _BetaToolRunner_options = new WeakMap(), _BetaToolRunner_message = new WeakMap(), _BetaToolRunner_toolResponse = new WeakMap(), _BetaToolRunner_completion = new WeakMap(), _BetaToolRunner_iterationCount = new WeakMap(), _BetaToolRunner_instances = new WeakSet(), Symbol.asyncIterator)]() {\n        var _a;\n        if ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_consumed, \"f\")) {\n            throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError('Cannot iterate over a consumed stream');\n        }\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_consumed, true, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_mutated, true, \"f\");\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_toolResponse, undefined, \"f\");\n        try {\n            while (true) {\n                let stream;\n                try {\n                    if ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params.max_iterations &&\n                        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_iterationCount, \"f\") >= (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params.max_iterations) {\n                        break;\n                    }\n                    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_mutated, false, \"f\");\n                    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_message, undefined, \"f\");\n                    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_toolResponse, undefined, \"f\");\n                    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_iterationCount, (_a = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_iterationCount, \"f\"), _a++, _a), \"f\");\n                    const { max_iterations, ...params } = (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params;\n                    if (params.stream) {\n                        stream = this.client.beta.messages.stream({ ...params }, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_options, \"f\"));\n                        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_message, stream.finalMessage(), \"f\");\n                        yield stream;\n                    }\n                    else {\n                        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_message, this.client.beta.messages.create({ ...params, stream: false }, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_options, \"f\")), \"f\");\n                        yield (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_message, \"f\");\n                    }\n                    if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_mutated, \"f\")) {\n                        const { role, content } = await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_message, \"f\");\n                        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params.messages.push({ role, content });\n                    }\n                    const toolMessage = await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_instances, \"m\", _BetaToolRunner_generateToolResponse).call(this, (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params.messages.at(-1));\n                    if (toolMessage) {\n                        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params.messages.push(toolMessage);\n                    }\n                    if (!toolMessage && !(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_mutated, \"f\")) {\n                        break;\n                    }\n                }\n                finally {\n                    if (stream) {\n                        stream.abort();\n                    }\n                }\n            }\n            if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_message, \"f\")) {\n                throw new _core_error_mjs__WEBPACK_IMPORTED_MODULE_1__.AnthropicError('ToolRunner concluded without a message from the server');\n            }\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_completion, \"f\").resolve(await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_message, \"f\"));\n        }\n        catch (error) {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_consumed, false, \"f\");\n            // Silence unhandled promise errors\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_completion, \"f\").promise.catch(() => { });\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_completion, \"f\").reject(error);\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_completion, promiseWithResolvers(), \"f\");\n            throw error;\n        }\n    }\n    setMessagesParams(paramsOrMutator) {\n        if (typeof paramsOrMutator === 'function') {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params = paramsOrMutator((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params);\n        }\n        else {\n            (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params = paramsOrMutator;\n        }\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_mutated, true, \"f\");\n        // Invalidate cached tool response since parameters changed\n        (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_toolResponse, undefined, \"f\");\n    }\n    /**\n     * Get the tool response for the last message from the assistant.\n     * Avoids redundant tool executions by caching results.\n     *\n     * @returns A promise that resolves to a BetaMessageParam containing tool results, or null if no tools need to be executed\n     *\n     * @example\n     * const toolResponse = await runner.generateToolResponse();\n     * if (toolResponse) {\n     *   console.log('Tool results:', toolResponse.content);\n     * }\n     */\n    async generateToolResponse() {\n        const message = (await (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_message, \"f\")) ?? this.params.messages.at(-1);\n        if (!message) {\n            return null;\n        }\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_instances, \"m\", _BetaToolRunner_generateToolResponse).call(this, message);\n    }\n    /**\n     * Wait for the async iterator to complete. This works even if the async iterator hasn't yet started, and\n     * will wait for an instance to start and go to completion.\n     *\n     * @returns A promise that resolves to the final BetaMessage when the iterator completes\n     *\n     * @example\n     * // Start consuming the iterator\n     * for await (const message of runner) {\n     *   console.log('Message:', message.content);\n     * }\n     *\n     * // Meanwhile, wait for completion from another part of the code\n     * const finalMessage = await runner.done();\n     * console.log('Final response:', finalMessage.content);\n     */\n    done() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_completion, \"f\").promise;\n    }\n    /**\n     * Returns a promise indicating that the stream is done. Unlike .done(), this will eagerly read the stream:\n     * * If the iterator has not been consumed, consume the entire iterator and return the final message from the\n     * assistant.\n     * * If the iterator has been consumed, waits for it to complete and returns the final message.\n     *\n     * @returns A promise that resolves to the final BetaMessage from the conversation\n     * @throws {AnthropicError} If no messages were processed during the conversation\n     *\n     * @example\n     * const finalMessage = await runner.runUntilDone();\n     * console.log('Final response:', finalMessage.content);\n     */\n    async runUntilDone() {\n        // If not yet consumed, start consuming and wait for completion\n        if (!(0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_consumed, \"f\")) {\n            for await (const _ of this) {\n                // Iterator naturally populates this.#message\n            }\n        }\n        // If consumed but not completed, wait for completion\n        return this.done();\n    }\n    /**\n     * Get the current parameters being used by the ToolRunner.\n     *\n     * @returns A readonly view of the current ToolRunnerParams\n     *\n     * @example\n     * const currentParams = runner.params;\n     * console.log('Current model:', currentParams.model);\n     * console.log('Message count:', currentParams.messages.length);\n     */\n    get params() {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params;\n    }\n    /**\n     * Add one or more messages to the conversation history.\n     *\n     * @param messages - One or more BetaMessageParam objects to add to the conversation\n     *\n     * @example\n     * runner.pushMessages(\n     *   { role: 'user', content: 'Also, what about the weather in NYC?' }\n     * );\n     *\n     * @example\n     * // Adding multiple messages\n     * runner.pushMessages(\n     *   { role: 'user', content: 'What about NYC?' },\n     *   { role: 'user', content: 'And Boston?' }\n     * );\n     */\n    pushMessages(...messages) {\n        this.setMessagesParams((params) => ({\n            ...params,\n            messages: [...params.messages, ...messages],\n        }));\n    }\n    /**\n     * Makes the ToolRunner directly awaitable, equivalent to calling .runUntilDone()\n     * This allows using `await runner` instead of `await runner.runUntilDone()`\n     */\n    then(onfulfilled, onrejected) {\n        return this.runUntilDone().then(onfulfilled, onrejected);\n    }\n}\n_BetaToolRunner_generateToolResponse = async function _BetaToolRunner_generateToolResponse(lastMessage) {\n    if ((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_toolResponse, \"f\") !== undefined) {\n        return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_toolResponse, \"f\");\n    }\n    (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldSet)(this, _BetaToolRunner_toolResponse, generateToolResponse((0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_state, \"f\").params, lastMessage), \"f\");\n    return (0,_internal_tslib_mjs__WEBPACK_IMPORTED_MODULE_0__.__classPrivateFieldGet)(this, _BetaToolRunner_toolResponse, \"f\");\n};\nasync function generateToolResponse(params, lastMessage = params.messages.at(-1)) {\n    // Only process if the last message is from the assistant and has tool use blocks\n    if (!lastMessage ||\n        lastMessage.role !== 'assistant' ||\n        !lastMessage.content ||\n        typeof lastMessage.content === 'string') {\n        return null;\n    }\n    const toolUseBlocks = lastMessage.content.filter((content) => content.type === 'tool_use');\n    if (toolUseBlocks.length === 0) {\n        return null;\n    }\n    const toolResults = await Promise.all(toolUseBlocks.map(async (toolUse) => {\n        const tool = params.tools.find((t) => t.name === toolUse.name);\n        if (!tool || !('run' in tool)) {\n            return {\n                type: 'tool_result',\n                tool_use_id: toolUse.id,\n                content: `Error: Tool '${toolUse.name}' not found`,\n                is_error: true,\n            };\n        }\n        try {\n            let input = toolUse.input;\n            if ('parse' in tool && tool.parse) {\n                input = tool.parse(input);\n            }\n            const result = await tool.run(input);\n            return {\n                type: 'tool_result',\n                tool_use_id: toolUse.id,\n                content: result,\n            };\n        }\n        catch (error) {\n            return {\n                type: 'tool_result',\n                tool_use_id: toolUse.id,\n                content: `Error: ${error instanceof Error ? error.message : String(error)}`,\n                is_error: true,\n            };\n        }\n    }));\n    return {\n        role: 'user',\n        content: toolResults,\n    };\n}\n//# sourceMappingURL=BetaToolRunner.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL2xpYi90b29scy9CZXRhVG9vbFJ1bm5lci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQzBGO0FBQ3BDO0FBQ0k7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRLDJFQUFzQjtBQUM5QjtBQUNBLHFCQUFxQixtRUFBWSxJQUFJLHdDQUF3QztBQUM3RSxTQUFTO0FBQ1QsUUFBUSwyRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyRUFBc0I7QUFDbEMsc0JBQXNCLDJEQUFjO0FBQ3BDO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUIsUUFBUSwyRUFBc0I7QUFDOUIsUUFBUSwyRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkVBQXNCO0FBQzlDLHdCQUF3QiwyRUFBc0IsK0NBQStDLDJFQUFzQjtBQUNuSDtBQUNBO0FBQ0Esb0JBQW9CLDJFQUFzQjtBQUMxQyxvQkFBb0IsMkVBQXNCO0FBQzFDLG9CQUFvQiwyRUFBc0I7QUFDMUMsb0JBQW9CLDJFQUFzQiw2Q0FBNkMsMkVBQXNCO0FBQzdHLDRCQUE0Qiw0QkFBNEIsRUFBRSwyRUFBc0I7QUFDaEY7QUFDQSxvRUFBb0UsV0FBVyxFQUFFLDJFQUFzQjtBQUN2Ryx3QkFBd0IsMkVBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyRUFBc0IsbUVBQW1FLDBCQUEwQixFQUFFLDJFQUFzQjtBQUNuSyw4QkFBOEIsMkVBQXNCO0FBQ3BEO0FBQ0EseUJBQXlCLDJFQUFzQjtBQUMvQyxnQ0FBZ0MsZ0JBQWdCLFFBQVEsMkVBQXNCO0FBQzlFLHdCQUF3QiwyRUFBc0IsMERBQTBELGVBQWU7QUFDdkg7QUFDQSw4Q0FBOEMsMkVBQXNCLHdGQUF3RiwyRUFBc0I7QUFDbEw7QUFDQSx3QkFBd0IsMkVBQXNCO0FBQzlDO0FBQ0EseUNBQXlDLDJFQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkVBQXNCO0FBQ3ZDLDBCQUEwQiwyREFBYztBQUN4QztBQUNBLFlBQVksMkVBQXNCLHNEQUFzRCwyRUFBc0I7QUFDOUc7QUFDQTtBQUNBLFlBQVksMkVBQXNCO0FBQ2xDO0FBQ0EsWUFBWSwyRUFBc0IsK0RBQStEO0FBQ2pHLFlBQVksMkVBQXNCO0FBQ2xDLFlBQVksMkVBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQiw0REFBNEQsMkVBQXNCO0FBQ3BIO0FBQ0E7QUFDQSxZQUFZLDJFQUFzQjtBQUNsQztBQUNBLFFBQVEsMkVBQXNCO0FBQzlCO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyRUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJFQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBDQUEwQztBQUNyRCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyRUFBc0I7QUFDOUIsZUFBZSwyRUFBc0I7QUFDckM7QUFDQSxJQUFJLDJFQUFzQiwwREFBMEQsMkVBQXNCO0FBQzFHLFdBQVcsMkVBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGFBQWE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdURBQXVEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9saWIvdG9vbHMvQmV0YVRvb2xSdW5uZXIubWpzPzMyNTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9CZXRhVG9vbFJ1bm5lcl9pbnN0YW5jZXMsIF9CZXRhVG9vbFJ1bm5lcl9jb25zdW1lZCwgX0JldGFUb29sUnVubmVyX211dGF0ZWQsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgX0JldGFUb29sUnVubmVyX29wdGlvbnMsIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLCBfQmV0YVRvb2xSdW5uZXJfdG9vbFJlc3BvbnNlLCBfQmV0YVRvb2xSdW5uZXJfY29tcGxldGlvbiwgX0JldGFUb29sUnVubmVyX2l0ZXJhdGlvbkNvdW50LCBfQmV0YVRvb2xSdW5uZXJfZ2VuZXJhdGVUb29sUmVzcG9uc2U7XG5pbXBvcnQgeyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0LCBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0IH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL3RzbGliLm1qc1wiO1xuaW1wb3J0IHsgQW50aHJvcGljRXJyb3IgfSBmcm9tIFwiLi4vLi4vY29yZS9lcnJvci5tanNcIjtcbmltcG9ydCB7IGJ1aWxkSGVhZGVycyB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9oZWFkZXJzLm1qc1wiO1xuLyoqXG4gKiBKdXN0IFByb21pc2Uud2l0aFJlc29sdmVycygpLCB3aGljaCBpcyBub3QgYXZhaWxhYmxlIGluIGFsbCBlbnZpcm9ubWVudHMuXG4gKi9cbmZ1bmN0aW9uIHByb21pc2VXaXRoUmVzb2x2ZXJzKCkge1xuICAgIGxldCByZXNvbHZlO1xuICAgIGxldCByZWplY3Q7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICByZWplY3QgPSByZWo7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzb2x2ZTogcmVzb2x2ZSwgcmVqZWN0OiByZWplY3QgfTtcbn1cbi8qKlxuICogQSBUb29sUnVubmVyIGhhbmRsZXMgdGhlIGF1dG9tYXRpYyBjb252ZXJzYXRpb24gbG9vcCBiZXR3ZWVuIHRoZSBhc3Npc3RhbnQgYW5kIHRvb2xzLlxuICpcbiAqIEEgVG9vbFJ1bm5lciBpcyBhbiBhc3luYyBpdGVyYWJsZSB0aGF0IHlpZWxkcyBlaXRoZXIgQmV0YU1lc3NhZ2Ugb3IgQmV0YU1lc3NhZ2VTdHJlYW0gb2JqZWN0c1xuICogZGVwZW5kaW5nIG9uIHRoZSBzdHJlYW1pbmcgY29uZmlndXJhdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEJldGFUb29sUnVubmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBfQmV0YVRvb2xSdW5uZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBhc3luYyBpdGVyYXRvciBoYXMgYmVlbiBjb25zdW1lZCAqL1xuICAgICAgICBfQmV0YVRvb2xSdW5uZXJfY29uc3VtZWQuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgLyoqIFdoZXRoZXIgcGFyYW1ldGVycyBoYXZlIGJlZW4gbXV0YXRlZCBzaW5jZSB0aGUgbGFzdCBBUEkgY2FsbCAqL1xuICAgICAgICBfQmV0YVRvb2xSdW5uZXJfbXV0YXRlZC5zZXQodGhpcywgZmFsc2UpO1xuICAgICAgICAvKiogQ3VycmVudCBzdGF0ZSBjb250YWluaW5nIHRoZSByZXF1ZXN0IHBhcmFtZXRlcnMgKi9cbiAgICAgICAgX0JldGFUb29sUnVubmVyX3N0YXRlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQmV0YVRvb2xSdW5uZXJfb3B0aW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLyoqIFByb21pc2UgZm9yIHRoZSBsYXN0IG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSB0aGUgYXNzaXN0YW50ICovXG4gICAgICAgIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvKiogQ2FjaGVkIHRvb2wgcmVzcG9uc2UgdG8gYXZvaWQgcmVkdW5kYW50IGV4ZWN1dGlvbnMgKi9cbiAgICAgICAgX0JldGFUb29sUnVubmVyX3Rvb2xSZXNwb25zZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgLyoqIFByb21pc2UgcmVzb2x2ZXJzIGZvciB3YWl0aW5nIG9uIGNvbXBsZXRpb24gKi9cbiAgICAgICAgX0JldGFUb29sUnVubmVyX2NvbXBsZXRpb24uc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKiBOdW1iZXIgb2YgaXRlcmF0aW9ucyAoQVBJIHJlcXVlc3RzKSBtYWRlIHNvIGZhciAqL1xuICAgICAgICBfQmV0YVRvb2xSdW5uZXJfaXRlcmF0aW9uQ291bnQuc2V0KHRoaXMsIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwge1xuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgLy8gWW91IGNhbid0IGNsb25lIHRoZSBlbnRpcmUgcGFyYW1zIHNpbmNlIHRoZXJlIGFyZSBmdW5jdGlvbnMgYXMgaGFuZGxlcnMuXG4gICAgICAgICAgICAgICAgLy8gWW91IGFsc28gZG9uJ3QgcmVhbGx5IG5lZWQgdG8gY2xvbmUgcGFyYW1zLm1lc3NhZ2VzLCBidXQgaXQgcHJvYmFibHkgd2lsbCBwcmV2ZW50IGEgZm9vdCBndW5cbiAgICAgICAgICAgICAgICAvLyBzb21ld2hlcmUuXG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdHJ1Y3R1cmVkQ2xvbmUocGFyYW1zLm1lc3NhZ2VzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfb3B0aW9ucywge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbeyAneC1zdGFpbmxlc3MtaGVscGVyJzogJ0JldGFUb29sUnVubmVyJyB9LCBvcHRpb25zPy5oZWFkZXJzXSksXG4gICAgICAgIH0sIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfY29tcGxldGlvbiwgcHJvbWlzZVdpdGhSZXNvbHZlcnMoKSwgXCJmXCIpO1xuICAgIH1cbiAgICBhc3luYyAqWyhfQmV0YVRvb2xSdW5uZXJfY29uc3VtZWQgPSBuZXcgV2Vha01hcCgpLCBfQmV0YVRvb2xSdW5uZXJfbXV0YXRlZCA9IG5ldyBXZWFrTWFwKCksIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSA9IG5ldyBXZWFrTWFwKCksIF9CZXRhVG9vbFJ1bm5lcl9vcHRpb25zID0gbmV3IFdlYWtNYXAoKSwgX0JldGFUb29sUnVubmVyX21lc3NhZ2UgPSBuZXcgV2Vha01hcCgpLCBfQmV0YVRvb2xSdW5uZXJfdG9vbFJlc3BvbnNlID0gbmV3IFdlYWtNYXAoKSwgX0JldGFUb29sUnVubmVyX2NvbXBsZXRpb24gPSBuZXcgV2Vha01hcCgpLCBfQmV0YVRvb2xSdW5uZXJfaXRlcmF0aW9uQ291bnQgPSBuZXcgV2Vha01hcCgpLCBfQmV0YVRvb2xSdW5uZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgU3ltYm9sLmFzeW5jSXRlcmF0b3IpXSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfY29uc3VtZWQsIFwiZlwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtJyk7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfY29uc3VtZWQsIHRydWUsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfbXV0YXRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl90b29sUmVzcG9uc2UsIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RyZWFtO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgXCJmXCIpLnBhcmFtcy5tYXhfaXRlcmF0aW9ucyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfaXRlcmF0aW9uQ291bnQsIFwiZlwiKSA+PSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgXCJmXCIpLnBhcmFtcy5tYXhfaXRlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfbXV0YXRlZCwgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfbWVzc2FnZSwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFUb29sUnVubmVyX3Rvb2xSZXNwb25zZSwgdW5kZWZpbmVkLCBcImZcIik7XG4gICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFUb29sUnVubmVyX2l0ZXJhdGlvbkNvdW50LCAoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9pdGVyYXRpb25Db3VudCwgXCJmXCIpLCBfYSsrLCBfYSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBtYXhfaXRlcmF0aW9ucywgLi4ucGFyYW1zIH0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgXCJmXCIpLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuY2xpZW50LmJldGEubWVzc2FnZXMuc3RyZWFtKHsgLi4ucGFyYW1zIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX29wdGlvbnMsIFwiZlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLCBzdHJlYW0uZmluYWxNZXNzYWdlKCksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0cmVhbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFUb29sUnVubmVyX21lc3NhZ2UsIHRoaXMuY2xpZW50LmJldGEubWVzc2FnZXMuY3JlYXRlKHsgLi4ucGFyYW1zLCBzdHJlYW06IGZhbHNlIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX29wdGlvbnMsIFwiZlwiKSksIFwiZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX21lc3NhZ2UsIFwiZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX211dGF0ZWQsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByb2xlLCBjb250ZW50IH0gPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLCBcImZcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgXCJmXCIpLnBhcmFtcy5tZXNzYWdlcy5wdXNoKHsgcm9sZSwgY29udGVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sTWVzc2FnZSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX2luc3RhbmNlcywgXCJtXCIsIF9CZXRhVG9vbFJ1bm5lcl9nZW5lcmF0ZVRvb2xSZXNwb25zZSkuY2FsbCh0aGlzLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9zdGF0ZSwgXCJmXCIpLnBhcmFtcy5tZXNzYWdlcy5hdCgtMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vbE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX3N0YXRlLCBcImZcIikucGFyYW1zLm1lc3NhZ2VzLnB1c2godG9vbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9vbE1lc3NhZ2UgJiYgIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX211dGF0ZWQsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLCBcImZcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW50aHJvcGljRXJyb3IoJ1Rvb2xSdW5uZXIgY29uY2x1ZGVkIHdpdGhvdXQgYSBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfY29tcGxldGlvbiwgXCJmXCIpLnJlc29sdmUoYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfbWVzc2FnZSwgXCJmXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFUb29sUnVubmVyX2NvbnN1bWVkLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICAgICAgLy8gU2lsZW5jZSB1bmhhbmRsZWQgcHJvbWlzZSBlcnJvcnNcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX2NvbXBsZXRpb24sIFwiZlwiKS5wcm9taXNlLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9jb21wbGV0aW9uLCBcImZcIikucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JldGFUb29sUnVubmVyX2NvbXBsZXRpb24sIHByb21pc2VXaXRoUmVzb2x2ZXJzKCksIFwiZlwiKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE1lc3NhZ2VzUGFyYW1zKHBhcmFtc09yTXV0YXRvcikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc09yTXV0YXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfc3RhdGUsIFwiZlwiKS5wYXJhbXMgPSBwYXJhbXNPck11dGF0b3IoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfc3RhdGUsIFwiZlwiKS5wYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfc3RhdGUsIFwiZlwiKS5wYXJhbXMgPSBwYXJhbXNPck11dGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfbXV0YXRlZCwgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlZCB0b29sIHJlc3BvbnNlIHNpbmNlIHBhcmFtZXRlcnMgY2hhbmdlZFxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl90b29sUmVzcG9uc2UsIHVuZGVmaW5lZCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvb2wgcmVzcG9uc2UgZm9yIHRoZSBsYXN0IG1lc3NhZ2UgZnJvbSB0aGUgYXNzaXN0YW50LlxuICAgICAqIEF2b2lkcyByZWR1bmRhbnQgdG9vbCBleGVjdXRpb25zIGJ5IGNhY2hpbmcgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgQmV0YU1lc3NhZ2VQYXJhbSBjb250YWluaW5nIHRvb2wgcmVzdWx0cywgb3IgbnVsbCBpZiBubyB0b29scyBuZWVkIHRvIGJlIGV4ZWN1dGVkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHRvb2xSZXNwb25zZSA9IGF3YWl0IHJ1bm5lci5nZW5lcmF0ZVRvb2xSZXNwb25zZSgpO1xuICAgICAqIGlmICh0b29sUmVzcG9uc2UpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdUb29sIHJlc3VsdHM6JywgdG9vbFJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZVRvb2xSZXNwb25zZSgpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IChhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9tZXNzYWdlLCBcImZcIikpID8/IHRoaXMucGFyYW1zLm1lc3NhZ2VzLmF0KC0xKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0JldGFUb29sUnVubmVyX2dlbmVyYXRlVG9vbFJlc3BvbnNlKS5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciB0aGUgYXN5bmMgaXRlcmF0b3IgdG8gY29tcGxldGUuIFRoaXMgd29ya3MgZXZlbiBpZiB0aGUgYXN5bmMgaXRlcmF0b3IgaGFzbid0IHlldCBzdGFydGVkLCBhbmRcbiAgICAgKiB3aWxsIHdhaXQgZm9yIGFuIGluc3RhbmNlIHRvIHN0YXJ0IGFuZCBnbyB0byBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbmFsIEJldGFNZXNzYWdlIHdoZW4gdGhlIGl0ZXJhdG9yIGNvbXBsZXRlc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBTdGFydCBjb25zdW1pbmcgdGhlIGl0ZXJhdG9yXG4gICAgICogZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlIG9mIHJ1bm5lcikge1xuICAgICAqICAgY29uc29sZS5sb2coJ01lc3NhZ2U6JywgbWVzc2FnZS5jb250ZW50KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiAvLyBNZWFud2hpbGUsIHdhaXQgZm9yIGNvbXBsZXRpb24gZnJvbSBhbm90aGVyIHBhcnQgb2YgdGhlIGNvZGVcbiAgICAgKiBjb25zdCBmaW5hbE1lc3NhZ2UgPSBhd2FpdCBydW5uZXIuZG9uZSgpO1xuICAgICAqIGNvbnNvbGUubG9nKCdGaW5hbCByZXNwb25zZTonLCBmaW5hbE1lc3NhZ2UuY29udGVudCk7XG4gICAgICovXG4gICAgZG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX2NvbXBsZXRpb24sIFwiZlwiKS5wcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBpbmRpY2F0aW5nIHRoYXQgdGhlIHN0cmVhbSBpcyBkb25lLiBVbmxpa2UgLmRvbmUoKSwgdGhpcyB3aWxsIGVhZ2VybHkgcmVhZCB0aGUgc3RyZWFtOlxuICAgICAqICogSWYgdGhlIGl0ZXJhdG9yIGhhcyBub3QgYmVlbiBjb25zdW1lZCwgY29uc3VtZSB0aGUgZW50aXJlIGl0ZXJhdG9yIGFuZCByZXR1cm4gdGhlIGZpbmFsIG1lc3NhZ2UgZnJvbSB0aGVcbiAgICAgKiBhc3Npc3RhbnQuXG4gICAgICogKiBJZiB0aGUgaXRlcmF0b3IgaGFzIGJlZW4gY29uc3VtZWQsIHdhaXRzIGZvciBpdCB0byBjb21wbGV0ZSBhbmQgcmV0dXJucyB0aGUgZmluYWwgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBCZXRhTWVzc2FnZSBmcm9tIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKiBAdGhyb3dzIHtBbnRocm9waWNFcnJvcn0gSWYgbm8gbWVzc2FnZXMgd2VyZSBwcm9jZXNzZWQgZHVyaW5nIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgZmluYWxNZXNzYWdlID0gYXdhaXQgcnVubmVyLnJ1blVudGlsRG9uZSgpO1xuICAgICAqIGNvbnNvbGUubG9nKCdGaW5hbCByZXNwb25zZTonLCBmaW5hbE1lc3NhZ2UuY29udGVudCk7XG4gICAgICovXG4gICAgYXN5bmMgcnVuVW50aWxEb25lKCkge1xuICAgICAgICAvLyBJZiBub3QgeWV0IGNvbnN1bWVkLCBzdGFydCBjb25zdW1pbmcgYW5kIHdhaXQgZm9yIGNvbXBsZXRpb25cbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl9jb25zdW1lZCwgXCJmXCIpKSB7XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgdGhpcykge1xuICAgICAgICAgICAgICAgIC8vIEl0ZXJhdG9yIG5hdHVyYWxseSBwb3B1bGF0ZXMgdGhpcy4jbWVzc2FnZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbnN1bWVkIGJ1dCBub3QgY29tcGxldGVkLCB3YWl0IGZvciBjb21wbGV0aW9uXG4gICAgICAgIHJldHVybiB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHBhcmFtZXRlcnMgYmVpbmcgdXNlZCBieSB0aGUgVG9vbFJ1bm5lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcmVhZG9ubHkgdmlldyBvZiB0aGUgY3VycmVudCBUb29sUnVubmVyUGFyYW1zXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSBydW5uZXIucGFyYW1zO1xuICAgICAqIGNvbnNvbGUubG9nKCdDdXJyZW50IG1vZGVsOicsIGN1cnJlbnRQYXJhbXMubW9kZWwpO1xuICAgICAqIGNvbnNvbGUubG9nKCdNZXNzYWdlIGNvdW50OicsIGN1cnJlbnRQYXJhbXMubWVzc2FnZXMubGVuZ3RoKTtcbiAgICAgKi9cbiAgICBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfc3RhdGUsIFwiZlwiKS5wYXJhbXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvbmUgb3IgbW9yZSBtZXNzYWdlcyB0byB0aGUgY29udmVyc2F0aW9uIGhpc3RvcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgLSBPbmUgb3IgbW9yZSBCZXRhTWVzc2FnZVBhcmFtIG9iamVjdHMgdG8gYWRkIHRvIHRoZSBjb252ZXJzYXRpb25cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogcnVubmVyLnB1c2hNZXNzYWdlcyhcbiAgICAgKiAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiAnQWxzbywgd2hhdCBhYm91dCB0aGUgd2VhdGhlciBpbiBOWUM/JyB9XG4gICAgICogKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gQWRkaW5nIG11bHRpcGxlIG1lc3NhZ2VzXG4gICAgICogcnVubmVyLnB1c2hNZXNzYWdlcyhcbiAgICAgKiAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiAnV2hhdCBhYm91dCBOWUM/JyB9LFxuICAgICAqICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdBbmQgQm9zdG9uPycgfVxuICAgICAqICk7XG4gICAgICovXG4gICAgcHVzaE1lc3NhZ2VzKC4uLm1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZXNQYXJhbXMoKHBhcmFtcykgPT4gKHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBbLi4ucGFyYW1zLm1lc3NhZ2VzLCAuLi5tZXNzYWdlc10sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIFRvb2xSdW5uZXIgZGlyZWN0bHkgYXdhaXRhYmxlLCBlcXVpdmFsZW50IHRvIGNhbGxpbmcgLnJ1blVudGlsRG9uZSgpXG4gICAgICogVGhpcyBhbGxvd3MgdXNpbmcgYGF3YWl0IHJ1bm5lcmAgaW5zdGVhZCBvZiBgYXdhaXQgcnVubmVyLnJ1blVudGlsRG9uZSgpYFxuICAgICAqL1xuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuVW50aWxEb25lKCkudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gICAgfVxufVxuX0JldGFUb29sUnVubmVyX2dlbmVyYXRlVG9vbFJlc3BvbnNlID0gYXN5bmMgZnVuY3Rpb24gX0JldGFUb29sUnVubmVyX2dlbmVyYXRlVG9vbFJlc3BvbnNlKGxhc3RNZXNzYWdlKSB7XG4gICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX3Rvb2xSZXNwb25zZSwgXCJmXCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX3Rvb2xSZXNwb25zZSwgXCJmXCIpO1xuICAgIH1cbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CZXRhVG9vbFJ1bm5lcl90b29sUmVzcG9uc2UsIGdlbmVyYXRlVG9vbFJlc3BvbnNlKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JldGFUb29sUnVubmVyX3N0YXRlLCBcImZcIikucGFyYW1zLCBsYXN0TWVzc2FnZSksIFwiZlwiKTtcbiAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQmV0YVRvb2xSdW5uZXJfdG9vbFJlc3BvbnNlLCBcImZcIik7XG59O1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUb29sUmVzcG9uc2UocGFyYW1zLCBsYXN0TWVzc2FnZSA9IHBhcmFtcy5tZXNzYWdlcy5hdCgtMSkpIHtcbiAgICAvLyBPbmx5IHByb2Nlc3MgaWYgdGhlIGxhc3QgbWVzc2FnZSBpcyBmcm9tIHRoZSBhc3Npc3RhbnQgYW5kIGhhcyB0b29sIHVzZSBibG9ja3NcbiAgICBpZiAoIWxhc3RNZXNzYWdlIHx8XG4gICAgICAgIGxhc3RNZXNzYWdlLnJvbGUgIT09ICdhc3Npc3RhbnQnIHx8XG4gICAgICAgICFsYXN0TWVzc2FnZS5jb250ZW50IHx8XG4gICAgICAgIHR5cGVvZiBsYXN0TWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdG9vbFVzZUJsb2NrcyA9IGxhc3RNZXNzYWdlLmNvbnRlbnQuZmlsdGVyKChjb250ZW50KSA9PiBjb250ZW50LnR5cGUgPT09ICd0b29sX3VzZScpO1xuICAgIGlmICh0b29sVXNlQmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdG9vbFJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29sVXNlQmxvY2tzLm1hcChhc3luYyAodG9vbFVzZSkgPT4ge1xuICAgICAgICBjb25zdCB0b29sID0gcGFyYW1zLnRvb2xzLmZpbmQoKHQpID0+IHQubmFtZSA9PT0gdG9vbFVzZS5uYW1lKTtcbiAgICAgICAgaWYgKCF0b29sIHx8ICEoJ3J1bicgaW4gdG9vbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Rvb2xfcmVzdWx0JyxcbiAgICAgICAgICAgICAgICB0b29sX3VzZV9pZDogdG9vbFVzZS5pZCxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBgRXJyb3I6IFRvb2wgJyR7dG9vbFVzZS5uYW1lfScgbm90IGZvdW5kYCxcbiAgICAgICAgICAgICAgICBpc19lcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBpbnB1dCA9IHRvb2xVc2UuaW5wdXQ7XG4gICAgICAgICAgICBpZiAoJ3BhcnNlJyBpbiB0b29sICYmIHRvb2wucGFyc2UpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHRvb2wucGFyc2UoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbC5ydW4oaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG9vbF9yZXN1bHQnLFxuICAgICAgICAgICAgICAgIHRvb2xfdXNlX2lkOiB0b29sVXNlLmlkLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlc3VsdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b29sX3Jlc3VsdCcsXG4gICAgICAgICAgICAgICAgdG9vbF91c2VfaWQ6IHRvb2xVc2UuaWQsXG4gICAgICAgICAgICAgICAgY29udGVudDogYEVycm9yOiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKX1gLFxuICAgICAgICAgICAgICAgIGlzX2Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IHRvb2xSZXN1bHRzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CZXRhVG9vbFJ1bm5lci5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs":
/*!********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Beta: () => (/* binding */ Beta)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _files_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./files.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/files.mjs\");\n/* harmony import */ var _models_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/models.mjs\");\n/* harmony import */ var _messages_messages_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./messages/messages.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n\n\nclass Beta extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    constructor() {\n        super(...arguments);\n        this.models = new _models_mjs__WEBPACK_IMPORTED_MODULE_2__.Models(this._client);\n        this.messages = new _messages_messages_mjs__WEBPACK_IMPORTED_MODULE_3__.Messages(this._client);\n        this.files = new _files_mjs__WEBPACK_IMPORTED_MODULE_1__.Files(this._client);\n    }\n}\nBeta.Models = _models_mjs__WEBPACK_IMPORTED_MODULE_2__.Models;\nBeta.Messages = _messages_messages_mjs__WEBPACK_IMPORTED_MODULE_3__.Messages;\nBeta.Files = _files_mjs__WEBPACK_IMPORTED_MODULE_1__.Files;\n//# sourceMappingURL=beta.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL2JldGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDc0Q7QUFDZDtBQUNIO0FBQ0s7QUFDSjtBQUNpQjtBQUNIO0FBQzdDLG1CQUFtQiwyREFBVztBQUNyQztBQUNBO0FBQ0EsMEJBQTBCLCtDQUFnQjtBQUMxQyw0QkFBNEIsNERBQW9CO0FBQ2hELHlCQUF5Qiw2Q0FBYztBQUN2QztBQUNBO0FBQ0EsY0FBYywrQ0FBTTtBQUNwQixnQkFBZ0IsNERBQVE7QUFDeEIsYUFBYSw2Q0FBSztBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL2JldGEubWpzPzI2OTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL2NvcmUvcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgKiBhcyBGaWxlc0FQSSBmcm9tIFwiLi9maWxlcy5tanNcIjtcbmltcG9ydCB7IEZpbGVzLCB9IGZyb20gXCIuL2ZpbGVzLm1qc1wiO1xuaW1wb3J0ICogYXMgTW9kZWxzQVBJIGZyb20gXCIuL21vZGVscy5tanNcIjtcbmltcG9ydCB7IE1vZGVscyB9IGZyb20gXCIuL21vZGVscy5tanNcIjtcbmltcG9ydCAqIGFzIE1lc3NhZ2VzQVBJIGZyb20gXCIuL21lc3NhZ2VzL21lc3NhZ2VzLm1qc1wiO1xuaW1wb3J0IHsgTWVzc2FnZXMsIH0gZnJvbSBcIi4vbWVzc2FnZXMvbWVzc2FnZXMubWpzXCI7XG5leHBvcnQgY2xhc3MgQmV0YSBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzQVBJLk1vZGVscyh0aGlzLl9jbGllbnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzQVBJLk1lc3NhZ2VzKHRoaXMuX2NsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXNBUEkuRmlsZXModGhpcy5fY2xpZW50KTtcbiAgICB9XG59XG5CZXRhLk1vZGVscyA9IE1vZGVscztcbkJldGEuTWVzc2FnZXMgPSBNZXNzYWdlcztcbkJldGEuRmlsZXMgPSBGaWxlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJldGEubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/files.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/beta/files.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Files: () => (/* binding */ Files)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_uploads_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../internal/uploads.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/uploads.mjs\");\n/* harmony import */ var _internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../internal/utils/path.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\nclass Files extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    /**\n     * List Files\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const fileMetadata of client.beta.files.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/files', (_core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__.Page), {\n            query,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Delete File\n     *\n     * @example\n     * ```ts\n     * const deletedFile = await client.beta.files.delete(\n     *   'file_id',\n     * );\n     * ```\n     */\n    delete(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.delete((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__.path) `/v1/files/${fileID}`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Download File\n     *\n     * @example\n     * ```ts\n     * const response = await client.beta.files.download(\n     *   'file_id',\n     * );\n     *\n     * const content = await response.blob();\n     * console.log(content);\n     * ```\n     */\n    download(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__.path) `/v1/files/${fileID}/content`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                {\n                    'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString(),\n                    Accept: 'application/binary',\n                },\n                options?.headers,\n            ]),\n            __binaryResponse: true,\n        });\n    }\n    /**\n     * Get File Metadata\n     *\n     * @example\n     * ```ts\n     * const fileMetadata =\n     *   await client.beta.files.retrieveMetadata('file_id');\n     * ```\n     */\n    retrieveMetadata(fileID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_4__.path) `/v1/files/${fileID}`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Upload File\n     *\n     * @example\n     * ```ts\n     * const fileMetadata = await client.beta.files.upload({\n     *   file: fs.createReadStream('path/to/file'),\n     * });\n     * ```\n     */\n    upload(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/files', (0,_internal_uploads_mjs__WEBPACK_IMPORTED_MODULE_3__.multipartFormRequestOptions)({\n            body,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'files-api-2025-04-14'].toString() },\n                options?.headers,\n            ]),\n        }, this._client));\n    }\n}\n//# sourceMappingURL=files.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL2ZpbGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNzRDtBQUNMO0FBQ1M7QUFDZTtBQUNwQjtBQUM5QyxvQkFBb0IsMkRBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0Isa0JBQWtCO0FBQ2xDLHFEQUFxRCxzREFBSTtBQUN6RDtBQUNBO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQix5RUFBeUU7QUFDM0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGdCQUFnQixRQUFRO0FBQ3hCLG1DQUFtQyw4REFBSSxjQUFjLE9BQU87QUFDNUQ7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0NBQWdDLDhEQUFJLGNBQWMsT0FBTztBQUN6RDtBQUNBLHFCQUFxQixtRUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLGdCQUFnQixRQUFRO0FBQ3hCLGdDQUFnQyw4REFBSSxjQUFjLE9BQU87QUFDekQ7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQyw4Q0FBOEMsa0ZBQTJCO0FBQ3pFO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLHlFQUF5RTtBQUMzRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL2ZpbGVzLm1qcz9jOTI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9jb3JlL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi8uLi9jb3JlL3BhZ2luYXRpb24ubWpzXCI7XG5pbXBvcnQgeyBidWlsZEhlYWRlcnMgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvaGVhZGVycy5tanNcIjtcbmltcG9ydCB7IG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC91cGxvYWRzLm1qc1wiO1xuaW1wb3J0IHsgcGF0aCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC91dGlscy9wYXRoLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEZpbGVzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIExpc3QgRmlsZXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiAvLyBBdXRvbWF0aWNhbGx5IGZldGNoZXMgbW9yZSBwYWdlcyBhcyBuZWVkZWQuXG4gICAgICogZm9yIGF3YWl0IChjb25zdCBmaWxlTWV0YWRhdGEgb2YgY2xpZW50LmJldGEuZmlsZXMubGlzdCgpKSB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbGlzdChwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGJldGFzLCAuLi5xdWVyeSB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy92MS9maWxlcycsIChQYWdlKSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFtcbiAgICAgICAgICAgICAgICB7ICdhbnRocm9waWMtYmV0YSc6IFsuLi4oYmV0YXMgPz8gW10pLCAnZmlsZXMtYXBpLTIwMjUtMDQtMTQnXS50b1N0cmluZygpIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIEZpbGVcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBkZWxldGVkRmlsZSA9IGF3YWl0IGNsaWVudC5iZXRhLmZpbGVzLmRlbGV0ZShcbiAgICAgKiAgICdmaWxlX2lkJyxcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZShmaWxlSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUocGF0aCBgL3YxL2ZpbGVzLyR7ZmlsZUlEfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdmaWxlcy1hcGktMjAyNS0wNC0xNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBGaWxlXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQuYmV0YS5maWxlcy5kb3dubG9hZChcbiAgICAgKiAgICdmaWxlX2lkJyxcbiAgICAgKiApO1xuICAgICAqXG4gICAgICogY29uc3QgY29udGVudCA9IGF3YWl0IHJlc3BvbnNlLmJsb2IoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhjb250ZW50KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkb3dubG9hZChmaWxlSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQocGF0aCBgL3YxL2ZpbGVzLyR7ZmlsZUlEfS9jb250ZW50YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAnYW50aHJvcGljLWJldGEnOiBbLi4uKGJldGFzID8/IFtdKSwgJ2ZpbGVzLWFwaS0yMDI1LTA0LTE0J10udG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vYmluYXJ5JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF9fYmluYXJ5UmVzcG9uc2U6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgRmlsZSBNZXRhZGF0YVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGZpbGVNZXRhZGF0YSA9XG4gICAgICogICBhd2FpdCBjbGllbnQuYmV0YS5maWxlcy5yZXRyaWV2ZU1ldGFkYXRhKCdmaWxlX2lkJyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmV0cmlldmVNZXRhZGF0YShmaWxlSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQocGF0aCBgL3YxL2ZpbGVzLyR7ZmlsZUlEfWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdmaWxlcy1hcGktMjAyNS0wNC0xNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgRmlsZVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGZpbGVNZXRhZGF0YSA9IGF3YWl0IGNsaWVudC5iZXRhLmZpbGVzLnVwbG9hZCh7XG4gICAgICogICBmaWxlOiBmcy5jcmVhdGVSZWFkU3RyZWFtKCdwYXRoL3RvL2ZpbGUnKSxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB1cGxvYWQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMsIC4uLmJvZHkgfSA9IHBhcmFtcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5wb3N0KCcvdjEvZmlsZXMnLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoe1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdmaWxlcy1hcGktMjAyNS0wNC0xNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0sIHRoaXMuX2NsaWVudCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/files.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs":
/*!********************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Batches: () => (/* binding */ Batches)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_decoders_jsonl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../internal/decoders/jsonl.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs\");\n/* harmony import */ var _internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../internal/utils/path.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n\nclass Batches extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.create({\n     *     requests: [\n     *       {\n     *         custom_id: 'my-custom-id-1',\n     *         params: {\n     *           max_tokens: 1024,\n     *           messages: [\n     *             { content: 'Hello, world', role: 'user' },\n     *           ],\n     *           model: 'claude-sonnet-4-5-20250929',\n     *         },\n     *       },\n     *     ],\n     *   });\n     * ```\n     */\n    create(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/batches?beta=true', {\n            body,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * This endpoint is idempotent and can be used to poll for Message Batch\n     * completion. To access the results of a Message Batch, make a request to the\n     * `results_url` field in the response.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.retrieve(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    retrieve(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}?beta=true`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List all Message Batches within a Workspace. Most recently created batches are\n     * returned first.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const betaMessageBatch of client.beta.messages.batches.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/messages/batches?beta=true', (_core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__.Page), {\n            query,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Delete a Message Batch.\n     *\n     * Message Batches can only be deleted once they've finished processing. If you'd\n     * like to delete an in-progress batch, you must first cancel it.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaDeletedMessageBatch =\n     *   await client.beta.messages.batches.delete(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    delete(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.delete((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}?beta=true`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Batches may be canceled any time before processing ends. Once cancellation is\n     * initiated, the batch enters a `canceling` state, at which time the system may\n     * complete any in-progress, non-interruptible requests before finalizing\n     * cancellation.\n     *\n     * The number of canceled requests is specified in `request_counts`. To determine\n     * which requests were canceled, check the individual results within the batch.\n     * Note that cancellation may not result in any canceled requests if they were\n     * non-interruptible.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatch =\n     *   await client.beta.messages.batches.cancel(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    cancel(messageBatchID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.post((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * Streams the results of a Message Batch as a `.jsonl` file.\n     *\n     * Each line in the file is a JSON object containing the result of a single request\n     * in the Message Batch. Results are not guaranteed to be in the same order as\n     * requests. Use the `custom_id` field to match results to requests.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const betaMessageBatchIndividualResponse =\n     *   await client.beta.messages.batches.results(\n     *     'message_batch_id',\n     *   );\n     * ```\n     */\n    async results(messageBatchID, params = {}, options) {\n        const batch = await this.retrieve(messageBatchID);\n        if (!batch.results_url) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_4__.AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        const { betas } = params ?? {};\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                {\n                    'anthropic-beta': [...(betas ?? []), 'message-batches-2024-09-24'].toString(),\n                    Accept: 'application/binary',\n                },\n                options?.headers,\n            ]),\n            stream: true,\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => _internal_decoders_jsonl_mjs__WEBPACK_IMPORTED_MODULE_3__.JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\n//# sourceMappingURL=batches.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21lc3NhZ2VzL2JhdGNoZXMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUN5RDtBQUNMO0FBQ1M7QUFDTztBQUNoQjtBQUNJO0FBQ2pELHNCQUFzQiwyREFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBWTtBQUNqQyxrQkFBa0IsK0VBQStFO0FBQ2pHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxnQkFBZ0IsUUFBUTtBQUN4QixnQ0FBZ0MsOERBQUkseUJBQXlCLGVBQWU7QUFDNUU7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLCtFQUErRTtBQUNqRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQixrQkFBa0I7QUFDbEMsMEVBQTBFLHNEQUFJO0FBQzlFO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLCtFQUErRTtBQUNqRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxnQkFBZ0IsUUFBUTtBQUN4QixtQ0FBbUMsOERBQUkseUJBQXlCLGVBQWU7QUFDL0U7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLCtFQUErRTtBQUNqRztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZ0JBQWdCLFFBQVE7QUFDeEIsaUNBQWlDLDhEQUFJLHlCQUF5QixlQUFlO0FBQzdFO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQiwrRUFBK0U7QUFDakc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLHNEQUFjLDRCQUE0Qiw4QkFBOEIseUJBQXlCLElBQUksU0FBUztBQUNwSTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtRUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDLHNFQUFZO0FBQ25EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21lc3NhZ2VzL2JhdGNoZXMubWpzPzhiOGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy4gU2VlIENPTlRSSUJVVElORy5tZCBmb3IgZGV0YWlscy5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcmVzb3VyY2UubWpzXCI7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2NvcmUvcGFnaW5hdGlvbi5tanNcIjtcbmltcG9ydCB7IGJ1aWxkSGVhZGVycyB9IGZyb20gXCIuLi8uLi8uLi9pbnRlcm5hbC9oZWFkZXJzLm1qc1wiO1xuaW1wb3J0IHsgSlNPTkxEZWNvZGVyIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2RlY29kZXJzL2pzb25sLm1qc1wiO1xuaW1wb3J0IHsgQW50aHJvcGljRXJyb3IgfSBmcm9tIFwiLi4vLi4vLi4vZXJyb3IubWpzXCI7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL3V0aWxzL3BhdGgubWpzXCI7XG5leHBvcnQgY2xhc3MgQmF0Y2hlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgYmF0Y2ggb2YgTWVzc2FnZSBjcmVhdGlvbiByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIFRoZSBNZXNzYWdlIEJhdGNoZXMgQVBJIGNhbiBiZSB1c2VkIHRvIHByb2Nlc3MgbXVsdGlwbGUgTWVzc2FnZXMgQVBJIHJlcXVlc3RzIGF0XG4gICAgICogb25jZS4gT25jZSBhIE1lc3NhZ2UgQmF0Y2ggaXMgY3JlYXRlZCwgaXQgYmVnaW5zIHByb2Nlc3NpbmcgaW1tZWRpYXRlbHkuIEJhdGNoZXNcbiAgICAgKiBjYW4gdGFrZSB1cCB0byAyNCBob3VycyB0byBjb21wbGV0ZS5cbiAgICAgKlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdGhlIE1lc3NhZ2UgQmF0Y2hlcyBBUEkgaW4gb3VyXG4gICAgICogW3VzZXIgZ3VpZGVdKC9lbi9kb2NzL2J1aWxkLXdpdGgtY2xhdWRlL2JhdGNoLXByb2Nlc3NpbmcpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgYmV0YU1lc3NhZ2VCYXRjaCA9XG4gICAgICogICBhd2FpdCBjbGllbnQuYmV0YS5tZXNzYWdlcy5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICogICAgIHJlcXVlc3RzOiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgY3VzdG9tX2lkOiAnbXktY3VzdG9tLWlkLTEnLFxuICAgICAqICAgICAgICAgcGFyYW1zOiB7XG4gICAgICogICAgICAgICAgIG1heF90b2tlbnM6IDEwMjQsXG4gICAgICogICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICogICAgICAgICAgICAgeyBjb250ZW50OiAnSGVsbG8sIHdvcmxkJywgcm9sZTogJ3VzZXInIH0sXG4gICAgICogICAgICAgICAgIF0sXG4gICAgICogICAgICAgICAgIG1vZGVsOiAnY2xhdWRlLXNvbm5ldC00LTUtMjAyNTA5MjknLFxuICAgICAqICAgICAgICAgfSxcbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICBdLFxuICAgICAqICAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGJldGFzLCAuLi5ib2R5IH0gPSBwYXJhbXM7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3YxL21lc3NhZ2VzL2JhdGNoZXM/YmV0YT10cnVlJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdtZXNzYWdlLWJhdGNoZXMtMjAyNC0wOS0yNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGVuZHBvaW50IGlzIGlkZW1wb3RlbnQgYW5kIGNhbiBiZSB1c2VkIHRvIHBvbGwgZm9yIE1lc3NhZ2UgQmF0Y2hcbiAgICAgKiBjb21wbGV0aW9uLiBUbyBhY2Nlc3MgdGhlIHJlc3VsdHMgb2YgYSBNZXNzYWdlIEJhdGNoLCBtYWtlIGEgcmVxdWVzdCB0byB0aGVcbiAgICAgKiBgcmVzdWx0c191cmxgIGZpZWxkIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdGhlIE1lc3NhZ2UgQmF0Y2hlcyBBUEkgaW4gb3VyXG4gICAgICogW3VzZXIgZ3VpZGVdKC9lbi9kb2NzL2J1aWxkLXdpdGgtY2xhdWRlL2JhdGNoLXByb2Nlc3NpbmcpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgYmV0YU1lc3NhZ2VCYXRjaCA9XG4gICAgICogICBhd2FpdCBjbGllbnQuYmV0YS5tZXNzYWdlcy5iYXRjaGVzLnJldHJpZXZlKFxuICAgICAqICAgICAnbWVzc2FnZV9iYXRjaF9pZCcsXG4gICAgICogICApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJldHJpZXZlKG1lc3NhZ2VCYXRjaElELCBwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGJldGFzIH0gPSBwYXJhbXMgPz8ge307XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KHBhdGggYC92MS9tZXNzYWdlcy9iYXRjaGVzLyR7bWVzc2FnZUJhdGNoSUR9P2JldGE9dHJ1ZWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdtZXNzYWdlLWJhdGNoZXMtMjAyNC0wOS0yNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBNZXNzYWdlIEJhdGNoZXMgd2l0aGluIGEgV29ya3NwYWNlLiBNb3N0IHJlY2VudGx5IGNyZWF0ZWQgYmF0Y2hlcyBhcmVcbiAgICAgKiByZXR1cm5lZCBmaXJzdC5cbiAgICAgKlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdGhlIE1lc3NhZ2UgQmF0Y2hlcyBBUEkgaW4gb3VyXG4gICAgICogW3VzZXIgZ3VpZGVdKC9lbi9kb2NzL2J1aWxkLXdpdGgtY2xhdWRlL2JhdGNoLXByb2Nlc3NpbmcpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogLy8gQXV0b21hdGljYWxseSBmZXRjaGVzIG1vcmUgcGFnZXMgYXMgbmVlZGVkLlxuICAgICAqIGZvciBhd2FpdCAoY29uc3QgYmV0YU1lc3NhZ2VCYXRjaCBvZiBjbGllbnQuYmV0YS5tZXNzYWdlcy5iYXRjaGVzLmxpc3QoKSkge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3QocGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcywgLi4ucXVlcnkgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvdjEvbWVzc2FnZXMvYmF0Y2hlcz9iZXRhPXRydWUnLCAoUGFnZSksIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICAgICAgeyAnYW50aHJvcGljLWJldGEnOiBbLi4uKGJldGFzID8/IFtdKSwgJ21lc3NhZ2UtYmF0Y2hlcy0yMDI0LTA5LTI0J10udG9TdHJpbmcoKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIE1lc3NhZ2UgQmF0Y2guXG4gICAgICpcbiAgICAgKiBNZXNzYWdlIEJhdGNoZXMgY2FuIG9ubHkgYmUgZGVsZXRlZCBvbmNlIHRoZXkndmUgZmluaXNoZWQgcHJvY2Vzc2luZy4gSWYgeW91J2RcbiAgICAgKiBsaWtlIHRvIGRlbGV0ZSBhbiBpbi1wcm9ncmVzcyBiYXRjaCwgeW91IG11c3QgZmlyc3QgY2FuY2VsIGl0LlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBiZXRhRGVsZXRlZE1lc3NhZ2VCYXRjaCA9XG4gICAgICogICBhd2FpdCBjbGllbnQuYmV0YS5tZXNzYWdlcy5iYXRjaGVzLmRlbGV0ZShcbiAgICAgKiAgICAgJ21lc3NhZ2VfYmF0Y2hfaWQnLFxuICAgICAqICAgKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkZWxldGUobWVzc2FnZUJhdGNoSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUocGF0aCBgL3YxL21lc3NhZ2VzL2JhdGNoZXMvJHttZXNzYWdlQmF0Y2hJRH0/YmV0YT10cnVlYCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICAgICAgeyAnYW50aHJvcGljLWJldGEnOiBbLi4uKGJldGFzID8/IFtdKSwgJ21lc3NhZ2UtYmF0Y2hlcy0yMDI0LTA5LTI0J10udG9TdHJpbmcoKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoZXMgbWF5IGJlIGNhbmNlbGVkIGFueSB0aW1lIGJlZm9yZSBwcm9jZXNzaW5nIGVuZHMuIE9uY2UgY2FuY2VsbGF0aW9uIGlzXG4gICAgICogaW5pdGlhdGVkLCB0aGUgYmF0Y2ggZW50ZXJzIGEgYGNhbmNlbGluZ2Agc3RhdGUsIGF0IHdoaWNoIHRpbWUgdGhlIHN5c3RlbSBtYXlcbiAgICAgKiBjb21wbGV0ZSBhbnkgaW4tcHJvZ3Jlc3MsIG5vbi1pbnRlcnJ1cHRpYmxlIHJlcXVlc3RzIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICogY2FuY2VsbGF0aW9uLlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBjYW5jZWxlZCByZXF1ZXN0cyBpcyBzcGVjaWZpZWQgaW4gYHJlcXVlc3RfY291bnRzYC4gVG8gZGV0ZXJtaW5lXG4gICAgICogd2hpY2ggcmVxdWVzdHMgd2VyZSBjYW5jZWxlZCwgY2hlY2sgdGhlIGluZGl2aWR1YWwgcmVzdWx0cyB3aXRoaW4gdGhlIGJhdGNoLlxuICAgICAqIE5vdGUgdGhhdCBjYW5jZWxsYXRpb24gbWF5IG5vdCByZXN1bHQgaW4gYW55IGNhbmNlbGVkIHJlcXVlc3RzIGlmIHRoZXkgd2VyZVxuICAgICAqIG5vbi1pbnRlcnJ1cHRpYmxlLlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBiZXRhTWVzc2FnZUJhdGNoID1cbiAgICAgKiAgIGF3YWl0IGNsaWVudC5iZXRhLm1lc3NhZ2VzLmJhdGNoZXMuY2FuY2VsKFxuICAgICAqICAgICAnbWVzc2FnZV9iYXRjaF9pZCcsXG4gICAgICogICApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNhbmNlbChtZXNzYWdlQmF0Y2hJRCwgcGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcyB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QocGF0aCBgL3YxL21lc3NhZ2VzL2JhdGNoZXMvJHttZXNzYWdlQmF0Y2hJRH0vY2FuY2VsP2JldGE9dHJ1ZWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICdtZXNzYWdlLWJhdGNoZXMtMjAyNC0wOS0yNCddLnRvU3RyaW5nKCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW1zIHRoZSByZXN1bHRzIG9mIGEgTWVzc2FnZSBCYXRjaCBhcyBhIGAuanNvbmxgIGZpbGUuXG4gICAgICpcbiAgICAgKiBFYWNoIGxpbmUgaW4gdGhlIGZpbGUgaXMgYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgYSBzaW5nbGUgcmVxdWVzdFxuICAgICAqIGluIHRoZSBNZXNzYWdlIEJhdGNoLiBSZXN1bHRzIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGUgc2FtZSBvcmRlciBhc1xuICAgICAqIHJlcXVlc3RzLiBVc2UgdGhlIGBjdXN0b21faWRgIGZpZWxkIHRvIG1hdGNoIHJlc3VsdHMgdG8gcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IHRoZSBNZXNzYWdlIEJhdGNoZXMgQVBJIGluIG91clxuICAgICAqIFt1c2VyIGd1aWRlXSgvZW4vZG9jcy9idWlsZC13aXRoLWNsYXVkZS9iYXRjaC1wcm9jZXNzaW5nKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGJldGFNZXNzYWdlQmF0Y2hJbmRpdmlkdWFsUmVzcG9uc2UgPVxuICAgICAqICAgYXdhaXQgY2xpZW50LmJldGEubWVzc2FnZXMuYmF0Y2hlcy5yZXN1bHRzKFxuICAgICAqICAgICAnbWVzc2FnZV9iYXRjaF9pZCcsXG4gICAgICogICApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VsdHMobWVzc2FnZUJhdGNoSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gYXdhaXQgdGhpcy5yZXRyaWV2ZShtZXNzYWdlQmF0Y2hJRCk7XG4gICAgICAgIGlmICghYmF0Y2gucmVzdWx0c191cmwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBbnRocm9waWNFcnJvcihgTm8gYmF0Y2ggXFxgcmVzdWx0c191cmxcXGA7IEhhcyBpdCBmaW5pc2hlZCBwcm9jZXNzaW5nPyAke2JhdGNoLnByb2Nlc3Npbmdfc3RhdHVzfSAtICR7YmF0Y2guaWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBiZXRhcyB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50XG4gICAgICAgICAgICAuZ2V0KGJhdGNoLnJlc3VsdHNfdXJsLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICdhbnRocm9waWMtYmV0YSc6IFsuLi4oYmV0YXMgPz8gW10pLCAnbWVzc2FnZS1iYXRjaGVzLTIwMjQtMDktMjQnXS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9iaW5hcnknLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5fdGhlblVud3JhcCgoXywgcHJvcHMpID0+IEpTT05MRGVjb2Rlci5mcm9tUmVzcG9uc2UocHJvcHMucmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaGVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BetaToolRunner: () => (/* reexport safe */ _lib_tools_BetaToolRunner_mjs__WEBPACK_IMPORTED_MODULE_5__.BetaToolRunner),\n/* harmony export */   Messages: () => (/* binding */ Messages)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _batches_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./batches.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _lib_BetaMessageStream_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../lib/BetaMessageStream.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs\");\n/* harmony import */ var _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../internal/constants.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/constants.mjs\");\n/* harmony import */ var _lib_tools_BetaToolRunner_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../lib/tools/BetaToolRunner.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n\n\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-3-opus-20240229': 'January 5th, 2026',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n    'claude-3-5-sonnet-20241022': 'October 22, 2025',\n    'claude-3-5-sonnet-20240620': 'October 22, 2025',\n};\nclass Messages extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new _batches_mjs__WEBPACK_IMPORTED_MODULE_1__.Batches(this._client);\n    }\n    create(params, options) {\n        const { betas, ...body } = params;\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        let timeout = this._client._options.timeout;\n        if (!body.stream && timeout == null) {\n            const maxNonstreamingTokens = _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_4__.MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;\n            timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);\n        }\n        return this._client.post('/v1/messages?beta=true', {\n            body,\n            timeout: timeout ?? 600000,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n            stream: params.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return _lib_BetaMessageStream_mjs__WEBPACK_IMPORTED_MODULE_3__.BetaMessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     *\n     * @example\n     * ```ts\n     * const betaMessageTokensCount =\n     *   await client.beta.messages.countTokens({\n     *     messages: [{ content: 'string', role: 'user' }],\n     *     model: 'claude-3-7-sonnet-latest',\n     *   });\n     * ```\n     */\n    countTokens(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/messages/count_tokens?beta=true', {\n            body,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { 'anthropic-beta': [...(betas ?? []), 'token-counting-2024-11-01'].toString() },\n                options?.headers,\n            ]),\n        });\n    }\n    toolRunner(body, options) {\n        return new _lib_tools_BetaToolRunner_mjs__WEBPACK_IMPORTED_MODULE_5__.BetaToolRunner(this._client, body, options);\n    }\n}\n\nMessages.Batches = _batches_mjs__WEBPACK_IMPORTED_MODULE_1__.Batches;\nMessages.BetaToolRunner = _lib_tools_BetaToolRunner_mjs__WEBPACK_IMPORTED_MODULE_5__.BetaToolRunner;\n//# sourceMappingURL=messages.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21lc3NhZ2VzL21lc3NhZ2VzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ3lEO0FBQ2I7QUFDSDtBQUNvQjtBQUNVO0FBQ0s7QUFDSjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1QiwyREFBVztBQUN6QztBQUNBO0FBQ0EsMkJBQTJCLGlEQUFrQjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBLHVDQUF1QyxXQUFXLGdEQUFnRCw4QkFBOEI7QUFDaEk7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhFQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLGtDQUFrQyxzQ0FBc0MsY0FBYztBQUN4RztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUVBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQiw4RUFBOEU7QUFDaEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLHlFQUFjO0FBQ2pDO0FBQ0E7QUFDdUU7QUFDdkUsbUJBQW1CLGlEQUFPO0FBQzFCLDBCQUEwQix5RUFBYztBQUN4QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21lc3NhZ2VzL21lc3NhZ2VzLm1qcz9hYjJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi8uLi9jb3JlL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0ICogYXMgQmF0Y2hlc0FQSSBmcm9tIFwiLi9iYXRjaGVzLm1qc1wiO1xuaW1wb3J0IHsgQmF0Y2hlcywgfSBmcm9tIFwiLi9iYXRjaGVzLm1qc1wiO1xuaW1wb3J0IHsgYnVpbGRIZWFkZXJzIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2hlYWRlcnMubWpzXCI7XG5pbXBvcnQgeyBCZXRhTWVzc2FnZVN0cmVhbSB9IGZyb20gXCIuLi8uLi8uLi9saWIvQmV0YU1lc3NhZ2VTdHJlYW0ubWpzXCI7XG5pbXBvcnQgeyBNT0RFTF9OT05TVFJFQU1JTkdfVE9LRU5TIH0gZnJvbSBcIi4uLy4uLy4uL2ludGVybmFsL2NvbnN0YW50cy5tanNcIjtcbmltcG9ydCB7IEJldGFUb29sUnVubmVyLCB9IGZyb20gXCIuLi8uLi8uLi9saWIvdG9vbHMvQmV0YVRvb2xSdW5uZXIubWpzXCI7XG5jb25zdCBERVBSRUNBVEVEX01PREVMUyA9IHtcbiAgICAnY2xhdWRlLTEuMyc6ICdOb3ZlbWJlciA2dGgsIDIwMjQnLFxuICAgICdjbGF1ZGUtMS4zLTEwMGsnOiAnTm92ZW1iZXIgNnRoLCAyMDI0JyxcbiAgICAnY2xhdWRlLWluc3RhbnQtMS4xJzogJ05vdmVtYmVyIDZ0aCwgMjAyNCcsXG4gICAgJ2NsYXVkZS1pbnN0YW50LTEuMS0xMDBrJzogJ05vdmVtYmVyIDZ0aCwgMjAyNCcsXG4gICAgJ2NsYXVkZS1pbnN0YW50LTEuMic6ICdOb3ZlbWJlciA2dGgsIDIwMjQnLFxuICAgICdjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjknOiAnSnVseSAyMXN0LCAyMDI1JyxcbiAgICAnY2xhdWRlLTMtb3B1cy0yMDI0MDIyOSc6ICdKYW51YXJ5IDV0aCwgMjAyNicsXG4gICAgJ2NsYXVkZS0yLjEnOiAnSnVseSAyMXN0LCAyMDI1JyxcbiAgICAnY2xhdWRlLTIuMCc6ICdKdWx5IDIxc3QsIDIwMjUnLFxuICAgICdjbGF1ZGUtMy01LXNvbm5ldC0yMDI0MTAyMic6ICdPY3RvYmVyIDIyLCAyMDI1JyxcbiAgICAnY2xhdWRlLTMtNS1zb25uZXQtMjAyNDA2MjAnOiAnT2N0b2JlciAyMiwgMjAyNScsXG59O1xuZXhwb3J0IGNsYXNzIE1lc3NhZ2VzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJhdGNoZXMgPSBuZXcgQmF0Y2hlc0FQSS5CYXRjaGVzKHRoaXMuX2NsaWVudCk7XG4gICAgfVxuICAgIGNyZWF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcywgLi4uYm9keSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoYm9keS5tb2RlbCBpbiBERVBSRUNBVEVEX01PREVMUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgbW9kZWwgJyR7Ym9keS5tb2RlbH0nIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgcmVhY2ggZW5kLW9mLWxpZmUgb24gJHtERVBSRUNBVEVEX01PREVMU1tib2R5Lm1vZGVsXX1cXG5QbGVhc2UgbWlncmF0ZSB0byBhIG5ld2VyIG1vZGVsLiBWaXNpdCBodHRwczovL2RvY3MuYW50aHJvcGljLmNvbS9lbi9kb2NzL3Jlc291cmNlcy9tb2RlbC1kZXByZWNhdGlvbnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLl9jbGllbnQuX29wdGlvbnMudGltZW91dDtcbiAgICAgICAgaWYgKCFib2R5LnN0cmVhbSAmJiB0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heE5vbnN0cmVhbWluZ1Rva2VucyA9IE1PREVMX05PTlNUUkVBTUlOR19UT0tFTlNbYm9keS5tb2RlbF0gPz8gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGltZW91dCA9IHRoaXMuX2NsaWVudC5jYWxjdWxhdGVOb25zdHJlYW1pbmdUaW1lb3V0KGJvZHkubWF4X3Rva2VucywgbWF4Tm9uc3RyZWFtaW5nVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92MS9tZXNzYWdlcz9iZXRhPXRydWUnLCB7XG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgdGltZW91dDogdGltZW91dCA/PyA2MDAwMDAsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFtcbiAgICAgICAgICAgICAgICB7IC4uLihiZXRhcz8udG9TdHJpbmcoKSAhPSBudWxsID8geyAnYW50aHJvcGljLWJldGEnOiBiZXRhcz8udG9TdHJpbmcoKSB9IDogdW5kZWZpbmVkKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHN0cmVhbTogcGFyYW1zLnN0cmVhbSA/PyBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIE1lc3NhZ2Ugc3RyZWFtXG4gICAgICovXG4gICAgc3RyZWFtKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIEJldGFNZXNzYWdlU3RyZWFtLmNyZWF0ZU1lc3NhZ2UodGhpcywgYm9keSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIGEgTWVzc2FnZS5cbiAgICAgKlxuICAgICAqIFRoZSBUb2tlbiBDb3VudCBBUEkgY2FuIGJlIHVzZWQgdG8gY291bnQgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gYSBNZXNzYWdlLFxuICAgICAqIGluY2x1ZGluZyB0b29scywgaW1hZ2VzLCBhbmQgZG9jdW1lbnRzLCB3aXRob3V0IGNyZWF0aW5nIGl0LlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0b2tlbiBjb3VudGluZyBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvdG9rZW4tY291bnRpbmcpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgYmV0YU1lc3NhZ2VUb2tlbnNDb3VudCA9XG4gICAgICogICBhd2FpdCBjbGllbnQuYmV0YS5tZXNzYWdlcy5jb3VudFRva2Vucyh7XG4gICAgICogICAgIG1lc3NhZ2VzOiBbeyBjb250ZW50OiAnc3RyaW5nJywgcm9sZTogJ3VzZXInIH1dLFxuICAgICAqICAgICBtb2RlbDogJ2NsYXVkZS0zLTctc29ubmV0LWxhdGVzdCcsXG4gICAgICogICB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb3VudFRva2VucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcywgLi4uYm9keSB9ID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92MS9tZXNzYWdlcy9jb3VudF90b2tlbnM/YmV0YT10cnVlJywge1xuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgJ2FudGhyb3BpYy1iZXRhJzogWy4uLihiZXRhcyA/PyBbXSksICd0b2tlbi1jb3VudGluZy0yMDI0LTExLTAxJ10udG9TdHJpbmcoKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvb2xSdW5uZXIoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEJldGFUb29sUnVubmVyKHRoaXMuX2NsaWVudCwgYm9keSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IHsgQmV0YVRvb2xSdW5uZXIgfSBmcm9tIFwiLi4vLi4vLi4vbGliL3Rvb2xzL0JldGFUb29sUnVubmVyLm1qc1wiO1xuTWVzc2FnZXMuQmF0Y2hlcyA9IEJhdGNoZXM7XG5NZXNzYWdlcy5CZXRhVG9vbFJ1bm5lciA9IEJldGFUb29sUnVubmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/models.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/beta/models.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Models: () => (/* binding */ Models)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../internal/utils/path.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\nclass Models extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     *\n     * @example\n     * ```ts\n     * const betaModelInfo = await client.beta.models.retrieve(\n     *   'model_id',\n     * );\n     * ```\n     */\n    retrieve(modelID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path) `/v1/models/${modelID}?beta=true`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List available models.\n     *\n     * The Models API response can be used to determine which models are available for\n     * use in the API. More recently released models are listed first.\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const betaModelInfo of client.beta.models.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/models?beta=true', (_core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__.Page), {\n            query,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n}\n//# sourceMappingURL=models.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21vZGVscy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNzRDtBQUNMO0FBQ1M7QUFDTDtBQUM5QyxxQkFBcUIsMkRBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsZ0JBQWdCLFFBQVE7QUFDeEIsZ0NBQWdDLDhEQUFJLGVBQWUsUUFBUTtBQUMzRDtBQUNBLHFCQUFxQixtRUFBWTtBQUNqQyxrQkFBa0Isa0NBQWtDLHNDQUFzQyxjQUFjO0FBQ3hHO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0VBQWdFLHNEQUFJO0FBQ3BFO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQVk7QUFDakMsa0JBQWtCLGtDQUFrQyxzQ0FBc0MsY0FBYztBQUN4RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9iZXRhL21vZGVscy5tanM/NjUwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vY29yZS9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi4vLi4vY29yZS9wYWdpbmF0aW9uLm1qc1wiO1xuaW1wb3J0IHsgYnVpbGRIZWFkZXJzIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2hlYWRlcnMubWpzXCI7XG5pbXBvcnQgeyBwYXRoIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL3V0aWxzL3BhdGgubWpzXCI7XG5leHBvcnQgY2xhc3MgTW9kZWxzIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIG1vZGVsLlxuICAgICAqXG4gICAgICogVGhlIE1vZGVscyBBUEkgcmVzcG9uc2UgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWNcbiAgICAgKiBtb2RlbCBvciByZXNvbHZlIGEgbW9kZWwgYWxpYXMgdG8gYSBtb2RlbCBJRC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBiZXRhTW9kZWxJbmZvID0gYXdhaXQgY2xpZW50LmJldGEubW9kZWxzLnJldHJpZXZlKFxuICAgICAqICAgJ21vZGVsX2lkJyxcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJldHJpZXZlKG1vZGVsSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQocGF0aCBgL3YxL21vZGVscy8ke21vZGVsSUR9P2JldGE9dHJ1ZWAsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiBidWlsZEhlYWRlcnMoW1xuICAgICAgICAgICAgICAgIHsgLi4uKGJldGFzPy50b1N0cmluZygpICE9IG51bGwgPyB7ICdhbnRocm9waWMtYmV0YSc6IGJldGFzPy50b1N0cmluZygpIH0gOiB1bmRlZmluZWQpIH0sXG4gICAgICAgICAgICAgICAgb3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIF0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhdmFpbGFibGUgbW9kZWxzLlxuICAgICAqXG4gICAgICogVGhlIE1vZGVscyBBUEkgcmVzcG9uc2UgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIG1vZGVscyBhcmUgYXZhaWxhYmxlIGZvclxuICAgICAqIHVzZSBpbiB0aGUgQVBJLiBNb3JlIHJlY2VudGx5IHJlbGVhc2VkIG1vZGVscyBhcmUgbGlzdGVkIGZpcnN0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIC8vIEF1dG9tYXRpY2FsbHkgZmV0Y2hlcyBtb3JlIHBhZ2VzIGFzIG5lZWRlZC5cbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGJldGFNb2RlbEluZm8gb2YgY2xpZW50LmJldGEubW9kZWxzLmxpc3QoKSkge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3QocGFyYW1zID0ge30sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcywgLi4ucXVlcnkgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXRBUElMaXN0KCcvdjEvbW9kZWxzP2JldGE9dHJ1ZScsIChQYWdlKSwge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFtcbiAgICAgICAgICAgICAgICB7IC4uLihiZXRhcz8udG9TdHJpbmcoKSAhPSBudWxsID8geyAnYW50aHJvcGljLWJldGEnOiBiZXRhcz8udG9TdHJpbmcoKSB9IDogdW5kZWZpbmVkKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWxzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/models.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/completions.mjs":
/*!**********************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/completions.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Completions: () => (/* binding */ Completions)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\nclass Completions extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    create(params, options) {\n        const { betas, ...body } = params;\n        return this._client.post('/v1/complete', {\n            body,\n            timeout: this._client._options.timeout ?? 600000,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_1__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n            stream: params.stream ?? false,\n        });\n    }\n}\n//# sourceMappingURL=completions.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9jb21wbGV0aW9ucy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDbUQ7QUFDSTtBQUNoRCwwQkFBMEIsMkRBQVc7QUFDNUM7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQixrQ0FBa0Msc0NBQXNDLGNBQWM7QUFDeEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9jb21wbGV0aW9ucy5tanM/ZDgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vY29yZS9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IGJ1aWxkSGVhZGVycyB9IGZyb20gXCIuLi9pbnRlcm5hbC9oZWFkZXJzLm1qc1wiO1xuZXhwb3J0IGNsYXNzIENvbXBsZXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAgIGNyZWF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBiZXRhcywgLi4uYm9keSB9ID0gcGFyYW1zO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92MS9jb21wbGV0ZScsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB0aW1lb3V0OiB0aGlzLl9jbGllbnQuX29wdGlvbnMudGltZW91dCA/PyA2MDAwMDAsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFtcbiAgICAgICAgICAgICAgICB7IC4uLihiZXRhcz8udG9TdHJpbmcoKSAhPSBudWxsID8geyAnYW50aHJvcGljLWJldGEnOiBiZXRhcz8udG9TdHJpbmcoKSB9IDogdW5kZWZpbmVkKSB9LFxuICAgICAgICAgICAgICAgIG9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHN0cmVhbTogcGFyYW1zLnN0cmVhbSA/PyBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGxldGlvbnMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/completions.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/index.mjs":
/*!****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/index.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Beta: () => (/* reexport safe */ _beta_beta_mjs__WEBPACK_IMPORTED_MODULE_1__.Beta),\n/* harmony export */   Completions: () => (/* reexport safe */ _completions_mjs__WEBPACK_IMPORTED_MODULE_2__.Completions),\n/* harmony export */   Messages: () => (/* reexport safe */ _messages_messages_mjs__WEBPACK_IMPORTED_MODULE_3__.Messages),\n/* harmony export */   Models: () => (/* reexport safe */ _models_mjs__WEBPACK_IMPORTED_MODULE_4__.Models)\n/* harmony export */ });\n/* harmony import */ var _shared_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shared.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/shared.mjs\");\n/* harmony import */ var _beta_beta_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./beta/beta.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs\");\n/* harmony import */ var _completions_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./completions.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/completions.mjs\");\n/* harmony import */ var _messages_messages_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./messages/messages.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs\");\n/* harmony import */ var _models_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/models.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDNkI7QUFDVztBQUNTO0FBQ0c7QUFDYjtBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9pbmRleC5tanM/NjczYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuZXhwb3J0ICogZnJvbSBcIi4vc2hhcmVkLm1qc1wiO1xuZXhwb3J0IHsgQmV0YSwgfSBmcm9tIFwiLi9iZXRhL2JldGEubWpzXCI7XG5leHBvcnQgeyBDb21wbGV0aW9ucywgfSBmcm9tIFwiLi9jb21wbGV0aW9ucy5tanNcIjtcbmV4cG9ydCB7IE1lc3NhZ2VzLCB9IGZyb20gXCIuL21lc3NhZ2VzL21lc3NhZ2VzLm1qc1wiO1xuZXhwb3J0IHsgTW9kZWxzLCB9IGZyb20gXCIuL21vZGVscy5tanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/index.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Batches: () => (/* binding */ Batches)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_decoders_jsonl_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../internal/decoders/jsonl.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs\");\n/* harmony import */ var _error_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../error.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/error.mjs\");\n/* harmony import */ var _internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../internal/utils/path.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\n\nclass Batches extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    /**\n     * Send a batch of Message creation requests.\n     *\n     * The Message Batches API can be used to process multiple Messages API requests at\n     * once. Once a Message Batch is created, it begins processing immediately. Batches\n     * can take up to 24 hours to complete.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.create({\n     *   requests: [\n     *     {\n     *       custom_id: 'my-custom-id-1',\n     *       params: {\n     *         max_tokens: 1024,\n     *         messages: [\n     *           { content: 'Hello, world', role: 'user' },\n     *         ],\n     *         model: 'claude-sonnet-4-5-20250929',\n     *       },\n     *     },\n     *   ],\n     * });\n     * ```\n     */\n    create(body, options) {\n        return this._client.post('/v1/messages/batches', { body, ...options });\n    }\n    /**\n     * This endpoint is idempotent and can be used to poll for Message Batch\n     * completion. To access the results of a Message Batch, make a request to the\n     * `results_url` field in the response.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.retrieve(\n     *   'message_batch_id',\n     * );\n     * ```\n     */\n    retrieve(messageBatchID, options) {\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}`, options);\n    }\n    /**\n     * List all Message Batches within a Workspace. Most recently created batches are\n     * returned first.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * // Automatically fetches more pages as needed.\n     * for await (const messageBatch of client.messages.batches.list()) {\n     *   // ...\n     * }\n     * ```\n     */\n    list(query = {}, options) {\n        return this._client.getAPIList('/v1/messages/batches', (_core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__.Page), { query, ...options });\n    }\n    /**\n     * Delete a Message Batch.\n     *\n     * Message Batches can only be deleted once they've finished processing. If you'd\n     * like to delete an in-progress batch, you must first cancel it.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const deletedMessageBatch =\n     *   await client.messages.batches.delete('message_batch_id');\n     * ```\n     */\n    delete(messageBatchID, options) {\n        return this._client.delete((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}`, options);\n    }\n    /**\n     * Batches may be canceled any time before processing ends. Once cancellation is\n     * initiated, the batch enters a `canceling` state, at which time the system may\n     * complete any in-progress, non-interruptible requests before finalizing\n     * cancellation.\n     *\n     * The number of canceled requests is specified in `request_counts`. To determine\n     * which requests were canceled, check the individual results within the batch.\n     * Note that cancellation may not result in any canceled requests if they were\n     * non-interruptible.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatch = await client.messages.batches.cancel(\n     *   'message_batch_id',\n     * );\n     * ```\n     */\n    cancel(messageBatchID, options) {\n        return this._client.post((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_5__.path) `/v1/messages/batches/${messageBatchID}/cancel`, options);\n    }\n    /**\n     * Streams the results of a Message Batch as a `.jsonl` file.\n     *\n     * Each line in the file is a JSON object containing the result of a single request\n     * in the Message Batch. Results are not guaranteed to be in the same order as\n     * requests. Use the `custom_id` field to match results to requests.\n     *\n     * Learn more about the Message Batches API in our\n     * [user guide](/en/docs/build-with-claude/batch-processing)\n     *\n     * @example\n     * ```ts\n     * const messageBatchIndividualResponse =\n     *   await client.messages.batches.results('message_batch_id');\n     * ```\n     */\n    async results(messageBatchID, options) {\n        const batch = await this.retrieve(messageBatchID);\n        if (!batch.results_url) {\n            throw new _error_mjs__WEBPACK_IMPORTED_MODULE_4__.AnthropicError(`No batch \\`results_url\\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);\n        }\n        return this._client\n            .get(batch.results_url, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([{ Accept: 'application/binary' }, options?.headers]),\n            stream: true,\n            __binaryResponse: true,\n        })\n            ._thenUnwrap((_, props) => _internal_decoders_jsonl_mjs__WEBPACK_IMPORTED_MODULE_3__.JSONLDecoder.fromResponse(props.response, props.controller));\n    }\n}\n//# sourceMappingURL=batches.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9tZXNzYWdlcy9iYXRjaGVzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDc0Q7QUFDTDtBQUNTO0FBQ087QUFDaEI7QUFDSTtBQUM5QyxzQkFBc0IsMkRBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxrQkFBa0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4REFBSSx5QkFBeUIsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixnRUFBZ0Usc0RBQUksS0FBSyxtQkFBbUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4REFBSSx5QkFBeUIsZUFBZTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDhEQUFJLHlCQUF5QixlQUFlO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWMsNEJBQTRCLDhCQUE4Qix5QkFBeUIsSUFBSSxTQUFTO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFZLElBQUksOEJBQThCO0FBQ25FO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsdUNBQXVDLHNFQUFZO0FBQ25EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9tZXNzYWdlcy9iYXRjaGVzLm1qcz9kMmU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi8uLi9jb3JlL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi8uLi9jb3JlL3BhZ2luYXRpb24ubWpzXCI7XG5pbXBvcnQgeyBidWlsZEhlYWRlcnMgfSBmcm9tIFwiLi4vLi4vaW50ZXJuYWwvaGVhZGVycy5tanNcIjtcbmltcG9ydCB7IEpTT05MRGVjb2RlciB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC9kZWNvZGVycy9qc29ubC5tanNcIjtcbmltcG9ydCB7IEFudGhyb3BpY0Vycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9yLm1qc1wiO1xuaW1wb3J0IHsgcGF0aCB9IGZyb20gXCIuLi8uLi9pbnRlcm5hbC91dGlscy9wYXRoLm1qc1wiO1xuZXhwb3J0IGNsYXNzIEJhdGNoZXMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogU2VuZCBhIGJhdGNoIG9mIE1lc3NhZ2UgY3JlYXRpb24gcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBUaGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBjYW4gYmUgdXNlZCB0byBwcm9jZXNzIG11bHRpcGxlIE1lc3NhZ2VzIEFQSSByZXF1ZXN0cyBhdFxuICAgICAqIG9uY2UuIE9uY2UgYSBNZXNzYWdlIEJhdGNoIGlzIGNyZWF0ZWQsIGl0IGJlZ2lucyBwcm9jZXNzaW5nIGltbWVkaWF0ZWx5LiBCYXRjaGVzXG4gICAgICogY2FuIHRha2UgdXAgdG8gMjQgaG91cnMgdG8gY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBMZWFybiBtb3JlIGFib3V0IHRoZSBNZXNzYWdlIEJhdGNoZXMgQVBJIGluIG91clxuICAgICAqIFt1c2VyIGd1aWRlXSgvZW4vZG9jcy9idWlsZC13aXRoLWNsYXVkZS9iYXRjaC1wcm9jZXNzaW5nKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG1lc3NhZ2VCYXRjaCA9IGF3YWl0IGNsaWVudC5tZXNzYWdlcy5iYXRjaGVzLmNyZWF0ZSh7XG4gICAgICogICByZXF1ZXN0czogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAgY3VzdG9tX2lkOiAnbXktY3VzdG9tLWlkLTEnLFxuICAgICAqICAgICAgIHBhcmFtczoge1xuICAgICAqICAgICAgICAgbWF4X3Rva2VuczogMTAyNCxcbiAgICAgKiAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICogICAgICAgICAgIHsgY29udGVudDogJ0hlbGxvLCB3b3JsZCcsIHJvbGU6ICd1c2VyJyB9LFxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIG1vZGVsOiAnY2xhdWRlLXNvbm5ldC00LTUtMjAyNTA5MjknLFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgIH0sXG4gICAgICogICBdLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZShib2R5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdCgnL3YxL21lc3NhZ2VzL2JhdGNoZXMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZW5kcG9pbnQgaXMgaWRlbXBvdGVudCBhbmQgY2FuIGJlIHVzZWQgdG8gcG9sbCBmb3IgTWVzc2FnZSBCYXRjaFxuICAgICAqIGNvbXBsZXRpb24uIFRvIGFjY2VzcyB0aGUgcmVzdWx0cyBvZiBhIE1lc3NhZ2UgQmF0Y2gsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZVxuICAgICAqIGByZXN1bHRzX3VybGAgZmllbGQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtZXNzYWdlQmF0Y2ggPSBhd2FpdCBjbGllbnQubWVzc2FnZXMuYmF0Y2hlcy5yZXRyaWV2ZShcbiAgICAgKiAgICdtZXNzYWdlX2JhdGNoX2lkJyxcbiAgICAgKiApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJldHJpZXZlKG1lc3NhZ2VCYXRjaElELCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0KHBhdGggYC92MS9tZXNzYWdlcy9iYXRjaGVzLyR7bWVzc2FnZUJhdGNoSUR9YCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIE1lc3NhZ2UgQmF0Y2hlcyB3aXRoaW4gYSBXb3Jrc3BhY2UuIE1vc3QgcmVjZW50bHkgY3JlYXRlZCBiYXRjaGVzIGFyZVxuICAgICAqIHJldHVybmVkIGZpcnN0LlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiAvLyBBdXRvbWF0aWNhbGx5IGZldGNoZXMgbW9yZSBwYWdlcyBhcyBuZWVkZWQuXG4gICAgICogZm9yIGF3YWl0IChjb25zdCBtZXNzYWdlQmF0Y2ggb2YgY2xpZW50Lm1lc3NhZ2VzLmJhdGNoZXMubGlzdCgpKSB7XG4gICAgICogICAvLyAuLi5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbGlzdChxdWVyeSA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQuZ2V0QVBJTGlzdCgnL3YxL21lc3NhZ2VzL2JhdGNoZXMnLCAoUGFnZSksIHsgcXVlcnksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIE1lc3NhZ2UgQmF0Y2guXG4gICAgICpcbiAgICAgKiBNZXNzYWdlIEJhdGNoZXMgY2FuIG9ubHkgYmUgZGVsZXRlZCBvbmNlIHRoZXkndmUgZmluaXNoZWQgcHJvY2Vzc2luZy4gSWYgeW91J2RcbiAgICAgKiBsaWtlIHRvIGRlbGV0ZSBhbiBpbi1wcm9ncmVzcyBiYXRjaCwgeW91IG11c3QgZmlyc3QgY2FuY2VsIGl0LlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBkZWxldGVkTWVzc2FnZUJhdGNoID1cbiAgICAgKiAgIGF3YWl0IGNsaWVudC5tZXNzYWdlcy5iYXRjaGVzLmRlbGV0ZSgnbWVzc2FnZV9iYXRjaF9pZCcpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZShtZXNzYWdlQmF0Y2hJRCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmRlbGV0ZShwYXRoIGAvdjEvbWVzc2FnZXMvYmF0Y2hlcy8ke21lc3NhZ2VCYXRjaElEfWAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaGVzIG1heSBiZSBjYW5jZWxlZCBhbnkgdGltZSBiZWZvcmUgcHJvY2Vzc2luZyBlbmRzLiBPbmNlIGNhbmNlbGxhdGlvbiBpc1xuICAgICAqIGluaXRpYXRlZCwgdGhlIGJhdGNoIGVudGVycyBhIGBjYW5jZWxpbmdgIHN0YXRlLCBhdCB3aGljaCB0aW1lIHRoZSBzeXN0ZW0gbWF5XG4gICAgICogY29tcGxldGUgYW55IGluLXByb2dyZXNzLCBub24taW50ZXJydXB0aWJsZSByZXF1ZXN0cyBiZWZvcmUgZmluYWxpemluZ1xuICAgICAqIGNhbmNlbGxhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgY2FuY2VsZWQgcmVxdWVzdHMgaXMgc3BlY2lmaWVkIGluIGByZXF1ZXN0X2NvdW50c2AuIFRvIGRldGVybWluZVxuICAgICAqIHdoaWNoIHJlcXVlc3RzIHdlcmUgY2FuY2VsZWQsIGNoZWNrIHRoZSBpbmRpdmlkdWFsIHJlc3VsdHMgd2l0aGluIHRoZSBiYXRjaC5cbiAgICAgKiBOb3RlIHRoYXQgY2FuY2VsbGF0aW9uIG1heSBub3QgcmVzdWx0IGluIGFueSBjYW5jZWxlZCByZXF1ZXN0cyBpZiB0aGV5IHdlcmVcbiAgICAgKiBub24taW50ZXJydXB0aWJsZS5cbiAgICAgKlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdGhlIE1lc3NhZ2UgQmF0Y2hlcyBBUEkgaW4gb3VyXG4gICAgICogW3VzZXIgZ3VpZGVdKC9lbi9kb2NzL2J1aWxkLXdpdGgtY2xhdWRlL2JhdGNoLXByb2Nlc3NpbmcpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbWVzc2FnZUJhdGNoID0gYXdhaXQgY2xpZW50Lm1lc3NhZ2VzLmJhdGNoZXMuY2FuY2VsKFxuICAgICAqICAgJ21lc3NhZ2VfYmF0Y2hfaWQnLFxuICAgICAqICk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2FuY2VsKG1lc3NhZ2VCYXRjaElELCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChwYXRoIGAvdjEvbWVzc2FnZXMvYmF0Y2hlcy8ke21lc3NhZ2VCYXRjaElEfS9jYW5jZWxgLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RyZWFtcyB0aGUgcmVzdWx0cyBvZiBhIE1lc3NhZ2UgQmF0Y2ggYXMgYSBgLmpzb25sYCBmaWxlLlxuICAgICAqXG4gICAgICogRWFjaCBsaW5lIGluIHRoZSBmaWxlIGlzIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0IG9mIGEgc2luZ2xlIHJlcXVlc3RcbiAgICAgKiBpbiB0aGUgTWVzc2FnZSBCYXRjaC4gUmVzdWx0cyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXNcbiAgICAgKiByZXF1ZXN0cy4gVXNlIHRoZSBgY3VzdG9tX2lkYCBmaWVsZCB0byBtYXRjaCByZXN1bHRzIHRvIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogTGVhcm4gbW9yZSBhYm91dCB0aGUgTWVzc2FnZSBCYXRjaGVzIEFQSSBpbiBvdXJcbiAgICAgKiBbdXNlciBndWlkZV0oL2VuL2RvY3MvYnVpbGQtd2l0aC1jbGF1ZGUvYmF0Y2gtcHJvY2Vzc2luZylcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBtZXNzYWdlQmF0Y2hJbmRpdmlkdWFsUmVzcG9uc2UgPVxuICAgICAqICAgYXdhaXQgY2xpZW50Lm1lc3NhZ2VzLmJhdGNoZXMucmVzdWx0cygnbWVzc2FnZV9iYXRjaF9pZCcpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlc3VsdHMobWVzc2FnZUJhdGNoSUQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBhd2FpdCB0aGlzLnJldHJpZXZlKG1lc3NhZ2VCYXRjaElEKTtcbiAgICAgICAgaWYgKCFiYXRjaC5yZXN1bHRzX3VybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFudGhyb3BpY0Vycm9yKGBObyBiYXRjaCBcXGByZXN1bHRzX3VybFxcYDsgSGFzIGl0IGZpbmlzaGVkIHByb2Nlc3Npbmc/ICR7YmF0Y2gucHJvY2Vzc2luZ19zdGF0dXN9IC0gJHtiYXRjaC5pZH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50XG4gICAgICAgICAgICAuZ2V0KGJhdGNoLnJlc3VsdHNfdXJsLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczogYnVpbGRIZWFkZXJzKFt7IEFjY2VwdDogJ2FwcGxpY2F0aW9uL2JpbmFyeScgfSwgb3B0aW9ucz8uaGVhZGVyc10pLFxuICAgICAgICAgICAgc3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5fdGhlblVud3JhcCgoXywgcHJvcHMpID0+IEpTT05MRGVjb2Rlci5mcm9tUmVzcG9uc2UocHJvcHMucmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXRjaGVzLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs":
/*!****************************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Messages: () => (/* binding */ Messages)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _lib_MessageStream_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/MessageStream.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs\");\n/* harmony import */ var _batches_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./batches.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs\");\n/* harmony import */ var _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../internal/constants.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/constants.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\n\nclass Messages extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    constructor() {\n        super(...arguments);\n        this.batches = new _batches_mjs__WEBPACK_IMPORTED_MODULE_2__.Batches(this._client);\n    }\n    create(body, options) {\n        if (body.model in DEPRECATED_MODELS) {\n            console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}\\nPlease migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);\n        }\n        let timeout = this._client._options.timeout;\n        if (!body.stream && timeout == null) {\n            const maxNonstreamingTokens = _internal_constants_mjs__WEBPACK_IMPORTED_MODULE_3__.MODEL_NONSTREAMING_TOKENS[body.model] ?? undefined;\n            timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);\n        }\n        return this._client.post('/v1/messages', {\n            body,\n            timeout: timeout ?? 600000,\n            ...options,\n            stream: body.stream ?? false,\n        });\n    }\n    /**\n     * Create a Message stream\n     */\n    stream(body, options) {\n        return _lib_MessageStream_mjs__WEBPACK_IMPORTED_MODULE_1__.MessageStream.createMessage(this, body, options);\n    }\n    /**\n     * Count the number of tokens in a Message.\n     *\n     * The Token Count API can be used to count the number of tokens in a Message,\n     * including tools, images, and documents, without creating it.\n     *\n     * Learn more about token counting in our\n     * [user guide](/en/docs/build-with-claude/token-counting)\n     *\n     * @example\n     * ```ts\n     * const messageTokensCount =\n     *   await client.messages.countTokens({\n     *     messages: [{ content: 'string', role: 'user' }],\n     *     model: 'claude-3-7-sonnet-latest',\n     *   });\n     * ```\n     */\n    countTokens(body, options) {\n        return this._client.post('/v1/messages/count_tokens', { body, ...options });\n    }\n}\nconst DEPRECATED_MODELS = {\n    'claude-1.3': 'November 6th, 2024',\n    'claude-1.3-100k': 'November 6th, 2024',\n    'claude-instant-1.1': 'November 6th, 2024',\n    'claude-instant-1.1-100k': 'November 6th, 2024',\n    'claude-instant-1.2': 'November 6th, 2024',\n    'claude-3-sonnet-20240229': 'July 21st, 2025',\n    'claude-3-opus-20240229': 'January 5th, 2026',\n    'claude-2.1': 'July 21st, 2025',\n    'claude-2.0': 'July 21st, 2025',\n    'claude-3-5-sonnet-20241022': 'October 22, 2025',\n    'claude-3-5-sonnet-20240620': 'October 22, 2025',\n};\nMessages.Batches = _batches_mjs__WEBPACK_IMPORTED_MODULE_2__.Batches;\n//# sourceMappingURL=messages.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9tZXNzYWdlcy9tZXNzYWdlcy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNzRDtBQUNNO0FBQ2hCO0FBQ0g7QUFDZ0M7QUFDbEUsdUJBQXVCLDJEQUFXO0FBQ3pDO0FBQ0E7QUFDQSwyQkFBMkIsaURBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXLGdEQUFnRCw4QkFBOEI7QUFDaEk7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhFQUF5QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBTztBQUMxQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BwaXAvdWkvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9tZXNzYWdlcy9tZXNzYWdlcy5tanM/YmQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLiBTZWUgQ09OVFJJQlVUSU5HLm1kIGZvciBkZXRhaWxzLlxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vY29yZS9yZXNvdXJjZS5tanNcIjtcbmltcG9ydCB7IE1lc3NhZ2VTdHJlYW0gfSBmcm9tIFwiLi4vLi4vbGliL01lc3NhZ2VTdHJlYW0ubWpzXCI7XG5pbXBvcnQgKiBhcyBCYXRjaGVzQVBJIGZyb20gXCIuL2JhdGNoZXMubWpzXCI7XG5pbXBvcnQgeyBCYXRjaGVzLCB9IGZyb20gXCIuL2JhdGNoZXMubWpzXCI7XG5pbXBvcnQgeyBNT0RFTF9OT05TVFJFQU1JTkdfVE9LRU5TIH0gZnJvbSBcIi4uLy4uL2ludGVybmFsL2NvbnN0YW50cy5tanNcIjtcbmV4cG9ydCBjbGFzcyBNZXNzYWdlcyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEJhdGNoZXNBUEkuQmF0Y2hlcyh0aGlzLl9jbGllbnQpO1xuICAgIH1cbiAgICBjcmVhdGUoYm9keSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYm9keS5tb2RlbCBpbiBERVBSRUNBVEVEX01PREVMUykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGUgbW9kZWwgJyR7Ym9keS5tb2RlbH0nIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgcmVhY2ggZW5kLW9mLWxpZmUgb24gJHtERVBSRUNBVEVEX01PREVMU1tib2R5Lm1vZGVsXX1cXG5QbGVhc2UgbWlncmF0ZSB0byBhIG5ld2VyIG1vZGVsLiBWaXNpdCBodHRwczovL2RvY3MuYW50aHJvcGljLmNvbS9lbi9kb2NzL3Jlc291cmNlcy9tb2RlbC1kZXByZWNhdGlvbnMgZm9yIG1vcmUgaW5mb3JtYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLl9jbGllbnQuX29wdGlvbnMudGltZW91dDtcbiAgICAgICAgaWYgKCFib2R5LnN0cmVhbSAmJiB0aW1lb3V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heE5vbnN0cmVhbWluZ1Rva2VucyA9IE1PREVMX05PTlNUUkVBTUlOR19UT0tFTlNbYm9keS5tb2RlbF0gPz8gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGltZW91dCA9IHRoaXMuX2NsaWVudC5jYWxjdWxhdGVOb25zdHJlYW1pbmdUaW1lb3V0KGJvZHkubWF4X3Rva2VucywgbWF4Tm9uc3RyZWFtaW5nVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92MS9tZXNzYWdlcycsIHtcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0ID8/IDYwMDAwMCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdHJlYW06IGJvZHkuc3RyZWFtID8/IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgTWVzc2FnZSBzdHJlYW1cbiAgICAgKi9cbiAgICBzdHJlYW0oYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gTWVzc2FnZVN0cmVhbS5jcmVhdGVNZXNzYWdlKHRoaXMsIGJvZHksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudCB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiBhIE1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBUaGUgVG9rZW4gQ291bnQgQVBJIGNhbiBiZSB1c2VkIHRvIGNvdW50IHRoZSBudW1iZXIgb2YgdG9rZW5zIGluIGEgTWVzc2FnZSxcbiAgICAgKiBpbmNsdWRpbmcgdG9vbHMsIGltYWdlcywgYW5kIGRvY3VtZW50cywgd2l0aG91dCBjcmVhdGluZyBpdC5cbiAgICAgKlxuICAgICAqIExlYXJuIG1vcmUgYWJvdXQgdG9rZW4gY291bnRpbmcgaW4gb3VyXG4gICAgICogW3VzZXIgZ3VpZGVdKC9lbi9kb2NzL2J1aWxkLXdpdGgtY2xhdWRlL3Rva2VuLWNvdW50aW5nKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IG1lc3NhZ2VUb2tlbnNDb3VudCA9XG4gICAgICogICBhd2FpdCBjbGllbnQubWVzc2FnZXMuY291bnRUb2tlbnMoe1xuICAgICAqICAgICBtZXNzYWdlczogW3sgY29udGVudDogJ3N0cmluZycsIHJvbGU6ICd1c2VyJyB9XSxcbiAgICAgKiAgICAgbW9kZWw6ICdjbGF1ZGUtMy03LXNvbm5ldC1sYXRlc3QnLFxuICAgICAqICAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY291bnRUb2tlbnMoYm9keSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy92MS9tZXNzYWdlcy9jb3VudF90b2tlbnMnLCB7IGJvZHksIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxufVxuY29uc3QgREVQUkVDQVRFRF9NT0RFTFMgPSB7XG4gICAgJ2NsYXVkZS0xLjMnOiAnTm92ZW1iZXIgNnRoLCAyMDI0JyxcbiAgICAnY2xhdWRlLTEuMy0xMDBrJzogJ05vdmVtYmVyIDZ0aCwgMjAyNCcsXG4gICAgJ2NsYXVkZS1pbnN0YW50LTEuMSc6ICdOb3ZlbWJlciA2dGgsIDIwMjQnLFxuICAgICdjbGF1ZGUtaW5zdGFudC0xLjEtMTAwayc6ICdOb3ZlbWJlciA2dGgsIDIwMjQnLFxuICAgICdjbGF1ZGUtaW5zdGFudC0xLjInOiAnTm92ZW1iZXIgNnRoLCAyMDI0JyxcbiAgICAnY2xhdWRlLTMtc29ubmV0LTIwMjQwMjI5JzogJ0p1bHkgMjFzdCwgMjAyNScsXG4gICAgJ2NsYXVkZS0zLW9wdXMtMjAyNDAyMjknOiAnSmFudWFyeSA1dGgsIDIwMjYnLFxuICAgICdjbGF1ZGUtMi4xJzogJ0p1bHkgMjFzdCwgMjAyNScsXG4gICAgJ2NsYXVkZS0yLjAnOiAnSnVseSAyMXN0LCAyMDI1JyxcbiAgICAnY2xhdWRlLTMtNS1zb25uZXQtMjAyNDEwMjInOiAnT2N0b2JlciAyMiwgMjAyNScsXG4gICAgJ2NsYXVkZS0zLTUtc29ubmV0LTIwMjQwNjIwJzogJ09jdG9iZXIgMjIsIDIwMjUnLFxufTtcbk1lc3NhZ2VzLkJhdGNoZXMgPSBCYXRjaGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVzc2FnZXMubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/models.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/models.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Models: () => (/* binding */ Models)\n/* harmony export */ });\n/* harmony import */ var _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/resource.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/resource.mjs\");\n/* harmony import */ var _core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/pagination.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/pagination.mjs\");\n/* harmony import */ var _internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal/headers.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/headers.mjs\");\n/* harmony import */ var _internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal/utils/path.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/internal/utils/path.mjs\");\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n\n\n\nclass Models extends _core_resource_mjs__WEBPACK_IMPORTED_MODULE_0__.APIResource {\n    /**\n     * Get a specific model.\n     *\n     * The Models API response can be used to determine information about a specific\n     * model or resolve a model alias to a model ID.\n     */\n    retrieve(modelID, params = {}, options) {\n        const { betas } = params ?? {};\n        return this._client.get((0,_internal_utils_path_mjs__WEBPACK_IMPORTED_MODULE_3__.path) `/v1/models/${modelID}`, {\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n    /**\n     * List available models.\n     *\n     * The Models API response can be used to determine which models are available for\n     * use in the API. More recently released models are listed first.\n     */\n    list(params = {}, options) {\n        const { betas, ...query } = params ?? {};\n        return this._client.getAPIList('/v1/models', (_core_pagination_mjs__WEBPACK_IMPORTED_MODULE_1__.Page), {\n            query,\n            ...options,\n            headers: (0,_internal_headers_mjs__WEBPACK_IMPORTED_MODULE_2__.buildHeaders)([\n                { ...(betas?.toString() != null ? { 'anthropic-beta': betas?.toString() } : undefined) },\n                options?.headers,\n            ]),\n        });\n    }\n}\n//# sourceMappingURL=models.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9tb2RlbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDbUQ7QUFDTDtBQUNTO0FBQ0w7QUFDM0MscUJBQXFCLDJEQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxnQkFBZ0IsUUFBUTtBQUN4QixnQ0FBZ0MsOERBQUksZUFBZSxRQUFRO0FBQzNEO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQixrQ0FBa0Msc0NBQXNDLGNBQWM7QUFDeEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0Isa0JBQWtCO0FBQ2xDLHNEQUFzRCxzREFBSTtBQUMxRDtBQUNBO0FBQ0EscUJBQXFCLG1FQUFZO0FBQ2pDLGtCQUFrQixrQ0FBa0Msc0NBQXNDLGNBQWM7QUFDeEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9yZXNvdXJjZXMvbW9kZWxzLm1qcz8zMWI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5pbXBvcnQgeyBBUElSZXNvdXJjZSB9IGZyb20gXCIuLi9jb3JlL3Jlc291cmNlLm1qc1wiO1xuaW1wb3J0IHsgUGFnZSB9IGZyb20gXCIuLi9jb3JlL3BhZ2luYXRpb24ubWpzXCI7XG5pbXBvcnQgeyBidWlsZEhlYWRlcnMgfSBmcm9tIFwiLi4vaW50ZXJuYWwvaGVhZGVycy5tanNcIjtcbmltcG9ydCB7IHBhdGggfSBmcm9tIFwiLi4vaW50ZXJuYWwvdXRpbHMvcGF0aC5tanNcIjtcbmV4cG9ydCBjbGFzcyBNb2RlbHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3BlY2lmaWMgbW9kZWwuXG4gICAgICpcbiAgICAgKiBUaGUgTW9kZWxzIEFQSSByZXNwb25zZSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgaW5mb3JtYXRpb24gYWJvdXQgYSBzcGVjaWZpY1xuICAgICAqIG1vZGVsIG9yIHJlc29sdmUgYSBtb2RlbCBhbGlhcyB0byBhIG1vZGVsIElELlxuICAgICAqL1xuICAgIHJldHJpZXZlKG1vZGVsSUQsIHBhcmFtcyA9IHt9LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmV0YXMgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQocGF0aCBgL3YxL21vZGVscy8ke21vZGVsSUR9YCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICAgICAgeyAuLi4oYmV0YXM/LnRvU3RyaW5nKCkgIT0gbnVsbCA/IHsgJ2FudGhyb3BpYy1iZXRhJzogYmV0YXM/LnRvU3RyaW5nKCkgfSA6IHVuZGVmaW5lZCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGF2YWlsYWJsZSBtb2RlbHMuXG4gICAgICpcbiAgICAgKiBUaGUgTW9kZWxzIEFQSSByZXNwb25zZSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggbW9kZWxzIGFyZSBhdmFpbGFibGUgZm9yXG4gICAgICogdXNlIGluIHRoZSBBUEkuIE1vcmUgcmVjZW50bHkgcmVsZWFzZWQgbW9kZWxzIGFyZSBsaXN0ZWQgZmlyc3QuXG4gICAgICovXG4gICAgbGlzdChwYXJhbXMgPSB7fSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGJldGFzLCAuLi5xdWVyeSB9ID0gcGFyYW1zID8/IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldEFQSUxpc3QoJy92MS9tb2RlbHMnLCAoUGFnZSksIHtcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IGJ1aWxkSGVhZGVycyhbXG4gICAgICAgICAgICAgICAgeyAuLi4oYmV0YXM/LnRvU3RyaW5nKCkgIT0gbnVsbCA/IHsgJ2FudGhyb3BpYy1iZXRhJzogYmV0YXM/LnRvU3RyaW5nKCkgfSA6IHVuZGVmaW5lZCkgfSxcbiAgICAgICAgICAgICAgICBvcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZGVscy5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/models.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/resources/shared.mjs":
/*!*****************************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/resources/shared.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.\n\n//# sourceMappingURL=shared.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3Jlc291cmNlcy9zaGFyZWQubWpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay9yZXNvdXJjZXMvc2hhcmVkLm1qcz82ZDRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuIFNlZSBDT05UUklCVVRJTkcubWQgZm9yIGRldGFpbHMuXG5leHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZWQubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/resources/shared.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/streaming.mjs":
/*!**********************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/streaming.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Stream: () => (/* reexport safe */ _core_streaming_mjs__WEBPACK_IMPORTED_MODULE_0__.Stream),\n/* harmony export */   _iterSSEMessages: () => (/* reexport safe */ _core_streaming_mjs__WEBPACK_IMPORTED_MODULE_0__._iterSSEMessages)\n/* harmony export */ });\n/* harmony import */ var _core_streaming_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/streaming.mjs */ \"(rsc)/../../node_modules/@anthropic-ai/sdk/core/streaming.mjs\");\n\n//# sourceMappingURL=streaming.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3N0cmVhbWluZy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHBpcC91aS8uLi8uLi9ub2RlX21vZHVsZXMvQGFudGhyb3BpYy1haS9zZGsvc3RyZWFtaW5nLm1qcz80YzRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCIuL2NvcmUvc3RyZWFtaW5nLm1qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtaW5nLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/streaming.mjs\n");

/***/ }),

/***/ "(rsc)/../../node_modules/@anthropic-ai/sdk/version.mjs":
/*!********************************************************!*\
  !*** ../../node_modules/@anthropic-ai/sdk/version.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\nconst VERSION = '0.65.0'; // x-release-please-version\n//# sourceMappingURL=version.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL0BhbnRocm9waWMtYWkvc2RrL3ZlcnNpb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTywwQkFBMEI7QUFDakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AcGlwL3VpLy4uLy4uL25vZGVfbW9kdWxlcy9AYW50aHJvcGljLWFpL3Nkay92ZXJzaW9uLm1qcz8wMjE4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzAuNjUuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/@anthropic-ai/sdk/version.mjs\n");

/***/ })

};
;